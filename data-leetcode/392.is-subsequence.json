[
    {
        "title": "Reverse Linked List II",
        "question_content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is n.\n\t1 <= n <= 500\n\t-500 <= Node.val <= 500\n\t1 <= left <= right <= n\n\n&nbsp;\nFollow up: Could you do it in one pass?",
        "solutions": [
            {
                "id": 30709,
                "title": "talk-is-cheap-show-me-the-code-and-drawing",
                "content": "On my way of self-learning, ```linked list``` was always a nightmare to me. Hopes the code and this graph (ugh, kind of ugly maybe) can help someone who was just like me.\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\\n![0_1490008790876_reversed_linked_list.jpeg](/uploads/files/1490008792563-reversed_linked_list.jpeg)",
                "solutionTags": [],
                "code": "```linked list```\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30666,
                "title": "simple-java-solution-with-clear-explanation",
                "content": "Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then\\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return null;\\n        ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list\\n        dummy.next = head;\\n        ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing\\n        for(int i = 0; i<m-1; i++) pre = pre.next;\\n        \\n        ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n        ListNode then = start.next; // a pointer to a node that will be reversed\\n        \\n        // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---> pre = 1, start = 2, then = 3\\n        // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n        \\n        for(int i=0; i<n-m; i++)\\n        {\\n            start.next = then.next;\\n            then.next = pre.next;\\n            pre.next = then;\\n            then = start.next;\\n        }\\n        \\n        // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n        // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n        \\n        return dummy.next;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then\\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return null;\\n        ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list\\n        dummy.next = head;\\n        ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing\\n        for(int i = 0; i<m-1; i++) pre = pre.next;\\n        \\n        ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n        ListNode then = start.next; // a pointer to a node that will be reversed\\n        \\n        // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---> pre = 1, start = 2, then = 3\\n        // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n        \\n        for(int i=0; i<n-m; i++)\\n        {\\n            start.next = then.next;\\n            then.next = pre.next;\\n            pre.next = then;\\n            then = start.next;\\n        }\\n        \\n        // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n        // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n        \\n        return dummy.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2311084,
                "title": "java-c-tried-to-explain-every-step",
                "content": "So, this problem is not that much hard, let me made it easy for you. Be with me **Ladies-N-Gentlemen**\\n\\nTo understand this problem let\\'s take an example:\\n\\n```\\nInput: head = [1,2,10,20,30,40,5], left = 3, right = 6\\nOutput: [1,2,40,30,20,10,5]\\n```\\n\\n\\n**So, first of all I would like to show you if we do reverse one-by-one then, how it\\'ll gonna looks like**\\n\\n![image](https://assets.leetcode.com/users/images/28290044-7497-4047-b3fd-8cb79794e386_1658375922.2664697.png)\\n\\n\\nNow, let\\'s talk about how we gonna achieve this result,\\n\\nSo, for that we gonna use 3 pointers:\\n* **Pre**\\n* **Curr**\\n* **Forw**\\n\\n```\\nSo, the pre pointer will be assigned on just before left position\\nCurr pointer & forw pointer will help in reversing the linkedlist\\n\\nSo, we gonna perform these steps,\\ncurr.next = forw.next\\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\\nprev.next = forw\\nforw = curr.next\\n```\\n* **`Step-1 :`** Assign the pointers at their positions\\n![image](https://assets.leetcode.com/users/images/786cd5ed-9358-44aa-8f7a-2165f3161765_1658373106.107245.png)\\n\\n* **`Step-2 :`** \\n* * **Curr** will point to 30 i.e. `10 --> 30`\\n* * **forw** will point to **curr** i.e. `20 --> 10`\\n* * **pre** will point to **forw** i.e. `2 --> 20`\\n![image](https://assets.leetcode.com/users/images/cf33f371-6877-4eee-a9ed-21f7345ce4d2_1658373524.8555613.png)\\n\\n* **`Step-3 :`** \\n* * **Curr** will point to 40 i.e. `10 --> 40`\\n* * **forw** will point to **just after prev** i.e. `30 --> 20` ***[Now at this point it\\'s get clear our forw will point to just after prev]***\\n* * **pre** will point to **forw** i.e. `2 --> 30`\\n![image](https://assets.leetcode.com/users/images/944a0961-1ae6-427d-9eff-973f95864860_1658373816.7264853.png)\\n\\n* **`Step-4 :`** \\n* * **Curr** will point to 5 i.e. `10 --> 5`\\n* * **forw** will point to **just after prev** i.e. `40 --> 30` \\n* * **pre** will point to **forw** i.e. `2 --> 40`\\n![image](https://assets.leetcode.com/users/images/01bdc537-40f9-4d83-8326-e6df28c517bc_1658374112.1678076.png)\\n\\nNow, ladies-n-gentlemen everything is absolutely clear I hope so. \\n\\nOops, one more thing I forgot to add and i.e. is we gonna use **`dummy list`**! Now you ask why?\\n```\\nBecause, let\\'s say we have given \"left = 1\" then where our prev pointer will be assigned then, \\nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node\\n```\\n\\nLet\\'s look at the code,\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(0); // created dummy node\\n        dummy.next = head;\\n        ListNode prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev.next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode curr = prev.next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode forw = curr.next; // forw pointer will be after curr\\n            curr.next = forw.next;\\n            forw.next = prev.next;\\n            prev.next = forw;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // created dummy node\\n        dummy->next = head;\\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev->next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode *curr = prev->next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode *forw = curr->next; // forw pointer will be after curr\\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nInput: head = [1,2,10,20,30,40,5], left = 3, right = 6\\nOutput: [1,2,40,30,20,10,5]\\n```\n```\\nSo, the pre pointer will be assigned on just before left position\\nCurr pointer & forw pointer will help in reversing the linkedlist\\n\\nSo, we gonna perform these steps,\\ncurr.next = forw.next\\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\\nprev.next = forw\\nforw = curr.next\\n```\n```\\nBecause, let\\'s say we have given \"left = 1\" then where our prev pointer will be assigned then, \\nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(0); // created dummy node\\n        dummy.next = head;\\n        ListNode prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev.next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode curr = prev.next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode forw = curr.next; // forw pointer will be after curr\\n            curr.next = forw.next;\\n            forw.next = prev.next;\\n            prev.next = forw;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // created dummy node\\n        dummy->next = head;\\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev->next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode *curr = prev->next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode *forw = curr->next; // forw pointer will be after curr\\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30668,
                "title": "c-simple",
                "content": "First locate the node before the `m`-th node (`pre`) and the `m`-th node (`cur`). Then move`cur -> next` to be after `pre` for `n - m` times.\\n\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n        dummy -> next = head;\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre -> next;\\n        }\\n        cur = pre -> next;\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n        dummy -> next = head;\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre -> next;\\n        }\\n        cur = pre -> next;\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30667,
                "title": "easy-understanding-java-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy = new ListNode(0);\\n            dummy.next = head;\\n            //first part\\n            ListNode cur1 = dummy;\\n            ListNode pre1 = null;\\n            for(int i=0;i<m;i++){\\n                pre1 = cur1;\\n                cur1 = cur1.next;\\n            }\\n            \\n            //reverse\\n            ListNode cur2 = cur1;\\n            ListNode pre2 = pre1;\\n            ListNode q2;\\n            for(int i=m;i<=n;i++){\\n                q2 = cur2.next;\\n                cur2.next = pre2;\\n                pre2 = cur2;\\n                cur2 = q2;\\n            }\\n            \\n            //connect \\n            pre1.next = pre2;\\n            cur1.next = cur2;\\n            \\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy = new ListNode(0);\\n            dummy.next = head;\\n            //first part\\n            ListNode cur1 = dummy;\\n            ListNode pre1 = null;\\n            for(int i=0;i<m;i++){\\n                pre1 = cur1;\\n                cur1 = cur1.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30672,
                "title": "python-one-pass-iterative-solution",
                "content": "The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1\\n\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @param m, an integer\\n        # @param n, an integer\\n        # @return a ListNode\\n        def reverseBetween(self, head, m, n):\\n            if m == n:\\n                return head\\n    \\n            dummyNode = ListNode(0)\\n            dummyNode.next = head\\n            pre = dummyNode\\n    \\n            for i in range(m - 1):\\n                pre = pre.next\\n            \\n            # reverse the [m, n] nodes\\n            reverse = None\\n            cur = pre.next\\n            for i in range(n - m + 1):\\n                next = cur.next\\n                cur.next = reverse\\n                reverse = cur\\n                cur = next\\n    \\n            pre.next.next = cur\\n            pre.next = reverse\\n    \\n            return dummyNode.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1\\n\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @param m, an integer\\n        # @param n, an integer\\n        # @return a ListNode\\n        def reverseBetween(self, head, m, n):\\n            if m == n:\\n                return head\\n    \\n            dummyNode = ListNode(0)\\n            dummyNode.next = head\\n            pre = dummyNode\\n    \\n            for i in range(m - 1):\\n                pre = pre.next\\n            \\n            # reverse the [m, n] nodes\\n            reverse = None\\n            cur = pre.next\\n            for i in range(n - m + 1):\\n                next = cur.next\\n                cur.next = reverse\\n                reverse = cur\\n                cur = next\\n    \\n            pre.next.next = cur\\n            pre.next = reverse\\n    \\n            return dummyNode.next",
                "codeTag": "Java"
            },
            {
                "id": 839124,
                "title": "short-solutions-long-explanations-with-pictures",
                "content": "This is the objective:\\n\\n\\n![image](https://assets.leetcode.com/users/images/229b6d58-2a1c-4f87-8af5-7a9ee5fdb50e_1599848792.0750904.png)\\n\\nAll solutions below are one-pass, iterative ` O(N)`, `4 ms`.\\n\\n#### Good solution, 11-lines, 3 variables\\n\\nI use `3` additional variables (`ListNode*` pointers). \\n* `start` points at the node that procedes the green sublist we want to invert (or holds `nullptr` if the sublist is at the front).\\n* `h` points at the current node.\\n* `prev` points at the previous node.\\n\\n\\nThe algo is the following: traverse the gray left sublist, keeping track of the previous node and adjusting `start` variable so that at the end it points at the last gray node.\\n\\n![image](https://assets.leetcode.com/users/images/cd668784-2ba0-4109-afff-2b8762d81711_1599850514.4737976.png)\\n\\n\\n\\nTraverse the green sublist, keeping track of the previous node and inverting the pointers of the nodes.\\nThe pointer of the leftmost green node can be undetermined though.\\n\\n![image](https://assets.leetcode.com/users/images/b5835d7a-8d30-440e-ae4b-aa0b8d396eef_1599850220.599696.png)\\n\\n\\n\\nNow let the `start` node point at the last node of the green sublist.\\nLet the first node of the green sublist point at the first node past green sublist. Return `head`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/80b81a94-6e9a-43a2-abaa-28d918174b64_1599849692.615093.png)\\n\\n\\n\\n\\nIf green sublist starts right at the start of the linked list, then `start` is `nullptr`. In this case set the `head` variable to the last node of the green sublist. As before the first node of the green sublist should point at the first node past green sublist. Return `head`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/f95ffe45-5f3a-453e-ac4c-3321797d1b39_1599850028.6086926.png)\\n\\n<br>\\n\\nHere\\'s the code:\\n\\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tListNode *start, *h, *prev = nullptr;\\n\\n\\tfor(h = head; n--; m--)\\n\\t\\tif(m>0)\\n\\t\\t\\tstart = exchange(prev, exchange(h, h->next));\\n\\t\\telse\\n\\t\\t\\tprev  = exchange(h, exchange(h->next, prev));\\n\\n    if(start)\\n        start->next->next = h, start->next = prev;\\n    else\\n        head->next = h, head = prev;\\n\\n\\treturn head;\\n}\\n```\\n\\n\\n\\nThe `if(m>0)` branch is responsible for traversing the gray sublist + the leftmost green node. The main objective : set the `start` variable that we will need later.\\nThe `else` branch is responsible for traversing all the rest of the green sublist. The main objective : invert pointers.\\nBoth branches maintain `h` and `prev` pointers (basically `h->next` \\u2192 `h` \\u2192 `prev`).\\nWe should be careful though because as we switch green pointers we can no longer use them to advance `h`, hence we should use temp variable to store `h->next` before we change it (I did it all with the help of handy `exchange` function instead).\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/1e5c8007-fadb-4c93-8679-63cb717f7c21_1599743516.2696543.png)\\n\\n<br>\\n\\nThe loop terminates after we process the last node in the green sublist.\\nWe can now use `start` variable to the set the pointers of `start` node and `start->next` node.\\n`Start` can be `nullptr` hence the `if` part.\\n\\n**Pictures**\\n\\nThe first line is the initial linked list with green sublist we aim to  invert.\\nThe second line represents the state after the loop.\\nThe last line shows the final result.\\n\\nHere is the testcase where the sublist we want to invert is inside the list.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/12e20c5a-f825-48d9-a8e9-80b7abe728bf_1599709537.467519.png)\\n\\n<br>\\n\\nHere is the testcase where the sublist we want to invert is at the front.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/89b26cfd-cc93-45c2-8e28-b7d13fe6cf95_1599762595.596899.png)\\n\\n<br>\\n<br>\\n\\n**Better solution, 5-liner, 3 variables**\\n\\nIt\\'s possible to improve the solution above.\\nIf we use `ListNode **`  variable we can get rid of `if` before`return` and treat two testcases from the pictures uniformly.\\nBasically it\\'s dummy node solution in disguise.\\nWe can also avoid `if` in the loop and break it down into two smaller loops instead.\\n\\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto *prev{head}, *h{head}, **start{&head};\\n\\n\\tfor(; prev = exchange(h, h->next), --m && --n; start = &prev->next); \\n\\tfor(; --n; prev = exchange(h, exchange(h->next, prev))); \\n\\n\\t(*start)->next = h, *start = prev;\\n\\n\\treturn head;\\n}\\n\\n```\\n\\n**Great solution, 4 liner, 2 variables** (credit to https://leetcode.com/problems/reverse-linked-list-ii/discuss/30676/6-10-lines-in-C%2B%2B) \\n\\nI don\\'t like a couple of things in my solution.\\nThe last line before `return` is kinda lame. It would be so much better if everything was finished inside the loop.\\nIt\\'s also wasteful that until the end the first green node doesn\\'t point at anything useful.\\nIf we can make it point at the node we are going to consider next, we no longer need `prev` and `h` variables hopping around, we just need one variable that I will call `pivot`.\\nIt other words instead of this\\n\\n\\n![image](https://assets.leetcode.com/users/images/c9e40926-14c4-4de5-b55f-ff77c5fd3458_1600043706.5722702.png)\\n\\n\\n\\nwe will have this\\n\\n![image](https://assets.leetcode.com/users/images/5f7c8be5-d6e9-4738-8c4d-b4222ffa4c65_1600042483.4226246.png)\\n\\n\\n\\nLet\\'s consider another green node. We need to manage three arrows (pointers `pivot->next`, `pivot->next->next` and `start->next`) namely\\n* `pivot->next` should go to `start`  \\n*  `pivot->next->next` should go to `pivot`\\n* `start->next` should go to `pivot->next->next`\\n\\n\\n![image](https://assets.leetcode.com/users/images/f12c0247-8569-47b8-8ce5-387fd244ef49_1600042419.6194477.png)\\n\\n\\nthat will result\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cc221e6-024d-4057-8764-59886426d6f1_1600044869.3226385.png)\\n\\n\\nThe amazing part is that we don\\'t need to \"cook up\" new pointers, we just transfer ownership of the existing ones. This truly shows that this problem is not about\\nnodes - it\\'s about pointers.\\n\\nIt\\'s also useful **both** auxilary variables `start` and `pivot` be of type `ListNode**`. This makes code easier.\\nThis leads to the solution\\n \\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto **pivot{&head->next}, **start{&head};\\n\\n\\tfor(; --n && --m; pivot = &(*(start = pivot))->next); \\n\\tfor(; n--; swap(*start, (*pivot)->next), swap(*start, *pivot)); \\n\\n\\treturn head;\\n}\\n```\\nThis is the most accurate picture of what is going on.\\n\\n\\n![image](https://assets.leetcode.com/users/images/51861227-af1e-4d4e-95ea-ac1a0e91b248_1600039376.005103.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/86d64a15-a9db-4675-b98a-8fadfcbf7909_1600045889.459057.png)\\n\\n\\nI like this solution (credit to StefanPochmann\\'s https://leetcode.com/problems/reverse-linked-list-ii/discuss/30676/6-10-lines-in-C%2B%2B)) because it reshuffles **existing** pointers, uses minimum number of additional variables, early returns and automatically handles special case when the green sublist starts at the start of the list (done by using `ListNode**` variables).\\n\\nP.S. Sorry, it has turned out to be pretty lengthy.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tListNode *start, *h, *prev = nullptr;\\n\\n\\tfor(h = head; n--; m--)\\n\\t\\tif(m>0)\\n\\t\\t\\tstart = exchange(prev, exchange(h, h->next));\\n\\t\\telse\\n\\t\\t\\tprev  = exchange(h, exchange(h->next, prev));\\n\\n    if(start)\\n        start->next->next = h, start->next = prev;\\n    else\\n        head->next = h, head = prev;\\n\\n\\treturn head;\\n}\\n```\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto *prev{head}, *h{head}, **start{&head};\\n\\n\\tfor(; prev = exchange(h, h->next), --m && --n; start = &prev->next); \\n\\tfor(; --n; prev = exchange(h, exchange(h->next, prev))); \\n\\n\\t(*start)->next = h, *start = prev;\\n\\n\\treturn head;\\n}\\n\\n```\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto **pivot{&head->next}, **start{&head};\\n\\n\\tfor(; --n && --m; pivot = &(*(start = pivot))->next); \\n\\tfor(; n--; swap(*start, (*pivot)->next), swap(*start, *pivot)); \\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011862,
                "title": "92-40-two-pointers-stack-recursion",
                "content": "# Interview Guide - Reversing a Sublist of a Linked List: A Comprehensive Analysis for Programmers\\n\\n## Introduction & Problem Statement\\n\\nWelcome to this detailed guide, where we delve into the fascinating problem of reversing a sublist within a singly-linked list. The challenge is not just to reverse a sublist but to do it efficiently, ideally in a single pass through the list. This guide is designed to arm you with multiple approaches for tackling this problem, each with its own unique advantages and considerations. Specifically, we will explore three distinct strategies: Two Pointers, Using a Stack, and Recursion.\\n\\n## Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n    Let\\'s start with the basics. In a singly-linked list, each node has an integer value and a `next` pointer that points to the subsequent node in the list.\\n    \\n2. **Sublist Reversal**:  \\n    The primary task is to reverse only the nodes between positions `left` and `right`, both inclusive, within the list.\\n\\n3. **Order Preservation**:  \\n    While reversing the sublist, we must ensure that the relative order of all nodes outside this range remains unchanged.\\n\\n4. **Size Constraints**:  \\n    The number of nodes in the list `n` can vary but will always be between 1 and 500, giving us more than enough to work with.\\n\\n# Live Coding & More\\nhttps://youtu.be/RohipcSF3HM?si=9GIVdRg72_EHEMmv\\n\\n- [\\uD83D\\uDC0D Two Pointers \\uD83D\\uDC49\\uD83D\\uDC48](https://youtu.be/RohipcSF3HM?si=9GIVdRg72_EHEMmv)\\n- [\\uD83D\\uDC0D Stack \\uD83D\\uDCDA](https://youtu.be/E79svvS1DB0?si=37SbMxSSJeQQHHcf)\\n- [\\uD83D\\uDC0D Recursion \\uD83D\\uDD01](https://youtu.be/xcKS9d1_vDg?si=rbsNpLsNa3EJSVD8)\\n\\n---\\n# Strategies to Tackle the Problem: A Three-Pronged Approach\\n\\n## 1. Using Two Pointers (One-Pass)\\n\\n### Intuition and Logic Behind the Solution\\n\\nIn this efficient method, we employ two pointers to traverse and manipulate the linked list in one go. The clever use of a dummy node helps us elegantly handle edge cases, and tuple unpacking makes the code more Pythonic and straightforward.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create a `dummy` node and connect its `next` to the head of the list.\\n    - Initialize a `prev` pointer to the `dummy` node.\\n\\n2. **Move to Start Position**:  \\n    - Traverse the list until the node just before the `left`-th node is reached.\\n\\n3. **Execute Sublist Reversal**:  \\n    - Use a `current` pointer to keep track of the first node in the sublist.\\n    - Reverse the sublist nodes using `prev` and `current`.\\n\\n4. **Link Back**:  \\n    - Automatically link the reversed sublist back into the original list.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)` \\u2014 A single traversal does the job.\\n- **Space Complexity**: `O(1)` \\u2014 Smart pointer manipulation eliminates the need for additional data structures.\\n\\n---\\n\\n## 2. Using a Stack\\n\\n### Intuition and Logic Behind the Solution\\n\\nThis approach uses a stack data structure to temporarily store and then reverse the sublist, making the logic easier to follow.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n    - Like before, create a `dummy` node and set a `prev` pointer.\\n\\n2. **Populate the Stack**:  \\n    - Traverse the list and populate the stack with the nodes falling within the `left` and `right` positions.\\n\\n3. **Perform Reversal and Relink Nodes**:  \\n    - Pop nodes from the stack and relink them, essentially reversing the sublist.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)`\\n- **Space Complexity**: `O(n)` \\u2014 The stack takes extra space.\\n\\n---\\n\\n## 3. Using Recursion\\n\\n#### Intuition and Logic Behind the Solution\\n\\nIn this elegant method, the language\\'s call stack is leveraged to reverse the sublist through recursive function calls.\\n\\n### Step-by-step Explanation\\n\\n1. **Define Recursive Function**: \\n    - Create a helper function that will do the heavy lifting, taking the node and its position as parameters.\\n\\n2. **Base and Recursive Cases**:  \\n    - Implement base and recursive cases to control the flow and reversal.\\n\\n3. **Unwind and Relink**:  \\n    - As the recursion unwinds, the nodes get relinked in the reversed order.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)`\\n- **Space Complexity**: `O(n)` \\u2014 The call stack consumes extra memory.\\n\\n## Code Highlights and Best Practices\\n\\n- The use of a `dummy` node is universal across all methods for handling edge cases gracefully.\\n- Tuple unpacking in the Two-Pointer approach makes the code clean and Pythonic.\\n- The Stack approach makes clever use of the stack data structure for sublist reversal.\\n- The Recursion method leverages the language\\'s call stack for a clean and elegant solution.\\n\\n---\\n\\n# Performance\\n\\n| Language     | Fastest Runtime (ms) | Memory Usage (MB) | Method      |\\n|--------------|----------------------|-------------------|-------------|\\n| Rust         | 0                    | 2.3               | Two-Pointers|\\n| PHP          | 0                    | 18.9              | Two-Pointers|\\n| Java         | 0                    | 40.8              | Two-Pointers|\\n| Go           | 1                    | 2.1               | Two-Pointers|\\n| C++          | 4                    | 7.4               | Two-Pointers|\\n| Python3      | 33                   | 16.6              | Two-Pointers|\\n| Python3      | 38                   | 16.6              | Recursion   |\\n| Python3      | 39                   | 16.3              | Stack       |\\n| JavaScript   | 44                   | 41.8              | Two-Pointers|\\n| C#           | 71                   | 38.4              | Two-Pointers|\\n \\n![n4.png](https://assets.leetcode.com/users/images/0ba70f84-5f2e-4007-aea3-7c491f9610e1_1694049302.9630964.png)\\n\\n\\n# Code Two Pointers\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n        \\n        dummy = ListNode(0, head)\\n        prev = dummy\\n        \\n        for _ in range(left - 1):\\n            prev = prev.next\\n        \\n        current = prev.next\\n        \\n        for _ in range(right - left):\\n            next_node = current.next\\n            current.next, next_node.next, prev.next = next_node.next, prev.next, next_node\\n\\n        return dummy.next\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n    \\n    dummy := &ListNode{0, head}\\n    prev := dummy\\n    \\n    for i := 0; i < left - 1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    current := prev.Next\\n    \\n    for i := 0; i < right - left; i++ {\\n        nextNode := current.Next\\n        current.Next = nextNode.Next\\n        nextNode.Next = prev.Next\\n        prev.Next = nextNode\\n    }\\n    \\n    return dummy.Next\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = Some(Box::new(ListNode {\\n            val: 0,\\n            next: head,\\n        }));\\n        let mut before = &mut dummy;\\n        for _ in 1..left {\\n            before = &mut before.as_mut()?.next;\\n        }\\n\\n        let mut node = before.as_mut()?.next.take();\\n        let mut node2 = node.as_mut()?.next.take();\\n        for _ in left..right {\\n            let node3 = node2.as_mut()?.next.take();\\n            node2.as_mut()?.next = node;\\n            node = node2;\\n            node2 = node3;\\n        }\\n\\n        let mut rev_tail = &mut node;\\n        for _ in left..right {\\n            rev_tail = &mut rev_tail.as_mut()?.next;\\n        }\\n        rev_tail.as_mut()?.next = node2;\\n        before.as_mut()?.next = node;\\n\\n        dummy.unwrap().next\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) return head;\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode* prev = &dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev->next;\\n        }\\n        \\n        ListNode* current = prev->next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode* next_node = current->next;\\n            current->next = next_node->next;\\n            next_node->next = prev->next;\\n            prev->next = next_node;\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function reverseBetween($head, $left, $right) {\\n        if ($head == null || $left == $right) return $head;\\n        \\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $prev = $dummy;\\n        \\n        for ($i = 0; $i < $left - 1; ++$i) {\\n            $prev = $prev->next;\\n        }\\n        \\n        $current = $prev->next;\\n        \\n        for ($i = 0; $i < $right - $left; ++$i) {\\n            $nextNode = $current->next;\\n            $current->next = $nextNode->next;\\n            $nextNode->next = $prev->next;\\n            $prev->next = $nextNode;\\n        }\\n        \\n        return $dummy->next;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    let prev = dummy;\\n    \\n    for (let i = 0; i < left - 1; ++i) {\\n        prev = prev.next;\\n    }\\n    \\n    let current = prev.next;\\n    \\n    for (let i = 0; i < right - left; ++i) {\\n        const nextNode = current.next;\\n        current.next = nextNode.next;\\n        nextNode.next = prev.next;\\n        prev.next = nextNode;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\n# Code Recursion\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not (head and left < right):\\n            return head\\n\\n        def helper(node, m):\\n            nonlocal left, right\\n            if m == left:\\n                prev = None\\n                current = node\\n                while m <= right:\\n                    current.next, prev, current = prev, current, current.next\\n                    m += 1\\n                node.next = current\\n                return prev\\n            elif m < left:\\n                node.next = helper(node.next, m + 1)\\n            return node\\n\\n        return helper(head, 1)\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left >= right {\\n        return head\\n    }\\n\\n    var helper func(node *ListNode, m int) *ListNode\\n    helper = func(node *ListNode, m int) *ListNode {\\n        if m == left {\\n            var prev, current *ListNode = nil, node\\n            for m <= right {\\n                current.Next, prev, current = prev, current, current.Next\\n                m++\\n            }\\n            node.Next = current\\n            return prev\\n        } else if m < left {\\n            node.Next = helper(node.Next, m+1)\\n        }\\n        return node\\n    }\\n\\n    return helper(head, 1)\\n}\\n\\n```\\n\\n# Code Stack\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        stack = []\\n        current = prev.next\\n\\n        for _ in range(right - left + 1):\\n            stack.append(current)\\n            current = current.next\\n\\n        while stack:\\n            prev.next = stack.pop()\\n            prev = prev.next\\n\\n        prev.next = current\\n\\n        return dummy.next\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n\\n    dummy := &ListNode{Val: 0, Next: head}\\n    prev := dummy\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    stack := []*ListNode{}\\n    current := prev.Next\\n\\n    for i := 0; i < right-left+1; i++ {\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    for len(stack) > 0 {\\n        last := len(stack) - 1\\n        prev.Next = stack[last]\\n        stack = stack[:last]\\n        prev = prev.Next\\n    }\\n\\n    prev.Next = current\\n\\n    return dummy.Next\\n}\\n\\n```\\n\\n# Live Coding & More\\n## Stack\\nhttps://youtu.be/E79svvS1DB0?si=37SbMxSSJeQQHHcf\\n## Recursion\\nhttps://youtu.be/xcKS9d1_vDg?si=rbsNpLsNa3EJSVD8\\n\\n## Final Thoughts\\n\\nEach of the three methods comes with its own set of pros and cons. Your choice would depend on various factors such as readability, space complexity, and the specific constraints of the problem at hand. This guide equips you with the knowledge to make that choice wisely.\\n\\nSo there you have it\\u2014a multifaceted guide to tackling the problem of reversing a sublist in a singly-linked list. Armed with this knowledge, you\\'re now better prepared to face linked list challenges in interviews and beyond. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Linked List",
                    "Stack"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n        \\n        dummy = ListNode(0, head)\\n        prev = dummy\\n        \\n        for _ in range(left - 1):\\n            prev = prev.next\\n        \\n        current = prev.next\\n        \\n        for _ in range(right - left):\\n            next_node = current.next\\n            current.next, next_node.next, prev.next = next_node.next, prev.next, next_node\\n\\n        return dummy.next\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n    \\n    dummy := &ListNode{0, head}\\n    prev := dummy\\n    \\n    for i := 0; i < left - 1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    current := prev.Next\\n    \\n    for i := 0; i < right - left; i++ {\\n        nextNode := current.Next\\n        current.Next = nextNode.Next\\n        nextNode.Next = prev.Next\\n        prev.Next = nextNode\\n    }\\n    \\n    return dummy.Next\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = Some(Box::new(ListNode {\\n            val: 0,\\n            next: head,\\n        }));\\n        let mut before = &mut dummy;\\n        for _ in 1..left {\\n            before = &mut before.as_mut()?.next;\\n        }\\n\\n        let mut node = before.as_mut()?.next.take();\\n        let mut node2 = node.as_mut()?.next.take();\\n        for _ in left..right {\\n            let node3 = node2.as_mut()?.next.take();\\n            node2.as_mut()?.next = node;\\n            node = node2;\\n            node2 = node3;\\n        }\\n\\n        let mut rev_tail = &mut node;\\n        for _ in left..right {\\n            rev_tail = &mut rev_tail.as_mut()?.next;\\n        }\\n        rev_tail.as_mut()?.next = node2;\\n        before.as_mut()?.next = node;\\n\\n        dummy.unwrap().next\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) return head;\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode* prev = &dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev->next;\\n        }\\n        \\n        ListNode* current = prev->next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode* next_node = current->next;\\n            current->next = next_node->next;\\n            next_node->next = prev->next;\\n            prev->next = next_node;\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function reverseBetween($head, $left, $right) {\\n        if ($head == null || $left == $right) return $head;\\n        \\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $prev = $dummy;\\n        \\n        for ($i = 0; $i < $left - 1; ++$i) {\\n            $prev = $prev->next;\\n        }\\n        \\n        $current = $prev->next;\\n        \\n        for ($i = 0; $i < $right - $left; ++$i) {\\n            $nextNode = $current->next;\\n            $current->next = $nextNode->next;\\n            $nextNode->next = $prev->next;\\n            $prev->next = $nextNode;\\n        }\\n        \\n        return $dummy->next;\\n    }\\n}\\n```\n``` JavaScript []\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    let prev = dummy;\\n    \\n    for (let i = 0; i < left - 1; ++i) {\\n        prev = prev.next;\\n    }\\n    \\n    let current = prev.next;\\n    \\n    for (let i = 0; i < right - left; ++i) {\\n        const nextNode = current.next;\\n        current.next = nextNode.next;\\n        nextNode.next = prev.next;\\n        prev.next = nextNode;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not (head and left < right):\\n            return head\\n\\n        def helper(node, m):\\n            nonlocal left, right\\n            if m == left:\\n                prev = None\\n                current = node\\n                while m <= right:\\n                    current.next, prev, current = prev, current, current.next\\n                    m += 1\\n                node.next = current\\n                return prev\\n            elif m < left:\\n                node.next = helper(node.next, m + 1)\\n            return node\\n\\n        return helper(head, 1)\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left >= right {\\n        return head\\n    }\\n\\n    var helper func(node *ListNode, m int) *ListNode\\n    helper = func(node *ListNode, m int) *ListNode {\\n        if m == left {\\n            var prev, current *ListNode = nil, node\\n            for m <= right {\\n                current.Next, prev, current = prev, current, current.Next\\n                m++\\n            }\\n            node.Next = current\\n            return prev\\n        } else if m < left {\\n            node.Next = helper(node.Next, m+1)\\n        }\\n        return node\\n    }\\n\\n    return helper(head, 1)\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        stack = []\\n        current = prev.next\\n\\n        for _ in range(right - left + 1):\\n            stack.append(current)\\n            current = current.next\\n\\n        while stack:\\n            prev.next = stack.pop()\\n            prev = prev.next\\n\\n        prev.next = current\\n\\n        return dummy.next\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n\\n    dummy := &ListNode{Val: 0, Next: head}\\n    prev := dummy\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    stack := []*ListNode{}\\n    current := prev.Next\\n\\n    for i := 0; i < right-left+1; i++ {\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    for len(stack) > 0 {\\n        last := len(stack) - 1\\n        prev.Next = stack[last]\\n        stack = stack[:last]\\n        prev = prev.Next\\n    }\\n\\n    prev.Next = current\\n\\n    return dummy.Next\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291559,
                "title": "python-o-1-o-n-space-time-solution-explained",
                "content": "Very similar to problem **25**. We keep three pointers as with any other reverse linked lists problems: `pre, curr, next`. We can split all algorithm into `3` steps:\\n\\n1. Do `m-1` steps to reach the first point of range we need to reverse.\\n2. Reverse range `[n - m]`, using 3 pointers approach.\\n3. Finally we need to fix connections for the start and for the end of reversed list, using saved pointer to `pre` element.\\n\\n#### Complexity\\nTime complexity is `O(n)`, because we need to traverse elements upto `n`-th. Space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def reverseBetween(self, head, m, n):\\n        if m == n: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(m-1):\\n            pre = pre.next\\n            \\n        curr = pre.next\\n        nxt = curr.next\\n        \\n        for i in range(n-m):\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        pre.next.next = nxt\\n        pre.next = curr\\n        return dummy.next\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head, m, n):\\n        if m == n: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(m-1):\\n            pre = pre.next\\n            \\n        curr = pre.next\\n        nxt = curr.next\\n        \\n        for i in range(n-m):\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        pre.next.next = nxt\\n        pre.next = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30744,
                "title": "share-my-14-lines-c-solution",
                "content": "     ListNode *reverseBetween(ListNode *head, int m, int n) {\\n        if(m==n)return head;\\n\\t\\tn-=m;\\n        ListNode prehead(0);\\n        prehead.next=head;\\n        ListNode* pre=&prehead;\\n        while(--m)pre=pre->next;        \\n        ListNode* pstart=pre->next;\\n        while(n--)\\n        {\\n            ListNode *p=pstart->next;\\n            pstart->next=p->next;\\n            p->next=pre->next;\\n            pre->next=p;\\n        }\\n        return prehead.next;\\n    }",
                "solutionTags": [],
                "code": "     ListNode *reverseBetween(ListNode *head, int m, int n) {\\n        if(m==n)return head;\\n\\t\\tn-=m;\\n        ListNode prehead(0);\\n        prehead.next=head;\\n        ListNode* pre=&prehead;\\n        while(--m)pre=pre->next;        \\n        ListNode* pstart=pre->next;\\n        while(n--)\\n        {\\n            ListNode *p=pstart->next;\\n            pstart->next=p->next;\\n            p->next=pre->next;\\n            pre->next=p;\\n        }\\n        return prehead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30676,
                "title": "6-10-lines-in-c",
                "content": "This ended up a bit extreme. I suggest to read the original one at the bottom first, which also includes an explanation. Then move upwards through the updates.\\n\\nUpdate 4:\\n\"Code golf\" (6 lines)\\n-\\n\\nNot fully golfed, but yeah...\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **a = &head, **b;\\n        for (;m--; n--)\\n            a = &(*(b=a))->next;\\n        for (;n--; swap(*b, *a))\\n            swap(*b, (*a)->next);\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 3:\\nPointer pointers (8 lines)\\n-\\n\\nRemoved duplicate code.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **pivot = &head, **prev;\\n        for (int i=0; i<m; i++)\\n            pivot = &(*(prev=pivot))->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 2:\\nPointer pointers (9 lines)\\n-\\n\\nUsing a second pointer pointer.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode **pivot = &(*prev)->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 1:\\nPointer pointer (9 lines)\\n-\\n\\nMotivated by quick glance at [lchen77's solution](https://leetcode.com/discuss/74361/less-than-10-lines-c-double-pointer-easy-understanding).\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode *pivot = *prev;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, pivot->next->next);\\n            swap(*prev, pivot->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nDummy node (10 lines)\\n-\\n\\nMy original one.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode dummy(0), *prev = &dummy;\\n        dummy.next = head;\\n        for (int i=1; i<m; i++)\\n            prev = prev->next;\\n        ListNode *pivot = prev->next;\\n        for (int i=m; i<n; i++) {\\n            swap(prev->next, pivot->next->next);\\n            swap(prev->next, pivot->next);\\n        }\\n        return dummy.next;\\n    }\\n\\nSome explanation: First I find the node right *before* the first node in the reverse range. I call it `prev`. And I call the first node *in* the reverse range `pivot`. Then this pivot node goes through the reverse range. Every next node it encounters is moved behind `prev`, i.e., to the start of the reverse range. \\n\\nSo before the reversing, I'm in this situation:\\n\\n    prev   pivot\\n     |       |\\n    [A] --> [B] --> [C] --> [D] --> [E] --> [F] --> ...\\n\\nIn front of the pivot we have node C, which gets moved to after prev, and pivot moves on:\\n\\n    prev           pivot\\n     |               |\\n    [A] --> [C] --> [B] --> [D] --> [E] --> [F] --> ...\\n\\nSo far the range from B to C has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node D, which gets moved to after prev, and pivot moves on:\\n\\n    prev                   pivot\\n     |                       |\\n    [A] --> [D] --> [C] --> [B] --> [E] --> [F] --> ...\\n\\nSo far the range from B to D has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node E, which gets moved to after prev, and pivot moves on:\\n\\n    prev                           pivot\\n     |                               |\\n    [A] --> [E] --> [D] --> [C] --> [B] --> [F] --> ...\\n\\nSo far the range from B to E has been reversed. If that was the goal, we can stop now. Otherwise...\\n\\nAnd so on...\\n\\nNote that taking out a node in front of the pivot and inserting it after prev involves modifying three pointers: `prev->next`, `pivot->next` and `pivot->next->next`. I do it with two swaps, but it could also be done with a helper variable and four assignments:\\n\\n            for (int i=m; i<n; i++) {\\n                auto next = pivot->next;\\n                pivot->next = next->next;\\n                next->next = prev->next;\\n                prev->next = next;\\n            }",
                "solutionTags": [
                    "C++"
                ],
                "code": "This ended up a bit extreme. I suggest to read the original one at the bottom first, which also includes an explanation. Then move upwards through the updates.\\n\\nUpdate 4:\\n\"Code golf\" (6 lines)\\n-\\n\\nNot fully golfed, but yeah...\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **a = &head, **b;\\n        for (;m--; n--)\\n            a = &(*(b=a))->next;\\n        for (;n--; swap(*b, *a))\\n            swap(*b, (*a)->next);\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 3:\\nPointer pointers (8 lines)\\n-\\n\\nRemoved duplicate code.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **pivot = &head, **prev;\\n        for (int i=0; i<m; i++)\\n            pivot = &(*(prev=pivot))->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 2:\\nPointer pointers (9 lines)\\n-\\n\\nUsing a second pointer pointer.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode **pivot = &(*prev)->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 1:\\nPointer pointer (9 lines)\\n-\\n\\nMotivated by quick glance at [lchen77's solution](https://leetcode.com/discuss/74361/less-than-10-lines-c-double-pointer-easy-understanding).\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode *pivot = *prev;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, pivot->next->next);\\n            swap(*prev, pivot->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nDummy node (10 lines)\\n-\\n\\nMy original one.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode dummy(0), *prev = &dummy;\\n        dummy.next = head;\\n        for (int i=1; i<m; i++)\\n            prev = prev->next;\\n        ListNode *pivot = prev->next;\\n        for (int i=m; i<n; i++) {\\n            swap(prev->next, pivot->next->next);\\n            swap(prev->next, pivot->next);\\n        }\\n        return dummy.next;\\n    }\\n\\nSome explanation: First I find the node right *before* the first node in the reverse range. I call it `prev`. And I call the first node *in* the reverse range `pivot`. Then this pivot node goes through the reverse range. Every next node it encounters is moved behind `prev`, i.e., to the start of the reverse range. \\n\\nSo before the reversing, I'm in this situation:\\n\\n    prev   pivot\\n     |       |\\n    [A] --> [B] --> [C] --> [D] --> [E] --> [F] --> ...\\n\\nIn front of the pivot we have node C, which gets moved to after prev, and pivot moves on:\\n\\n    prev           pivot\\n     |               |\\n    [A] --> [C] --> [B] --> [D] --> [E] --> [F] --> ...\\n\\nSo far the range from B to C has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node D, which gets moved to after prev, and pivot moves on:\\n\\n    prev                   pivot\\n     |                       |\\n    [A] --> [D] --> [C] --> [B] --> [E] --> [F] --> ...\\n\\nSo far the range from B to D has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node E, which gets moved to after prev, and pivot moves on:\\n\\n    prev                           pivot\\n     |                               |\\n    [A] --> [E] --> [D] --> [C] --> [B] --> [F] --> ...\\n\\nSo far the range from B to E has been reversed. If that was the goal, we can stop now. Otherwise...\\n\\nAnd so on...\\n\\nNote that taking out a node in front of the pivot and inserting it after prev involves modifying three pointers: `prev->next`, `pivot->next` and `pivot->next->next`. I do it with two swaps, but it could also be done with a helper variable and four assignments:\\n\\n            for (int i=m; i<n; i++) {\\n                auto next = pivot->next;\\n                pivot->next = next->next;\\n                next->next = prev->next;\\n                prev->next = next;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 30673,
                "title": "why-nobody-does-it-with-recursion-shouldn-t-the-code-be-simpler",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(m==n){\\n            return head;\\n        }\\n        if(m>1){\\n            ListNode newHead = head;\\n            newHead.next = reverseBetween(head.next, m-1, n-1);\\n            return newHead;\\n        }else{\\n            ListNode next = head.next;\\n            ListNode newHead = reverseBetween(next, 1, n-1);\\n            ListNode nextnext = next.next;\\n            next.next = head;\\n            head.next = nextnext;\\n            return newHead;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(m==n){\\n            return head;\\n        }\\n        if(m>1){\\n            ListNode newHead = head;\\n            newHead.next = reverseBetween(head.next, m-1, n-1);\\n            return newHead;\\n        }else{\\n            ListNode next = head.next;\\n            ListNode newHead = reverseBetween(next, 1, n-1);\\n            ListNode nextnext = next.next;\\n            next.next = head;\\n            head.next = nextnext;\\n            return newHead;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30732,
                "title": "python-implementation-and-detailed-explanation",
                "content": "For List with [1, 2, 3, 4, 5], supposed m ==  2 and n == 4\\n\\n**Step1:**\\nThe part I need to reversed is node 2 to node 4, which has `n - m + 1` = 3 nodes.\\nTherefore, I would like to maintain a window with `n - m + 1` nodes with the window's head `whead` and window's tail `wtail`, then if `whead` is head,  `wtail` would be the next `n-m` node from head.\\n\\n-  [123]45 => `whead` is 1 and `wtail` is 3\\n\\n**Step2:**\\nAnd to get to the right reversed portion we want, we need to shift the window `m-1` times\\n\\n- 1[234]5 => `whead` is 2 and `wtail` is 4\\n\\n**Step3:** Isolate the nodes inside the window, reverse the window as [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n\\n**Step4:** combine the outside node with reversed node.\\nTo do so, I need to record the head outside the window `ohead`, and the tail outside the window `otail` \\n\\n- `ohead` is 1, `otail` is 5\\n- 1-[432]-5\\n\\n**Implementation detail:** Since in **step 4**, you need to let `ohead.next = reversed_head`If you create a dummy node, you can save some lines for m == 1 cases, where `ohead` would be `None` and `ohead.next` would fail the program.\\n\\n\\n    class Solution(object):\\n        def reverseBetween(self, head, m, n):\\n            if m >= n:\\n                return head\\n            #Step 1#    \\n            ohead = dummy = ListNode(0)\\n            whead = wtail = head\\n            dummy.next = head\\n            for i in range(n-m):\\n                wtail = wtail.next\\n            #Step 2#  \\n            for i in range(m-1):\\n                ohead, whead, wtail = whead, whead.next, wtail.next\\n            #Step 3#  \\n            otail, wtail.next = wtail.next, None\\n            revhead, revtail = self.reverse(whead)\\n            #Step 4#  \\n            ohead.next, revtail.next = revhead, otail\\n            return dummy.next\\n                \\n        def reverse(self, head):\\n            pre, cur, tail = None, head, head\\n            while cur:\\n                cur.next, pre, cur = pre, cur, cur.next\\n            return pre, tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "For List with [1, 2, 3, 4, 5], supposed m ==  2 and n == 4\\n\\n**Step1:**\\nThe part I need to reversed is node 2 to node 4, which has `n - m + 1` = 3 nodes.\\nTherefore, I would like to maintain a window with `n - m + 1` nodes with the window's head `whead` and window's tail `wtail`, then if `whead` is head,  `wtail` would be the next `n-m` node from head.\\n\\n-  [123]45 => `whead` is 1 and `wtail` is 3\\n\\n**Step2:**\\nAnd to get to the right reversed portion we want, we need to shift the window `m-1` times\\n\\n- 1[234]5 => `whead` is 2 and `wtail` is 4\\n\\n**Step3:** Isolate the nodes inside the window, reverse the window as [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n\\n**Step4:** combine the outside node with reversed node.\\nTo do so, I need to record the head outside the window `ohead`, and the tail outside the window `otail` \\n\\n- `ohead` is 1, `otail` is 5\\n- 1-[432]-5\\n\\n**Implementation detail:** Since in **step 4**, you need to let `ohead.next = reversed_head`If you create a dummy node, you can save some lines for m == 1 cases, where `ohead` would be `None` and `ohead.next` would fail the program.\\n\\n\\n    class Solution(object):\\n        def reverseBetween(self, head, m, n):\\n            if m >= n:\\n                return head\\n            #Step 1#    \\n            ohead = dummy = ListNode(0)\\n            whead = wtail = head\\n            dummy.next = head\\n            for i in range(n-m):\\n                wtail = wtail.next\\n            #Step 2#  \\n            for i in range(m-1):\\n                ohead, whead, wtail = whead, whead.next, wtail.next\\n            #Step 3#  \\n            otail, wtail.next = wtail.next, None\\n            revhead, revtail = self.reverse(whead)\\n            #Step 4#  \\n            ohead.next, revtail.next = revhead, otail\\n            return dummy.next\\n                \\n        def reverse(self, head):\\n            pre, cur, tail = None, head, head\\n            while cur:\\n                cur.next, pre, cur = pre, cur, cur.next\\n            return pre, tail",
                "codeTag": "Java"
            },
            {
                "id": 30681,
                "title": "python-one-pass-concise-solution-with-comments",
                "content": "        \\n    def reverseBetween(self, head, m, n):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(m-1):\\n            pre = pre.next\\n        cur= pre.next\\n        # reverse the defined part \\n        node = None\\n        for _ in xrange(n-m+1):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur= nxt\\n        # connect three parts\\n        pre.next.next = cur\\n        pre.next = node\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def reverseBetween(self, head, m, n):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(m-1):\\n            pre = pre.next\\n        cur= pre.next\\n        # reverse the defined part \\n        node = None\\n        for _ in xrange(n-m+1):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur= nxt\\n        # connect three parts\\n        pre.next.next = cur\\n        pre.next = node\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 4011892,
                "title": "video-beat-97-21-python-javascript-java-c",
                "content": "This Python solution beats 97.21%.\\n\\n![Screen Shot 2023-09-07 at 9.31.46.png](https://assets.leetcode.com/users/images/7dd9d408-b0b0-495a-a052-ec386f5e8fdc_1694046724.5898378.png)\\n\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 257 videos as of September 7th, 2023.\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/vE__gU1MUnw\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2245\\nThank you for your support!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Check for base cases.\\n   - If the linked list is empty (`not head`) or `left` is equal to `right`, return the original `head` as there is no reversal needed.\\n\\n2. Initialize a `dummy` node to simplify edge cases and connect it to the head of the linked list.\\n   - Create a `dummy` node with a value of 0 and set its `next` pointer to the `head` of the linked list. This dummy node helps in handling the case when `left` is 1.\\n\\n3. Traverse the list to find the (left-1)-th node.\\n   - Initialize a `prev` pointer to `dummy`.\\n   - Loop `left - 1` times to move the `prev` pointer to the node just before the left-th node.\\n\\n4. Reverse the portion of the linked list from the left-th node to the right-th node.\\n   - Initialize a `cur` pointer to `prev.next`.\\n   - Loop `right - left` times to reverse the direction of the pointers in this portion of the linked list:\\n     - Store the next node (`temp`) of `cur` to avoid losing the reference.\\n     - Update the `cur.next` to point to `temp.next`, effectively reversing the direction.\\n     - Move `temp.next` to point to `prev.next`, effectively moving `temp` to the correct position in the reversed portion.\\n     - Update `prev.next` to point to `temp`, making `temp` the new next node of `prev`.\\n\\n5. Return the new head of the modified linked list.\\n   - `dummy.next` points to the head of the modified linked list, so return `dummy.next` as the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0, head)\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        cur = prev.next\\n        for _ in range(right - left):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next = prev.next\\n            prev.next = temp\\n\\n        return dummy.next\\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) {\\n        return head;\\n    }\\n\\n    const dummy = new ListNode(0, head);\\n    let prev = dummy;\\n\\n    for (let i = 0; i < left - 1; i++) {\\n        prev = prev.next;\\n    }\\n\\n    let cur = prev.next;\\n\\n    for (let i = 0; i < right - left; i++) {\\n        const temp = cur.next;\\n        cur.next = temp.next;\\n        temp.next = prev.next;\\n        prev.next = temp;\\n    }\\n\\n    return dummy.next;    \\n};\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) {\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        ListNode cur = prev.next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode temp = cur.next;\\n            cur.next = temp.next;\\n            temp.next = prev.next;\\n            prev.next = temp;\\n        }\\n\\n        return dummy.next;        \\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) {\\n            return head;\\n        }\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        ListNode* cur = prev->next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = cur->next;\\n            cur->next = temp->next;\\n            temp->next = prev->next;\\n            prev->next = temp;\\n        }\\n\\n        return dummy->next;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0, head)\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        cur = prev.next\\n        for _ in range(right - left):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next = prev.next\\n            prev.next = temp\\n\\n        return dummy.next\\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) {\\n        return head;\\n    }\\n\\n    const dummy = new ListNode(0, head);\\n    let prev = dummy;\\n\\n    for (let i = 0; i < left - 1; i++) {\\n        prev = prev.next;\\n    }\\n\\n    let cur = prev.next;\\n\\n    for (let i = 0; i < right - left; i++) {\\n        const temp = cur.next;\\n        cur.next = temp.next;\\n        temp.next = prev.next;\\n        prev.next = temp;\\n    }\\n\\n    return dummy.next;    \\n};\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) {\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        ListNode cur = prev.next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode temp = cur.next;\\n            cur.next = temp.next;\\n            temp.next = prev.next;\\n            prev.next = temp;\\n        }\\n\\n        return dummy.next;        \\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) {\\n            return head;\\n        }\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        ListNode* cur = prev->next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = cur->next;\\n            cur->next = temp->next;\\n            temp->next = prev->next;\\n            prev->next = temp;\\n        }\\n\\n        return dummy->next;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30876,
                "title": "share-my-java-code",
                "content": "The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. \\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n    \\tListNode dummyhead = new ListNode(0);\\n    \\tdummyhead.next = head;\\n    \\tListNode sublisthead = new ListNode(0);\\n    \\tListNode sublisttail = new ListNode(0);\\n    \\tint count = 1;\\n    \\tListNode pre_cur = dummyhead, cur = head;\\n    \\twhile(count <=n){\\n\\t\\t\\tListNode temp = cur.next;\\n    \\t\\tif (count < m)\\n    \\t\\t\\tpre_cur = cur;\\n    \\t\\telse if (count == m){\\n    \\t\\t\\tsublisttail = cur;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}else if (count > m){\\n    \\t\\t\\tcur.next = sublisthead.next;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}\\n    \\t\\tcur = temp;\\n    \\t\\t++count;\\n    \\t}\\n    \\tpre_cur.next = sublisthead.next;\\n    \\tsublisttail.next = cur;\\n    \\treturn dummyhead.next;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. \\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n    \\tListNode dummyhead = new ListNode(0);\\n    \\tdummyhead.next = head;\\n    \\tListNode sublisthead = new ListNode(0);\\n    \\tListNode sublisttail = new ListNode(0);\\n    \\tint count = 1;\\n    \\tListNode pre_cur = dummyhead, cur = head;\\n    \\twhile(count <=n){\\n\\t\\t\\tListNode temp = cur.next;\\n    \\t\\tif (count < m)\\n    \\t\\t\\tpre_cur = cur;\\n    \\t\\telse if (count == m){\\n    \\t\\t\\tsublisttail = cur;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}else if (count > m){\\n    \\t\\t\\tcur.next = sublisthead.next;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}\\n    \\t\\tcur = temp;\\n    \\t\\t++count;\\n    \\t}\\n    \\tpre_cur.next = sublisthead.next;\\n    \\tsublisttail.next = cur;\\n    \\treturn dummyhead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2310832,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseBetween(ListNode *head, int left, int right){\\n            ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n            dummy->next = head;\\n            for (int i = 0; i < left - 1; i++){\\n                pre = pre->next;\\n            }\\n            cur = pre->next;\\n            for (int i = 0; i < right - left; i++){\\n                ListNode *temp = pre->next;\\n                pre->next = cur->next;\\n                cur->next = cur->next->next;\\n                pre->next->next = temp;\\n            }\\n            return dummy->next;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseBetween(ListNode *head, int left, int right){\\n            ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n            dummy->next = head;\\n            for (int i = 0; i < left - 1; i++){\\n                pre = pre->next;\\n            }\\n            cur = pre->next;\\n            for (int i = 0; i < right - left; i++){\\n                ListNode *temp = pre->next;\\n                pre->next = cur->next;\\n                cur->next = cur->next->next;\\n                pre->next->next = temp;\\n            }\\n            return dummy->next;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910770,
                "title": "easy-js-solution",
                "content": "```\\nvar reverseBetween = function(head, m, n) {\\n    let start = head, cur = head;\\n    let i = 1;\\n    while (i < m) {\\n        start = cur;\\n        cur = cur.next;\\n        i++;\\n    }\\n    let prev = null, tail = cur;\\n    while (i <= n) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n        i++;\\n    }\\n    start.next = prev;\\n    tail.next = cur;\\n    return m == 1 ? prev : head; \\n    // if m == 1, we have no need to connect start list with reversed list reversed list itself is the start (or the head)\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseBetween = function(head, m, n) {\\n    let start = head, cur = head;\\n    let i = 1;\\n    while (i < m) {\\n        start = cur;\\n        cur = cur.next;\\n        i++;\\n    }\\n    let prev = null, tail = cur;\\n    while (i <= n) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n        i++;\\n    }\\n    start.next = prev;\\n    tail.next = cur;\\n    return m == 1 ? prev : head; \\n    // if m == 1, we have no need to connect start list with reversed list reversed list itself is the start (or the head)\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292582,
                "title": "2-different-approach-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* it = dummy;\\n        ListNode* pre_it = NULL;\\n        //traverse till left index\\n        for(int i = 0; i < left; i++){\\n            pre_it = it;\\n            it = it->next;\\n        }\\n        \\n        ListNode* itR = it;\\n        ListNode* pre_R = pre_it;\\n        //reverse \\n        for(int i = left; i <= right; i++){\\n            ListNode* forward = itR->next;\\n            itR->next = pre_R;\\n            pre_R = itR;\\n            itR = forward;\\n        }\\n        \\n        //connect\\n        pre_it->next = pre_R;\\n        it->next = itR;\\n\\t\\t\\n        return dummy->next;      \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* left_node = head; \\n        for(int i = 1; i < left; i++) left_node = left_node->next;\\n        \\n        ListNode* node = left_node;\\n        for(int i = 0; i < (right-left+1); i++){\\n            v.push_back(node->val);\\n            node = node->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i = 0; i < v.size(); i++){\\n            left_node->val = v[i];\\n            left_node = left_node->next;\\n        }\\n    return head;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* it = dummy;\\n        ListNode* pre_it = NULL;\\n        //traverse till left index\\n        for(int i = 0; i < left; i++){\\n            pre_it = it;\\n            it = it->next;\\n        }\\n        \\n        ListNode* itR = it;\\n        ListNode* pre_R = pre_it;\\n        //reverse \\n        for(int i = left; i <= right; i++){\\n            ListNode* forward = itR->next;\\n            itR->next = pre_R;\\n            pre_R = itR;\\n            itR = forward;\\n        }\\n        \\n        //connect\\n        pre_it->next = pre_R;\\n        it->next = itR;\\n\\t\\t\\n        return dummy->next;      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* left_node = head; \\n        for(int i = 1; i < left; i++) left_node = left_node->next;\\n        \\n        ListNode* node = left_node;\\n        for(int i = 0; i < (right-left+1); i++){\\n            v.push_back(node->val);\\n            node = node->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i = 0; i < v.size(); i++){\\n            left_node->val = v[i];\\n            left_node = left_node->next;\\n        }\\n    return head;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167109,
                "title": "python3-one-pass-iterative-solution-beats-95-50-with-figure-explanation",
                "content": "**Idea**\\nReverse a part of linked list can be performed by iteratively move nodes to the beginning within the reverse part\\n![image](https://assets.leetcode.com/users/images/f5d2b8e7-a60f-4708-95f0-ccefec71d3b2_1618866607.652895.png)\\n\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next or left == right:\\n            return head\\n        \\n        dummy_head = ListNode(val=-1, next=head)\\n        p_prev = dummy_head\\n        \\n        # Iterate p_prev to the (left-1)-th node\\n        for _ in range(left - 1):\\n            p_prev = p_prev.next\\n            \\n        p_cur = p_prev.next # p_cur is at the left-th node\\n        \\n        # Within the reverse part, iteratively move the next node of p_cur to the beginning\\n        for _ in range(right - left):\\n            p_next = p_cur.next\\n            p_cur.next = p_next.next\\n            p_next.next = p_prev.next\\n            p_prev.next = p_next\\n        \\n        return dummy_head.next\\n```\\n\\nExplanation:\\n- In the first loop `for _ in range(left - 1)`, we iterate `p_prev` to the (`left-1`) -th node\\n- In the second loop, within the reverse part, we iteratively shift the next node of `p_cur` to the beginning of the reverse part\\n\\t![image](https://assets.leetcode.com/users/images/3e5ec220-c2f8-4b5f-9e9f-012fabfa4e86_1618867097.78969.png)\\n> For the links modification in the second loop, it is easy to get lost or create loop accidentally. To handle this problem, I have a small trick.\\n> 1. Figure out how the list looks like **before** and **after** links modification\\n> ![image](https://assets.leetcode.com/users/images/89404580-5ca4-47b4-b61c-7ba26cf586f3_1618868088.0298142.png)\\n> 2. Mark the order of nodes alphabetically and start modifying from the **last** letter\\n> ![image](https://assets.leetcode.com/users/images/3f51fe85-c465-4656-a9fc-5eed981d3e33_1618868258.3117332.png)\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next or left == right:\\n            return head\\n        \\n        dummy_head = ListNode(val=-1, next=head)\\n        p_prev = dummy_head\\n        \\n        # Iterate p_prev to the (left-1)-th node\\n        for _ in range(left - 1):\\n            p_prev = p_prev.next\\n            \\n        p_cur = p_prev.next # p_cur is at the left-th node\\n        \\n        # Within the reverse part, iteratively move the next node of p_cur to the beginning\\n        for _ in range(right - left):\\n            p_next = p_cur.next\\n            p_cur.next = p_next.next\\n            p_next.next = p_prev.next\\n            p_prev.next = p_next\\n        \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607485,
                "title": "simple-with-explanation-o-n-same-as-problem-206",
                "content": "\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        # Comparing with Problem 206: just need to find the start position \\n        # then reverse (same as 206)\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        pre = dummy\\n        cur = dummy.next\\n        \\n        # find the position\\n        for i in range(1,m):\\n            cur = cur.next\\n            pre = pre.next\\n        \\n        \\n        # reverse\\n        for i in range(n-m):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next  = pre.next\\n            pre.next = temp\\n        \\n        return dummy.next\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        # Comparing with Problem 206: just need to find the start position \\n        # then reverse (same as 206)\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        pre = dummy\\n        cur = dummy.next\\n        \\n        # find the position\\n        for i in range(1,m):\\n            cur = cur.next\\n            pre = pre.next\\n        \\n        \\n        # reverse\\n        for i in range(n-m):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next  = pre.next\\n            pre.next = temp\\n        \\n        return dummy.next\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 4013431,
                "title": "beats-100-o-1-space-easy-code-video-in-depth-c-java-python",
                "content": "# intuition\\n Just do manipulation of pointers and call reverse function.\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n### Problem Description\\n\\nThe problem asks to reverse a specified portion of a singly linked list between positions `left` and `right`. You are given the head of the linked list and two integers, `left` and `right`, where `1 <= left <= right <= n` (n is the number of nodes in the linked list). Your task is to reverse the nodes between positions `left` and `right` and return the modified linked list.\\n\\n### Solution Explanation\\n\\n#### `rev` Function\\n\\nThe `rev` function is a helper function used to reverse a linked list. It takes the head of a linked list as input and returns the head of the reversed linked list.\\n\\nHere\\'s how it works:\\n\\n1. If the input `head` is `NULL` or it has only one node (i.e., `head->next` is `NULL`), there\\'s nothing to reverse, so it returns `head` as it is.\\n\\n2. Create three pointers: `curr` (current), `prev` (previous), and `nex` (next) to traverse the linked list.\\n\\n3. Start a `while` loop that continues until `curr` becomes `NULL`, which means we have traversed the entire original linked list.\\n\\n4. Inside the loop:\\n   - Save the next node in `nex`.\\n   - Update `curr->next` to point to the previous node (`prev`), effectively reversing the link.\\n   - Move `prev` to `curr` and `curr` to `nex` for the next iteration.\\n\\n5. Finally, return `prev` as the new head of the reversed linked list.\\n\\n#### `reverseBetween` Function\\n\\nThe `reverseBetween` function is the main function that solves the problem by reversing the specified portion of the linked list between positions `left` and `right`. It takes the head of the linked list, `left`, and `right` as input and returns the modified linked list.\\n\\nHere\\'s how it works:\\n\\n1. Similar to the `rev` function, it first handles the base cases. If `head` is `NULL` or has only one node, it returns `head` as it is.\\n\\n2. If `left` is equal to `right`, it means there\\'s no need to reverse anything, so it also returns `head` as it is.\\n\\n3. Initialize several pointers and a boolean variable `f`:\\n   - `curr` points to the current node while traversing the linked list.\\n   - `t` will eventually point to the node at position `left`.\\n   - `prev` is used to keep track of the previous node.\\n   - `s` will eventually point to the node at position `right + 1`.\\n   - `v` will point to the node just before position `left`.\\n   - `f` is a boolean flag that indicates whether `left` is equal to 1.\\n\\n4. If `left` is 1, set `f` to `true`, and `t` to `curr` initially. This is done to handle the case where we need to reverse from the beginning of the list.\\n\\n5. Use a loop to traverse the list:\\n   - When we reach `left`, set `v` to `prev` and `t` to `curr`. `v` is used to keep track of the node just before the reverse portion, and `t` is used to keep track of the first node in the reverse portion.\\n   - When we reach `right`, set `s` to `curr->next` and break the loop. This separates the portion to be reversed from the rest of the list.\\n\\n6. If `f` is `false`, it means `left` is not 1, so we need to disconnect the nodes before the reverse portion. Set `v->next` to `NULL`.\\n\\n7. Call the `rev` function to reverse the portion of the linked list starting from `t`. This returns the new head of the reversed portion.\\n\\n8. Connect the reversed portion to the rest of the list:\\n   - Set `t->next` to `s` to link the end of the reversed portion to the node at position `right + 1`.\\n   - If `f` is `false`, connect `v` to the new head of the reversed portion.\\n\\n9. If `f` is `true`, it means we reversed the portion starting from the beginning, so update `head` to point to the new head of the reversed portion.\\n\\n10. Return `head` as the final result.\\n\\n### Overall Explanation\\n\\nThe given code effectively reverses the portion of the linked list between positions `left` and `right` and returns the modified linked list. It uses the `rev` function to reverse a linked list and carefully handles the edge cases and pointer manipulation to achieve the desired result. The time complexity of this solution is O(n), where n is the number of nodes in the linked list.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1))$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode*rev(ListNode*head){\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*prev=NULL;\\n        ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(left==right)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*t=NULL;\\n        ListNode*prev=NULL;\\n        ListNode*s=NULL;\\n        ListNode*v=NULL;\\n        bool f=0;\\n        if(left==1){\\n            f=1;\\n            t=curr;\\n        }\\n        int s1=1;\\n        while(curr!=NULL){\\n            if(s1==left&&f==0){\\n                v=prev;\\n                t=curr;\\n            }\\n            if(s1==right){\\n                s=curr->next;\\n                curr->next=NULL;\\n                break;\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            s1++;\\n        }\\n        if(f==0){\\n        v->next=NULL;\\n        }\\n        ListNode*ans=rev(t);\\n        t->next=s;\\n        if(f==0)\\n        v->next=ans;\\n        if(f==1)\\n            head=ans;\\n        return head;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || head.next == null)\\n            return head;\\n        if (left == right)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode t = null;\\n        ListNode prev = null;\\n        ListNode s = null;\\n        ListNode v = null;\\n        boolean f = false;\\n\\n        if (left == 1) {\\n            f = true;\\n            t = curr;\\n        }\\n\\n        int s1 = 1;\\n\\n        while (curr != null) {\\n            if (s1 == left && !f) {\\n                v = prev;\\n                t = curr;\\n            }\\n\\n            if (s1 == right) {\\n                s = curr.next;\\n                curr.next = null;\\n                break;\\n            }\\n\\n            prev = curr;\\n            curr = curr.next;\\n            s1++;\\n        }\\n\\n        if (!f) {\\n            v.next = null;\\n        }\\n\\n        ListNode ans = reverseList(t);\\n        t.next = s;\\n\\n        if (!f) {\\n            v.next = ans;\\n        }\\n\\n        if (f) {\\n            head = ans;\\n        }\\n\\n        return head;\\n    }\\n\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n\\n        while (curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head\\n\\n        curr = head\\n        t = None\\n        prev = None\\n        s = None\\n        v = None\\n        f = False\\n\\n        if left == 1:\\n            f = True\\n            t = curr\\n\\n        s1 = 1\\n\\n        while curr:\\n            if s1 == left and not f:\\n                v = prev\\n                t = curr\\n\\n            if s1 == right:\\n                s = curr.next\\n                curr.next = None\\n                break\\n\\n            prev = curr\\n            curr = curr.next\\n            s1 += 1\\n\\n        if not f:\\n            v.next = None\\n\\n        ans = self.reverseList(t)\\n        t.next = s\\n\\n        if not f:\\n            v.next = ans\\n\\n        if f:\\n            head = ans\\n\\n        return head\\n\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        curr = head\\n        prev = None\\n        next_node = None\\n\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n\\n        return prev\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode*rev(ListNode*head){\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*prev=NULL;\\n        ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(left==right)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*t=NULL;\\n        ListNode*prev=NULL;\\n        ListNode*s=NULL;\\n        ListNode*v=NULL;\\n        bool f=0;\\n        if(left==1){\\n            f=1;\\n            t=curr;\\n        }\\n        int s1=1;\\n        while(curr!=NULL){\\n            if(s1==left&&f==0){\\n                v=prev;\\n                t=curr;\\n            }\\n            if(s1==right){\\n                s=curr->next;\\n                curr->next=NULL;\\n                break;\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            s1++;\\n        }\\n        if(f==0){\\n        v->next=NULL;\\n        }\\n        ListNode*ans=rev(t);\\n        t->next=s;\\n        if(f==0)\\n        v->next=ans;\\n        if(f==1)\\n            head=ans;\\n        return head;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || head.next == null)\\n            return head;\\n        if (left == right)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode t = null;\\n        ListNode prev = null;\\n        ListNode s = null;\\n        ListNode v = null;\\n        boolean f = false;\\n\\n        if (left == 1) {\\n            f = true;\\n            t = curr;\\n        }\\n\\n        int s1 = 1;\\n\\n        while (curr != null) {\\n            if (s1 == left && !f) {\\n                v = prev;\\n                t = curr;\\n            }\\n\\n            if (s1 == right) {\\n                s = curr.next;\\n                curr.next = null;\\n                break;\\n            }\\n\\n            prev = curr;\\n            curr = curr.next;\\n            s1++;\\n        }\\n\\n        if (!f) {\\n            v.next = null;\\n        }\\n\\n        ListNode ans = reverseList(t);\\n        t.next = s;\\n\\n        if (!f) {\\n            v.next = ans;\\n        }\\n\\n        if (f) {\\n            head = ans;\\n        }\\n\\n        return head;\\n    }\\n\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n\\n        while (curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head\\n\\n        curr = head\\n        t = None\\n        prev = None\\n        s = None\\n        v = None\\n        f = False\\n\\n        if left == 1:\\n            f = True\\n            t = curr\\n\\n        s1 = 1\\n\\n        while curr:\\n            if s1 == left and not f:\\n                v = prev\\n                t = curr\\n\\n            if s1 == right:\\n                s = curr.next\\n                curr.next = None\\n                break\\n\\n            prev = curr\\n            curr = curr.next\\n            s1 += 1\\n\\n        if not f:\\n            v.next = None\\n\\n        ans = self.reverseList(t)\\n        t.next = s\\n\\n        if not f:\\n            v.next = ans\\n\\n        if f:\\n            head = ans\\n\\n        return head\\n\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        curr = head\\n        prev = None\\n        next_node = None\\n\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n\\n        return prev\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012057,
                "title": "c-5ms-fastest-easy-to-understand",
                "content": "# C++ | 5ms | Fastest | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (head == nullptr) return head;\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        ListNode* prev = dummy;\\n        for (int i = 0; i < left-1; i++) {\\n            prev = prev->next;\\n        }\\n        ListNode* curr = prev->next;\\n        \\n        for (int i = 0; i < right-left; i++) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = prev->next;\\n            prev->next = next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (head == nullptr) return head;\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        ListNode* prev = dummy;\\n        for (int i = 0; i < left-1; i++) {\\n            prev = prev->next;\\n        }\\n        ListNode* curr = prev->next;\\n        \\n        for (int i = 0; i < right-left; i++) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = prev->next;\\n            prev->next = next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291851,
                "title": "easy-to-understand-java-solution-explanation-with-comments-and-diagrams",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n/*  Approach:  \\n\\n                                                   reverse\\n    Input: m = 4, n = 6                      m  <----------->  n\\n    \\n                  a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n                 head       \\n    \\n    \\n    i. Store preHead as parent of head to return (preHead.next) at last.\\n       It will return the updated list with new head at that position.\\n\\n     \\n          0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head\\n\\n\\n    ii. Loop prev till reaches position m - 1\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev\\n       \\n\\n\\n    iii. Reverse list from m to n\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev     curr     temp\\n       \\n    \\n        reverseHead = null\\n        \\n                                            d   ->   e   ->   f   ->   g\\n                                           curr     temp                   temp = curr.next\\n                                           \\n                                  revH  <-  d        e   ->   f   ->   g\\n                                   --      curr     temp                   curr.next = revH\\n                                           \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr                   revH = curr, curr = temp\\n                                   \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr     temp          temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------\\n                            \\n                                        <-   d   <-  e        f   ->   g\\n                                   --      revH     curr     temp           curr.next = revH\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr           revH = curr, curr = temp\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr     temp  temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------           \\n                                   \\n                                   \\n                                        <-   d   <-  e   <-   f        g\\n                                   --               revH     curr     temp    curr.next = revH\\n                                    \\n                                        <-   d   <-  e   <-   f        g\\n                                   --                        revH     curr    revH = curr, curr = temp\\n                                   \\n                                   \\n    \\n               Reversed sublist :  __   <-   d   <-  e   <-   f     <=>   f  ->  e  ->  d  -> __\\n    \\n    \\n    iv. Connect the reversed list\\n\\n\\n    \\n    \\n            \\n            \\n*/\\n\\nclass Solution {\\n    \\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        \\n        int m = left, n = right;\\n        \\n        /*  Corner Case */\\n        \\n        if (head == null || head.next == null || m <= 0 || n <= 0 || m == n) {\\n            return head;\\n        }\\n        \\n        // to store the head index, to return the final updated head at this index.\\n        \\n        ListNode preHead = new ListNode(0);  \\n        preHead.next = head;\\n        \\n        // Traverse the list till position m. Position m -> index m-1 => loop till 0 to m-2.\\n        \\n        ListNode prev = preHead;\\n        \\n        for (int i = 0; i <= m-2; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Reverse the list from position m to n.\\n        \\n        ListNode curr = prev.next;\\n        ListNode temp = null;\\n        \\n        ListNode reverseHead = null;\\n        \\n        for (int i = 0; i <= n-m; i++) {\\n            \\n            temp = curr.next;         // save next of current for next iteration\\n            curr.next = reverseHead;  // reset current to point back not forward\\n            \\n            reverseHead = curr;       // make current as head of new reverseHead list\\n            curr = temp;              // move to next node\\n            \\n        }\\n        \\n        \\n        // Connect the reversed list with the prev node (position m-1)\\n        \\n        prev.next.next = curr;\\n        prev.next = reverseHead;\\n        \\n     \\n    return preHead.next;\\n        \\n        \\n    }\\n}\\n```\\n\\n\\n**Please Upvote if you find it helpful. Happy Coding!**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n/*  Approach:  \\n\\n                                                   reverse\\n    Input: m = 4, n = 6                      m  <----------->  n\\n    \\n                  a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n                 head       \\n    \\n    \\n    i. Store preHead as parent of head to return (preHead.next) at last.\\n       It will return the updated list with new head at that position.\\n\\n     \\n          0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head\\n\\n\\n    ii. Loop prev till reaches position m - 1\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev\\n       \\n\\n\\n    iii. Reverse list from m to n\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev     curr     temp\\n       \\n    \\n        reverseHead = null\\n        \\n                                            d   ->   e   ->   f   ->   g\\n                                           curr     temp                   temp = curr.next\\n                                           \\n                                  revH  <-  d        e   ->   f   ->   g\\n                                   --      curr     temp                   curr.next = revH\\n                                           \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr                   revH = curr, curr = temp\\n                                   \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr     temp          temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------\\n                            \\n                                        <-   d   <-  e        f   ->   g\\n                                   --      revH     curr     temp           curr.next = revH\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr           revH = curr, curr = temp\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr     temp  temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------           \\n                                   \\n                                   \\n                                        <-   d   <-  e   <-   f        g\\n                                   --               revH     curr     temp    curr.next = revH\\n                                    \\n                                        <-   d   <-  e   <-   f        g\\n                                   --                        revH     curr    revH = curr, curr = temp\\n                                   \\n                                   \\n    \\n               Reversed sublist :  __   <-   d   <-  e   <-   f     <=>   f  ->  e  ->  d  -> __\\n    \\n    \\n    iv. Connect the reversed list\\n\\n\\n    \\n    \\n            \\n            \\n*/\\n\\nclass Solution {\\n    \\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        \\n        int m = left, n = right;\\n        \\n        /*  Corner Case */\\n        \\n        if (head == null || head.next == null || m <= 0 || n <= 0 || m == n) {\\n            return head;\\n        }\\n        \\n        // to store the head index, to return the final updated head at this index.\\n        \\n        ListNode preHead = new ListNode(0);  \\n        preHead.next = head;\\n        \\n        // Traverse the list till position m. Position m -> index m-1 => loop till 0 to m-2.\\n        \\n        ListNode prev = preHead;\\n        \\n        for (int i = 0; i <= m-2; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Reverse the list from position m to n.\\n        \\n        ListNode curr = prev.next;\\n        ListNode temp = null;\\n        \\n        ListNode reverseHead = null;\\n        \\n        for (int i = 0; i <= n-m; i++) {\\n            \\n            temp = curr.next;         // save next of current for next iteration\\n            curr.next = reverseHead;  // reset current to point back not forward\\n            \\n            reverseHead = curr;       // make current as head of new reverseHead list\\n            curr = temp;              // move to next node\\n            \\n        }\\n        \\n        \\n        // Connect the reversed list with the prev node (position m-1)\\n        \\n        prev.next.next = curr;\\n        prev.next = reverseHead;\\n        \\n     \\n    return preHead.next;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322510,
                "title": "cpp-solution-faster-than-100-of-submissions-faster-than-55-runtime",
                "content": "Here\\'s an easy to understand iterative solution to the problem of reversing a sublist within a list given the boundaries. The code has comments to help you understand better, why the conditions are as such.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        if(head == NULL)\\n            return NULL; //Handled an edge case\\n        \\n        ListNode *temp, *curr = head, *prev = NULL;\\n        while(m>1)\\n        {\\n            prev = curr;\\n            curr = curr->next;\\n            m--;\\n            n--; //Only relative shifting of variable n. Doesn\\'t make a difference to the logic\\n        }\\n        //Through this We have traversed till the mth node.\\n        \\n        ListNode *con = prev, *tail = curr;\\n        //Two nodes to help the set the connections of the list at the end of sublist reversal\\n        \\n        while(n>0)\\n        { //The actual reversal happens here\\n            temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n            n--;\\n        }\\n        //Setting the connections to complete sublist reversal\\n        if(con!= NULL) \\n        {\\n            con->next = prev;\\n        }\\n        else\\n        { //To handle the case if m=0\\n            head = prev;\\n        }\\n        \\n        tail->next = curr; //Even if current node is NULL, the tail node is the last node of the new list which in turn points to null\\n        return head;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        if(head == NULL)\\n            return NULL; //Handled an edge case\\n        \\n        ListNode *temp, *curr = head, *prev = NULL;\\n        while(m>1)\\n        {\\n            prev = curr;\\n            curr = curr->next;\\n            m--;\\n            n--; //Only relative shifting of variable n. Doesn\\'t make a difference to the logic\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4011894,
                "title": "mastering-linked-list-reversal-a-step-by-step-guide-easy-to-understand-beginner",
                "content": "# PROBLEM UNDERSTANDING:\\n- **The code appears** to be a C++ implementation of a function `reverseBetween `within a class `Solution`. \\n- This function takes as input a singly-linked list represented by a `ListNode` and two integers, `left` and `right`. \\n- It aims to reverse the elements of the linked list from the `left`-th node to the `right`-th node (inclusive).\\n\\n# Here\\'s a step-by-step explanation of the code:\\n**Step 1: Initializing Pointers**\\n```\\nListNode* temp = new ListNode(-1);\\nListNode* prev = temp;\\ntemp->next = head;\\n\\n```\\n- `temp` is a new **ListNode created with a value of -1**. This is used as a dummy node to simplify the logic.\\n- `prev` is initialized to `temp`, which **initially points to the same location as** `temp`.\\n- `temp->next` is set to point to the head of the input linked list (`head`).\\n\\n**Step 2: Moving to the Left Position:**\\n```\\nfor (int i = 0; i < left - 1; i++) {\\n    prev = prev->next;\\n}\\n\\n```\\n- This loop moves the `prev` pointer to the node just before the `left`-th node in the linked list.\\n\\n**Step 3: Reversing the Nodes:**\\n```\\nListNode* cur = prev->next;\\nfor (int i = 0; i < right - left; i++) {\\n    ListNode* ptr = prev->next;\\n    prev->next = cur->next;\\n    cur->next = cur->next->next;\\n    prev->next->next = ptr;\\n}\\n\\n```\\n- In this loop, a pointer `cur` is used to keep track of the current node.\\n- For each iteration, a pointer `ptr` is used to temporarily store `prev->next`.\\n- **The code then rearranges the pointers to reverse** the direction of the nodes between `left` and `right`.\\n\\n**Step 4: Returning the Result:**\\n```\\nreturn temp->next;\\n\\n```\\n- Finally, the modified linked list is returned. `temp->next` points to the new head of the linked list after reversing the specified portion.\\n\\n# Strategy to Tackle the Problem:\\n\\n**1. Initialize a dummy node (`temp`) to simplify handling edge cases.**\\n**1. Move `prev` to the node just before the `left`-th node using a loop.**\\n**1. Reverse the nodes between left and right using a loop.**\\n**1. Return the modified linked list.**\\n\\n\\n\\n\\n\\n\\n\\n# Intuition\\n- The code employs a common technique for reversing a portion of a linked list. \\n- It uses pointers (`prev`, `cur`, and `ptr`) to manipulate the connections between nodes, effectively reversing the direction of the nodes between `left` and `right`.\\n\\n# Approach\\n- Initialize `temp` and `prev` pointers.\\n- Move `prev` to the node before the `left`-th node.\\n- Reverse nodes between `left` and `right` using a loop.\\n- Return the modified linked list.\\n\\n# Complexity\\n- **Time complexity:**\\n 1. **Initialization:** The initialization part involves creating a dummy node (`temp`) and moving prev to the `left-1`-th node, both of which take constant time, `O(1)`.\\n\\n 1. **Reversing the Nodes:** The loop that reverses the nodes between `left` and right runs for `right - left` iterations. \\n     - Inside the loop, there are constant-time operations like pointer assignments. \\n     - Therefore, this part of the code also has a time complexity of `O(right - left)`, which can be simplified to `O(n)`, where n is the number of nodes in the linked list.\\n\\n**Overall, the time complexity of the code is `O(n)`, where n is the number of nodes in the linked list.**\\n\\n- **Space complexity:**\\n1. **Additional Pointers:** The code uses a few extra pointers (`temp`, `prev`, `cur`, and `ptr`) to keep track of nodes and perform the reversal. These pointers occupy a constant amount of space regardless of the size of the linked list. \\n2. Therefore, the `space complexity is O(1)`, indicating constant space usage.\\n\\n# PLEASE UPVOTE\\uD83D\\uDE0D\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n      ListNode*temp= new ListNode(-1);\\n      ListNode*prev=temp;\\n      temp->next=head;\\n      for(int i=0;i<left-1;i++)\\n      {\\n          prev=prev->next;\\n      }\\n     ListNode*cur=prev->next;\\n    for(int i=0;i<right-left;i++)\\n    {\\n       ListNode *ptr = prev->next;\\n       prev->next = cur->next;\\n       cur->next = cur->next->next;\\n       prev->next->next = ptr;\\n    }\\n     return temp->next;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode temp = new ListNode(-1);\\n        ListNode prev = temp;\\n        temp.next = head;\\n        \\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode cur = prev.next;\\n        \\n        for (int i = 0; i < right - left; i++) {\\n            ListNode ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n        \\n        return temp.next;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def reverseBetween(self, head, left, right):\\n        temp = ListNode(-1)\\n        prev = temp\\n        temp.next = head\\n        \\n        for i in range(left - 1):\\n            prev = prev.next\\n        \\n        cur = prev.next\\n        \\n        for i in range(right - left):\\n            ptr = prev.next\\n            prev.next = cur.next\\n            cur.next = cur.next.next\\n            prev.next.next = ptr\\n        \\n        return temp.next\\n\\n```\\n# JAVASCRIPT\\n```\\nclass ListNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n    }\\n}\\n\\nclass Solution {\\n    reverseBetween(head, left, right) {\\n        const temp = new ListNode(-1);\\n        let prev = temp;\\n        temp.next = head;\\n\\n        for (let i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        let cur = prev.next;\\n\\n        for (let i = 0; i < right - left; i++) {\\n            let ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n\\n        return temp.next;\\n    }\\n}\\n\\n```\\n# GO\\n```\\npackage main\\n\\ntype ListNode struct {\\n    Val  int\\n    Next *ListNode\\n}\\n\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    temp := &ListNode{Val: -1}\\n    prev := temp\\n    temp.Next = head\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    cur := prev.Next\\n\\n    for i := 0; i < right-left; i++ {\\n        ptr := prev.Next\\n        prev.Next = cur.Next\\n        cur.Next = cur.Next.Next\\n        prev.Next.Next = ptr\\n    }\\n\\n    return temp.Next\\n}\\n\\n```\\n# \\uD83D\\uDC7E\\u2763PLEASE UPVOTE\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nListNode* temp = new ListNode(-1);\\nListNode* prev = temp;\\ntemp->next = head;\\n\\n```\n```\\nfor (int i = 0; i < left - 1; i++) {\\n    prev = prev->next;\\n}\\n\\n```\n```\\nListNode* cur = prev->next;\\nfor (int i = 0; i < right - left; i++) {\\n    ListNode* ptr = prev->next;\\n    prev->next = cur->next;\\n    cur->next = cur->next->next;\\n    prev->next->next = ptr;\\n}\\n\\n```\n```\\nreturn temp->next;\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n      ListNode*temp= new ListNode(-1);\\n      ListNode*prev=temp;\\n      temp->next=head;\\n      for(int i=0;i<left-1;i++)\\n      {\\n          prev=prev->next;\\n      }\\n     ListNode*cur=prev->next;\\n    for(int i=0;i<right-left;i++)\\n    {\\n       ListNode *ptr = prev->next;\\n       prev->next = cur->next;\\n       cur->next = cur->next->next;\\n       prev->next->next = ptr;\\n    }\\n     return temp->next;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode temp = new ListNode(-1);\\n        ListNode prev = temp;\\n        temp.next = head;\\n        \\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode cur = prev.next;\\n        \\n        for (int i = 0; i < right - left; i++) {\\n            ListNode ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n        \\n        return temp.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def reverseBetween(self, head, left, right):\\n        temp = ListNode(-1)\\n        prev = temp\\n        temp.next = head\\n        \\n        for i in range(left - 1):\\n            prev = prev.next\\n        \\n        cur = prev.next\\n        \\n        for i in range(right - left):\\n            ptr = prev.next\\n            prev.next = cur.next\\n            cur.next = cur.next.next\\n            prev.next.next = ptr\\n        \\n        return temp.next\\n\\n```\n```\\nclass ListNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n    }\\n}\\n\\nclass Solution {\\n    reverseBetween(head, left, right) {\\n        const temp = new ListNode(-1);\\n        let prev = temp;\\n        temp.next = head;\\n\\n        for (let i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        let cur = prev.next;\\n\\n        for (let i = 0; i < right - left; i++) {\\n            let ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n\\n        return temp.next;\\n    }\\n}\\n\\n```\n```\\npackage main\\n\\ntype ListNode struct {\\n    Val  int\\n    Next *ListNode\\n}\\n\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    temp := &ListNode{Val: -1}\\n    prev := temp\\n    temp.Next = head\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    cur := prev.Next\\n\\n    for i := 0; i < right-left; i++ {\\n        ptr := prev.Next\\n        prev.Next = cur.Next\\n        cur.Next = cur.Next.Next\\n        prev.Next.Next = ptr\\n    }\\n\\n    return temp.Next\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292413,
                "title": "easy-use-of-stack-c-beginners-friendly",
                "content": "I used curr pointer to store the value of node into the stack and popped out while traversing the previous pointer.\\n\\n```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = head;\\n        \\n        stack<int> st;\\n        for(int i=0; i<left-1; i++)\\n        {\\n             curr=curr->next;\\n             prev=prev->next;\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            st.push(curr->val);\\n            curr=curr->next;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            prev->val = st.top();\\n            st.pop();\\n            prev = prev->next;\\n        }\\n        \\n      return head;  \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = head;\\n        \\n        stack<int> st;\\n        for(int i=0; i<left-1; i++)\\n        {\\n             curr=curr->next;\\n             prev=prev->next;\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            st.push(curr->val);\\n            curr=curr->next;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            prev->val = st.top();\\n            st.pop();\\n            prev = prev->next;\\n        }\\n        \\n      return head;  \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30827,
                "title": "c-in-14-lines",
                "content": "    class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *slow = &dummy;\\n            n -= m;\\n            while (--m)\\n                slow = slow->next;\\n            ListNode *fast = slow->next, *tmp;\\n            while (n--) {\\n                tmp = fast->next;\\n                fast->next = fast->next->next;\\n                tmp->next = slow->next;\\n                slow->next = tmp;\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *slow = &dummy;\\n            n -= m;\\n            while (--m)\\n                slow = slow->next;\\n            ListNode *fast = slow->next, *tmp;\\n            while (n--) {\\n                tmp = fast->next;\\n                fast->next = fast->next->next;\\n                tmp->next = slow->next;\\n                slow->next = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30873,
                "title": "240ms-java-solution",
                "content": "    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy=new ListNode(0);\\n            dummy.next=head;\\n            ListNode pre=dummy; //pre is the node before orignal M\\n            ListNode M=head;    //M is after pre\\n            \\n            for(int i=1;i<m;i++){ //Move pre and M to orignal place\\n                pre=pre.next;\\n                M=M.next;\\n            }\\n            \\n            for(int i=0;i<n-m;i++){ \\n                ListNode current=M.next; //Both pre and M are all fixed, only current is assigned every time to M.next. M is pushed back everytime\\n                M.next=current.next;     //Move current to the position after pre\\n                current.next=pre.next;\\n                pre.next=current;\\n            }\\n            \\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy=new ListNode(0);\\n            dummy.next=head;\\n            ListNode pre=dummy; //pre is the node before orignal M\\n            ListNode M=head;    //M is after pre\\n            \\n            for(int i=1;i<m;i++){ //Move pre and M to orignal place\\n                pre=pre.next;\\n                M=M.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4012465,
                "title": "java-beats-100-0ms-c-2ms-two-solutions-commented-code",
                "content": "# Problem Description\\nGiven a singly linked list and two integers `left` and `right`, where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.\\n\\n\\n---\\n\\n# Proposed Solutions\\n## 1. Using an Array \\n### Approach\\n1. **Copy** the elements of the given Linked List into **another array**.\\n2. **Reverse** the required range of the copied array. \\n3. **Copy** the array elements **into the Linked List**.\\n4. **Return** the modified Linked List.\\n\\n\\n### Complexity\\n- **Time complexity**:\\nSince we are traversing the LinkedList twice and the array once, it is `3*N`. so time complexity is `O(N)`.\\n\\n- **Space complexity**:\\nWe store the values of linked list in an array then space complexity is `O(N)`.\\n\\n\\n## 2. Inplace Reversing\\n### Approach\\n1. Make a **dummy node** with dummy value **before the head**.\\n2. Initialize a pointer `pervLeft` and make it **points** to the node **just before** the first node in our range.\\n3. Apply **inplace reversing** method by maintaing current node and shift it to the right like the picture below :\\n![leet.PNG](https://assets.leetcode.com/users/images/807730e7-9afc-4cd3-9f69-d863bbd51c38_1694063044.7778773.png)\\n4. **return** the modified node.  \\n\\n\\n### Complexity\\n- **Time complexity**:\\nThere are two for loops, it is `2*N`. so time complexity is `O(N)`.\\n\\n- **Space complexity**:\\nWe store only couple of additional nodes (prevLeft, current and nextNode), then is is `O(1)`.\\n\\n\\n---\\n\\n\\n# Code\\n## 1. Using an Array \\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a list to store the values of the linked list\\n        List<Integer> valueList = new ArrayList<Integer>();\\n        \\n        // Traverse the linked list and store its values in the list\\n        ListNode current = head;\\n        while (current != null) {\\n            valueList.add(current.val);\\n            current = current.next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the value list\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int num1 = valueList.get(i);\\n            int num2 = valueList.get(right - 1 - shift);\\n            \\n            // Swap the values in the value list\\n            valueList.set(i, num2);\\n            valueList.set(right - 1 - shift, num1);\\n            \\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != null) {\\n            current.val = valueList.get(ptr++);\\n            current = current.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a vector to store the values of the linked list\\n        vector<int> valueList;\\n        \\n        // Traverse the linked list and store its values in the vector\\n        ListNode *current = head;\\n        while (current != nullptr) {\\n            valueList.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the vector\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int temp = valueList[i];\\n            valueList[i] = valueList[right - 1 - shift];\\n            valueList[right - 1 - shift] = temp;\\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != nullptr) {\\n            current->val = valueList[ptr++];\\n            current = current->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n## 2. Inplace Reversing\\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevLeft = dummy;\\n        \\n        // Move \\'prevLeft\\' to the node just before the \\'left\\' position\\n        for (int i = 0; i < left - 1; ++i) {\\n            prevLeft = prevLeft.next;\\n        }\\n        \\n        // Initialize the current node within the sublist\\n        ListNode current = prevLeft.next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prevLeft.next;\\n            prevLeft.next = nextNode;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode* dummy = new ListNode(1);\\n        dummy->next = head;\\n        \\n        // Find the node just before the \\'left\\' position\\n        ListNode* prevLeft  = dummy;\\n        for (int i = 0; i < left - 1; i++) {\\n            prevLeft  = prevLeft ->next;\\n        }\\n        \\n        // Initialize the current pointer within the sublist\\n        ListNode* current = prevLeft ->next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = prevLeft ->next;\\n            prevLeft ->next = current->next;\\n            current->next = current->next->next;\\n            prevLeft ->next->next = temp;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List"
                ],
                "code": "```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a list to store the values of the linked list\\n        List<Integer> valueList = new ArrayList<Integer>();\\n        \\n        // Traverse the linked list and store its values in the list\\n        ListNode current = head;\\n        while (current != null) {\\n            valueList.add(current.val);\\n            current = current.next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the value list\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int num1 = valueList.get(i);\\n            int num2 = valueList.get(right - 1 - shift);\\n            \\n            // Swap the values in the value list\\n            valueList.set(i, num2);\\n            valueList.set(right - 1 - shift, num1);\\n            \\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != null) {\\n            current.val = valueList.get(ptr++);\\n            current = current.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a vector to store the values of the linked list\\n        vector<int> valueList;\\n        \\n        // Traverse the linked list and store its values in the vector\\n        ListNode *current = head;\\n        while (current != nullptr) {\\n            valueList.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the vector\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int temp = valueList[i];\\n            valueList[i] = valueList[right - 1 - shift];\\n            valueList[right - 1 - shift] = temp;\\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != nullptr) {\\n            current->val = valueList[ptr++];\\n            current = current->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevLeft = dummy;\\n        \\n        // Move \\'prevLeft\\' to the node just before the \\'left\\' position\\n        for (int i = 0; i < left - 1; ++i) {\\n            prevLeft = prevLeft.next;\\n        }\\n        \\n        // Initialize the current node within the sublist\\n        ListNode current = prevLeft.next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prevLeft.next;\\n            prevLeft.next = nextNode;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode* dummy = new ListNode(1);\\n        dummy->next = head;\\n        \\n        // Find the node just before the \\'left\\' position\\n        ListNode* prevLeft  = dummy;\\n        for (int i = 0; i < left - 1; i++) {\\n            prevLeft  = prevLeft ->next;\\n        }\\n        \\n        // Initialize the current pointer within the sublist\\n        ListNode* current = prevLeft ->next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = prevLeft ->next;\\n            prevLeft ->next = current->next;\\n            current->next = current->next->next;\\n            prevLeft ->next->next = temp;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384023,
                "title": "javascript-solution-time-o-n-space-o-1-with-very-detailed-explanation",
                "content": "We can split this problem into 2 problems\\n1. Find where the reversal should begin (start of left)\\n2. Reverse the section between left to right\\n\\n**Where the reversal should begin**\\nWe need to set a pointer to the node right before the reversed section of the list. If we keep a pointer `position`  and use the condition `position<left` we can traverse through the linked list and set a `start` pointer to the node prior to where the reversal starts.\\n\\n**Reverse teh section between left and right**\\nNow that we have the node prior to where the reversal begins, we need to set a `tail` pointer that points to the beginning of the reversed list. Reason? Because we know the first node will be the tail of the `reversedList` we need that reference in order to assign its next value to whatever of the original list is left over. \\n\\nOnce we set the tail to the `current` node which is the beginning of the reversed list, we can traverse through this section with the condition `position >= left && position <= right` which is the portion that needs to be reversed. I highly recommend checking out the [reverse linked list problem](https://leetcode.com/problems/reverse-linked-list/) which is all the logic we need here. We simply just reverse this portion of the linkedlist and set it to `reversedList`.\\n\\nNow because we have the `start` pointer before the reversal begin, all we need to do is set the starts next property to the `reversedList` and because the `tail` pointer is now set to the end of the `reversedlist` we can set the tail\\'s next pointer to the `current` node which is the left over portion of the list. \\n\\n**One caveat**\\nThe reason why this ternary return statement is needed: `left > 1 ? head : reversedList` at the end is because if `left` is equal to 1 there is essentially no start value ever set. We are reversing from the beginning of the list, so we can just return the `reversedList` which will have the reversed portion of the list and whatever is left over.\\n\\nHope this helps and keep working hard!\\n\\n```\\nvar reverseBetween = function(head, left, right){\\n    let current = head, start = head, position = 1;\\n    \\n    while(position < left) {\\n        start = current\\n        current = current.next;\\n        position ++;\\n    }\\n    \\n    let reversedList = null,  tail = current;\\n    \\n    while(position >= left && position <= right) {\\n        const next = current.next;\\n        current.next = reversedList;\\n        reversedList = current;\\n        current = next;\\n        position ++\\n    }\\n    start.next = reversedList;\\n    tail.next = current;\\n    \\n    return left > 1 ? head : reversedList\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar reverseBetween = function(head, left, right){\\n    let current = head, start = head, position = 1;\\n    \\n    while(position < left) {\\n        start = current\\n        current = current.next;\\n        position ++;\\n    }\\n    \\n    let reversedList = null,  tail = current;\\n    \\n    while(position >= left && position <= right) {\\n        const next = current.next;\\n        current.next = reversedList;\\n        reversedList = current;\\n        current = next;\\n        position ++\\n    }\\n    start.next = reversedList;\\n    tail.next = current;\\n    \\n    return left > 1 ? head : reversedList\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291670,
                "title": "c-with-diagram-example-comments",
                "content": "##### The main idea is to advance the left pointer to the location just before from where we want to inverse the linked list (because we can\\'nt travel backwards ). After that we have to reverse the linked list in the range [0, right- left ).\\n#### Example :\\n\\nGive Linked List : 1 --> 2 --> 3 --> 4 --> 5 --> 6\\nleft = 2 , right = 5\\nAdd Dummy node ( To handle the case when left =1 )\\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> 6\\nAfter first loop , LEFT_PTR will be pointing to 1 and LEFT to 2\\n\\nNow reversing for one iteration,(**with logic of inserting element after LEFT_PTR)**\\n```\\ntemp = node(2)\\nnode(1) ->next =  node(2) ->next   (i.e node(1) next is node(3))\\nnode(2) ->next = node(2) ->next ->next (i.e node(2) next is node(4))\\nnode(1) ->next ->next = node(2)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5adcc438-8cfe-4311-a4d5-23361b10b965_1624436981.9676034.png)\\n\\n##### CODE : \\n```\\n\\t\\t//If right == left then no need to reverse\\n\\t\\tif(!head or left == right)\\n            return head;\\n\\t\\t\\n\\t\\t//inserting dummy node in front\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next =head;\\n\\t\\t\\n\\t\\t// L is pointer to the left node to reverse ans LEFT_PTR is pointer left of L (just before L)\\n        ListNode *L ,*LEFT_PTR=dummy;\\n        for(int i=0;i<left-1;i++)\\n            LEFT_PTR = LEFT_PTR->next;\\n\\t\\t\\n        L = LEFT_PTR->next;\\n\\t\\t \\n\\t\\t //JUST REVERSE LOGIC HERE\\n        for(int i=0;i<right-left;i++){\\n            ListNode *tmp  = LEFT_PTR->next;\\n            LEFT_PTR->next = L->next;\\n            L->next  =  L->next->next;\\n            LEFT_PTR->next->next = tmp;\\n        }\\n        return dummy->next;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntemp = node(2)\\nnode(1) ->next =  node(2) ->next   (i.e node(1) next is node(3))\\nnode(2) ->next = node(2) ->next ->next (i.e node(2) next is node(4))\\nnode(1) ->next ->next = node(2)\\n```\n```\\n\\t\\t//If right == left then no need to reverse\\n\\t\\tif(!head or left == right)\\n            return head;\\n\\t\\t\\n\\t\\t//inserting dummy node in front\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next =head;\\n\\t\\t\\n\\t\\t// L is pointer to the left node to reverse ans LEFT_PTR is pointer left of L (just before L)\\n        ListNode *L ,*LEFT_PTR=dummy;\\n        for(int i=0;i<left-1;i++)\\n            LEFT_PTR = LEFT_PTR->next;\\n\\t\\t\\n        L = LEFT_PTR->next;\\n\\t\\t \\n\\t\\t //JUST REVERSE LOGIC HERE\\n        for(int i=0;i<right-left;i++){\\n            ListNode *tmp  = LEFT_PTR->next;\\n            LEFT_PTR->next = L->next;\\n            L->next  =  L->next->next;\\n            LEFT_PTR->next->next = tmp;\\n        }\\n        return dummy->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30831,
                "title": "short-java-solution-for-reverse-linked-list-ii",
                "content": "    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode curr = new ListNode(0);\\n            curr.next = head;\\n            int k = n - m;\\n            int j = m;\\n            while(j > 1){\\n                curr = curr.next;\\n                j--;\\n            }\\n            ListNode reve = curr.next;\\n            while(k > 0){\\n                ListNode temp = reve.next;\\n                reve.next = reve.next.next;\\n                temp.next = curr.next;\\n                curr.next = temp;\\n                k--;\\n            }\\n            if(m == 1){\\n                head = curr.next;\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode curr = new ListNode(0);\\n            curr.next = head;\\n            int k = n - m;\\n            int j = m;\\n            while(j > 1){\\n                curr = curr.next;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30724,
                "title": "my-2-ms-c-solution-o-n-time-and-o-1-space-with-comments",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode *reverseBetween(struct ListNode *head, int m, int n) {\\n        \\n    \\n        //handle case for empty list\\n        if(head == NULL){\\n            return NULL;\\n        }\\n    \\n        //handle special case for one node list\\n        if(head->next == NULL){\\n            return head;\\n        }\\n        \\n        //handle input values of m & n , if m==n - no need to do anything \\n        if(m >= n){\\n            return head;\\n        }\\n        \\n\\n        struct ListNode * prev  = head;    \\n        struct ListNode * curr  = head;\\n        struct ListNode * next  = head;\\n\\n        struct ListNode *mTh   = NULL; //mTh node\\n        struct ListNode *nTh   = NULL; //nTh node         \\n        struct ListNode *mPrev = NULL; // node just previous to mTh node\\n        struct ListNode *nNext = NULL; // node next to the nTh node\\n        \\n    \\n        for(int i = 1 ; curr != NULL ; i++){\\n    \\n            next = curr->next ;\\n    \\n            if(i == m){\\n               //when we reach the mTh node, save mTh and mPrevious\\n                mPrev = prev ; \\n                mTh   = curr ; \\n            }\\n    \\n            if(i> m && i <= n){    \\n                 //revese links if we fall within the m and n range (include n)\\n                 curr->next = prev;\\n            }\\n            \\n            if(i == n ){\\n               //when we reach the nTh node, save nTh and nNext\\n                nNext = next ;\\n                nTh   = curr ;  \\n            }\\n                \\n            prev = curr; \\n            curr = next;\\n        }\\n        \\n        if(m == 1 ){\\n            //handle special case if head needs to be changed since m==1 \\n            mTh->next = nNext;\\n            head = nTh;\\n        }else{\\n            mPrev->next  = nTh ; \\n            mTh->next = nNext; \\n        }\\n    \\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode *reverseBetween(struct ListNode *head, int m, int n) {\\n        \\n    \\n        //handle case for empty list\\n        if(head == NULL){\\n            return NULL;\\n        }\\n    \\n        //handle special case for one node list\\n        if(head->next == NULL){\\n            return head;\\n        }\\n        \\n        //handle input values of m & n , if m==n - no need to do anything \\n        if(m >= n){\\n            return head;\\n        }\\n        \\n\\n        struct ListNode * prev  = head;    \\n        struct ListNode * curr  = head;\\n        struct ListNode * next  = head;\\n\\n        struct ListNode *mTh   = NULL; //mTh node\\n        struct ListNode *nTh   = NULL; //nTh node         \\n        struct ListNode *mPrev = NULL; // node just previous to mTh node\\n        struct ListNode *nNext = NULL; // node next to the nTh node\\n        \\n    \\n        for(int i = 1 ; curr != NULL ; i++){\\n    \\n            next = curr->next ;\\n    \\n            if(i == m){\\n               //when we reach the mTh node, save mTh and mPrevious\\n                mPrev = prev ; \\n                mTh   = curr ; \\n            }\\n    \\n            if(i> m && i <= n){    \\n                 //revese links if we fall within the m and n range (include n)\\n                 curr->next = prev;\\n            }\\n            \\n            if(i == n ){\\n               //when we reach the nTh node, save nTh and nNext\\n                nNext = next ;\\n                nTh   = curr ;  \\n            }\\n                \\n            prev = curr; \\n            curr = next;\\n        }\\n        \\n        if(m == 1 ){\\n            //handle special case if head needs to be changed since m==1 \\n            mTh->next = nNext;\\n            head = nTh;\\n        }else{\\n            mPrev->next  = nTh ; \\n            mTh->next = nNext; \\n        }\\n    \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4012847,
                "title": "c-solution-100-faster-with-test-cases-and-asked-in-tech-inteviews",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 7},\\n    {\"Microsoft\", 5},\\n    {\"Amazon\", 5},\\n    {\"Google\", 3},\\n    {\"Apple\", 2},\\n    {\"Adobe\", 2}\\n};\\n```\\n# C++ Code\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *head = new ListNode(1);\\n\\thead->next = new ListNode(2);\\n\\thead->next->next = new ListNode(3);\\n\\thead->next->next->next = new ListNode(4);\\n\\thead->next->next->next->next = new ListNode(5);\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\thead = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1), *L2 = new ListNode(2), *L3 = new ListNode(3);\\n\\tListNode *L4 = new ListNode(4), *L5 = new ListNode(5);\\n\\n\\tL1->next = L2;\\n\\tL2->next = L3;\\n\\tL3->next = L4;\\n\\tL4->next = L5;\\n\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 7},\\n    {\"Microsoft\", 5},\\n    {\"Amazon\", 5},\\n    {\"Google\", 3},\\n    {\"Apple\", 2},\\n    {\"Adobe\", 2}\\n};\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *head = new ListNode(1);\\n\\thead->next = new ListNode(2);\\n\\thead->next->next = new ListNode(3);\\n\\thead->next->next->next = new ListNode(4);\\n\\thead->next->next->next->next = new ListNode(5);\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\thead = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1), *L2 = new ListNode(2), *L3 = new ListNode(3);\\n\\tListNode *L4 = new ListNode(4), *L5 = new ListNode(5);\\n\\n\\tL1->next = L2;\\n\\tL2->next = L3;\\n\\tL3->next = L4;\\n\\tL4->next = L5;\\n\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2310950,
                "title": "python-simple-and-clean-solution",
                "content": "```python\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        p1, p2 = None, head\\n        for _ in range(left - 1):\\n            p1, p2 = p2, p2.next\\n        \\n        p4, p5 = p2, p2.next\\n        for _ in range(right - left):\\n            p5.next, p4, p5 = p4, p5, p5.next\\n\\n        p2.next = p5\\n        if p1:\\n            p1.next, p4 = p4, head\\n        \\n        return p4\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        p1, p2 = None, head\\n        for _ in range(left - 1):\\n            p1, p2 = p2, p2.next\\n        \\n        p4, p5 = p2, p2.next\\n        for _ in range(right - left):\\n            p5.next, p4, p5 = p4, p5, p5.next\\n\\n        p2.next = p5\\n        if p1:\\n            p1.next, p4 = p4, head\\n        \\n        return p4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222461,
                "title": "visual-explanation-drawings-with-easiest-approach",
                "content": "Since linkedlist problems are playing with pointers.. Its very easy to understand by diagrams. To keep it simple I just used classic iterative approach of reversing linked list but with two extra variables to reverse the required portion in **one pass**.. UPVOTE IT IF U LIKE MY EFFORTS ;)\\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        if left == right:\\n            return head\\n        p = dummy\\n        for i in range(left-1):\\n            p = p.next\\n        \\n        #initialising prev = None, cur = p\\'s next, start = p\\'s next, new = cur\\'s next\\n        prev = None\\n        cur = p.next\\n        start = cur\\n        new = cur.next\\n        p.next = None\\n        for i in range(right-left):\\n            # storing new\\'s next node\\n            store = new.next\\n            \\n            #reversing link between nodes\\n            new.next = cur\\n            cur.next = prev\\n            \\n            # updating prev,cur,new\\n            prev = cur\\n            cur = new\\n            new = store\\n        \\n        #finishing touch\\n        p.next = cur\\n        start.next = store\\n        \\n        #returning head\\n        return dummy.next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b001bbb5-b975-426d-a78a-6e21a6f21f0c_1656669945.6396508.jpeg)\\n![image](https://assets.leetcode.com/users/images/2c5df3ff-30cf-4662-ac61-281186fcd6b2_1656670598.9884937.jpeg)\\n![image](https://assets.leetcode.com/users/images/bb930a89-efac-46f6-aa85-5e2dd5bc255c_1656670610.17001.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        if left == right:\\n            return head\\n        p = dummy\\n        for i in range(left-1):\\n            p = p.next\\n        \\n        #initialising prev = None, cur = p\\'s next, start = p\\'s next, new = cur\\'s next\\n        prev = None\\n        cur = p.next\\n        start = cur\\n        new = cur.next\\n        p.next = None\\n        for i in range(right-left):\\n            # storing new\\'s next node\\n            store = new.next\\n            \\n            #reversing link between nodes\\n            new.next = cur\\n            cur.next = prev\\n            \\n            # updating prev,cur,new\\n            prev = cur\\n            cur = new\\n            new = store\\n        \\n        #finishing touch\\n        p.next = cur\\n        start.next = store\\n        \\n        #returning head\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339407,
                "title": "easy-code-one-pass-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int cnt = 0;\\n        \\n        while(curr != NULL){\\n            cnt++;\\n            if(cnt == left){\\n                \\n                ListNode* inner_curr = curr;\\n                ListNode* inner_prev = NULL;\\n                \\n                while(cnt <= right){\\n                    ListNode* nextptr = inner_curr->next;\\n                    inner_curr->next = inner_prev;\\n                    inner_prev = inner_curr;\\n                    inner_curr = nextptr;\\n                    cnt++;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev->next = inner_prev;\\n                }\\n                else{\\n                    head = inner_prev;\\n                }\\n                curr->next = inner_curr;\\n                \\n                break;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int cnt = 0;\\n        \\n        while(curr != NULL){\\n            cnt++;\\n            if(cnt == left){\\n                \\n                ListNode* inner_curr = curr;\\n                ListNode* inner_prev = NULL;\\n                \\n                while(cnt <= right){\\n                    ListNode* nextptr = inner_curr->next;\\n                    inner_curr->next = inner_prev;\\n                    inner_prev = inner_curr;\\n                    inner_curr = nextptr;\\n                    cnt++;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev->next = inner_prev;\\n                }\\n                else{\\n                    head = inner_prev;\\n                }\\n                curr->next = inner_curr;\\n                \\n                break;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038167,
                "title": "javascript-solution-with-easy-explanation-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Takes a singly linked list and two integers as inputs\\nreverses the order of the elements of the list between the indices (left, right) inclusively.\\n2. Uses two pointers, head and tail along with a dummy variable to perform the reverse operation.\\n3. Iterates the list using head pointer till it reaches the left pointer.\\n4. Uses tail pointer to mark the first element which needs to be reversed.\\n5. Uses a while loop that iterates till the left pointer becomes equal to the right pointer to perform the reversal operation .\\n6. Returns the head of the modified list which is the dummy.next variable\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the function reverseBetween is O(n), where n is the number of elements in the linked list.\\n\\nThe function iterates through the list twice. First, it uses a while loop to move the head pointer to the starting point of the sublist that needs to be reversed. The second while loop performs the reversal of the elements which is taking at most n steps. The rest of the operations like moving pointers, swapping links etc all takes O(1) so the overall time complexity is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs far as space complexity is concerned, it is O(1). The function uses a few variables (dummy, head, tail, next, and curr) to perform the reversal, but it doesn\\'t use any additional data structure like an array or a stack, so the space complexity is constant. The function only uses constant extra memory throughout its execution.\\n# Note\\nIt is important to note that this is for the singly linked list if it were doubly linked list the time complexity would have been O(n/2) and space complexity would have been O(1\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nconst reverseBetween = (list, left, right) => {\\n  const dummy = new ListNode(0, list);\\n  let head = dummy;\\n  let curr = 1;\\n\\n  while (curr++ < left) head = head.next;\\n\\n  let tail = head.next;\\n  while (left++ < right) {\\n    const next = tail.next; \\n    tail.next = next.next; \\n    next.next = head.next; \\n    head.next = next;\\n  }\\n  return dummy.next;\\n};\\n```\\n# \\n Please upvote if you like this solution.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nconst reverseBetween = (list, left, right) => {\\n  const dummy = new ListNode(0, list);\\n  let head = dummy;\\n  let curr = 1;\\n\\n  while (curr++ < left) head = head.next;\\n\\n  let tail = head.next;\\n  while (left++ < right) {\\n    const next = tail.next; \\n    tail.next = next.next; \\n    next.next = head.next; \\n    head.next = next;\\n  }\\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310994,
                "title": "python3-easy-in-one-go-explained-with-and-without-extra-space",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        values = []                        # to stores the values that needed to be reverse\\n        nodes = []                         # to keep track of the nodes which needs to be reverse\\n        counter = 0\\n        curr = head\\n        while curr:\\n            counter += 1\\n            if counter >= left and counter <= right:\\n                values.append(curr.val)     #  | adding value and nodes in the list\\n                nodes.append(curr)          #  |\\n            curr = curr.next\\n        for node in nodes:\\n            node.val = values.pop(-1)       #  replace the value of nodes\\n        return head\\n```\\nAND\\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next or left == right:          # base case\\n            return head\\n        temp = ListNode(val=-1e9)\\n        temp.next = head\\n        curr = temp\\n        for _ in range(left - 1):               # iterate through the list\\n            curr = curr.next\\n            \\n            \\n        temp_curr = curr.next\\n        for _ in range(right - left):           # reverse the list\\n            nxt = temp_curr.next\\n            temp_curr.next = nxt.next\\n            nxt.next = curr.next\\n            curr.next = nxt\\n\\n        return temp.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        values = []                        # to stores the values that needed to be reverse\\n        nodes = []                         # to keep track of the nodes which needs to be reverse\\n        counter = 0\\n        curr = head\\n        while curr:\\n            counter += 1\\n            if counter >= left and counter <= right:\\n                values.append(curr.val)     #  | adding value and nodes in the list\\n                nodes.append(curr)          #  |\\n            curr = curr.next\\n        for node in nodes:\\n            node.val = values.pop(-1)       #  replace the value of nodes\\n        return head\\n```\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next or left == right:          # base case\\n            return head\\n        temp = ListNode(val=-1e9)\\n        temp.next = head\\n        curr = temp\\n        for _ in range(left - 1):               # iterate through the list\\n            curr = curr.next\\n            \\n            \\n        temp_curr = curr.next\\n        for _ in range(right - left):           # reverse the list\\n            nxt = temp_curr.next\\n            temp_curr.next = nxt.next\\n            nxt.next = curr.next\\n            curr.next = nxt\\n\\n        return temp.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921952,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\\n        var left_head = head\\n        var left_tail: ListNode?\\n        var current = head\\n        var index = 1\\n        \\n        while index < left {\\n            left_tail = current\\n            current = current?.next\\n            index += 1 \\n        }\\n\\n        var mid_tail = current\\n        var node0: ListNode? = current\\n        var node1: ListNode? = node0?.next\\n        var node2: ListNode? = node1?.next\\n        \\n        while index < right {\\n            node1?.next = node0\\n            node0 = node1\\n            node1 = node2\\n            node2 = node2?.next\\n            index += 1\\n        }\\n\\n        if left_tail == nil {\\n            mid_tail?.next = node1\\n            return node0\\n            \\n        } else {\\n            left_tail?.next = node0\\n            mid_tail?.next = node1\\n            return left_head\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\\n        var left_head = head\\n        var left_tail: ListNode?\\n        var current = head\\n        var index = 1\\n        \\n        while index < left {\\n            left_tail = current\\n            current = current?.next\\n            index += 1 \\n        }\\n\\n        var mid_tail = current\\n        var node0: ListNode? = current\\n        var node1: ListNode? = node0?.next\\n        var node2: ListNode? = node1?.next\\n        \\n        while index < right {\\n            node1?.next = node0\\n            node0 = node1\\n            node1 = node2\\n            node2 = node2?.next\\n            index += 1\\n        }\\n\\n        if left_tail == nil {\\n            mid_tail?.next = node1\\n            return node0\\n            \\n        } else {\\n            left_tail?.next = node0\\n            mid_tail?.next = node1\\n            return left_head\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853388,
                "title": "c-easy-to-understand-code",
                "content": "**Please upvote if you find this helpful :)**\\n\\n```\\nclass Solution {\\npublic:\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n    if(head == NULL)\\n        return head; \\n    \\n    \\n    ListNode *curr = head;\\n    ListNode *prev = nullptr;\\n    int k = 1;\\n    while(k<m)\\n    {\\n        prev = curr;\\n        curr = curr->next;\\n        k++;\\n    }\\n      \\n    ListNode *temp = curr->next;\\n    \\n    ListNode *join1 = prev, *join2 = curr;\\n\\n    while(k<=n)\\n    { \\n        temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        k++;\\n    }\\n    \\n    if(join1!= NULL) \\n    {\\n        join1->next = prev;\\n    }\\n    else\\n    { \\n        head = prev;\\n    }\\n    \\n    join2->next = curr; \\n    return head;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n    if(head == NULL)\\n        return head; \\n    \\n    \\n    ListNode *curr = head;\\n    ListNode *prev = nullptr;\\n    int k = 1;\\n    while(k<m)\\n    {\\n        prev = curr;\\n        curr = curr->next;\\n        k++;\\n    }\\n      \\n    ListNode *temp = curr->next;\\n    \\n    ListNode *join1 = prev, *join2 = curr;\\n\\n    while(k<=n)\\n    { \\n        temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        k++;\\n    }\\n    \\n    if(join1!= NULL) \\n    {\\n        join1->next = prev;\\n    }\\n    else\\n    { \\n        head = prev;\\n    }\\n    \\n    join2->next = curr; \\n    return head;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151384,
                "title": "javascript-solution",
                "content": "```js\\nfunction reverseBetween(head, m, n) {\\n  const before = { next: head };\\n  let prev = before;\\n\\n  while (--m) {\\n    prev = prev.next;\\n    --n;\\n  }\\n\\n  let curr = prev.next;\\n  while (--n) {\\n    let next = curr.next;\\n    curr.next = next.next;\\n    next.next = prev.next;\\n    prev.next = next;\\n  }\\n\\n  return before.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction reverseBetween(head, m, n) {\\n  const before = { next: head };\\n  let prev = before;\\n\\n  while (--m) {\\n    prev = prev.next;\\n    --n;\\n  }\\n\\n  let curr = prev.next;\\n  while (--n) {\\n    let next = curr.next;\\n    curr.next = next.next;\\n    next.next = prev.next;\\n    prev.next = next;\\n  }\\n\\n  return before.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430686,
                "title": "easy-to-understand-step-by-step-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Check for special cases (empty list, single node, left and right positions are the same).\\n2. Traverse the list until we reach the left position, keeping track of previous node, current node and count.\\n3. The left position becomes the new start of the reversed list.\\nReverse the nodes from left to right by keeping track of next node and setting the current node\\'s next pointer to the previous node.\\n4. The right position becomes the new end of the reversed list.\\n5. Connect the reversed list with the rest of the original list by setting the next pointer of start node to the node after right position, and next pointer of previous node to the end node.\\n6. If left position was the first node, return the end node as new head of the list. Else, return the original head node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given implementation is O(n), where n is the length of the linked list. This is because we traverse the linked list only once, and perform constant-time operations for each node.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the implementation is O(1), as we use only constant extra space for the variables used in the algorithm, and do not use any additional data structures to store the nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n    if(head == NULL || head->next == NULL || left == right) {\\n        return head;\\n    }\\n    \\n    ListNode *start = NULL, *end = NULL, *temp = head, *prev = NULL, *next = NULL;\\n    int cnt = 1;\\n\\n    // Traverse the list until we reach the left position\\n    while(cnt < left) {\\n        prev = temp;\\n        temp = temp->next;\\n        cnt++;\\n    }\\n    start = temp; // The left position becomes the new start of the reversed list\\n\\n    // Reverse the nodes from left to right position\\n    while(cnt <= right) {\\n        next = temp->next;\\n        temp->next = end;\\n        end = temp;\\n        temp = next;\\n        cnt++;\\n    }\\n\\n    // Connect the reversed list with the rest of the original list\\n    start->next = temp;\\n    if(prev != NULL) {\\n        prev->next = end;\\n        return head; // The left position was not the first node\\n    }\\n    return end; // The left position was the first node\\n}\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/523c089a-bf72-4b59-aa88-dccd424608a9_1681816403.0643857.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n    if(head == NULL || head->next == NULL || left == right) {\\n        return head;\\n    }\\n    \\n    ListNode *start = NULL, *end = NULL, *temp = head, *prev = NULL, *next = NULL;\\n    int cnt = 1;\\n\\n    // Traverse the list until we reach the left position\\n    while(cnt < left) {\\n        prev = temp;\\n        temp = temp->next;\\n        cnt++;\\n    }\\n    start = temp; // The left position becomes the new start of the reversed list\\n\\n    // Reverse the nodes from left to right position\\n    while(cnt <= right) {\\n        next = temp->next;\\n        temp->next = end;\\n        end = temp;\\n        temp = next;\\n        cnt++;\\n    }\\n\\n    // Connect the reversed list with the rest of the original list\\n    start->next = temp;\\n    if(prev != NULL) {\\n        prev->next = end;\\n        return head; // The left position was not the first node\\n    }\\n    return end; // The left position was the first node\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602516,
                "title": "simple-solution-explained-with-images",
                "content": "This is solution was implemented by @firemanysome ( https://leetcode.com/problems/reverse-linked-list-ii/discuss/30666/Simple-Java-solution-with-clear-explanation/221870 ). I just added images for better understanding.\\nSo if you find it helpful please upvote so others can benefit.\\n\\n```    \\n        ListNode fakeHead = new ListNode(-1);\\n        fakeHead.next = head;\\n        ListNode prev = fakeHead;\\n        ListNode curr = fakeHead.next;\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/170cdd26-ee46-476e-be7b-ee8429ab5e06_1638184968.5516498.png)\\n\\n  ```\\n        int i=1;\\n        while(i<left){\\n            prev = curr;\\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        ListNode node = prev;\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/29c99523-e025-4850-a213-ab30cc1ada86_1638185026.5081031.png)\\n\\n        while(i<=right){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            i++;\\n        }\\n![image](https://assets.leetcode.com/users/images/2905b5fb-ebda-4121-aa95-f3c3b4b692a2_1638185048.7788653.png)\\n``` \\n\\n        node.next.next = curr;\\n        node.next = prev;\\n        \\n        return fakeHead.next;\\n```\\n![image](https://assets.leetcode.com/users/images/1a273093-dbba-4b4b-9932-d6050a36dc8a_1638185063.6721435.png)\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```    \\n        ListNode fakeHead = new ListNode(-1);\\n        fakeHead.next = head;\\n        ListNode prev = fakeHead;\\n        ListNode curr = fakeHead.next;\\n  ```\n```\\n        int i=1;\\n        while(i<left){\\n            prev = curr;\\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        ListNode node = prev;\\n  ```\n``` \\n\\n        node.next.next = curr;\\n        node.next = prev;\\n        \\n        return fakeHead.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553812,
                "title": "python-o-n-in-one-pass-85-w-visualization",
                "content": "Python O(n) in one-pass. \\n\\n---\\n**Abstract Model & Algorithm**:\\n\\nTerminology\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392151.png)\\n\\n---\\n\\nStep_#1:\\nReverse the linkage on specified interval\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392161.png)\\n\\n---\\n\\nStep_#2:\\nUpdate the linkage on boundary\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392168.png)\\n\\n\\n---\\n**Implementation**:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        if m == n:\\n            # Quick response for empty reverse interval\\n            return head\\n        \\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        \\n        cur, prev = head, dummy_head\\n        cur_idx = 1\\n        \\n        # left sentry is the the m-th node\\n        # right sentry is the the n-th node\\n        left_sentry, right_sentry = None, None\\n        \\n        # left junction is the (m-1)-th node\\n        # right junction is the (n+1)-th node\\n        left_junction, right_junction = None, None\\n        \\n        rev = False\\n        \\n        while cur:\\n            \\n            if rev:\\n                # now we are in reverse interval\\n                \\n                # Backup original next node\\n                ori_next = cur.next\\n                \\n                # Let current node point to previous node\\n                cur.next = prev\\n                \\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = ori_next\\n                \\n                # Handle for right junction node\\n                if cur_idx == n:\\n                    right_sentry = prev\\n                    right_junction = cur\\n\\n                    # Construct new linkage based on left junction and right junction\\n                    left_junction.next = right_sentry\\n                    left_sentry.next = right_junction\\n\\n                    # turn off reverse flag\\n                    rev = False              \\n                \\n                \\n            else:\\n                # now we are in normal interval\\n                \\n                # Handle for left junction node\\n                if cur_idx == m:\\n                \\n                    left_sentry = cur\\n                    left_junction = prev\\n                    \\n                    # turn on reverse flag\\n                    rev = True\\n\\n\\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = cur.next\\n            \\n            \\n  \\n            # update visiting index\\n            cur_idx +=1\\n            \\n        return dummy_head.next\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #206 Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        if m == n:\\n            # Quick response for empty reverse interval\\n            return head\\n        \\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        \\n        cur, prev = head, dummy_head\\n        cur_idx = 1\\n        \\n        # left sentry is the the m-th node\\n        # right sentry is the the n-th node\\n        left_sentry, right_sentry = None, None\\n        \\n        # left junction is the (m-1)-th node\\n        # right junction is the (n+1)-th node\\n        left_junction, right_junction = None, None\\n        \\n        rev = False\\n        \\n        while cur:\\n            \\n            if rev:\\n                # now we are in reverse interval\\n                \\n                # Backup original next node\\n                ori_next = cur.next\\n                \\n                # Let current node point to previous node\\n                cur.next = prev\\n                \\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = ori_next\\n                \\n                # Handle for right junction node\\n                if cur_idx == n:\\n                    right_sentry = prev\\n                    right_junction = cur\\n\\n                    # Construct new linkage based on left junction and right junction\\n                    left_junction.next = right_sentry\\n                    left_sentry.next = right_junction\\n\\n                    # turn off reverse flag\\n                    rev = False              \\n                \\n                \\n            else:\\n                # now we are in normal interval\\n                \\n                # Handle for left junction node\\n                if cur_idx == m:\\n                \\n                    left_sentry = cur\\n                    left_junction = prev\\n                    \\n                    # turn on reverse flag\\n                    rev = True\\n\\n\\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = cur.next\\n            \\n            \\n  \\n            # update visiting index\\n            cur_idx +=1\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261443,
                "title": "golang-recursive-iterative-versions-dummy-beat-100",
                "content": "Iterative version\\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ { head = head.Next }\\n    var curr, prev *ListNode = head.Next, nil\\n    for i := 0; i < n - m + 1; i++ {\\n        next := curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n    head.Next.Next = curr\\n    head.Next = prev\\n    return dummy.Next\\n}\\n```\\n\\nRecursive version\\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ {\\n        head = head.Next\\n    }\\n    newHead, _ := reverseList(head.Next, n - m + 1)\\n    head.Next = newHead\\n    // if m == 1 { return head.Next } else { return dummy.Next }\\n    return dummy.Next\\n}\\n\\n// return new head and the head of the rest\\nfunc reverseList(head *ListNode, cnt int) (*ListNode, *ListNode) {\\n    if cnt == 1 { return head, head.Next }\\n    newHead, restHead := reverseList(head.Next, cnt - 1)\\n    head.Next.Next = head\\n    head.Next = restHead\\n    return newHead, restHead\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ { head = head.Next }\\n    var curr, prev *ListNode = head.Next, nil\\n    for i := 0; i < n - m + 1; i++ {\\n        next := curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n    head.Next.Next = curr\\n    head.Next = prev\\n    return dummy.Next\\n}\\n```\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ {\\n        head = head.Next\\n    }\\n    newHead, _ := reverseList(head.Next, n - m + 1)\\n    head.Next = newHead\\n    // if m == 1 { return head.Next } else { return dummy.Next }\\n    return dummy.Next\\n}\\n\\n// return new head and the head of the rest\\nfunc reverseList(head *ListNode, cnt int) (*ListNode, *ListNode) {\\n    if cnt == 1 { return head, head.Next }\\n    newHead, restHead := reverseList(head.Next, cnt - 1)\\n    head.Next.Next = head\\n    head.Next = restHead\\n    return newHead, restHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012582,
                "title": "simple-solution-using-stack-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know, a stack can be used to reverse elements that are pushed into in an specific order. \\nSo, using this concept we are going to solve this problem. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will reach out to the left position ans from there, we will start pushing data of nodes to a stack until right position is reached.\\nAfter that we will again treverse from left to right and keep adding the top of stack from left to right.\\nIn this way, we can get the nodes of a linked list reversed from given left to given right position.\\n\\n# Complexity\\n- Time complexity: O(right)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(right-left)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        stack<int> s;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int le = left;\\n        while(--left){  // traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(--right){  // traversing to right\\n            temp2 = temp2->next;\\n        }\\n        while(temp1 != temp2->next){  //pushing nodes->val to stack\\n            s.push(temp1->val);\\n            temp1 = temp1->next;\\n        }\\n        temp1 = head;\\n        while(--le){   //again traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(s.size()){   //from left keep changing nodes->val to s.top()\\n            temp1->val = s.top();\\n            temp1 = temp1->next;\\n            s.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        stack<int> s;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int le = left;\\n        while(--left){  // traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(--right){  // traversing to right\\n            temp2 = temp2->next;\\n        }\\n        while(temp1 != temp2->next){  //pushing nodes->val to stack\\n            s.push(temp1->val);\\n            temp1 = temp1->next;\\n        }\\n        temp1 = head;\\n        while(--le){   //again traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(s.size()){   //from left keep changing nodes->val to s.top()\\n            temp1->val = s.top();\\n            temp1 = temp1->next;\\n            s.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310945,
                "title": "0ms-c-easy-one-pass-solution-with-comments-easy-to-understand-o-n",
                "content": "# **0ms C++ Easy One Pass Solution With Comments || Easy To Understand || O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int L, int R) {\\n        ListNode*dummy=new ListNode(),*prev=dummy,*left=head,*right=head,*forw=head->next;\\n        dummy->next=head;//we have declared dummy variable and initialize its next to head\\n\\t\\t\\n        int dif=(R-L);//we have stored the difference between R and L\\n        while(--L){//we are traversing to the left node \\n            prev=left;\\n            left=forw;\\n            right=forw;\\n            forw=forw->next;\\n        }\\n        \\n        while(dif--){//after we reach the left node we will start reversing the linked list\\n            ListNode*temp=forw->next;\\n            forw->next=right;\\n            right=forw;\\n            forw=temp;\\n        }\\n        prev->next=right;\\n        left->next=forw;\\n        return dummy->next;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/240e007e-5fd0-4806-a3d2-4894c0b13902_1658371188.1270595.png)\\n\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int L, int R) {\\n        ListNode*dummy=new ListNode(),*prev=dummy,*left=head,*right=head,*forw=head->next;\\n        dummy->next=head;//we have declared dummy variable and initialize its next to head\\n\\t\\t\\n        int dif=(R-L);//we have stored the difference between R and L\\n        while(--L){//we are traversing to the left node \\n            prev=left;\\n            left=forw;\\n            right=forw;\\n            forw=forw->next;\\n        }\\n        \\n        while(dif--){//after we reach the left node we will start reversing the linked list\\n            ListNode*temp=forw->next;\\n            forw->next=right;\\n            right=forw;\\n            forw=temp;\\n        }\\n        prev->next=right;\\n        left->next=forw;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292131,
                "title": "python-explained-intuitive-and-one-pass-algo-easy-to-understand",
                "content": "**Method 1: Intuitive Approach.**\\n\\nStep1: Find the node with at position = left and the node with position = right.\\nStep2: Split the linkedlist into three linked list like nodeL = [1, left-1], nodeM = [left, right] and nodeR = [right, n], where n = length of the linkedlist.\\nStep3: Reverse the nodeM linkedlist.\\nStep4: Merge the linkedlists as  nodeL + nodeM(reversed) + nodeR.\\n![image](https://assets.leetcode.com/users/images/b071e9ed-493a-4f04-b4d1-6f0baa3d8bb6_1624451012.2986653.png)\\n\\n\\nFull code for intuitive approach:\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        # a standard template code to reverse a linkedlist\\n        def reverse(head):\\n            if head is None or head.next is None:\\n                return head\\n            rest = reverse(head.next)\\n            head.next.next = head\\n            head.next = None\\n            return rest\\n        \\n        nodeL, nodeM, nodeR = None, None, None\\n        \\n        # if both left and right points to the same element, then there is no point of reversing\\n        if left == right:\\n            return head\\n        \\n        # Split the list into left, middle, and right part, \\n        # such that the middle part needs to be reversed.\\n        temp = ListNode()\\n        temp.next = head\\n        nodeL = temp\\n        \\n        i = 0\\n        while i < right:\\n            if i + 1 == left:\\n                nodeM = temp.next\\n                temp.next = None\\n                temp = nodeM\\n            elif i + 1 == right:\\n                nodeR = temp.next\\n                temp.next = None\\n                temp = nodeR\\n                break\\n            temp = temp.next\\n            i += 1\\n        \\n        nodeL = nodeL.next\\n        \\n        # reverse the middle part\\n        nodeM = reverse(nodeM)\\n        \\n        # if left part exists then add middle part to the end of left part\\n        if nodeL:\\n            temp = nodeL\\n            while temp.next:\\n                temp = temp.next\\n            temp.next = nodeM\\n        else:\\n            nodeL = nodeM\\n        \\n        # add right part to the end of middle part\\n        temp = nodeM\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = nodeR\\n        \\n        return nodeL\\n```\\n**Time = O(n)** as we need to traverse through the whole linked list(atleast upto right).\\n**Space = O(n)** as we are using the recursive approach to reverse the linked list, so stack space = O(right - left) which is O(n).\\nBut **this can be reduced to constant space** by changing the recursive method of reversing linkedlist to iterative method. \\nIterative method to reverse linkedlist:\\n```\\n\\t\\tdef reverse(head):\\n            prev = None\\n            current = head\\n            while(current is not None):\\n                next = current.next\\n                current.next = prev\\n                prev = current\\n                current = next\\n            head = prev\\n            return head\\n```\\nThus, **Space = O(1)**.\\n\\nBut the challenge is can we do it in one pass? -> Yes.\\n\\n**Method 2: One - pass solution**\\n*Note: It is not much efficient than the above intuitive method as a lots of swaps are happening, also the above method take much lesser time than this one in actual implementation. Try executing both and see the actual runtimes.*\\nApproach: Find the node previous of left, then swap left and left+1 along with  previous next at the same time.\\n\\n*Read the code, then look into the picture given below and try to map the idea, it\\'s simple.*\\n\\nOne pass code:\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        if left == right:\\n            return head\\n        \\n        node = temp = ListNode()\\n        node.next = head\\n        \\n        i = 1\\n        while i < left:\\n            temp = temp.next\\n            i += 1\\n        \\n        \\n        current = temp.next\\n        while left < right:\\n            t = current.next\\n            current.next = t.next\\n            t.next = temp.next\\n            temp.next = t\\n            left += 1\\n            print(node.next)\\n        \\n        return node.next\\n ```\\n Now you guys might be wondering how is it one pass solution, as there are two loops.\\n See, the first loop is going from start to left and second loop is going from left to right, so overall we are going from start to right once, hence it is one-pass.\\n \\n*Try doing it in a pen and paper, you will easily understand how the node-links are changing.*\\n *Try for [1,2,3,4,5,6] with  left = 3 and right= 5.*\\n \\n ![image](https://assets.leetcode.com/users/images/29f94123-2066-4d1b-8004-743a2165f1ce_1624454579.0142164.png)\\n \\n Time = O(n)\\n Space = O(1).\\n \\n Hope it helps!\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        # a standard template code to reverse a linkedlist\\n        def reverse(head):\\n            if head is None or head.next is None:\\n                return head\\n            rest = reverse(head.next)\\n            head.next.next = head\\n            head.next = None\\n            return rest\\n        \\n        nodeL, nodeM, nodeR = None, None, None\\n        \\n        # if both left and right points to the same element, then there is no point of reversing\\n        if left == right:\\n            return head\\n        \\n        # Split the list into left, middle, and right part, \\n        # such that the middle part needs to be reversed.\\n        temp = ListNode()\\n        temp.next = head\\n        nodeL = temp\\n        \\n        i = 0\\n        while i < right:\\n            if i + 1 == left:\\n                nodeM = temp.next\\n                temp.next = None\\n                temp = nodeM\\n            elif i + 1 == right:\\n                nodeR = temp.next\\n                temp.next = None\\n                temp = nodeR\\n                break\\n            temp = temp.next\\n            i += 1\\n        \\n        nodeL = nodeL.next\\n        \\n        # reverse the middle part\\n        nodeM = reverse(nodeM)\\n        \\n        # if left part exists then add middle part to the end of left part\\n        if nodeL:\\n            temp = nodeL\\n            while temp.next:\\n                temp = temp.next\\n            temp.next = nodeM\\n        else:\\n            nodeL = nodeM\\n        \\n        # add right part to the end of middle part\\n        temp = nodeM\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = nodeR\\n        \\n        return nodeL\\n```\n```\\n\\t\\tdef reverse(head):\\n            prev = None\\n            current = head\\n            while(current is not None):\\n                next = current.next\\n                current.next = prev\\n                prev = current\\n                current = next\\n            head = prev\\n            return head\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        if left == right:\\n            return head\\n        \\n        node = temp = ListNode()\\n        node.next = head\\n        \\n        i = 1\\n        while i < left:\\n            temp = temp.next\\n            i += 1\\n        \\n        \\n        current = temp.next\\n        while left < right:\\n            t = current.next\\n            current.next = t.next\\n            t.next = temp.next\\n            temp.next = t\\n            left += 1\\n            print(node.next)\\n        \\n        return node.next\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 110983,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null){\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        for(int i = 1; i < m; i++){\\n            previous = current;\\n            current = current.next;\\n        }\\n        \\n        ListNode newCurrent = current;\\n        ListNode prev = null;\\n        \\n        while(current != null && m <= n){\\n            ListNode temp = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = temp;\\n            m++;\\n        }\\n        \\n        if(previous == null){\\n            head = prev;\\n        } else {\\n            previous.next = prev;\\n        }\\n        \\n        newCurrent.next = current;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null){\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        for(int i = 1; i < m; i++){\\n            previous = current;\\n            current = current.next;\\n        }\\n        \\n        ListNode newCurrent = current;\\n        ListNode prev = null;\\n        \\n        while(current != null && m <= n){\\n            ListNode temp = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = temp;\\n            m++;\\n        }\\n        \\n        if(previous == null){\\n            head = prev;\\n        } else {\\n            previous.next = prev;\\n        }\\n        \\n        newCurrent.next = current;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311055,
                "title": "easy-to-understand-dry-run-with-example",
                "content": "**if(like) upvote;**\\n\\n ![image](https://assets.leetcode.com/users/images/d8139dd2-81ca-445c-bff5-1d3530881aba_1658378298.123155.jpeg)\\n\\n ListNode *forw = curr->next; \\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n\\n\\n```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *prev = dummy, *curr;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           prev = prev-> next;\\n       }\\n       curr = prev -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode *forw = curr->next; \\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n       }\\n       return dummy -> next;\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *prev = dummy, *curr;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           prev = prev-> next;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2310852,
                "title": "java-easy-solution-100-faster-code",
                "content": "PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public ListNode rev(ListNode head)\\n{\\nListNode curr=head,prev=null,next=null;\\nwhile(curr!=null)\\n{\\n\\n        next=curr.next;\\n        curr.next=prev;\\n        prev=curr;\\n        curr=next;\\n    }\\n    return prev;\\n}\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    if(left==right)\\n        return head;\\n    ListNode l=null,r=null,curr=head;\\n    int c=0;\\n    while(curr!=null)\\n    {\\n        c++;\\n        if(c==left)\\n         break;\\n        l=curr;\\n        curr=curr.next;\\n    }\\n    ListNode lt=curr;\\n   while(curr!=null)\\n    {\\n       \\n        if(c==right)\\n            break;\\n        c++;\\n        curr=curr.next;\\n    }\\n  \\n    r=curr.next;\\n     curr.next=null;\\n   lt=rev(lt);\\n   if(l==null)\\n       head=lt;\\n    else\\n        l.next=lt;\\n          while(lt.next!=null)\\n         {\\n               lt=lt.next;\\n          }\\n    lt.next=r;\\n    \\n    return head;\\n    \\n    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public ListNode rev(ListNode head)\\n{\\nListNode curr=head,prev=null,next=null;\\nwhile(curr!=null)\\n{\\n\\n        next=curr.next;\\n        curr.next=prev;\\n        prev=curr;\\n        curr=next;\\n    }\\n    return prev;\\n}\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    if(left==right)\\n        return head;\\n    ListNode l=null,r=null,curr=head;\\n    int c=0;\\n    while(curr!=null)\\n    {\\n        c++;\\n        if(c==left)\\n         break;\\n        l=curr;\\n        curr=curr.next;\\n    }\\n    ListNode lt=curr;\\n   while(curr!=null)\\n    {\\n       \\n        if(c==right)\\n            break;\\n        c++;\\n        curr=curr.next;\\n    }\\n  \\n    r=curr.next;\\n     curr.next=null;\\n   lt=rev(lt);\\n   if(l==null)\\n       head=lt;\\n    else\\n        l.next=lt;\\n          while(lt.next!=null)\\n         {\\n               lt=lt.next;\\n          }\\n    lt.next=r;\\n    \\n    return head;\\n    \\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849391,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\n    ListNode *reverse(ListNode *head)\\n    {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode *smallAns=reverse(head->next);\\n        ListNode *temp=head->next;\\n        temp->next=head;\\n        head->next=NULL;\\n        return smallAns;\\n    }\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {   if(head==NULL or head->next==NULL)\\n        {\\n            return head; \\n        }\\n        if(left==right)\\n        {\\n            return head;\\n        }\\n        if((right-left+1)==length(head))\\n        {\\n            return reverse(head);\\n        }\\n        if(left==1)\\n        {\\n            ListNode *end=NULL;\\n            ListNode *temp=head;\\n            int count=1;\\n            while(temp!=NULL)\\n            {\\n                if(count==right)\\n                {\\n                    end=temp;\\n                    break;\\n                }\\n                temp=temp->next;\\n                count=count+1;\\n            }\\n            ListNode *remain=end->next;\\n            end->next=NULL;\\n            ListNode *first=head;\\n            head=reverse(head);\\n            first->next=remain;\\n            return head;\\n        }\\n        ListNode *start=NULL;\\n        ListNode *end=NULL;\\n        ListNode *temp=head;\\n        int count=1;\\n        while(temp!=NULL)\\n        {\\n            if(count==left){\\n                start=temp;\\n            }\\n            if(count==right){\\n                end=temp;\\n            }\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        temp=head;\\n        while(temp->next!=start)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        ListNode *part2=end->next;\\n        end->next=NULL;\\n        start=reverse(start);\\n        temp->next=start;\\n        ListNode *curr=start;\\n        while(curr->next!=NULL){\\n            curr=curr->next;\\n        }\\n        curr->next=part2;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    ListNode *reverse(ListNode *head)\\n    {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode *smallAns=reverse(head->next);\\n        ListNode *temp=head->next;\\n        temp->next=head;\\n        head->next=NULL;\\n        return smallAns;\\n    }\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {   if(head==NULL or head->next==NULL)\\n        {\\n            return head; \\n        }\\n        if(left==right)\\n        {\\n            return head;\\n        }\\n        if((right-left+1)==length(head))\\n        {\\n            return reverse(head);\\n        }\\n        if(left==1)\\n        {\\n            ListNode *end=NULL;\\n            ListNode *temp=head;\\n            int count=1;\\n            while(temp!=NULL)\\n            {\\n                if(count==right)\\n                {\\n                    end=temp;\\n                    break;\\n                }\\n                temp=temp->next;\\n                count=count+1;\\n            }\\n            ListNode *remain=end->next;\\n            end->next=NULL;\\n            ListNode *first=head;\\n            head=reverse(head);\\n            first->next=remain;\\n            return head;\\n        }\\n        ListNode *start=NULL;\\n        ListNode *end=NULL;\\n        ListNode *temp=head;\\n        int count=1;\\n        while(temp!=NULL)\\n        {\\n            if(count==left){\\n                start=temp;\\n            }\\n            if(count==right){\\n                end=temp;\\n            }\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        temp=head;\\n        while(temp->next!=start)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        ListNode *part2=end->next;\\n        end->next=NULL;\\n        start=reverse(start);\\n        temp->next=start;\\n        ListNode *curr=start;\\n        while(curr->next!=NULL){\\n            curr=curr->next;\\n        }\\n        curr->next=part2;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831913,
                "title": "single-traversal-interview-approaches-100-beating-other-solutions",
                "content": "**Please Upvote it helps a lot**\\n*Approach 1 Using Stack,it takes two traversals(using data change)*\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n     \\n        ListNode ptr = head;\\n        int count = 1;\\n        Stack<Integer> st = new Stack<>();\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                st.push(ptr.val);\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        count = 1;\\n        ptr = head;\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                ptr.val = st.pop();\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n*Single Traversal Solution,Using Link Change*\\n\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        \\n        int count = 0;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode ptr = dummy;    //ptr for iteration\\n        ListNode h1 = null;\\n        \\n        while(ptr != null){\\n            if(count == left - 1){\\n                 h1 = ptr;  //store it as we have to change its next pointer\\n            }\\n            \\n            if(count == left){\\n                ListNode h2 = ptr;      //store it as we have to change its next pointer\\n                reverse(h2,right - left,h1,h2);\\n                return dummy.next;\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    private void reverse(ListNode head,int con,ListNode h1,ListNode h2){\\n        //function for reversing the sub list and after that \\n        //add it to main list using h1 and h2 pointers\\n        \\n        ListNode prev = head;\\n        ListNode cur = prev.next;\\n        ListNode next = null ;\\n        \\n        for(int i = 1;i<=con;i++){ //reverse the sub list\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        h1.next = prev;\\n        h2.next = cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n     \\n        ListNode ptr = head;\\n        int count = 1;\\n        Stack<Integer> st = new Stack<>();\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                st.push(ptr.val);\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        count = 1;\\n        ptr = head;\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                ptr.val = st.pop();\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        \\n        int count = 0;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode ptr = dummy;    //ptr for iteration\\n        ListNode h1 = null;\\n        \\n        while(ptr != null){\\n            if(count == left - 1){\\n                 h1 = ptr;  //store it as we have to change its next pointer\\n            }\\n            \\n            if(count == left){\\n                ListNode h2 = ptr;      //store it as we have to change its next pointer\\n                reverse(h2,right - left,h1,h2);\\n                return dummy.next;\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    private void reverse(ListNode head,int con,ListNode h1,ListNode h2){\\n        //function for reversing the sub list and after that \\n        //add it to main list using h1 and h2 pointers\\n        \\n        ListNode prev = head;\\n        ListNode cur = prev.next;\\n        ListNode next = null ;\\n        \\n        for(int i = 1;i<=con;i++){ //reverse the sub list\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        h1.next = prev;\\n        h2.next = cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30815,
                "title": "less-than-10-lines-c-double-pointer-easy-understanding",
                "content": "    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode **pre = &head;\\n        int steps = m;\\n        while (--steps) { pre = &(*pre)->next;}\\n        ListNode *cur = *pre;\\n        for (int i = m; i < n; i++) {\\n            ListNode *next_n = cur->next;\\n            cur->next = next_n->next;\\n            next_n->next = *pre;\\n            *pre = next_n;\\n        }\\n        return head; \\n    }",
                "solutionTags": [],
                "code": "    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode **pre = &head;\\n        int steps = m;\\n        while (--steps) { pre = &(*pre)->next;}\\n        ListNode *cur = *pre;\\n        for (int i = m; i < n; i++) {\\n            ListNode *next_n = cur->next;\\n            cur->next = next_n->next;\\n            next_n->next = *pre;\\n            *pre = next_n;\\n        }\\n        return head; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3197002,
                "title": "c-linked-list-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        reverse(v.begin()+left-1, v.begin()+right);\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        reverse(v.begin()+left-1, v.begin()+right);\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090795,
                "title": "c-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        for(int i=1;i<left;i++) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n        ListNode* first = prev;\\n        ListNode* newend = curr;\\n        ListNode* nextNode = curr -> next;\\n        for(int i = 0;i<right - left + 1;i++) {\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n            if(nextNode != NULL) nextNode = nextNode -> next;\\n        }\\n        if(first != NULL) first -> next = prev;\\n        else head = prev;\\n        newend -> next = curr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        for(int i=1;i<left;i++) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n        ListNode* first = prev;\\n        ListNode* newend = curr;\\n        ListNode* nextNode = curr -> next;\\n        for(int i = 0;i<right - left + 1;i++) {\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n            if(nextNode != NULL) nextNode = nextNode -> next;\\n        }\\n        if(first != NULL) first -> next = prev;\\n        else head = prev;\\n        newend -> next = curr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497448,
                "title": "python-easy-solution-with-explanation",
                "content": "\\n        # setting dummy node \\n        dummy = ListNode(0, head)\\n        \\n        \\n        # setting leftprev so that we can link this linkedlist with the reversed one\\n        leftprev, curr = dummy, head\\n        \\n        \\n        # iterating till we reach the desired start pos from where we need to reverse the list\\n        \\n        for i in range(0, left-1):\\n            \\n            leftprev , curr = curr, curr.next\\n            \\n        #leftprev = curr    \\n        \\n        #now reversing the linkedlist\\n        \\n        #this will run from right -left +1\\n        \\n        prev = None\\n        for i in range(right - left +1):\\n            \\n            nxt = curr.next\\n            \\n            curr.next = prev\\n            \\n            prev = curr\\n            \\n            curr = nxt\\n            \\n            \\n        # Now the main logic \\n        \\n        #since we got the given range linkedlist reversed but it is connected with the other so how to do that\\n        \\n        # see exp 1 we want 2\\'s next pointer to be 5 and 1\\'s next pointer to be 4 right??\\n        \\n        # So our leftprev is pointing to 1 and currently its .next is pointing to 2 coz we have linked the reversed linkedlist\\n        \\n        # with the non reversed linkedlist\\n        \\n        # so we will do leftprev. next.next to be curr coz curr is pointing to last as it is evident from line 36 above\\n        \\n        #now to make the next pointer of left prev to point to 4 how can we do that ???\\n        \\n        # remember that in reversed linkedlist prev is pointing to 4, so all we need to do is that do leftprev.next = prev\\n        \\n        \\n       \\n\\t   #REMEMBER THE ORDER SHOULD BE THIS WAY ELSE WE DO VICE VERSA THEN LEFTPREV.NEXT WILL POINT TO 4 AND 4\\'S NEXT WILL START\\n        \\n        # POINTING TO 5 RATHER THAN POINTING TO 3\\n        \\n        leftprev.next.next = curr # now 2\\'s next is pointing to 5 \\n        \\n        leftprev.next = prev # 1\\'s next pointer is poiting to 4\\n        \\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\n        # setting dummy node \\n        dummy = ListNode(0, head)\\n        \\n        \\n        # setting leftprev so that we can link this linkedlist with the reversed one\\n        leftprev, curr = dummy, head\\n        \\n        \\n        # iterating till we reach the desired start pos from where we need to reverse the list\\n        \\n        for i in range(0, left-1):\\n            \\n            leftprev , curr = curr, curr.next\\n            \\n        #leftprev = curr    \\n        \\n        #now reversing the linkedlist\\n        \\n        #this will run from right -left +1\\n        \\n        prev = None\\n        for i in range(right - left +1):\\n            \\n            nxt = curr.next\\n            \\n            curr.next = prev\\n            \\n            prev = curr\\n            \\n            curr = nxt\\n            \\n            \\n        # Now the main logic \\n        \\n        #since we got the given range linkedlist reversed but it is connected with the other so how to do that\\n        \\n        # see exp 1 we want 2\\'s next pointer to be 5 and 1\\'s next pointer to be 4 right??\\n        \\n        # So our leftprev is pointing to 1 and currently its .next is pointing to 2 coz we have linked the reversed linkedlist\\n        \\n        # with the non reversed linkedlist\\n        \\n        # so we will do leftprev. next.next to be curr coz curr is pointing to last as it is evident from line 36 above\\n        \\n        #now to make the next pointer of left prev to point to 4 how can we do that ???\\n        \\n        # remember that in reversed linkedlist prev is pointing to 4, so all we need to do is that do leftprev.next = prev\\n        \\n        \\n       \\n\\t   #REMEMBER THE ORDER SHOULD BE THIS WAY ELSE WE DO VICE VERSA THEN LEFTPREV.NEXT WILL POINT TO 4 AND 4\\'S NEXT WILL START\\n        \\n        # POINTING TO 5 RATHER THAN POINTING TO 3\\n        \\n        leftprev.next.next = curr # now 2\\'s next is pointing to 5 \\n        \\n        leftprev.next = prev # 1\\'s next pointer is poiting to 4\\n        \\n        return dummy.next",
                "codeTag": "Unknown"
            },
            {
                "id": 4011861,
                "title": "c-simple-solution-13-line-code",
                "content": "`Time Complexity` -O(n)\\n`Space Complexity` -O(1)\\nGiven the code, we have a `ListNode` definition with three constructors, a class `Solution` with a `reverseBetween` function.\\n### Step 1: Initialize Variables\\n\\n1. Create a `dummy` node and set its `next` pointer to the original `head`.\\n2. Initialize the `prev` pointer on the `dummy` node.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n ^\\n head\\n prev\\n```\\n\\n### Step 2: Move `prev` to (left - 1) position\\n\\nIterate `left - 1` times to position `prev` at the node just before the segment to be reversed.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^   \\n         prev\\n```\\n\\n### Step 3: Initialize `current`\\n\\nSet the `current` pointer to the `prev` node. This is because we want to start reversing from position `left`.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^        \\n         prev\\n         current\\n```\\n\\n### Step 4: Reverse the Segment\\n\\nIterate and reverse the nodes between `left` and `right`.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[3]->[2]->[4]->[5]->[6]->nullptr\\n          ^   ^    ^\\n         prev  |  current\\n               x\\n```\\n\\n### Step 5: Continue Reversing\\n\\nRepeat the process until `right - left` times.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n          ^   ^        ^\\n         prev  |       current\\n               x\\n```\\n\\n### Step 6: Return the Modified List\\nReturn the `next` pointer of `dummy` which points to the modified list.\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n```\\nThis completes the process of reversing the segment between `left` and `right` in the linked list.\\n![image](https://assets.leetcode.com/users/images/10c4c0ba-f8bf-45db-9b6f-80a1ddb25653_1694047517.3518703.png)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // Create a dummy node.\\n        dummy->next = head;\\n        ListNode *prev = dummy; //the prev pointer on the dummy node.\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next; // Move the prev pointer to the (left - 1)-th node.\\n        }\\n\\n        ListNode *current = prev->next; // The current pointer starts just after the prev.\\n\\n        // Reverse the portion.\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode *x = current->next; // save current->next \\n            current->next = x->next; // Update current\\'s next \\n            x->next = prev->next; // Insert x node between prev and its next node.\\n            prev->next = x; // Update prev\\'s next to point to forw.\\n        }\\n\\n        return dummy->next; \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dc223b26-c098-421b-8482-bde1e4972cb1_1694045277.3329945.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n ^\\n head\\n prev\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^   \\n         prev\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^        \\n         prev\\n         current\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[3]->[2]->[4]->[5]->[6]->nullptr\\n          ^   ^    ^\\n         prev  |  current\\n               x\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n          ^   ^        ^\\n         prev  |       current\\n               x\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // Create a dummy node.\\n        dummy->next = head;\\n        ListNode *prev = dummy; //the prev pointer on the dummy node.\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next; // Move the prev pointer to the (left - 1)-th node.\\n        }\\n\\n        ListNode *current = prev->next; // The current pointer starts just after the prev.\\n\\n        // Reverse the portion.\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode *x = current->next; // save current->next \\n            current->next = x->next; // Update current\\'s next \\n            x->next = prev->next; // Insert x node between prev and its next node.\\n            prev->next = x; // Update prev\\'s next to point to forw.\\n        }\\n\\n        return dummy->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011858,
                "title": "c-linked-list-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike yesterday transverse the list.  Use a dummy ListNode makes programming easier.\\n```\\nListNode dummy=ListNode();\\nListNode* L=&dummy, *R;\\ndummy.next=head;\\n```\\n# Approach\\n\\nThe implementation avoids the possiblity for memory leaks.\\n<!-- Describe your approach to solving the problem. -->\\nLeetcode 86. Partition List\\n[Please turn on english subtitles if necessary]\\n[https://youtu.be/LZ6oARGKnZA?si=JszrMJrISfmZkSd-](https://youtu.be/LZ6oARGKnZA?si=JszrMJrISfmZkSd-)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code runtime 0 ms beats 100%\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        if (right==1) return head;\\n        ListNode dummy=ListNode();\\n        ListNode* L=&dummy, *R;\\n        dummy.next=head;\\n        // Move L to the position left\\n        for(int i=0; i<left-1; i++)\\n            L=L->next;\\n        R=L->next;\\n        //From i=left to right, move R->next to the position right stepwise\\n        for(int i=left; i<right; i++){\\n            ListNode* rev=R->next;//Reverse the linked list (1)\\n            R->next=rev->next;//(2)position for R->next in next i \\n            rev->next=L->next;//(3)\\n            L->next=rev; //(4)\\n        }\\n\\n        return dummy.next;\\n    }\\n};\\n```\\n# Diagram for reversing linked list\\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nListNode dummy=ListNode();\\nListNode* L=&dummy, *R;\\ndummy.next=head;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        if (right==1) return head;\\n        ListNode dummy=ListNode();\\n        ListNode* L=&dummy, *R;\\n        dummy.next=head;\\n        // Move L to the position left\\n        for(int i=0; i<left-1; i++)\\n            L=L->next;\\n        R=L->next;\\n        //From i=left to right, move R->next to the position right stepwise\\n        for(int i=left; i<right; i++){\\n            ListNode* rev=R->next;//Reverse the linked list (1)\\n            R->next=rev->next;//(2)position for R->next in next i \\n            rev->next=L->next;//(3)\\n            L->next=rev; //(4)\\n        }\\n\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742121,
                "title": "using-stacks-in-c",
                "content": "# Intuition\\nuse stacks.push the elments in stack to be reversed .then we will have a reversed list of the elements then insert the remaining elements to the list at beginning and at last\\n# Approach\\n\\nThe code aims to reverse a sublist of a singly-linked list between two given positions, left and right. It follows the following approach:\\n\\nInitialize a stack (top) to store the elements that need to be reversed.\\n\\nImplement the isfull function to check if the stack is full. In this code, it always returns 0 as the stack is implemented using a linked list and doesn\\'t have a predefined size.\\n\\nImplement the isempty function to check if the stack is empty. It returns 1 if the stack is empty (i.e., t is NULL) and 0 otherwise.\\n\\nImplement the push function to push an element onto the stack. It first checks if the stack is full using the isfull function. If the stack is not full, it allocates memory for a new node, assigns the value to the node, updates the next pointer to point to the current top of the stack, and then updates the stack\\'s top to the new node. It returns the updated top of the stack.\\n\\nThe reverseBetween function takes the head of the linked list, head, and the positions left and right as input. It initializes pointers p and q to point to the head of the list and sets top (the stack) to NULL.\\n\\nThe function iterates p to reach the node at position left - 1 and q to reach the node at position right. This is done using two for-loops.\\n\\nNext, it iterates from p to q and pushes the values of the nodes onto the stack using the push function.\\n\\nAfter the iteration, it pushes the value of p onto the stack as well.\\n\\nIt then finds the last node in the stack by iterating from top until the next pointer is NULL. It assigns q->next to the next of this last node.\\n\\nIf left > 1, it updates the next pointer of the node at position left - 2 to the top of the stack. Otherwise, it updates the head of the list to top.\\n\\nFinally, it returns the head of the modified list.\\n\\nThe time complexity of the code is O(N), where N is the number of nodes in the linked list. This is because the code iterates over the sublist to be reversed and pushes the values onto the stack, which takes O(N) time. Additionally, it iterates over the stack to find the last node, which also takes O(N) time.\\n\\nThe space complexity of the code is O(N) as well. It uses a stack (top) to store the sublist elements that need to be reversed. The maximum size of the stack will be equal to the size of the sublist, which can be up to N in the worst case.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n struct  ListNode *top=NULL;\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    struct ListNode *p=head;\\n    struct ListNode *q=head;\\n         struct ListNode *top=NULL;\\n    int i;\\n    for(i=0;i<left-1;i++)\\n    {\\n        p=p->next;\\n    }\\n    for(i=0;i<right-1;i++)\\n    {\\n        q=q->next;\\n    }\\n    while(p!=q)\\n    {\\n        top=push(top,p->val);\\n        p=p->next;\\n    }\\n    top=push(top,p->val);\\nstruct ListNode* o = top;\\n    while (o->next != NULL) {\\n        o = o->next;\\n    }\\n    o->next = q->next;\\n    struct ListNode* e = head;\\n    if (left > 1) {\\n        for (i = 0; i < left - 2; i++) {\\n            e = e->next;\\n        }\\n        e->next = top;\\n        return head;\\n    } else {\\n        return top;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n struct  ListNode *top=NULL;\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    struct ListNode *p=head;\\n    struct ListNode *q=head;\\n         struct ListNode *top=NULL;\\n    int i;\\n    for(i=0;i<left-1;i++)\\n    {\\n        p=p->next;\\n    }\\n    for(i=0;i<right-1;i++)\\n    {\\n        q=q->next;\\n    }\\n    while(p!=q)\\n    {\\n        top=push(top,p->val);\\n        p=p->next;\\n    }\\n    top=push(top,p->val);\\nstruct ListNode* o = top;\\n    while (o->next != NULL) {\\n        o = o->next;\\n    }\\n    o->next = q->next;\\n    struct ListNode* e = head;\\n    if (left > 1) {\\n        for (i = 0; i < left - 2; i++) {\\n            e = e->next;\\n        }\\n        e->next = top;\\n        return head;\\n    } else {\\n        return top;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3187602,
                "title": "reverse-linked-list-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a dummy node to keep track of the previous node. It first moves prev to the node before the start node, and then reverse the nodes from the start node to the end node. For each iteration, it changes the next pointer of the start node to the next node of the end node, and changes the next pointer of the end node to the next node of prev.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Create a dummy node\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        # Keep track of the previous node\\n        prev = dummy\\n        # Move to the node before the start node\\n        for i in range(left - 1):\\n            prev = prev.next\\n        start = prev.next\\n        end = start.next\\n        # Reverse the nodes\\n        for i in range(right - left):\\n            start.next = end.next\\n            end.next = prev.next\\n            prev.next = end\\n            end = start.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Create a dummy node\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        # Keep track of the previous node\\n        prev = dummy\\n        # Move to the node before the start node\\n        for i in range(left - 1):\\n            prev = prev.next\\n        start = prev.next\\n        end = start.next\\n        # Reverse the nodes\\n        for i in range(right - left):\\n            start.next = end.next\\n            end.next = prev.next\\n            prev.next = end\\n            end = start.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713725,
                "title": "c-0-ms-beats-100-runtime",
                "content": "# C++ || 0 ms || beats 100% runtime || \\uD83D\\uDCAF\\uD83D\\uDCAF\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n  ListNode* reverse(ListNode* start, ListNode* end ){\\n      \\n         ListNode *curr = start;\\n         ListNode *prev = NULL ;\\n         ListNode *forward = NULL;\\n              \\n           while(curr != end  ){\\n            \\n              forward = curr->next;\\n              curr -> next = prev;\\n         \\n             prev = curr;\\n            curr = forward;\\n        }\\n          \\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(head->next==NULL || head==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *start=head;\\n        ListNode *end = head;\\n        ListNode *temp = start;\\n        ListNode* nextToEnd = NULL;\\n       if(left==1 && right==1){\\n           return head;\\n       }\\n        int cnt = 1 ;\\n        \\n        while(cnt<left){\\n            temp=start;\\n            start=start->next;\\n            cnt++;\\n        }\\n        cnt = 1;\\n           while(cnt<right){\\n            end=end->next;\\n               \\n            cnt++;\\n        }\\n        nextToEnd = end->next  ;\\n        //for left = 1\\n        \\n        if(left==1 ){\\n         head = reverse(start, nextToEnd);\\n          ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n         }\\n                    tail->next = nextToEnd ;\\n             return head;\\n        }\\n        \\n       temp->next = reverse(start, nextToEnd);\\n    \\n        ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n        }\\n        tail->next = nextToEnd ;\\n       return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n  ListNode* reverse(ListNode* start, ListNode* end ){\\n      \\n         ListNode *curr = start;\\n         ListNode *prev = NULL ;\\n         ListNode *forward = NULL;\\n              \\n           while(curr != end  ){\\n            \\n              forward = curr->next;\\n              curr -> next = prev;\\n         \\n             prev = curr;\\n            curr = forward;\\n        }\\n          \\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(head->next==NULL || head==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *start=head;\\n        ListNode *end = head;\\n        ListNode *temp = start;\\n        ListNode* nextToEnd = NULL;\\n       if(left==1 && right==1){\\n           return head;\\n       }\\n        int cnt = 1 ;\\n        \\n        while(cnt<left){\\n            temp=start;\\n            start=start->next;\\n            cnt++;\\n        }\\n        cnt = 1;\\n           while(cnt<right){\\n            end=end->next;\\n               \\n            cnt++;\\n        }\\n        nextToEnd = end->next  ;\\n        //for left = 1\\n        \\n        if(left==1 ){\\n         head = reverse(start, nextToEnd);\\n          ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n         }\\n                    tail->next = nextToEnd ;\\n             return head;\\n        }\\n        \\n       temp->next = reverse(start, nextToEnd);\\n    \\n        ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n        }\\n        tail->next = nextToEnd ;\\n       return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086886,
                "title": "simple-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL){return head;} // Base case:- If there are no nodes or only a single node. \\n        \\n        ListNode* dummy=new ListNode(-1); // Creating a dummy node.\\n        dummy->next=head; // Making connection of the dummy node to head.\\n        \\n        // Creating pointers for traversal which will further help in making connections after the reversal operation.\\n        ListNode* previt=NULL; \\n        ListNode* it=dummy;\\n        \\n        // Traverse till the left node which is the beginning node for the reversal part of the linked list. \\n        for(int i=0;i<left;i++){\\n            previt=it;\\n            it=it->next;\\n        }\\n        \\n        // Appointing pointers to the left node and its previous node to help in reversal operation.\\n        ListNode* curr=it;\\n        ListNode* prev=previt;\\n        \\n        \\n        // Traverse till the right node which is the ending point for the reverse operation and reverse nodes side by side as done in \"Reverse Linked List 1(Leetcode no. 206)\"\\n        for(int i=left;i<=right;i++){\\n            ListNode* Next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=Next;\\n        }\\n        \\n        // Make connections \\n        previt->next=prev;\\n        it->next=curr;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL){return head;} // Base case:- If there are no nodes or only a single node. \\n        \\n        ListNode* dummy=new ListNode(-1); // Creating a dummy node.\\n        dummy->next=head; // Making connection of the dummy node to head.\\n        \\n        // Creating pointers for traversal which will further help in making connections after the reversal operation.\\n        ListNode* previt=NULL; \\n        ListNode* it=dummy;\\n        \\n        // Traverse till the left node which is the beginning node for the reversal part of the linked list. \\n        for(int i=0;i<left;i++){\\n            previt=it;\\n            it=it->next;\\n        }\\n        \\n        // Appointing pointers to the left node and its previous node to help in reversal operation.\\n        ListNode* curr=it;\\n        ListNode* prev=previt;\\n        \\n        \\n        // Traverse till the right node which is the ending point for the reverse operation and reverse nodes side by side as done in \"Reverse Linked List 1(Leetcode no. 206)\"\\n        for(int i=left;i<=right;i++){\\n            ListNode* Next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=Next;\\n        }\\n        \\n        // Make connections \\n        previt->next=prev;\\n        it->next=curr;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621775,
                "title": "easy-to-understand-13-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right || !head || !head->next)return head;\\n             \\n        ListNode* temp = head;\\n        vector<int> order;\\n        \\n        while(temp != NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        reverse(order.begin() + left - 1 , order.begin() + right);\\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right || !head || !head->next)return head;\\n             \\n        ListNode* temp = head;\\n        vector<int> order;\\n        \\n        while(temp != NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        reverse(order.begin() + left - 1 , order.begin() + right);\\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498545,
                "title": "c-simple-and-commented-solution-faster-than-100-0-ms",
                "content": "```\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0,head);\\n        //dummy will always point to head , to handle edge cases\\n        \\n        ListNode *Leftprev = dummy;\\n        ListNode *cur = head;\\n        //1st pass -> iterate to left and previous of left means iterate till left-1\\n        for(int i=1;i<left;i++)\\n        {\\n            Leftprev = cur;\\n            cur = cur->next;\\n        }\\n        //prev which will iterate to right \\n        ListNode *prev = NULL;\\n        \\n        //2nd pass , reverse from left to right\\n        for(int i=1;i<=(right-left+1);i++)\\n        {\\n            ListNode *tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        //now the list is 0->1->2<-3<-4->5 \\n        //leftprev is at 1 , prev = 4 , cur = 5 \\n        // so we just need to connect leftprev->next->next = cur and leftprev->next = prev;\\n        Leftprev->next->next = cur;\\n        Leftprev->next = prev;\\n        \\n        return dummy->next;\\n            \\n    }\\n```\\n**If you like it , Do upvote\\nHappy Coding;**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0,head);\\n        //dummy will always point to head , to handle edge cases\\n        \\n        ListNode *Leftprev = dummy;\\n        ListNode *cur = head;\\n        //1st pass -> iterate to left and previous of left means iterate till left-1\\n        for(int i=1;i<left;i++)\\n        {\\n            Leftprev = cur;\\n            cur = cur->next;\\n        }\\n        //prev which will iterate to right \\n        ListNode *prev = NULL;\\n        \\n        //2nd pass , reverse from left to right\\n        for(int i=1;i<=(right-left+1);i++)\\n        {\\n            ListNode *tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        //now the list is 0->1->2<-3<-4->5 \\n        //leftprev is at 1 , prev = 4 , cur = 5 \\n        // so we just need to connect leftprev->next->next = cur and leftprev->next = prev;\\n        Leftprev->next->next = cur;\\n        Leftprev->next = prev;\\n        \\n        return dummy->next;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291724,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head== NULL) return NULL;\\n        ListNode* res= new ListNode(0,head);\\n        ListNode* prev= res;\\n        for(int i=0; i<left-1; i++) prev= prev->next; \\n        ListNode* curr= prev->next;\\n        while(left++ < right){\\n            ListNode* temp= curr->next;\\n            curr->next= temp->next;\\n            temp->next= prev->next;\\n            prev->next= temp;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head== NULL) return NULL;\\n        ListNode* res= new ListNode(0,head);\\n        ListNode* prev= res;\\n        for(int i=0; i<left-1; i++) prev= prev->next; \\n        ListNode* curr= prev->next;\\n        while(left++ < right){\\n            ListNode* temp= curr->next;\\n            curr->next= temp->next;\\n            temp->next= prev->next;\\n            prev->next= temp;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230124,
                "title": "easy-c-solution-without-creating-any-dummy-node",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode *tmp=head,*age;\\n        int count=1;\\n        while(tmp && count<left)\\n        {\\n            age=tmp;\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        ListNode *prev=NULL,*later=NULL,*curr=tmp;\\n        while(curr && count<=right)\\n        {\\n            later=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=later;\\n            count++;\\n        }\\n        if(left==1)\\n        {\\n            head=prev;\\n        }\\n        else\\n        {\\n            age->next=prev;\\n        }\\n        tmp->next=curr;\\n        return head;\\n    }\\n};\\n```\\n**Please upvote if you have any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode *tmp=head,*age;\\n        int count=1;\\n        while(tmp && count<left)\\n        {\\n            age=tmp;\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        ListNode *prev=NULL,*later=NULL,*curr=tmp;\\n        while(curr && count<=right)\\n        {\\n            later=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=later;\\n            count++;\\n        }\\n        if(left==1)\\n        {\\n            head=prev;\\n        }\\n        else\\n        {\\n            age->next=prev;\\n        }\\n        tmp->next=curr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641876,
                "title": "c-50-well-commented-code",
                "content": "**If needed explanation please comment will reply within 2 hours**\\n**Upvotes are appreciated**\\n```\\nListNode* reverse(ListNode* head){\\n        ListNode* curr=head;\\n        ListNode* nxt=head;\\n        ListNode* prev=NULL;\\n        while(curr){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n\\t\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(!head || !head->next ||m==n)\\n            return head;\\n        ListNode* p1=head;\\n        ListNode* prevp1=head;\\n        ListNode* p2=head;\\n        ListNode* forp2=head;\\n        int x=m,y=n;\\n        //traversing upto m and marking prevp1 as previous to p1 pointer\\n        while(x-->1){\\n            prevp1=p1;\\n            p1=p1->next;\\n        }\\n        //traversing upto n\\n        while(y-->1)\\n            p2=p2->next;\\n        //marking forp2 as next pointer to p2\\n        forp2=p2->next;\\n        //if we have to reverse 1 node to last node\\n        //just revrse whole linked list\\n        if(m==1 and p2->next==NULL){\\n            p1=reverse(p1);\\n            return p1;\\n        }\\n        //if we have to revrese upto last node strating from any node but first\\n        if(p2->next==NULL){\\n            p1=reverse(p1);\\n            prevp1->next=p1;\\n            return head;\\n        }\\n        //breaking linked list in two parts for reversal\\n        p2->next=NULL;\\n        //returning head pointer to reveresed list\\n        p1=reverse(p1);\\n        //if have to reverse from 1st node to any node but last\\n        if(m==1){\\n            prevp1=p1;\\n            while(p1->next)\\n                p1=p1->next;\\n            p1->next=forp2;\\n            return prevp1;\\n        }\\n        // if any other condition than above\\n        //that is want to reverse list when m!=1 and n!=length of list\\n        prevp1->next=p1;\\n        while(p1->next)\\n            p1=p1->next;\\n        p1->next=forp2;\\n        \\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverse(ListNode* head){\\n        ListNode* curr=head;\\n        ListNode* nxt=head;\\n        ListNode* prev=NULL;\\n        while(curr){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n\\t\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(!head || !head->next ||m==n)\\n            return head;\\n        ListNode* p1=head;\\n        ListNode* prevp1=head;\\n        ListNode* p2=head;\\n        ListNode* forp2=head;\\n        int x=m,y=n;\\n        //traversing upto m and marking prevp1 as previous to p1 pointer\\n        while(x-->1){\\n            prevp1=p1;\\n            p1=p1->next;\\n        }\\n        //traversing upto n\\n        while(y-->1)\\n            p2=p2->next;\\n        //marking forp2 as next pointer to p2\\n        forp2=p2->next;\\n        //if we have to reverse 1 node to last node\\n        //just revrse whole linked list\\n        if(m==1 and p2->next==NULL){\\n            p1=reverse(p1);\\n            return p1;\\n        }\\n        //if we have to revrese upto last node strating from any node but first\\n        if(p2->next==NULL){\\n            p1=reverse(p1);\\n            prevp1->next=p1;\\n            return head;\\n        }\\n        //breaking linked list in two parts for reversal\\n        p2->next=NULL;\\n        //returning head pointer to reveresed list\\n        p1=reverse(p1);\\n        //if have to reverse from 1st node to any node but last\\n        if(m==1){\\n            prevp1=p1;\\n            while(p1->next)\\n                p1=p1->next;\\n            p1->next=forp2;\\n            return prevp1;\\n        }\\n        // if any other condition than above\\n        //that is want to reverse list when m!=1 and n!=length of list\\n        prevp1->next=p1;\\n        while(p1->next)\\n            p1=p1->next;\\n        p1->next=forp2;\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620280,
                "title": "python-iterative-sol-beats-95",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        if not head:\\n            return head\\n        cur, prev = head, None\\n        for _ in range(m-1):\\n            prev = cur\\n            cur = cur.next\\n        tail, con = cur, prev\\n        for _ in range(n-m+1):\\n            third = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = third\\n        if con:\\n            con.next = prev\\n        else:\\n            head = prev\\n        tail.next = cur\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        if not head:\\n            return head\\n        cur, prev = head, None\\n        for _ in range(m-1):\\n            prev = cur\\n            cur = cur.next\\n        tail, con = cur, prev\\n        for _ in range(n-m+1):\\n            third = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = third\\n        if con:\\n            con.next = prev\\n        else:\\n            head = prev\\n        tail.next = cur\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30695,
                "title": "java-solution-with-less-pointers-and-detailed-comments",
                "content": "```\\npublic ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return head;\\n        ListNode fake_head = new ListNode(0);\\n        fake_head.next = head;\\n        \\n        //move to the start point\\n        ListNode pre = fake_head;\\n        for(int i = 0; i < m - 1; i ++){\\n            pre = pre.next;\\n        }\\n        \\n        //do the reverse\\n        ListNode cur = pre.next;\\n        ListNode new_head = null;\\n        for(int i = 0; i <= n - m; i ++){\\n            ListNode next = cur.next;\\n            cur.next = new_head;\\n            new_head = cur;\\n            cur = next;\\n        }\\n        \\n        //reconnect\\n        pre.next.next = cur;\\n        pre.next = new_head;\\n        \\n        return fake_head.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return head;\\n        ListNode fake_head = new ListNode(0);\\n        fake_head.next = head;\\n        \\n        //move to the start point\\n        ListNode pre = fake_head;\\n        for(int i = 0; i < m - 1; i ++){\\n            pre = pre.next;\\n        }\\n        \\n        //do the reverse\\n        ListNode cur = pre.next;\\n        ListNode new_head = null;\\n        for(int i = 0; i <= n - m; i ++){\\n            ListNode next = cur.next;\\n            cur.next = new_head;\\n            new_head = cur;\\n            cur = next;\\n        }\\n        \\n        //reconnect\\n        pre.next.next = cur;\\n        pre.next = new_head;\\n        \\n        return fake_head.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012720,
                "title": "drawing-explanation-easy-to-understand",
                "content": "# Intuition and Approach\\n\\n    1. Find left node indcated by index - l\\n    2. Find right node indicated by index - r\\n    3. Revers left node till right node\\n    4. Link the broken links\\n\\n    Note: Add a dummy head to track left_prev node in case left node is at head\\n\\n#### Please bear with my diagrams :)\\n\\nInput: head = ```[1,2,3,4,5]```, l = ```2``` (left index), r = ```4``` (right index)\\nOutput: ```[1,4,3,2,5]```\\n\\n![20230907_111845_1.jpg](https://assets.leetcode.com/users/images/e5b2b627-ed02-4dca-a99e-751701ca1170_1694068233.7766912.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(2r - l))$$ ```r```= right index, ```l``` = left index\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# C++\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode* dummy_head = new ListNode(-1);\\n        dummy_head->next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode* left_prev = dummy_head;\\n        ListNode* left = dummy_head->next;\\n        int left_count = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (left_count < l) {\\n            left_prev = left;\\n            left = left->next;\\n            left_count++;\\n        }\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode* right = left;\\n        ListNode* right_next = left->next;\\n        int right_count = 0;\\n        while (right_count < r - l) {\\n            right = right_next;\\n            right_next = right_next->next;\\n            right_count++;\\n        }\\n        // 3rd while loop (reverse element between left and right node)\\n        ListNode* cur = left;\\n        ListNode* pre = nullptr;\\n        while (cur != right_next) {\\n            ListNode* tmp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n        // 4th fix breakage link\\n        left_prev->next = right;\\n        left->next = right_next;\\n\\n        head = dummy_head->next;\\n        delete dummy_head;\\n        return head;\\n    }\\n};\\n```\\n# Python3\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], l: int, r: int) -> Optional[ListNode]:\\n        \\n        # Dummy head insertion\\n        dummy_head = ListNode(None)\\n        dummy_head.next = head\\n\\n        # 1st while loop (spot left_prev, left nodes)\\n        left_prev = dummy_head\\n        left = dummy_head.next\\n        left_count = 1  # we start with 1 because we have to stop previous to left (because dummy head added)\\n        while left_count < l:\\n            left_prev = left\\n            left = left.next\\n            left_count += 1\\n\\n        # 2nd while loop (spot the right, right_next nodes)\\n        right = left\\n        right_next = left.next\\n        right_count = 0\\n        while right_count < r - l:\\n            right = right_next\\n            right_next = right_next.next\\n            right_count += 1\\n\\n        # 3rd while loop (reverse element between left and right node)\\n        cur = left\\n        pre = None\\n        while cur != right_next:\\n            tmp = cur.next\\n            cur.next = pre\\n            pre = cur\\n            cur = tmp\\n        \\n        # 4th fix breakage link\\n        left_prev.next = right\\n        left.next = right_next\\n\\n        head = dummy_head.next\\n        del dummy_head\\n        return head\\n```\\n# Java\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode leftPrev = dummyHead;\\n        ListNode left = dummyHead.next;\\n        int leftCount = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (leftCount < l) {\\n            leftPrev = left;\\n            left = left.next;\\n            leftCount++;\\n        }\\n\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode right = left;\\n        ListNode rightNext = left.next;\\n        int rightCount = 0;\\n        while (rightCount < r - l) {\\n            right = rightNext;\\n            rightNext = rightNext.next;\\n            rightCount++;\\n        }\\n\\n        // 3rd while loop (reverse elements between left and right node)\\n        ListNode cur = left;\\n        ListNode pre = null;\\n        while (cur != rightNext) {\\n            ListNode tmp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n\\n        // 4th fix breakage link\\n        leftPrev.next = right;\\n        left.next = rightNext;\\n\\n        head = dummyHead.next;\\n        // remove(dummyHead);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```[1,2,3,4,5]```\n```2```\n```4```\n```[1,4,3,2,5]```\n```r```\n```l```\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode* dummy_head = new ListNode(-1);\\n        dummy_head->next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode* left_prev = dummy_head;\\n        ListNode* left = dummy_head->next;\\n        int left_count = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (left_count < l) {\\n            left_prev = left;\\n            left = left->next;\\n            left_count++;\\n        }\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode* right = left;\\n        ListNode* right_next = left->next;\\n        int right_count = 0;\\n        while (right_count < r - l) {\\n            right = right_next;\\n            right_next = right_next->next;\\n            right_count++;\\n        }\\n        // 3rd while loop (reverse element between left and right node)\\n        ListNode* cur = left;\\n        ListNode* pre = nullptr;\\n        while (cur != right_next) {\\n            ListNode* tmp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n        // 4th fix breakage link\\n        left_prev->next = right;\\n        left->next = right_next;\\n\\n        head = dummy_head->next;\\n        delete dummy_head;\\n        return head;\\n    }\\n};\\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], l: int, r: int) -> Optional[ListNode]:\\n        \\n        # Dummy head insertion\\n        dummy_head = ListNode(None)\\n        dummy_head.next = head\\n\\n        # 1st while loop (spot left_prev, left nodes)\\n        left_prev = dummy_head\\n        left = dummy_head.next\\n        left_count = 1  # we start with 1 because we have to stop previous to left (because dummy head added)\\n        while left_count < l:\\n            left_prev = left\\n            left = left.next\\n            left_count += 1\\n\\n        # 2nd while loop (spot the right, right_next nodes)\\n        right = left\\n        right_next = left.next\\n        right_count = 0\\n        while right_count < r - l:\\n            right = right_next\\n            right_next = right_next.next\\n            right_count += 1\\n\\n        # 3rd while loop (reverse element between left and right node)\\n        cur = left\\n        pre = None\\n        while cur != right_next:\\n            tmp = cur.next\\n            cur.next = pre\\n            pre = cur\\n            cur = tmp\\n        \\n        # 4th fix breakage link\\n        left_prev.next = right\\n        left.next = right_next\\n\\n        head = dummy_head.next\\n        del dummy_head\\n        return head\\n```\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode leftPrev = dummyHead;\\n        ListNode left = dummyHead.next;\\n        int leftCount = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (leftCount < l) {\\n            leftPrev = left;\\n            left = left.next;\\n            leftCount++;\\n        }\\n\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode right = left;\\n        ListNode rightNext = left.next;\\n        int rightCount = 0;\\n        while (rightCount < r - l) {\\n            right = rightNext;\\n            rightNext = rightNext.next;\\n            rightCount++;\\n        }\\n\\n        // 3rd while loop (reverse elements between left and right node)\\n        ListNode cur = left;\\n        ListNode pre = null;\\n        while (cur != rightNext) {\\n            ListNode tmp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n\\n        // 4th fix breakage link\\n        leftPrev.next = right;\\n        left.next = rightNext;\\n\\n        head = dummyHead.next;\\n        // remove(dummyHead);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012232,
                "title": "making-the-linked-list-isolated-easy-approach-o-n-complexity-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is same as the [**Reversal Of Linked List**](https://leetcode.com/problems/reverse-linked-list). But , the problem asked for reversal of specific part of the linked list to get reversed.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe mail approach is to make the the part of the linked list that is need to be reversed **isolated** from the *original linked list* and after the reversal make the original linked list connected with the reversed linked list.\\n\\n---\\n\\n# Steps Involved\\n- Traverse the linked list so that left2 represents the starting node of the list to be reversed and left1 represents the node before the left2.\\n ```\\nwhile(left-->1){\\n    left1=left2;\\n    left2=left2.next;\\n}\\n```\\n\\n- Traverse the linked list such that, right2 represents the end node of the list to be reversed. right1 represents the immediate node after right1.\\n```\\nwhile(right-->=1){\\n    right2=right1;\\n    right1=right1.next;\\n}\\n```\\n- Isolating the Linked list that is to be reversed.\\n```\\nif (l!=1)\\n    left1.next=null;    \\nright2.next=null;\\n```\\n\\n- The intention of making the condition l!=1 is that, if the given left most node is head , it is important to have it remebered. otherwise the traversal for the linked list will not get the head node.\\nTry it by removing the condition if you wanna see what happens \\uD83D\\uDE0A.\\n\\n- The Next part of code is for reversal of the isolated linked list.\\n```\\nListNode prev=null,next=null,curr=left2;\\n\\nwhile(curr!=null){\\n    next=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=next;\\n}\\n```\\n- Here comes the part where we will make the isolated reversed linked list connected with the original linked list.\\n\\n```\\nif (l==1){\\n    head.next=right1;\\n    return prev;\\n}        \\nleft1.next=prev;\\nleft2.next=right1;\\n```\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode left2=head,left1=head,right1=head,right2=head;\\n        int l=left;\\n        \\n        if (head==null)\\n            return null;\\n        if (head.next==null)\\n            return head;\\n\\n        \\n        while(left-->1){\\n            left1=left2;\\n            left2=left2.next;\\n        }\\n\\n        while(right-->=1){\\n            right2=right1;\\n            right1=right1.next;\\n        }\\n        \\n        if (l!=1)\\n            left1.next=null;\\n        \\n        right2.next=null;\\n        \\n        ListNode prev=null,next=null,curr=left2;\\n\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        if (l==1){\\n            head.next=right1;\\n            return prev;\\n        }\\n        \\n        left1.next=prev;\\n        left2.next=right1;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwhile(left-->1){\\n    left1=left2;\\n    left2=left2.next;\\n}\\n```\n```\\nwhile(right-->=1){\\n    right2=right1;\\n    right1=right1.next;\\n}\\n```\n```\\nif (l!=1)\\n    left1.next=null;    \\nright2.next=null;\\n```\n```\\nListNode prev=null,next=null,curr=left2;\\n\\nwhile(curr!=null){\\n    next=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=next;\\n}\\n```\n```\\nif (l==1){\\n    head.next=right1;\\n    return prev;\\n}        \\nleft1.next=prev;\\nleft2.next=right1;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode left2=head,left1=head,right1=head,right2=head;\\n        int l=left;\\n        \\n        if (head==null)\\n            return null;\\n        if (head.next==null)\\n            return head;\\n\\n        \\n        while(left-->1){\\n            left1=left2;\\n            left2=left2.next;\\n        }\\n\\n        while(right-->=1){\\n            right2=right1;\\n            right1=right1.next;\\n        }\\n        \\n        if (l!=1)\\n            left1.next=null;\\n        \\n        right2.next=null;\\n        \\n        ListNode prev=null,next=null,curr=left2;\\n\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        if (l==1){\\n            head.next=right1;\\n            return prev;\\n        }\\n        \\n        left1.next=prev;\\n        left2.next=right1;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011933,
                "title": "c-optimal-solution-explained",
                "content": "# Intuition: Just reverse nodes inbetween L and R\\n\\n# Approach:\\n\\n**Step 1: Insert a Dummy Node**\\n- This will help us solve edge cases where the reversal starts from the head (node 1) of the list\\n- Without this, we will not have a previous node to act as our previous left node for future linking\\n- See code below for this insertion:\\n```\\n    ListNode* dummy = new ListNode(0,head);\\n    head = dummy;\\n```\\n\\n**Step 2: Find our Left Node and the Node before Left**\\n- As we can see below in the example, the left node (2) and left previous (1) play pivotal roles in solving the questions\\n- The left node is the start of the reverse part\\n- The node before the left is important as its next pointer needs to eventually be updated to the right node in the list\\n- See Example (note the dummy node is not included in diagram):\\n![IMG_0712.jpeg](https://assets.leetcode.com/users/images/1270f88d-57c7-413c-a5de-dc8d075c350c_1694047969.3313951.jpeg)\\n\\nThe following code will do this\\n```\\n // Step 2: Find l_prev and l\\n ListNode* curr = head->next; // original head\\nListNode* prev = dummy;\\n\\nfor(int i = 0; i < left - 1; i++) {\\n    prev = curr;\\n    curr = curr->next;\\n}\\n\\n```\\nNote: L - 1 iterations will ALWAYS reult in curr at the left node\\n\\n**Step 3: Reverse from L to R**\\n- to do this we will create a list that will result in this. \\n- Notice the previous pointer is left at the right node of the reversal, and curr is the right->next node\\n\\n![IMG_0715.jpeg](https://assets.leetcode.com/users/images/eddf30ad-3bb3-4281-be92-9d282881595a_1694048550.1179438.jpeg)\\n- See the code for this below:\\n```\\n// Step 3: Revere from L to r\\nListNode* left_prev = prev;\\nprev = nullptr;\\n\\nfor(int i = 0; i < right - left + 1; i++) {\\n    ListNode* temp = curr->next;\\n    curr->next = prev;\\n    prev = curr;\\n    curr = temp;\\n}\\n```\\n\\n**Step 4: Rerrange Pointers**\\n- In the above diagram we can see a couple of the next pointers that are not quite correct yet.\\n- The first is the original left node. It currently points to a nullptr. However in the example provided, we want this to point to the right->next node, which in the example is node 5. In the diagram above we can see the curr pointer is there after reversing the nodes. therefore we can directly set this next pointer. The next code snippet does this by making use of the left_prev->left connection\\n```\\nleft_prev->next->next = curr;\\n```\\n- The next pointer that is not correct is the left_prev->next pointer. It still points to the original left node (2). It is supposed to be pointing to the right node (4). In the diagram above we can see after the reverse iterations the prev pointer is positioned at the right node. Thefore we can directly update this connection\\n```\\n    left_prev->next = prev;\\n```\\n\\nwe can finally return dummy->next to return the next head of the rearrganged linked list.\\n\\n# Complexity\\n**Time complexity: O(n)**\\n- We only traverse through the linked list\\n\\n**Space complexity: O(1)**\\n- Only a constant amount of variables are used in this soloution\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head) return nullptr;\\n\\n        // Step 1: Add dummy node to front of LL\\n        ListNode* dummy = new ListNode(0,head);\\n        head = dummy;\\n\\n        // Step 2: Find l_prev and l\\n        ListNode* curr = head->next; // original head\\n        ListNode* prev = dummy;\\n\\n        for(int i = 0; i < left - 1; i++) {\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        // Step 3: Revere from L to r\\n        ListNode* left_prev = prev;\\n        prev = nullptr;\\n\\n        for(int i = 0; i < right - left + 1; i++) {\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n\\n        // Step 4: Rearrange pointers\\n        left_prev->next->next = curr;\\n        left_prev->next = prev;\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    ListNode* dummy = new ListNode(0,head);\\n    head = dummy;\\n```\n```\\n // Step 2: Find l_prev and l\\n ListNode* curr = head->next; // original head\\nListNode* prev = dummy;\\n\\nfor(int i = 0; i < left - 1; i++) {\\n    prev = curr;\\n    curr = curr->next;\\n}\\n\\n```\n```\\n// Step 3: Revere from L to r\\nListNode* left_prev = prev;\\nprev = nullptr;\\n\\nfor(int i = 0; i < right - left + 1; i++) {\\n    ListNode* temp = curr->next;\\n    curr->next = prev;\\n    prev = curr;\\n    curr = temp;\\n}\\n```\n```\\nleft_prev->next->next = curr;\\n```\n```\\n    left_prev->next = prev;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head) return nullptr;\\n\\n        // Step 1: Add dummy node to front of LL\\n        ListNode* dummy = new ListNode(0,head);\\n        head = dummy;\\n\\n        // Step 2: Find l_prev and l\\n        ListNode* curr = head->next; // original head\\n        ListNode* prev = dummy;\\n\\n        for(int i = 0; i < left - 1; i++) {\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        // Step 3: Revere from L to r\\n        ListNode* left_prev = prev;\\n        prev = nullptr;\\n\\n        for(int i = 0; i < right - left + 1; i++) {\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n\\n        // Step 4: Rearrange pointers\\n        left_prev->next->next = curr;\\n        left_prev->next = prev;\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773055,
                "title": "java-solution-explained-with-diagram-good-as-well-as-important-question",
                "content": "![image.png](https://assets.leetcode.com/users/images/463f4099-7ac8-4be9-a958-413a293f1722_1689502227.159058.png)\\n![image.png](https://assets.leetcode.com/users/images/86b9e30b-45cc-4e4f-9d97-0b29d0961779_1689502491.443635.png)\\n![image.png](https://assets.leetcode.com/users/images/8faa3fcc-168e-490b-aa43-0f5e824e15df_1689502611.894665.png)\\n\\nThis list is returned from the reverse function ;\\n\\n![image.png](https://assets.leetcode.com/users/images/8129bfee-56db-45a0-bcfc-1b593c2d9fde_1689502809.16709.png)\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        //first we handle the edge cases ;\\n        if(head==null||head.next==null){\\n            return head ;\\n        }\\n        //then e make a dummy node iterator and deveral different nodes like l,r and int x ;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode i = dummy ; int x = 0 ;\\n        ListNode l=null;ListNode r = null;ListNode temp = null;\\n\\n        //then we iterate i till i reaches null ;\\n        while(i!=null){\\n            //if i reaches 1 previous node to left index ; we put l node at that place;\\n            if(x==left-1){\\n                l = i;\\n            }if(x==right){\\n                //and it i reaches the right index we put r at that place ;\\n                r = i;\\n            }\\n            //then we move both pointer and iterator;\\n            i=i.next;x++;\\n        }\\n        \\n        //then what we have to do is make the next of r node to be null and move r by 1;\\n        if(r.next!=null){\\n            temp = r.next;\\n        }\\n\\n        r.next=null;\\n        r=temp;\\n\\n        //then we reverse the list; from l.next to null as we ahve seperated the list\\n        //that we have to revese;\\n        ListNode next = reverse(l.next,r);\\n        l.next=next;//here we just link the reverse list to l.next;\\n\\n        return dummy.next;\\n    }\\n    public ListNode reverse(ListNode l , ListNode r){\\n        //in this function i have to reverse the l lnked list and connect it to r;\\n        //this is a little bit tricky as i have both r and l in the function\\'s parameter\\n        //as you know when we reverse a linked list we make a dummt null and link it to the head of \\n        //linked list and then reverse all the links of the list ; here in the place of null\\n        // we are just joining it to the next part of our question\\'s linked list \\n        ListNode i = l ;\\n\\n        //this is simple reversing function ;\\n        while(i!=null){\\n            ListNode temp = i.next;\\n            i.next = r;\\n            r=i;\\n            i=temp;\\n        }\\n        return r;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        //first we handle the edge cases ;\\n        if(head==null||head.next==null){\\n            return head ;\\n        }\\n        //then e make a dummy node iterator and deveral different nodes like l,r and int x ;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode i = dummy ; int x = 0 ;\\n        ListNode l=null;ListNode r = null;ListNode temp = null;\\n\\n        //then we iterate i till i reaches null ;\\n        while(i!=null){\\n            //if i reaches 1 previous node to left index ; we put l node at that place;\\n            if(x==left-1){\\n                l = i;\\n            }if(x==right){\\n                //and it i reaches the right index we put r at that place ;\\n                r = i;\\n            }\\n            //then we move both pointer and iterator;\\n            i=i.next;x++;\\n        }\\n        \\n        //then what we have to do is make the next of r node to be null and move r by 1;\\n        if(r.next!=null){\\n            temp = r.next;\\n        }\\n\\n        r.next=null;\\n        r=temp;\\n\\n        //then we reverse the list; from l.next to null as we ahve seperated the list\\n        //that we have to revese;\\n        ListNode next = reverse(l.next,r);\\n        l.next=next;//here we just link the reverse list to l.next;\\n\\n        return dummy.next;\\n    }\\n    public ListNode reverse(ListNode l , ListNode r){\\n        //in this function i have to reverse the l lnked list and connect it to r;\\n        //this is a little bit tricky as i have both r and l in the function\\'s parameter\\n        //as you know when we reverse a linked list we make a dummt null and link it to the head of \\n        //linked list and then reverse all the links of the list ; here in the place of null\\n        // we are just joining it to the next part of our question\\'s linked list \\n        ListNode i = l ;\\n\\n        //this is simple reversing function ;\\n        while(i!=null){\\n            ListNode temp = i.next;\\n            i.next = r;\\n            r=i;\\n            i=temp;\\n        }\\n        return r;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768814,
                "title": "easy-java-solution-easy-to-understand-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(left == right) {\\n            return head;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        for(int i = 1; curr != null && i < left; i++) {\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode temp = prev;\\n        ListNode temp1 = curr;\\n        ListNode forw = null;\\n\\n        for(int i = left; i <=  right; i++) {\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n\\n        if(temp != null) {\\n            temp.next = prev;\\n        }\\n        else {\\n        head = prev;\\n        }\\n\\n        temp1.next = curr;\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/90e24a6e-1b48-458f-ae07-8180ee271778_1689426592.0713346.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(left == right) {\\n            return head;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        for(int i = 1; curr != null && i < left; i++) {\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode temp = prev;\\n        ListNode temp1 = curr;\\n        ListNode forw = null;\\n\\n        for(int i = left; i <=  right; i++) {\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n\\n        if(temp != null) {\\n            temp.next = prev;\\n        }\\n        else {\\n        head = prev;\\n        }\\n\\n        temp1.next = curr;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609243,
                "title": "easy-to-understand-c-solution-using-vectors",
                "content": "# Intuition\\n<!-- DeI scribe your first thoughts on how to solve this problem. -->\\nI need to swap left and right indices and keep on doing it until they both collide \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCopy all the values in vector , swap left and right and keep on doing it until left!=right\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int> buff;\\n        ListNode *p = head;\\n        int i = 0;\\n        \\n        while (p != nullptr) {\\n            buff.push_back(p->val);\\n            p = p->next;\\n            i++;\\n        }\\n        \\n        while (left < right) {\\n            swap(buff[left - 1], buff[right - 1]);\\n            left++;\\n            right--;\\n        }\\n        \\n        ListNode* newHead = new ListNode(buff[0]);\\n        ListNode* current = newHead;\\n        \\n        for (int i = 1; i < buff.size(); i++) {\\n            ListNode* newNode = new ListNode(buff[i]);\\n            current->next = newNode;\\n            current = newNode;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int> buff;\\n        ListNode *p = head;\\n        int i = 0;\\n        \\n        while (p != nullptr) {\\n            buff.push_back(p->val);\\n            p = p->next;\\n            i++;\\n        }\\n        \\n        while (left < right) {\\n            swap(buff[left - 1], buff[right - 1]);\\n            left++;\\n            right--;\\n        }\\n        \\n        ListNode* newHead = new ListNode(buff[0]);\\n        ListNode* current = newHead;\\n        \\n        for (int i = 1; i < buff.size(); i++) {\\n            ListNode* newNode = new ListNode(buff[i]);\\n            current->next = newNode;\\n            current = newNode;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149900,
                "title": "easy-solution-o-n",
                "content": "# Code\\n    C++ easy solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right)\\n    {\\n        if(head==NULL || head->next==NULL) return head;    //if list contain only single node or no node\\n        ListNode *h1=head;\\n        ListNode *x = head;\\n        ListNode *x1=head,*x2=head;\\n        int n = 0;\\n        while(x!=NULL) {\\n            n++;\\n            x=x->next;\\n        }\\n        if(left==n) return head;   //if left position is equal to size \\n        int i=1;\\n        while(i<left) {      //assining left position\\n            x1 = h1;\\n            h1=h1->next;\\n            i++;\\n        }\\n        ListNode *t1=head;\\n        if(right<n) {        //assigning right position\\n            i=1;\\n            while(i<right){\\n                t1=t1->next;\\n                i++;\\n            }\\n            x2=t1->next;\\n            t1->next=NULL;\\n        }\\n        ListNode *t = NULL, *p=NULL;\\n        ListNode *temp = h1;\\n        while(h1!=NULL)       //reversing from left positin to right position\\n        {\\n            t=h1->next;\\n            h1->next=p;\\n            p=h1;\\n            h1=t;\\n        }\\n        h1=p;\\n        while(p->next != NULL)\\n            p=p->next;\\n        if(left!=1)\\n        {\\n            x1->next=h1;\\n            if(right != n)\\n                temp->next = x2;\\n            return head;\\n        }\\n        if(right != n)\\n                temp->next = x2;\\n        return h1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right)\\n    {\\n        if(head==NULL || head->next==NULL) return head;    //if list contain only single node or no node\\n        ListNode *h1=head;\\n        ListNode *x = head;\\n        ListNode *x1=head,*x2=head;\\n        int n = 0;\\n        while(x!=NULL) {\\n            n++;\\n            x=x->next;\\n        }\\n        if(left==n) return head;   //if left position is equal to size \\n        int i=1;\\n        while(i<left) {      //assining left position\\n            x1 = h1;\\n            h1=h1->next;\\n            i++;\\n        }\\n        ListNode *t1=head;\\n        if(right<n) {        //assigning right position\\n            i=1;\\n            while(i<right){\\n                t1=t1->next;\\n                i++;\\n            }\\n            x2=t1->next;\\n            t1->next=NULL;\\n        }\\n        ListNode *t = NULL, *p=NULL;\\n        ListNode *temp = h1;\\n        while(h1!=NULL)       //reversing from left positin to right position\\n        {\\n            t=h1->next;\\n            h1->next=p;\\n            p=h1;\\n            h1=t;\\n        }\\n        h1=p;\\n        while(p->next != NULL)\\n            p=p->next;\\n        if(left!=1)\\n        {\\n            x1->next=h1;\\n            if(right != n)\\n                temp->next = x2;\\n            return head;\\n        }\\n        if(right != n)\\n                temp->next = x2;\\n        return h1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095221,
                "title": "easy-solution-pointers-and-counter-easy-understanding-very-fast",
                "content": "# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1) => because it\\'s just a static pointers and we are changing their refrences \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    let currNode = head, start = head, counter = 1;\\n    while(counter < left) {\\n        start = currNode; \\n        currNode = currNode.next;\\n        counter++;\\n    }\\n    let tail = currNode, prev = null;\\n    while(counter >=  left && counter <= right){\\n        const next = currNode.next;\\n        currNode.next = prev;\\n        prev = currNode;\\n        currNode = next;\\n        counter++;\\n    }\\n    start.next = prev;\\n    tail.next = currNode;\\n    if(left > 1){\\n        return head;\\n    }else{\\n        return prev\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Linked List",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    let currNode = head, start = head, counter = 1;\\n    while(counter < left) {\\n        start = currNode; \\n        currNode = currNode.next;\\n        counter++;\\n    }\\n    let tail = currNode, prev = null;\\n    while(counter >=  left && counter <= right){\\n        const next = currNode.next;\\n        currNode.next = prev;\\n        prev = currNode;\\n        currNode = next;\\n        counter++;\\n    }\\n    start.next = prev;\\n    tail.next = currNode;\\n    if(left > 1){\\n        return head;\\n    }else{\\n        return prev\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3045252,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* pre = dummy;\\n        for(int i = 0; i < m-1; i++)\\n            pre = pre->next;\\n        ListNode* cur=pre->next;\\n        ListNode* curR = cur;\\n        ListNode* pre_R = pre;\\n        //reverse \\n        for(int i = m; i <= n; i++){\\n            ListNode* next = curR->next;\\n            curR->next = pre_R;\\n            pre_R = curR;\\n            curR = next;\\n        }\\n        \\n        //connect\\n        pre->next = pre_R;\\n        cur->next = curR;\\n\\t\\t\\n        return dummy->next;    \\n\\t}\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* pre = dummy;\\n        for(int i = 0; i < m-1; i++)\\n            pre = pre->next;\\n        ListNode* cur=pre->next;\\n        ListNode* curR = cur;\\n        ListNode* pre_R = pre;\\n        //reverse \\n        for(int i = m; i <= n; i++){\\n            ListNode* next = curR->next;\\n            curR->next = pre_R;\\n            pre_R = curR;\\n            curR = next;\\n        }\\n        \\n        //connect\\n        pre->next = pre_R;\\n        cur->next = curR;\\n\\t\\t\\n        return dummy->next;    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698062,
                "title": "easy-solution-diagrams-approach",
                "content": "**Python**\\n\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\\n\\n\\n**JAVA**\\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        //first part\\n        ListNode cur1 = dummy;\\n        ListNode pre1 = null;\\n        for(int i=0;i<m;i++){\\n            pre1 = cur1;\\n            cur1 = cur1.next;\\n        }\\n        \\n        //reverse\\n        ListNode cur2 = cur1;\\n        ListNode pre2 = pre1;\\n        ListNode q2;\\n        for(int i=m;i<=n;i++){\\n            q2 = cur2.next;\\n            cur2.next = pre2;\\n            pre2 = cur2;\\n            cur2 = q2;\\n        }\\n        \\n        //connect \\n        pre1.next = pre2;\\n        cur1.next = cur2;\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n# *DIAGRAMS*\\n\\nhttps://assets.leetcode.com/users/images/286faf1c-7e7b-44a8-ab21-093645471823_1665657107.7047188.png\\n\\n![image](https://assets.leetcode.com/users/images/589ce713-275e-4604-be95-b262dbfb9256_1665657060.8020976.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/8bcfc04c-fcf6-46e0-ad60-c491c8dfb8c7_1665657076.5328043.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/0453d446-ec80-4448-b417-b37203f973ce_1665657093.2993279.png)\\n\\n\\n**The backtracking process. We don\\'t recurse further. The operation performed during the backtracking is swapping of data between the left and right nodes.**\\n\\n![image](https://assets.leetcode.com/users/images/286faf1c-7e7b-44a8-ab21-093645471823_1665657107.7047188.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        //first part\\n        ListNode cur1 = dummy;\\n        ListNode pre1 = null;\\n        for(int i=0;i<m;i++){\\n            pre1 = cur1;\\n            cur1 = cur1.next;\\n        }\\n        \\n        //reverse\\n        ListNode cur2 = cur1;\\n        ListNode pre2 = pre1;\\n        ListNode q2;\\n        for(int i=m;i<=n;i++){\\n            q2 = cur2.next;\\n            cur2.next = pre2;\\n            pre2 = cur2;\\n            cur2 = q2;\\n        }\\n        \\n        //connect \\n        pre1.next = pre2;\\n        cur1.next = cur2;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311349,
                "title": "easy-to-understand-c-solution-with-explanation",
                "content": "I\\'ll try to explain in simple words.\\n\\n1. Take a TempPrev variable to store, such that from left = TempPrev + 1, So we can connect the reversed sub-linkedlist to it.\\n2. Next we Store the curr_p = right + 1.\\nSo that we can connect the remaining one to the right side.\\n3. Reverse the linkedlist in regular fashion.\\n4. Connect the parts.\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode * start = head;\\n        ListNode * tempPrev = new ListNode(0,head); // Will be at left - 1\\n        int cnt = 1;\\n        while(cnt < left)\\n            cnt++,tempPrev = tempPrev->next,head=head->next;\\n        ListNode * temp = head;\\n        ListNode * prev_p = NULL;\\n        ListNode * curr_p = head;\\n        ListNode * next_p;\\n        \\n        while(cnt <= right){\\n            next_p = curr_p -> next;\\n            curr_p -> next = prev_p;\\n            \\n            prev_p = curr_p;\\n            curr_p = next_p;\\n            cnt++;\\n        }\\n        head = prev_p;\\n        tempPrev->next = head;\\n        temp->next = curr_p;\\n        if(left == 1) // Starting point will change\\n            return head;\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode * start = head;\\n        ListNode * tempPrev = new ListNode(0,head); // Will be at left - 1\\n        int cnt = 1;\\n        while(cnt < left)\\n            cnt++,tempPrev = tempPrev->next,head=head->next;\\n        ListNode * temp = head;\\n        ListNode * prev_p = NULL;\\n        ListNode * curr_p = head;\\n        ListNode * next_p;\\n        \\n        while(cnt <= right){\\n            next_p = curr_p -> next;\\n            curr_p -> next = prev_p;\\n            \\n            prev_p = curr_p;\\n            curr_p = next_p;\\n            cnt++;\\n        }\\n        head = prev_p;\\n        tempPrev->next = head;\\n        temp->next = curr_p;\\n        if(left == 1) // Starting point will change\\n            return head;\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310666,
                "title": "daily-leetcoding-challenge-july-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-linked-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterative Link Reversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-linked-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2254933,
                "title": "java-100-faster-0-ms-time-complexity-o-n-space-complexity-o-1",
                "content": "To solve the quesrion you have to add the sentinal node so that edge case of head node will become the intermidiate node and make problem easy to solve.\\n```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode sentinalNode = new ListNode(0,head);\\n        var temp = sentinalNode;\\n        \\n        for(int i = 0;i<left-1;i++){\\n            temp = temp.next;\\n        }\\n        var start = temp.next;\\n        for(int i = 0 ;start!=null && start.next!=null && i < right - left;i++){\\n            var next = start.next;\\n            start.next = start.next.next;\\n            next.next = temp.next;\\n            temp.next = next; \\n        }\\n        return sentinalNode.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode sentinalNode = new ListNode(0,head);\\n        var temp = sentinalNode;\\n        \\n        for(int i = 0;i<left-1;i++){\\n            temp = temp.next;\\n        }\\n        var start = temp.next;\\n        for(int i = 0 ;start!=null && start.next!=null && i < right - left;i++){\\n            var next = start.next;\\n            start.next = start.next.next;\\n            next.next = temp.next;\\n            temp.next = next; \\n        }\\n        return sentinalNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523758,
                "title": "amazing-approach-to-solve-in-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head || left==right) return head;\\n        ListNode dummy(0);\\n        dummy.next=head;\\n        ListNode* nodebeforesublist=&dummy;\\n        int pos=1;\\n        while(pos<left){\\n            nodebeforesublist=nodebeforesublist->next;\\n            pos++;\\n        }\\n        ListNode* workingptr=nodebeforesublist->next;\\n        while(left<right){\\n            ListNode* nodetobeextracted=workingptr->next;\\n            workingptr->next=nodetobeextracted->next;\\n            \\n            nodetobeextracted->next=nodebeforesublist->next;\\n            nodebeforesublist->next=nodetobeextracted;\\n            left++;\\n        }\\n        return dummy.next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head || left==right) return head;\\n        ListNode dummy(0);\\n        dummy.next=head;\\n        ListNode* nodebeforesublist=&dummy;\\n        int pos=1;\\n        while(pos<left){\\n            nodebeforesublist=nodebeforesublist->next;\\n            pos++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1427894,
                "title": "sharing-simplest-c-solution-beats-100",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right || head==NULL || left==right ) return head;      // Base Condition\\n        \\n        ListNode* dummy=new ListNode(0);                //Dummy Node\\n        ListNode *curr=head,*prev=dummy,*nxt=NULL;\\n        dummy->next=head;\\n        \\n        for(int i=1;i<left; i++)                                        //Make left position node as curr\\n              {    prev=curr;                                              //Store previous element of left node in prev\\n\\t\\t\\t       curr=curr->next;\\n              }\\n        ListNode *first=curr,*temp=prev;                   //store current in first because its the element at left pos\\n        for(int i=1;i<=(right-left)+1;i++)                    //store previous element of first in temp,because here we modify prev element\\n            {  nxt=curr->next;                                     \\n              curr->next=prev;\\n              prev=curr;\\n             curr=nxt;\\n        }                                // Here prev return newhead of reversed linkedlist\\n        \\n        temp->next=prev;   \\n        first->next=curr;\\n        return dummy->next;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right || head==NULL || left==right ) return head;      // Base Condition\\n        \\n        ListNode* dummy=new ListNode(0);                //Dummy Node\\n        ListNode *curr=head,*prev=dummy,*nxt=NULL;\\n        dummy->next=head;\\n        \\n        for(int i=1;i<left; i++)                                        //Make left position node as curr\\n              {    prev=curr;                                              //Store previous element of left node in prev\\n\\t\\t\\t       curr=curr->next;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1292564,
                "title": "reverse-linked-list-ii-java-iterative-approach-with-one-pass-o-n-solution",
                "content": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n\\n        // In case of empty list return null\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        int count = 1;\\n\\n        // Move curr and prev until they reach proper starting point in the list\\n        ListNode curr = head;\\n\\n        ListNode prev = null;\\n\\n        while (curr != null && count < left) {\\n            prev = curr;\\n            curr = curr.next;\\n            count++;\\n        }\\n\\n        // A node before the subList\\'s node\\n        ListNode beforeNode = prev;\\n\\n        // Sublist\\'s first node\\n        ListNode subHead = curr;\\n\\n        ListNode next;\\n\\n        // Reverse the sublist\\n        while (curr != null && count <= right) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Fix the connections\\n        if (beforeNode != null) {\\n            beforeNode.next = prev;\\n        } else {\\n            head = prev;\\n        }\\n\\n        subHead.next = curr;\\n\\n        return head;\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n\\n        // In case of empty list return null\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        int count = 1;\\n\\n        // Move curr and prev until they reach proper starting point in the list\\n        ListNode curr = head;\\n\\n        ListNode prev = null;\\n\\n        while (curr != null && count < left) {\\n            prev = curr;\\n            curr = curr.next;\\n            count++;\\n        }\\n\\n        // A node before the subList\\'s node\\n        ListNode beforeNode = prev;\\n\\n        // Sublist\\'s first node\\n        ListNode subHead = curr;\\n\\n        ListNode next;\\n\\n        // Reverse the sublist\\n        while (curr != null && count <= right) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Fix the connections\\n        if (beforeNode != null) {\\n            beforeNode.next = prev;\\n        } else {\\n            head = prev;\\n        }\\n\\n        subHead.next = curr;\\n\\n        return head;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1291790,
                "title": "c-reverse-linked-list-ii-one-pass-solution",
                "content": "So reversing a part of a linked list is very similar to reversing the whole list, but we just have to handle the elements at the boundary of the reverse sublist, i.e the element before left and the element after right (let\\'s assume that the first one is start and the second one is end).\\n\\nWe use the usual three pointer approach to reversing the linked list, this time just limiting the number of iterations so that we end up with c = end (i.e the element after right). \\nThen we put b->next = a, but don\\'t increment the pointers, since this is the last step of the reversing operation. Now the start of the sublist is pointed to by b and let\\'s say we have a reference to both the start pointer (as mentioned above) and the actual starting point of the sublist (i.e left). \\nThen to make the list consistent again, but with reversed order, we assign `start->next = b` and `left->next = c`. \\n\\nBut now we will need to think about some edge cases.\\n\\n1. What if left == 1? \\n\\there our start pointer will be nullptr, so we have to handle that separately and c will become the new head, so we return that.\\n2. What if left == right?\\n\\there we don\\'t have to do anything, since the length of the reversed subarray is only 1 element, so we just return the list as it was.\\n3. What if the list has fewer than two elements?\\n\\tthen we handle that separately, checking if left == 1 and right == 2 and length == 2, then either just reversing the list, or returning the same list.\\n\\t\\nAfter incorporating the following checks into the code, here is the result:\\n```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\tListNode *a = nullptr, *b = head, *c = head->next;\\n\\tif(!b || !c) return head;\\n\\tif(left == right) return head;\\n\\tfor(int i = 0; i<left-1; i++) {\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tListNode *start = a;\\n\\tListNode *rev_start = b;\\n\\ta = b;\\n\\tb = c;\\n\\tc = c->next;\\n\\tfor(int i = left + 1; i<right; i++) {\\n\\t\\tb->next = a;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tb->next = a;\\n\\trev_start->next = c;\\n\\tif(left == 1) {\\n\\t\\treturn b;\\n\\t}\\n\\tstart->next = b;\\n\\treturn head;\\n}\\n```\\n\\n**Time: O(n)**, its just a single pass of the list, (not even a full single pass)\\n**Space: O(1)**, just a bunch of pointers.\\n\\n<br/>\\n\\nFeel free to ask any doubts, or suggest any corrections/improvements in the comments, and please upvote this post if you liked it.\\n**Note:** I just noticed that I didn\\'t incorporate the last check (that for fewer than 2 elements) quite correctly. I forgot to account for the case where there are only two elements and left == 1 and right == 2. So please be sure to incorporate that. But anyways, it passed without that as well :P.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\tListNode *a = nullptr, *b = head, *c = head->next;\\n\\tif(!b || !c) return head;\\n\\tif(left == right) return head;\\n\\tfor(int i = 0; i<left-1; i++) {\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tListNode *start = a;\\n\\tListNode *rev_start = b;\\n\\ta = b;\\n\\tb = c;\\n\\tc = c->next;\\n\\tfor(int i = left + 1; i<right; i++) {\\n\\t\\tb->next = a;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tb->next = a;\\n\\trev_start->next = c;\\n\\tif(left == 1) {\\n\\t\\treturn b;\\n\\t}\\n\\tstart->next = b;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831030,
                "title": "c-easiest-sol-so-far-using-vector-beats-65-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head==NULL)\\n            return NULL;\\n        vector<int>v;\\n        ListNode *p=head;\\n        while(p!=NULL)\\n        {\\n            v.push_back(p->val);\\n            p=p->next;\\n        }\\n        p=head;\\n        for(int i=0;i<m-1;i++) //till m-1 values will remain same as in the list..\\n            p=p->next;\\n        for(int i=n;i>=m;i--)\\n        {\\n            p->val=v[i-1];    //reverse the value within range..\\n            p=p->next;\\n        }\\n        return head;",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head==NULL)\\n            return NULL;\\n        vector<int>v;\\n        ListNode *p=head;\\n        while(p!=NULL)\\n        {\\n            v.push_back(p->val);\\n            p=p->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 300120,
                "title": "java-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\n\\t// logic: keep swapping next elements and change the pointers accordingly\\n    private static LinkedListUtils.ListNode reverseBetween(LinkedListUtils.ListNode head, int m, int n) {\\n        if (head == null || head.next == null || m <= 0 || n <= 0) {\\n            return head;\\n        }\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode pre = dummyNode;\\n        ListNode start = head;\\n\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre.next;\\n            start = start.next;\\n        }\\n\\n        // flow of execution in each iteration (for the 2nd input): 1->2->3->4->5->6->7  |  1->2->4->3->5->6->7 | 1->2->5->4->3->6->7 | 1->2->6->5->4->3->7 | 1->2->7->6->5->4->3\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode current = start.next;\\n            start.next = current.next;\\n            current.next = pre.next;\\n            pre.next = current;\\n        }\\n        return dummyNode.next;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t// logic: keep swapping next elements and change the pointers accordingly\\n    private static LinkedListUtils.ListNode reverseBetween(LinkedListUtils.ListNode head, int m, int n) {\\n        if (head == null || head.next == null || m <= 0 || n <= 0) {\\n            return head;\\n        }\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode pre = dummyNode;\\n        ListNode start = head;\\n\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre.next;\\n            start = start.next;\\n        }\\n\\n        // flow of execution in each iteration (for the 2nd input): 1->2->3->4->5->6->7  |  1->2->4->3->5->6->7 | 1->2->5->4->3->6->7 | 1->2->6->5->4->3->7 | 1->2->7->6->5->4->3\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode current = start.next;\\n            start.next = current.next;\\n            current.next = pre.next;\\n            pre.next = current;\\n        }\\n        return dummyNode.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 259924,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n\\t  guard head != nil else { return nil }\\n\\t\\t\\n      let dm: ListNode? = ListNode(0)\\n      dm?.next = head\\n\\n      var before = dm\\n\\n      for _ in 0..<m-1 {\\n        before = before?.next\\n      }\\n\\n      let endOfReverse = before?.next\\n      var prev = before?.next\\n      var curr = prev?.next\\n\\n      for _ in 0..<n-m {\\n        let next = curr?.next\\n        curr?.next = prev\\n        prev = curr\\n        curr = next\\n      }\\n\\n      before?.next = prev\\n      endOfReverse?.next = curr\\n\\n      return dm?.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n\\t  guard head != nil else { return nil }\\n\\t\\t\\n      let dm: ListNode? = ListNode(0)\\n      dm?.next = head\\n\\n      var before = dm\\n\\n      for _ in 0..<m-1 {\\n        before = before?.next\\n      }\\n\\n      let endOfReverse = before?.next\\n      var prev = before?.next\\n      var curr = prev?.next\\n\\n      for _ in 0..<n-m {\\n        let next = curr?.next\\n        curr?.next = prev\\n        prev = curr\\n        curr = next\\n      }\\n\\n      before?.next = prev\\n      endOfReverse?.next = curr\\n\\n      return dm?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226518,
                "title": "concise-javascript",
                "content": "```javascript\\nvar reverseBetween = function(head, m, n) {\\n  let dummy = new ListNode(undefined);\\n  let sentinel = dummy;\\n  sentinel.next = head;\\n  \\n  for(let i = 1; i < m; i++) {\\n    sentinel = sentinel.next;\\n  }\\n  \\n  let curr = sentinel.next;\\n  let next = curr.next;\\n  \\n  for(let i = 0; i < n - m; i++) {\\n    curr.next = next.next;\\n    next.next = sentinel.next;\\n    sentinel.next = next;\\n    \\n    next = curr.next;\\n  }\\n  \\n  return dummy.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reverseBetween = function(head, m, n) {\\n  let dummy = new ListNode(undefined);\\n  let sentinel = dummy;\\n  sentinel.next = head;\\n  \\n  for(let i = 1; i < m; i++) {\\n    sentinel = sentinel.next;\\n  }\\n  \\n  let curr = sentinel.next;\\n  let next = curr.next;\\n  \\n  for(let i = 0; i < n - m; i++) {\\n    curr.next = next.next;\\n    next.next = sentinel.next;\\n    sentinel.next = next;\\n    \\n    next = curr.next;\\n  }\\n  \\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30770,
                "title": "clean-yet-efficient-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        ListNode newHead(0);\\n        newHead.next = head;\\n        ListNode *pre = &newHead, *cur = head, *next = NULL;\\n        int i = 1;\\n        while(i < n)\\n        {\\n            if(i++ < m) { pre = cur; cur = cur->next; }\\n            else\\n            { \\n                next = cur->next; \\n                cur->next = cur->next->next; \\n                next->next = pre->next; \\n                pre->next = next; \\n            }\\n        }\\n        return newHead.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        ListNode newHead(0);\\n        newHead.next = head;\\n        ListNode *pre = &newHead, *cur = head, *next = NULL;\\n        int i = 1;\\n        while(i < n)\\n        {\\n            if(i++ < m) { pre = cur; cur = cur->next; }\\n            else\\n            { \\n                next = cur->next; \\n                cur->next = cur->next->next; \\n                next->next = pre->next; \\n                pre->next = next; \\n            }\\n        }\\n        return newHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30803,
                "title": "c-solution-for-reverse-linked-list-ii",
                "content": "    typedef struct ListNode node;\\n\\n    struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {\\n    if(head == NULL || head->next == NULL || m == n)\\n        return head;\\n        \\n    node *temp = head;\\n    node *start = head;\\n    int i = 1;\\n    \\n    while(i < m && temp->next != NULL)\\n    {\\n        start = temp;\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    node *curr = temp->next;\\n    node *prev = temp;\\n    node *t;\\n    prev->next = NULL;\\n    \\n    while(i < n && curr != NULL)\\n    {\\n        t = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = t;\\n        i++;\\n    }\\n    \\n    start->next = prev;\\n    temp->next = curr;\\n    \\n    if(m == 1)\\n        return prev;\\n    return head;\\n}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "    typedef struct ListNode node;\\n\\n    struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {\\n    if(head == NULL || head->next == NULL || m == n)\\n        return head;\\n        \\n    node *temp = head;\\n    node *start = head;\\n    int i = 1;\\n    \\n    while(i < m && temp->next != NULL)\\n    {\\n        start = temp;\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    node *curr = temp->next;\\n    node *prev = temp;\\n    node *t;\\n    prev->next = NULL;\\n    \\n    while(i < n && curr != NULL)\\n    {\\n        t = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = t;\\n        i++;\\n    }\\n    \\n    start->next = prev;\\n    temp->next = curr;\\n    \\n    if(m == 1)\\n        return prev;\\n    return head;\\n}",
                "codeTag": "Python3"
            },
            {
                "id": 4088356,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next==null || right==left) return head;\\n        boolean check = false;\\n        ListNode Pleft = null;\\n        ListNode Pright = null;\\n        ListNode Tleft = null;\\n        ListNode Tright = null;\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            if(count==left-1)   Pleft = curr;\\n            if(count==right+1)  Pright = curr;          \\n            if(count==left)     Tleft = curr;\\n            if(count==right)    Tright = curr;\\n            curr = curr.next;\\n        }\\n        if(Tleft==head)  check = true;     \\n        if(Pleft!=null && Pleft.next!=null)  Pleft.next = null;\\n        if(Tright.next!=null) Tright.next = null;\\n        curr = Tleft;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }    \\n        if(Pleft!=null )  Pleft.next = Tright;\\n        Tleft.next = Pright;\\n        if(head.next==null || check)  return Tright;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next==null || right==left) return head;\\n        boolean check = false;\\n        ListNode Pleft = null;\\n        ListNode Pright = null;\\n        ListNode Tleft = null;\\n        ListNode Tright = null;\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            if(count==left-1)   Pleft = curr;\\n            if(count==right+1)  Pright = curr;          \\n            if(count==left)     Tleft = curr;\\n            if(count==right)    Tright = curr;\\n            curr = curr.next;\\n        }\\n        if(Tleft==head)  check = true;     \\n        if(Pleft!=null && Pleft.next!=null)  Pleft.next = null;\\n        if(Tright.next!=null) Tright.next = null;\\n        curr = Tleft;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }    \\n        if(Pleft!=null )  Pleft.next = Tright;\\n        Tleft.next = Pright;\\n        if(head.next==null || check)  return Tright;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012831,
                "title": "java-single-pass-solution-explanation-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution uses the approach of reversing the list in a smarter way that is using the insert at starting.\\n1->2->3\\n\\nremove 1 \\n \\nnew list: 1\\ncurr list: 2->3\\n\\nremove 2\\ninsert at start\\n\\nnew list: 2->1\\ncurr list: 3\\n\\nremove 3\\n\\nnew list: 3->2->1\\ncurr list : {}\\nKeep in mind to mark the next pointer of curr null \\uD83D\\uDE09\\n\\nWe have created temporary head and temporary tail which will store the reversed linkedlist.\\n\\n\\nCan you solve reverseInKgroup using this?? (made something much easy for you) \\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprev pointer is taken so that we can be just behind the curr pointer because when we our in range where we have to reverse the linkedList. we need to hold on our prev Node so that once we get the fully reversed linkedList we can simply attach that prev node to the temporary head and temporary tail to the curr.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode th=null;\\n    ListNode tt=null;\\n    void addFirst(ListNode node){\\n        if(th==null){\\n            th=node;\\n            tt=node;\\n        }\\n        else{\\n            node.next=th;\\n            th=node;\\n        }\\n    }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        int idx=1;\\n        while(curr!=null){\\n            while(idx>=left && idx<=right){\\n                ListNode fwd = curr.next;\\n                curr.next=null;\\n                addFirst(curr);\\n                curr=fwd;\\n                idx++;\\n            }\\n            if(idx>right){\\n                if(prev!=null){\\n                    prev.next=th;\\n                    tt.next=curr;\\n                    return head;\\n                }\\n                else{\\n                    tt.next=curr;\\n                    return th;\\n                }\\n            }\\n            idx++;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n![please upvote me.jpg](https://assets.leetcode.com/users/images/9d9aaf36-e638-4581-9ae8-36466e9548b3_1694068310.5698211.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode th=null;\\n    ListNode tt=null;\\n    void addFirst(ListNode node){\\n        if(th==null){\\n            th=node;\\n            tt=node;\\n        }\\n        else{\\n            node.next=th;\\n            th=node;\\n        }\\n    }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        int idx=1;\\n        while(curr!=null){\\n            while(idx>=left && idx<=right){\\n                ListNode fwd = curr.next;\\n                curr.next=null;\\n                addFirst(curr);\\n                curr=fwd;\\n                idx++;\\n            }\\n            if(idx>right){\\n                if(prev!=null){\\n                    prev.next=th;\\n                    tt.next=curr;\\n                    return head;\\n                }\\n                else{\\n                    tt.next=curr;\\n                    return th;\\n                }\\n            }\\n            idx++;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012534,
                "title": "c-easy-explanation-pictorial-explanation",
                "content": "## Logic\\n- This is one of the *standard* question in Single Linked List.\\n- I have solved it using ***three pointer approach*** which is *inplace* and fast.\\n\\n## Implementation\\n```\\nListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\t//The three pointers here are prev , curr and forw\\n            ListNode *temp = new ListNode(0);\\n\\t\\t\\t//A dummy node before head\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n```\\n\\n## Pictorial Representation\\n![image](https://assets.leetcode.com/users/images/3e2162ba-9084-40f7-97b6-81ee2cca70d9_1658424854.7308772.jpeg)\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanation and if there is any scope of improvement do mention it in the comments section\\uD83D\\uDE01.\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\t//The three pointers here are prev , curr and forw\\n            ListNode *temp = new ListNode(0);\\n\\t\\t\\t//A dummy node before head\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012485,
                "title": "easy-beginner-friendly-o-n-with-proper-explain-c-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we get the linked list from left to right separete from remaninig list we can easily reverse it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply split the linked list int three parts 0<-->left-1 && left<-->right  && right+1<-->end .\\nTo do this make some pointers as\\n(temp) ptr to traverse linked list.\\n(temp1) ptr to point to the node just before left one node.\\n(temp2) ptr to point to the node just before right one node.\\n(newh) this point to left one node(temp1->next) and used for reverse that list as head of linked list.\\n(end) to point on the node just after right one node used to reconnent them all.\\n\\n\\nNow, separate them in 3 parts by making temp1->next=NULL  and temp2->next->next=ULL and reverse the linked list with head as newh.\\n\\nIn the end join them again by making temp1->next=newh  and \\n(last node of reversed list)->next=end.\\n\\n!!!Please UPvote\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* temp;\\n        while(cur!=NULL)\\n        {\\n            temp=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }  \\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right)\\n        return head;\\n        ListNode* dummy=new ListNode(-600);\\n        dummy->next=head;\\n        ListNode* temp1;\\n        ListNode* temp2;\\n        ListNode* temp=dummy;\\n        int l=left,r=right;\\n        while(temp)\\n        {\\n            l--;\\n            r--;\\n            if(l==0)\\n            temp1=temp;\\n            if(r==0)\\n            temp2=temp;\\n            temp=temp->next;\\n\\n        }\\n        ListNode* end=temp2->next->next;\\n        ListNode* newh=temp1->next;\\n        temp1->next=NULL;\\n        temp2->next->next=NULL;\\n        newh=reverseList(newh);\\n        temp1->next=newh;\\n        while(newh->next)\\n        {\\n            newh=newh->next;\\n        }\\n        newh->next=end;\\n        return dummy->next;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* temp;\\n        while(cur!=NULL)\\n        {\\n            temp=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }  \\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right)\\n        return head;\\n        ListNode* dummy=new ListNode(-600);\\n        dummy->next=head;\\n        ListNode* temp1;\\n        ListNode* temp2;\\n        ListNode* temp=dummy;\\n        int l=left,r=right;\\n        while(temp)\\n        {\\n            l--;\\n            r--;\\n            if(l==0)\\n            temp1=temp;\\n            if(r==0)\\n            temp2=temp;\\n            temp=temp->next;\\n\\n        }\\n        ListNode* end=temp2->next->next;\\n        ListNode* newh=temp1->next;\\n        temp1->next=NULL;\\n        temp2->next->next=NULL;\\n        newh=reverseList(newh);\\n        temp1->next=newh;\\n        while(newh->next)\\n        {\\n            newh=newh->next;\\n        }\\n        newh->next=end;\\n        return dummy->next;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011871,
                "title": "java-beats-100-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public ListNode reverseBetween(ListNode head, int lindex, int rindex) {\\n    ListNode ptr, l = null;\\n    var i = 1;\\n    \\n    for (ptr = head; i < lindex; ptr = ptr.next, i++)\\n      if (i+1 == lindex) l = ptr;\\n\\n    var left = ptr;\\n    \\n    for (; i < rindex; ptr = ptr.next, i++);\\n    var right = ptr;\\n    \\n    if (l == null) head = right;\\n    else l.next = right;\\n  \\n    if (left != right) {\\n      var p1 = left;\\n      var p2 = p1.next;\\n      var p3 = p2.next;\\n      left.next = right.next;\\n      \\n      while (p2 != right) {\\n        p2.next = p1;\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = p3.next;\\n      }\\n      p2.next = p1;\\n    }   \\n    return head;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode reverseBetween(ListNode head, int lindex, int rindex) {\\n    ListNode ptr, l = null;\\n    var i = 1;\\n    \\n    for (ptr = head; i < lindex; ptr = ptr.next, i++)\\n      if (i+1 == lindex) l = ptr;\\n\\n    var left = ptr;\\n    \\n    for (; i < rindex; ptr = ptr.next, i++);\\n    var right = ptr;\\n    \\n    if (l == null) head = right;\\n    else l.next = right;\\n  \\n    if (left != right) {\\n      var p1 = left;\\n      var p2 = p1.next;\\n      var p3 = p2.next;\\n      left.next = right.next;\\n      \\n      while (p2 != right) {\\n        p2.next = p1;\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = p3.next;\\n      }\\n      p2.next = p1;\\n    }   \\n    return head;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865862,
                "title": "java-0ms-easy-to-understand-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next == null)   return head;\\n\\n        ListNode dummy_node = new ListNode(0);\\n        dummy_node.next= head;\\n        ListNode prev = dummy_node;\\n\\n        for(int i = 1; i <= left - 1; i++ )     prev = prev.next;\\n        \\n        ListNode curr = prev.next;\\n        \\n\\n        for(int i = 1; i <= right - left; i++)\\n        {\\n            ListNode frwd = curr.next;\\n            curr.next = frwd.next;\\n            frwd.next = prev.next;\\n            prev.next = frwd;\\n        } \\n        return dummy_node.next;\\n        \\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next == null)   return head;\\n\\n        ListNode dummy_node = new ListNode(0);\\n        dummy_node.next= head;\\n        ListNode prev = dummy_node;\\n\\n        for(int i = 1; i <= left - 1; i++ )     prev = prev.next;\\n        \\n        ListNode curr = prev.next;\\n        \\n\\n        for(int i = 1; i <= right - left; i++)\\n        {\\n            ListNode frwd = curr.next;\\n            curr.next = frwd.next;\\n            frwd.next = prev.next;\\n            prev.next = frwd;\\n        } \\n        return dummy_node.next;\\n        \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800443,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem asks to reverse a linked list from position `left` to position `right`. This can be solved by locating the `left-1` position node first and then reversing the sublist from `left` to `right`.\\n\\n# Approach\\n1. **Create a Dummy Node**: Initialize a dummy node that points to the head to handle edge cases such as reversing at the very beginning of the list.\\n2. **Locate the `left-1` Position**: Move a pointer `prev` to its place, which is at position `left-1`.\\n3. **Reverse the Sublist**: Use another pointer to reverse the sublist from position `left` to `right`. While reversing, also keep track of the next node `currRev` after the reversed sublist for later reconnection.\\n4. **Reconnect**: Connect the `prev.Next` with the reversed sublist and also connect the end of the reversed sublist with the remaining list `currRev`.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where `n` is the number of nodes in the list, because we potentially need to traverse all the nodes in the list.\\n- Space complexity: The space complexity is O(1), as we only use a constant amount of space to store the pointers.\\n\\n# Code\\n```\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    // Return nil if the list is empty\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Initialize a dummy node that points to the head\\n    dummy := &ListNode{Next: head}\\n    prev := dummy\\n\\n    // Move \\'prev\\' to its place which is at position \\'left - 1\\'\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    // Reverse the sublist from position \\'left\\' to \\'right\\'\\n    prevRev, currRev := reverse(prev.Next, right-left+1)\\n\\n    // Connect the \\'prev.Next\\' with the reversed sublist and \\n    // also connect the end of reversed sublist with the remaining list \\'currRev\\'\\n    prev.Next.Next = currRev\\n    prev.Next = prevRev\\n\\n    // Return the next node of dummy node\\n    return dummy.Next\\n}\\n\\nfunc reverse(head *ListNode, len int) (*ListNode, *ListNode) {\\n    var prev *ListNode\\n    // Reverse \\'len\\' nodes of the list and keep track of the next node after the reversed sublist\\n    for i := 0; i < len; i++ {\\n        nextRev := head.Next\\n        head.Next = prev\\n        prev = head\\n        head = nextRev\\n    }\\n    // Return the head of reversed sublist and the next node after the reversed sublist\\n    return prev, head\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    // Return nil if the list is empty\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Initialize a dummy node that points to the head\\n    dummy := &ListNode{Next: head}\\n    prev := dummy\\n\\n    // Move \\'prev\\' to its place which is at position \\'left - 1\\'\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    // Reverse the sublist from position \\'left\\' to \\'right\\'\\n    prevRev, currRev := reverse(prev.Next, right-left+1)\\n\\n    // Connect the \\'prev.Next\\' with the reversed sublist and \\n    // also connect the end of reversed sublist with the remaining list \\'currRev\\'\\n    prev.Next.Next = currRev\\n    prev.Next = prevRev\\n\\n    // Return the next node of dummy node\\n    return dummy.Next\\n}\\n\\nfunc reverse(head *ListNode, len int) (*ListNode, *ListNode) {\\n    var prev *ListNode\\n    // Reverse \\'len\\' nodes of the list and keep track of the next node after the reversed sublist\\n    for i := 0; i < len; i++ {\\n        nextRev := head.Next\\n        head.Next = prev\\n        prev = head\\n        head = nextRev\\n    }\\n    // Return the head of reversed sublist and the next node after the reversed sublist\\n    return prev, head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767472,
                "title": "java-easy-steps-explanation-with-drawing-beats-100",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![LLsolution.jpeg](https://assets.leetcode.com/users/images/0e0e6f31-fd37-484a-b096-243f5d8886f0_1689405838.3570461.jpeg)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==right) return head;\\n       ListNode prev = null;\\n       ListNode curr = head;\\n       for(int i=0; curr!=null && i<left-1; i++){\\n           prev = curr;\\n           curr = curr.next;\\n       }\\n       ListNode last = prev;\\n       ListNode newEnd = curr;\\n       ListNode forward = curr.next;\\n       for(int i=0; curr!=null && i<right-left+1; i++){\\n           curr.next = prev;\\n           prev = curr;\\n           curr = forward;\\n           if(forward!=null){\\n               forward = forward.next;\\n           }\\n       }\\n       if(last!=null) last.next = prev;\\n       else head = prev;\\n\\n       newEnd.next=curr;\\n       return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==right) return head;\\n       ListNode prev = null;\\n       ListNode curr = head;\\n       for(int i=0; curr!=null && i<left-1; i++){\\n           prev = curr;\\n           curr = curr.next;\\n       }\\n       ListNode last = prev;\\n       ListNode newEnd = curr;\\n       ListNode forward = curr.next;\\n       for(int i=0; curr!=null && i<right-left+1; i++){\\n           curr.next = prev;\\n           prev = curr;\\n           curr = forward;\\n           if(forward!=null){\\n               forward = forward.next;\\n           }\\n       }\\n       if(last!=null) last.next = prev;\\n       else head = prev;\\n\\n       newEnd.next=curr;\\n       return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534924,
                "title": "java-solution-100-faster-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode ptr=head;\\n        int k=0;\\n\\n        Stack<Integer> s=new Stack<>();\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                s.push(ptr.val);\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        ptr=head;\\n\\n        k=0;\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                ptr.val=s.pop();\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode ptr=head;\\n        int k=0;\\n\\n        Stack<Integer> s=new Stack<>();\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                s.push(ptr.val);\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        ptr=head;\\n\\n        k=0;\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                ptr.val=s.pop();\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256987,
                "title": "beats-100-0ms-java-detailed-explanation-python3-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this problem is to use a simple two-pointer approach to manipulate the pointers of the nodes in the linked list in order to reverse a sublist in place.\\n\\n# Approach\\nThe input to the function is the `head` of the linked list, and two integers `left` and `right` representing the starting and ending indices (1-based) of the sublist to be reversed.\\n\\nThe function starts by handling the edge case where `left` is equal to `right`, in which case it simply returns the original list as it is.\\n\\nNext, it initializes two pointers `prev` and `curr` to traverse the list until `curr` points to the node at index `left`. It also maintains a reference to the node immediately preceding the sublist, `last`.\\n\\nAfter locating the starting point of the sublist, the function then reverses the sublist in place. This is done by iterating over the nodes between `left` and `right`, and swapping the next pointers of the nodes to reverse the order of the sublist.\\n\\nOnce the sublist is reversed, the function then connects it back to the rest of the list. This is done by setting the `next` pointer of the node at index `last` to point to the first node of the reversed sublist (`prev`). If `last` is `null`, then the sublist starts at the `head` of the list, so the `head` variable is updated to point to the first node of the reversed sublist. The `next` pointer of the last node of the reversed sublist is then set to point to the node immediately following the sublist, which is `curr`.\\n\\nFinally, the function returns the updated `head` of the list.\\n\\n# Complexity\\n- Time complexity:  O(n)\\nTime complexity of this solution is O(n), where n is the length of the list, since it only requires a single pass over the list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\nThe space complexity is O(1), since it only uses a constant amount of extra space to store pointers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        for(int i=0 ; curr != null && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode last = prev;\\n        ListNode newEnd = curr;\\n        ListNode next = curr.next;\\n        for(int i=0 ; curr != null && i < right - left + 1 ; i++){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != null) {next = next.next;}\\n        }\\n        if(last != null){ last.next = prev;}\\n        else {head = prev;}\\n        newEnd.next = curr;\\n        return head;\\n    }\\n}\\n```\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* last = prev;\\n        ListNode* newEnd = curr;\\n        ListNode* next = curr->next;\\n        for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != NULL) {next = next->next;}\\n        }\\n        if(last != NULL){ last->next = prev;}\\n        else {head = prev;}\\n        newEnd->next = curr;\\n        return head;\\n    }\\n};\\n\\n```\\n# Python3\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if left == right:\\n            return head\\n        curr = head\\n        prev = None\\n        for i in range(left-1):\\n            prev = curr\\n            curr = curr.next\\n        last = prev\\n        new_end = curr\\n        next = curr.next\\n        for i in range(right - left + 1):\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            if next != None:\\n                next = next.next\\n        if last != None:\\n            last.next = prev\\n        else:\\n            head = prev\\n        new_end.next = curr\\n        return head\\n\\n```\\n# C\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    if(left == right) return head;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n        prev = curr;\\n        curr = curr->next;\\n    }\\n    struct ListNode* last = prev;\\n    struct ListNode* newEnd = curr;\\n    struct ListNode* next = curr->next;\\n    for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n        if (next != NULL) {next = next->next;}\\n    }\\n    if(last != NULL){ last->next = prev;}\\n    else {head = prev;}\\n    newEnd->next = curr;\\n    return head;\\n}\\n\\n```\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        for(int i=0 ; curr != null && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode last = prev;\\n        ListNode newEnd = curr;\\n        ListNode next = curr.next;\\n        for(int i=0 ; curr != null && i < right - left + 1 ; i++){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != null) {next = next.next;}\\n        }\\n        if(last != null){ last.next = prev;}\\n        else {head = prev;}\\n        newEnd.next = curr;\\n        return head;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* last = prev;\\n        ListNode* newEnd = curr;\\n        ListNode* next = curr->next;\\n        for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != NULL) {next = next->next;}\\n        }\\n        if(last != NULL){ last->next = prev;}\\n        else {head = prev;}\\n        newEnd->next = curr;\\n        return head;\\n    }\\n};\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if left == right:\\n            return head\\n        curr = head\\n        prev = None\\n        for i in range(left-1):\\n            prev = curr\\n            curr = curr.next\\n        last = prev\\n        new_end = curr\\n        next = curr.next\\n        for i in range(right - left + 1):\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            if next != None:\\n                next = next.next\\n        if last != None:\\n            last.next = prev\\n        else:\\n            head = prev\\n        new_end.next = curr\\n        return head\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    if(left == right) return head;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n        prev = curr;\\n        curr = curr->next;\\n    }\\n    struct ListNode* last = prev;\\n    struct ListNode* newEnd = curr;\\n    struct ListNode* next = curr->next;\\n    for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n        if (next != NULL) {next = next->next;}\\n    }\\n    if(last != NULL){ last->next = prev;}\\n    else {head = prev;}\\n    newEnd->next = curr;\\n    return head;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070934,
                "title": "python-simple-solution-beats-100-explained",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        cn_position = 1\\n        current_node = head\\n        start = head\\n        while cn_position < left:\\n            start = current_node\\n            current_node = current_node.next\\n            cn_position +=1\\n        newlist = None\\n        tail = current_node\\n        while cn_position >= left and cn_position <= right:\\n            next_node = current_node.next\\n            current_node.next = newlist\\n            newlist = current_node\\n            current_node = next_node\\n            cn_position +=1\\n        start.next = newlist\\n        tail.next =current_node\\n        if left >1:\\n            return head\\n        else:\\n            return newlist\\n\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        cn_position = 1\\n        current_node = head\\n        start = head\\n        while cn_position < left:\\n            start = current_node\\n            current_node = current_node.next\\n            cn_position +=1\\n        newlist = None\\n        tail = current_node\\n        while cn_position >= left and cn_position <= right:\\n            next_node = current_node.next\\n            current_node.next = newlist\\n            newlist = current_node\\n            current_node = next_node\\n            cn_position +=1\\n        start.next = newlist\\n        tail.next =current_node\\n        if left >1:\\n            return head\\n        else:\\n            return newlist\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044019,
                "title": "c-simple-reverse-list-beginner-friendly",
                "content": "\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = next -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *leftPrev = nullptr, *r = nullptr, *l = nullptr;\\n        ListNode *curr = head, *prev = nullptr;\\n\\n        int cnt = 1;\\n        while(curr) {\\n            if(cnt == left) {\\n                leftPrev = prev;\\n                l = curr;\\n            }\\n\\n            if(cnt == right) r = curr;\\n\\n            prev = curr;\\n            curr = curr -> next; \\n            cnt++;\\n        }\\n        \\n        ListNode *rightSide = r -> next;\\n        r -> next = nullptr;\\n        \\n        ListNode *a = F(l);\\n        l -> next = rightSide;\\n\\n        if(!leftPrev) return a;\\n        leftPrev -> next = a;\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = next -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *leftPrev = nullptr, *r = nullptr, *l = nullptr;\\n        ListNode *curr = head, *prev = nullptr;\\n\\n        int cnt = 1;\\n        while(curr) {\\n            if(cnt == left) {\\n                leftPrev = prev;\\n                l = curr;\\n            }\\n\\n            if(cnt == right) r = curr;\\n\\n            prev = curr;\\n            curr = curr -> next; \\n            cnt++;\\n        }\\n        \\n        ListNode *rightSide = r -> next;\\n        r -> next = nullptr;\\n        \\n        ListNode *a = F(l);\\n        l -> next = rightSide;\\n\\n        if(!leftPrev) return a;\\n        leftPrev -> next = a;\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978378,
                "title": "python-3-solution-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Linked list reversal** can be accomplished with minimal code. With this problem, there\\'s a complication: we need to reverse a *sublist* and join the parts together again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the unaltered first section that precedes the starting node of the reversal\\n1. Reverse the specified section\\n1. Join the unaltered first section, the reversed middle section, and the unaltered ending section\\n\\nIt\\'s possible that either of both of the unaltered sections is empty, or that the section to be reversed has only one node (meaning no reversal).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if left == right or not head.next:          # Nothing to change\\n            return head\\n        current, prev, pos = head, None, 1\\n        while current.next and pos < left:          # Traverse and count the left section\\n            prev, current = current, current.next\\n            pos += 1\\n        end_of_left = prev                          # end_of_left.next = start of the reversed segment\\n        end_of_mid = current                        # end_of_mid.next = start of the right section\\n        while pos < right:                          # Reverse the middle section\\n            to_do_next, current.next, prev = current.next, prev, current\\n            current = to_do_next\\n            pos += 1\\n        # Finish middle and attach sections\\n        if left == 1:                               # Special case: no left section\\n            head = current\\n        else:\\n            end_of_left.next = current\\n        end_of_mid.next, current.next = current.next, prev\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if left == right or not head.next:          # Nothing to change\\n            return head\\n        current, prev, pos = head, None, 1\\n        while current.next and pos < left:          # Traverse and count the left section\\n            prev, current = current, current.next\\n            pos += 1\\n        end_of_left = prev                          # end_of_left.next = start of the reversed segment\\n        end_of_mid = current                        # end_of_mid.next = start of the right section\\n        while pos < right:                          # Reverse the middle section\\n            to_do_next, current.next, prev = current.next, prev, current\\n            current = to_do_next\\n            pos += 1\\n        # Finish middle and attach sections\\n        if left == 1:                               # Special case: no left section\\n            head = current\\n        else:\\n            end_of_left.next = current\\n        end_of_mid.next, current.next = current.next, prev\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618388,
                "title": "100-faster-submission-c-solution-easy-understandable",
                "content": "![image](https://assets.leetcode.com/users/images/bc24cb38-8d79-4193-9688-1e1fb72921cd_1664027885.8875773.png)\\n**Approach:**\\n1.convert to vector\\n2.reverse vector using stl sort function time complex=ologn\\n3.now insert to the linked list\\n\\ncode is in simple and understandable format\\n\\nfollow on linked in = https://www.linkedin.com/in/kishan-kadam/",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bc24cb38-8d79-4193-9688-1e1fb72921cd_1664027885.8875773.png)\\n**Approach:**\\n1.convert to vector\\n2.reverse vector using stl sort function time complex=ologn\\n3.now insert to the linked list\\n\\ncode is in simple and understandable format\\n\\nfollow on linked in = https://www.linkedin.com/in/kishan-kadam/",
                "codeTag": "Unknown"
            },
            {
                "id": 2542093,
                "title": "java-solution-with-comments-and-clear-variable-name-for-better-understanding-o-1-memory",
                "content": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(right == left)\\n            return head;\\n        \\n        ListNode currentNode = head;\\n        ListNode previousNode = null;\\n        \\n        //Get the node before the left position\\n        for(int index = 0; index < left - 1 && currentNode != null; index++){\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n        \\n        ListNode lastNodeBeforeLeftNode = previousNode;\\n        \\n        ListNode firstNodeAfterLeftNode = currentNode;\\n        \\n        ListNode nextNode = null;\\n        \\n        //Perform a reverse between left and right\\n        for(int index = 0; index < right - left +1 && currentNode != null; index++){\\n            nextNode = currentNode.next;\\n            currentNode.next = previousNode;\\n            previousNode = currentNode;\\n            currentNode = nextNode;\\n        }\\n        \\n        \\n        if(lastNodeBeforeLeftNode != null){\\n            lastNodeBeforeLeftNode.next = previousNode;\\n        }else{\\n            head = previousNode;\\n        }\\n        \\n        firstNodeAfterLeftNode.next = currentNode;\\n        \\n        return head;\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(right == left)\\n            return head;\\n        \\n        ListNode currentNode = head;\\n        ListNode previousNode = null;\\n        \\n        //Get the node before the left position\\n        for(int index = 0; index < left - 1 && currentNode != null; index++){\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n        \\n        ListNode lastNodeBeforeLeftNode = previousNode;\\n        \\n        ListNode firstNodeAfterLeftNode = currentNode;\\n        \\n        ListNode nextNode = null;\\n        \\n        //Perform a reverse between left and right\\n        for(int index = 0; index < right - left +1 && currentNode != null; index++){\\n            nextNode = currentNode.next;\\n            currentNode.next = previousNode;\\n            previousNode = currentNode;\\n            currentNode = nextNode;\\n        }\\n        \\n        \\n        if(lastNodeBeforeLeftNode != null){\\n            lastNodeBeforeLeftNode.next = previousNode;\\n        }else{\\n            head = previousNode;\\n        }\\n        \\n        firstNodeAfterLeftNode.next = currentNode;\\n        \\n        return head;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2320281,
                "title": "simple-java-c-solution-with-clear-explanation",
                "content": "\\nC++ Solution\\nhttps://leetcode.com/problems/reverse-linked-list-ii/discuss/2320268/Simple-C%2B%2B-JAVA-Solution-with-TC-O(N)-SC-O(1)\\n\\nVery similar to problem 25. We keep three pointers as with any other reverse linked lists problems: pre, curr, next. We can split all algorithm into 3 steps:\\n\\nDo m-1 steps to reach the first point of range we need to reverse.\\nReverse range [n - m], using 3 pointers approach.\\nFinally we need to fix connections for the start and for the end of reversed list, using saved pointer to pre element.\\n\\n**Complexity**\\nTime complexity is O(n), because we need to traverse elements upto n-th. Space complexity is O(1).\\n\\n```\\nclass Solution {\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    \\n    if(head == null && head.next==null) return null;\\n    \\n    ListNode dummy = new ListNode(Integer.MIN_VALUE); // dummy node at head\\n    dummy.next = head;\\n    \\n    ListNode pre = dummy; //   prev pointer at the node before reversing\\n    for(int i = 0; i<left - 1; i++) pre = pre.next;\\n    \\n    ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n    ListNode then = start.next; // a pointer to a node that will be reversed\\n    \\n    // 1 - 2 -3 - 4 - 5 ; left=2; right =4 --> pre = 1, start = 2, then = 3\\n    // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n    for(int i=0; i<right-left; i++)\\n    {\\n        start.next = then.next;\\n        then.next = pre.next;\\n        //System.out.println(pre.next.val);        \\n        pre.next = then;\\n        then = start.next;\\n    }\\n    \\n    // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n    // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n    \\n    return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    \\n    if(head == null && head.next==null) return null;\\n    \\n    ListNode dummy = new ListNode(Integer.MIN_VALUE); // dummy node at head\\n    dummy.next = head;\\n    \\n    ListNode pre = dummy; //   prev pointer at the node before reversing\\n    for(int i = 0; i<left - 1; i++) pre = pre.next;\\n    \\n    ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n    ListNode then = start.next; // a pointer to a node that will be reversed\\n    \\n    // 1 - 2 -3 - 4 - 5 ; left=2; right =4 --> pre = 1, start = 2, then = 3\\n    // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n    for(int i=0; i<right-left; i++)\\n    {\\n        start.next = then.next;\\n        then.next = pre.next;\\n        //System.out.println(pre.next.val);        \\n        pre.next = then;\\n        then = start.next;\\n    }\\n    \\n    // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n    // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n    \\n    return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320268,
                "title": "simple-c-java-solution-with-tc-o-n-sc-o-1",
                "content": "JAVA Solution \\nhttps://leetcode.com/problems/reverse-linked-list-ii/discuss/2320281/Simple-JAVA-C%2B%2B-Solution-with-clear-explanation\\n```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           pre = pre -> next;\\n       }\\n       cur = pre -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode* temp = pre -> next;\\n           pre -> next = cur -> next;\\n           cur -> next = cur -> next -> next;\\n           pre -> next -> next = temp;\\n       }\\n       return dummy -> next;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           pre = pre -> next;\\n       }\\n       cur = pre -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode* temp = pre -> next;\\n           pre -> next = cur -> next;\\n           cur -> next = cur -> next -> next;\\n           pre -> next -> next = temp;\\n       }\\n       return dummy -> next;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315123,
                "title": "92-reverse-linked-list-ii-c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\n            ListNode *temp = new ListNode(0);\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\n            ListNode *temp = new ListNode(0);\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311050,
                "title": "beats-100-other-solutions",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int o) {\\n        if(!head) return head;\\n        ListNode *t1=nullptr,*t2=head;\\n        for(int i=0;i<m-1;i++){\\n            t1=t2;\\n            t2=t2->next;\\n        } \\n        int cnt=0;\\n        ListNode *c=t2,*p=nullptr,*n;\\n        while(cnt<o-m+1){\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            cnt++;\\n        }\\n        if(!t1) head=p;\\n        else t1->next=p;\\n        t2->next=c;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int o) {\\n        if(!head) return head;\\n        ListNode *t1=nullptr,*t2=head;\\n        for(int i=0;i<m-1;i++){\\n            t1=t2;\\n            t2=t2->next;\\n        } \\n        int cnt=0;\\n        ListNode *c=t2,*p=nullptr,*n;\\n        while(cnt<o-m+1){\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            cnt++;\\n        }\\n        if(!t1) head=p;\\n        else t1->next=p;\\n        t2->next=c;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310931,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "**Java**\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null)    return null;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for(int i=0; i<left-1; i++)  pre = pre.next;\\n        ListNode start = pre.next;\\n        ListNode tmp = start.next;\\n        for(int i=0; i<right-left; i++){\\n            start.next = tmp.next;\\n            tmp.next = pre.next;\\n            pre.next = tmp;\\n            tmp = start.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar reverseBetween = function(head, left, right) {\\n    if(!head)    return null\\n    let dummy = new ListNode()\\n    dummy.next = head\\n    let pre = dummy\\n    for(let i=0; i<left-1; i++)  pre = pre.next;\\n    let start = pre.next\\n    let tmp = start.next\\n    for(let i=0; i<right-left; i++){\\n        start.next = tmp.next\\n        tmp.next = pre.next\\n        pre.next = tmp\\n        tmp = start.next\\n    }\\n    return dummy.next\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if not head:\\n            return null\\n        dummy = ListNode()\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(left-1):\\n            pre = pre.next\\n        start = pre.next\\n        tmp = start.next\\n        for i in range(right-left):\\n            start.next = tmp.next\\n            tmp.next = pre.next\\n            pre.next = tmp\\n            tmp = start.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null)    return null;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for(int i=0; i<left-1; i++)  pre = pre.next;\\n        ListNode start = pre.next;\\n        ListNode tmp = start.next;\\n        for(int i=0; i<right-left; i++){\\n            start.next = tmp.next;\\n            tmp.next = pre.next;\\n            pre.next = tmp;\\n            tmp = start.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nvar reverseBetween = function(head, left, right) {\\n    if(!head)    return null\\n    let dummy = new ListNode()\\n    dummy.next = head\\n    let pre = dummy\\n    for(let i=0; i<left-1; i++)  pre = pre.next;\\n    let start = pre.next\\n    let tmp = start.next\\n    for(let i=0; i<right-left; i++){\\n        start.next = tmp.next\\n        tmp.next = pre.next\\n        pre.next = tmp\\n        tmp = start.next\\n    }\\n    return dummy.next\\n};\\n```\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if not head:\\n            return null\\n        dummy = ListNode()\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(left-1):\\n            pre = pre.next\\n        start = pre.next\\n        tmp = start.next\\n        for i in range(right-left):\\n            start.next = tmp.next\\n            tmp.next = pre.next\\n            pre.next = tmp\\n            tmp = start.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310899,
                "title": "simple-iterative-java-solution-tc-o-n-sc-o-n",
                "content": "\\n\\tclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        //iterate until left\\n        ListNode currLeft = dummy;\\n        ListNode prevLeft = null;\\n        for(int i = 0; i < left; i++){\\n            prevLeft = currLeft;\\n            currLeft = currLeft.next;\\n        }\\n        \\n        //reverse until right\\n        ListNode currRight = currLeft;\\n        ListNode prevRight = prevLeft;\\n        for(int i = left; i <= right; i++){\\n            ListNode temp = currRight.next;\\n            currRight.next = prevRight;\\n            prevRight = currRight;\\n            currRight = temp;\\n        }\\n        \\n        //connect the left and right pointers appropriately\\n        prevLeft.next = prevRight;\\n        currLeft.next = currRight;\\n        \\n        return dummy.next;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        //iterate until left\\n        ListNode currLeft = dummy;\\n        ListNode prevLeft = null;\\n        for(int i = 0; i < left; i++){\\n            prevLeft = currLeft;\\n            currLeft = currLeft.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2310877,
                "title": "easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if (!head || m == n)\\n            return head;\\n\\n        ListNode dummy(0, head);\\n        ListNode* front = &dummy;\\n        ListNode* end = &dummy;\\n        \\n        for (int i = 0; i < m - 1; ++i)\\n            front = front->next;\\n        \\n        for (int i = 0; i <= n; ++i)\\n            end = end->next;\\n        \\n        ListNode* inter = front->next;\\n        stack<ListNode*> stack;\\n        \\n        while (inter != end) {\\n            stack.push(inter);\\n            \\n            inter = inter->next;\\n        }\\n        \\n        while (!stack.empty()) {\\n            front->next = stack.top();\\n            stack.pop();\\n            front = front->next;\\n        }\\n        \\n        front->next = end;\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if (!head || m == n)\\n            return head;\\n\\n        ListNode dummy(0, head);\\n        ListNode* front = &dummy;\\n        ListNode* end = &dummy;\\n        \\n        for (int i = 0; i < m - 1; ++i)\\n            front = front->next;\\n        \\n        for (int i = 0; i <= n; ++i)\\n            end = end->next;\\n        \\n        ListNode* inter = front->next;\\n        stack<ListNode*> stack;\\n        \\n        while (inter != end) {\\n            stack.push(inter);\\n            \\n            inter = inter->next;\\n        }\\n        \\n        while (!stack.empty()) {\\n            front->next = stack.top();\\n            stack.pop();\\n            front = front->next;\\n        }\\n        \\n        front->next = end;\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278406,
                "title": "java-single-pass",
                "content": "````\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // 1. Iterate till left pointer\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prevLeft = dummy, cur = head;\\n        \\n        for(int i=0; i<left-1; i++){\\n            prevLeft = cur;\\n            cur = cur.next;\\n        }\\n        \\n        // 2. reverse the lists from left to right i.e., right -left + 1 times\\n        ListNode prev = null;\\n        for(int i=0; i<right-left+1; i++){\\n            ListNode tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        // 3. Rearrange the pointers\\n        prevLeft.next.next = cur;\\n        prevLeft.next = prev;\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // 1. Iterate till left pointer\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prevLeft = dummy, cur = head;\\n        \\n        for(int i=0; i<left-1; i++){\\n            prevLeft = cur;\\n            cur = cur.next;\\n        }\\n        \\n        // 2. reverse the lists from left to right i.e., right -left + 1 times\\n        ListNode prev = null;\\n        for(int i=0; i<right-left+1; i++){\\n            ListNode tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        // 3. Rearrange the pointers\\n        prevLeft.next.next = cur;\\n        prevLeft.next = prev;\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2217647,
                "title": "c-2-solutions-dummy-node",
                "content": "Dummy Node Approach\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        // Dummy Node Approach (helps to handle edge cases)\\n        \\n        ListNode* dummy = new ListNode;   // dummy node\\n        dummy -> next = head;\\n        \\n        // 1. reach node at position \\'left\\'\\n        \\n        ListNode* leftPrev = dummy;\\n        ListNode* curr = head;\\n        for(int i=0; i<left-1; i++){\\n            leftPrev = curr;\\n            curr = curr -> next;\\n        }\\n        \\n        // curr = \\'left\\', leftPrev = \\'node before left\\'\\n        // 2. reverse from left to right \\n        \\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        for(int i=0; i<right-left+1; i++){  \\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // 3. updating pointers\\n        \\n        leftPrev -> next -> next = curr;\\n        leftPrev -> next = prev;\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nSimple Iterative Approach\\n\\n```\\nclass Solution {\\nprivate:\\n    // Iterative Approach\\n    ListNode* reverse(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        \\n        int count = 1;\\n        while(count != left){\\n            prev = curr;          // prev will be placed just before left\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* start = curr;   // start is placed on left \\n        \\n        while(count != right){\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* end = curr;       // end is placed on right\\n        curr = curr -> next;        // curr is placed just after right\\n        end -> next = NULL;        \\n        \\n        ListNode* newHead = reverse(start);    // reversing Linked List from start to end (NULL)\\n        \\n        if(prev != NULL)\\n            prev -> next = newHead;        // as prev stores left-side data not reversed\\n        else\\n            head = newHead;               // when (left == 1) -> prev is still at NULL\\n        \\n        while(newHead -> next != NULL)\\n            newHead = newHead -> next;\\n        \\n        newHead -> next = curr;        // as curr stores right-side data not reversed\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        // Dummy Node Approach (helps to handle edge cases)\\n        \\n        ListNode* dummy = new ListNode;   // dummy node\\n        dummy -> next = head;\\n        \\n        // 1. reach node at position \\'left\\'\\n        \\n        ListNode* leftPrev = dummy;\\n        ListNode* curr = head;\\n        for(int i=0; i<left-1; i++){\\n            leftPrev = curr;\\n            curr = curr -> next;\\n        }\\n        \\n        // curr = \\'left\\', leftPrev = \\'node before left\\'\\n        // 2. reverse from left to right \\n        \\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        for(int i=0; i<right-left+1; i++){  \\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // 3. updating pointers\\n        \\n        leftPrev -> next -> next = curr;\\n        leftPrev -> next = prev;\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // Iterative Approach\\n    ListNode* reverse(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        \\n        int count = 1;\\n        while(count != left){\\n            prev = curr;          // prev will be placed just before left\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* start = curr;   // start is placed on left \\n        \\n        while(count != right){\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* end = curr;       // end is placed on right\\n        curr = curr -> next;        // curr is placed just after right\\n        end -> next = NULL;        \\n        \\n        ListNode* newHead = reverse(start);    // reversing Linked List from start to end (NULL)\\n        \\n        if(prev != NULL)\\n            prev -> next = newHead;        // as prev stores left-side data not reversed\\n        else\\n            head = newHead;               // when (left == 1) -> prev is still at NULL\\n        \\n        while(newHead -> next != NULL)\\n            newHead = newHead -> next;\\n        \\n        newHead -> next = curr;        // as curr stores right-side data not reversed\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163598,
                "title": "very-easy-and-different-c-solution-70-faster",
                "content": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* p = new ListNode(0,head);\\n        if(right==left)\\n            return head;\\n        ListNode* l1 = p;\\n        int i=1;\\n        while(l1)\\n        {\\n            if(i>=left)\\n                break;\\n            l1=l1->next;\\n            i++;\\n        }\\n        ListNode* next = l1;\\n        ListNode* curr = l1->next;\\n        ListNode* prev = l1;\\n        while(curr)\\n        {\\n            if(i==right+1)\\n                break;\\n            next = curr->next;\\n            curr->next=prev;\\n            prev = curr;\\n            curr = next;\\n            i++;   \\n        }\\n        l1->next->next = curr;\\n        l1->next = prev;\\n        return p->next;\\n    }\\n\\t\\n\\tIf you like the code, do upvote.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* p = new ListNode(0,head);\\n        if(right==left)\\n            return head;\\n        ListNode* l1 = p;\\n        int i=1;\\n        while(l1)\\n        {\\n            if(i>=left)\\n                break;\\n            l1=l1->next;\\n            i++;\\n        }\\n        ListNode* next = l1;\\n        ListNode* curr = l1->next;\\n        ListNode* prev = l1;\\n        while(curr)\\n        {\\n            if(i==right+1)\\n                break;\\n            next = curr->next;\\n            curr->next=prev;\\n            prev = curr;\\n            curr = next;\\n            i++;   \\n        }\\n        l1->next->next = curr;\\n        l1->next = prev;\\n        return p->next;\\n    }\\n\\t\\n\\tIf you like the code, do upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 2089708,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head->next) return head;\\n        if(left == right) return head;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        ListNode* curr = head;\\n        ListNode* start = NULL;\\n        //ListNode* end = NULL;\\n        int idx = 1;\\n        while(curr && idx <= right)\\n        {\\n            if(idx == left)\\n            {\\n                start = prev;\\n                \\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            idx++;\\n        }\\n        //cout << start->next->val << \" \" << end->val;\\n        while(start->next != prev)\\n        {\\n            //cout<< start->next->val;\\n            //if(!curr) cout<<prev->val << \" \";\\n            prev->next = start->next;\\n            //cout<< start->next->val;\\n            //cout << prev->next->val;\\n            ListNode* tmp = start->next->next;\\n            start->next->next = curr;\\n            start->next = tmp;\\n            curr = prev->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head->next) return head;\\n        if(left == right) return head;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        ListNode* curr = head;\\n        ListNode* start = NULL;\\n        //ListNode* end = NULL;\\n        int idx = 1;\\n        while(curr && idx <= right)\\n        {\\n            if(idx == left)\\n            {\\n                start = prev;\\n                \\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            idx++;\\n        }\\n        //cout << start->next->val << \" \" << end->val;\\n        while(start->next != prev)\\n        {\\n            //cout<< start->next->val;\\n            //if(!curr) cout<<prev->val << \" \";\\n            prev->next = start->next;\\n            //cout<< start->next->val;\\n            //cout << prev->next->val;\\n            ListNode* tmp = start->next->next;\\n            start->next->next = curr;\\n            start->next = tmp;\\n            curr = prev->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2026310,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        curCount = 1\\n        leftPre = dummy\\n        rightNex = head\\n        \\n        while cur:\\n            if curCount < left:\\n                leftPre = leftPre.next\\n            if curCount == right:\\n                rightNex = cur.next\\n                cur.next = None\\n                break\\n            cur = cur.next\\n            curCount += 1\\n        \\n        pre = leftPre\\n        cur = pre.next\\n        nex = cur.next\\n        while nex:\\n            cur.next = nex.next\\n            nex.next = pre.next\\n            pre.next = nex\\n            nex = cur.next\\n        \\n        cur.next = rightNex\\n        return dummy.next\\n\\t\\t\\n# Time: O(n)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        curCount = 1\\n        leftPre = dummy\\n        rightNex = head\\n        \\n        while cur:\\n            if curCount < left:\\n                leftPre = leftPre.next\\n            if curCount == right:\\n                rightNex = cur.next\\n                cur.next = None\\n                break\\n            cur = cur.next\\n            curCount += 1\\n        \\n        pre = leftPre\\n        cur = pre.next\\n        nex = cur.next\\n        while nex:\\n            cur.next = nex.next\\n            nex.next = pre.next\\n            pre.next = nex\\n            nex = cur.next\\n        \\n        cur.next = rightNex\\n        return dummy.next\\n\\t\\t\\n# Time: O(n)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934292,
                "title": "clean-iterative-ruby",
                "content": "Using Ruby\\'s parallel assignment really helps clean things up\\n\\n```\\ndef reverse_between(head, left, right)\\n  prehead = ListNode.new(0, head)\\n  prev, curr = prehead, head\\n  \\n  (left-1).times { prev, curr = curr, curr.next } # set pointers\\n  \\n  node = prev\\n  (right-left+1).times { curr.next, prev, curr = prev, curr, curr.next } # reverse list\\n  \\n  node.next.next, node.next = curr, prev # attach nodes\\n  prehead.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef reverse_between(head, left, right)\\n  prehead = ListNode.new(0, head)\\n  prev, curr = prehead, head\\n  \\n  (left-1).times { prev, curr = curr, curr.next } # set pointers\\n  \\n  node = prev\\n  (right-left+1).times { curr.next, prev, curr = prev, curr, curr.next } # reverse list\\n  \\n  node.next.next, node.next = curr, prev # attach nodes\\n  prehead.next\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1694423,
                "title": "reverse-linked-list-ii-c-east-to-understand-o-n-time",
                "content": "Logic is to seperate the right side  node and then reverse the remaining from the given left part and then combine the 2 half \\n```\\n ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        ListNode* templeft = head;\\n        ListNode* prevleft = NULL;\\n        while(right)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n            right--;\\n            left--;\\n            if(left > 0)\\n            {\\n                prevleft = templeft;\\n                templeft = templeft->next;\\n            }\\n        }\\n        if(prevleft != NULL)\\n        {\\n            prev->next = NULL;\\n            prevleft->next = reverse(templeft);\\n            templeft->next = temp;\\n            return head;\\n        }\\n        prev->next = NULL;\\n        head = reverse(templeft);\\n        templeft->next = temp;\\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Logic is to seperate the right side  node and then reverse the remaining from the given left part and then combine the 2 half \\n```\\n ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        ListNode* templeft = head;\\n        ListNode* prevleft = NULL;\\n        while(right)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n            right--;\\n            left--;\\n            if(left > 0)\\n            {\\n                prevleft = templeft;\\n                templeft = templeft->next;\\n            }\\n        }\\n        if(prevleft != NULL)\\n        {\\n            prev->next = NULL;\\n            prevleft->next = reverse(templeft);\\n            templeft->next = temp;\\n            return head;\\n        }\\n        prev->next = NULL;\\n        head = reverse(templeft);\\n        templeft->next = temp;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1621650,
                "title": "c-non-recursive-iterative-approach-linked-list-to-vector-0-n-0ms",
                "content": "**Idea : First store values of linked list in a vector then reverse it . It\\'s easy that way :)\\nand in the end store values of vector into linked list again**.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* temp = head;\\n        vector<int> nums;\\n        // Store linked list data in a vector so it\\'s operation becomes easier\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        // subtract left and right by 1 because vector\\'s index starts from 0\\n        left--;\\n        right--;\\n        \\n        // swap them\\n        while(left < right)\\n            swap(nums[left++], nums[right--]);\\n        \\n        // restore back vector\\'s data in linked list and return it\\n        temp = head;\\n        int i = 0;\\n        while(i < nums.size()){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Note : When u convert linked list into vectors/arrays it\\'s operation becomes easier\\nI know that\\'s not a good method to do it but still this way it makes problemsa easier lol**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* temp = head;\\n        vector<int> nums;\\n        // Store linked list data in a vector so it\\'s operation becomes easier\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        // subtract left and right by 1 because vector\\'s index starts from 0\\n        left--;\\n        right--;\\n        \\n        // swap them\\n        while(left < right)\\n            swap(nums[left++], nums[right--]);\\n        \\n        // restore back vector\\'s data in linked list and return it\\n        temp = head;\\n        int i = 0;\\n        while(i < nums.size()){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594309,
                "title": "java-easy-0ms-100-faster",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        if(left==right) return head;\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next=head;\\n        ListNode s= dummy;\\n        if(left>1) s=s.next;\\n        ListNode e=head;\\n        \\n        for(int i=1;i<left-1;i++) s=s.next;\\n        for(int i=1;i<=right;i++) e=e.next;\\n       \\n       ListNode r= reverseList(s.next,e);\\n         \\n        s.next=r;\\n        while(s.next!=null){\\n            s=s.next;\\n        }\\n        s.next=e;\\n          \\n        return dummy.next;\\n        \\n    }\\n   \\n    public ListNode reverseList(ListNode head, ListNode tail) {\\n        if(head==null || head.next==null) return head;\\n       ListNode newhead = null;\\n        while(head!=tail){\\n            ListNode temp = head.next;\\n            \\n            head.next= newhead;\\n            newhead= head;\\n            head=temp;\\n            \\n        }\\n        \\n        return newhead;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        if(left==right) return head;\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next=head;\\n        ListNode s= dummy;\\n        if(left>1) s=s.next;\\n        ListNode e=head;\\n        \\n        for(int i=1;i<left-1;i++) s=s.next;\\n        for(int i=1;i<=right;i++) e=e.next;\\n       \\n       ListNode r= reverseList(s.next,e);\\n         \\n        s.next=r;\\n        while(s.next!=null){\\n            s=s.next;\\n        }\\n        s.next=e;\\n          \\n        return dummy.next;\\n        \\n    }\\n   \\n    public ListNode reverseList(ListNode head, ListNode tail) {\\n        if(head==null || head.next==null) return head;\\n       ListNode newhead = null;\\n        while(head!=tail){\\n            ListNode temp = head.next;\\n            \\n            head.next= newhead;\\n            newhead= head;\\n            head=temp;\\n            \\n        }\\n        \\n        return newhead;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467541,
                "title": "easy-naive-cpp-solution",
                "content": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* temp=head,*temp1=NULL;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        int j=left;\\n        while(j<=right){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n            j++;\\n        }\\n        temp=head;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        j=v.size()-1;\\n        while(left<=right){\\n            temp->val=v[j--];\\n            temp=temp->next;\\n            left++;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* temp=head,*temp1=NULL;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        int j=left;\\n        while(j<=right){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n            j++;\\n        }\\n        temp=head;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        j=v.size()-1;\\n        while(left<=right){\\n            temp->val=v[j--];\\n            temp=temp->next;\\n            left++;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292533,
                "title": "reverse-linked-list-ii-python3-two-solutions",
                "content": "```\\nclass Solution:\\n    def Stack_reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Solutino using stack to push itens that should be reversed, and pop them after\\n        pos = 1\\n        curr = head\\n        anter = None\\n        stack = []\\n        while pos < left:\\n            pos += 1\\n            anter = curr\\n            curr = curr.next\\n        nodoleft = anter\\n        while pos <= right:\\n            pos += 1\\n            stack.append(curr)\\n            curr = curr.next\\n        if not nodoleft:\\n            nodoleft = stack.pop()\\n            head = nodoleft\\n        while len(stack):\\n            nodoleft.next = stack.pop()\\n            nodoleft = nodoleft.next\\n        nodoleft.next = curr\\n        return head\\n\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Reverting on the way\\n        if left == right:\\n            return head\\n        prev = curr = head\\n        pos = 1\\n        while pos < left:\\n            pos += 1\\n            prev = curr\\n            curr = curr.next\\n        nleft = prev\\n        nlast = curr\\n        nfirst = curr\\n        curr = curr.next\\n        pos += 1\\n        while pos < right:\\n            pos += 1\\n            next = curr.next\\n            curr.next = nfirst\\n            nfirst = curr\\n            curr = next\\n        if left > 1:\\n            nleft.next = curr\\n        else:\\n            head = curr\\n        nlast.next = curr.next\\n        curr.next = nfirst\\n        return head\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def Stack_reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Solutino using stack to push itens that should be reversed, and pop them after\\n        pos = 1\\n        curr = head\\n        anter = None\\n        stack = []\\n        while pos < left:\\n            pos += 1\\n            anter = curr\\n            curr = curr.next\\n        nodoleft = anter\\n        while pos <= right:\\n            pos += 1\\n            stack.append(curr)\\n            curr = curr.next\\n        if not nodoleft:\\n            nodoleft = stack.pop()\\n            head = nodoleft\\n        while len(stack):\\n            nodoleft.next = stack.pop()\\n            nodoleft = nodoleft.next\\n        nodoleft.next = curr\\n        return head\\n\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Reverting on the way\\n        if left == right:\\n            return head\\n        prev = curr = head\\n        pos = 1\\n        while pos < left:\\n            pos += 1\\n            prev = curr\\n            curr = curr.next\\n        nleft = prev\\n        nlast = curr\\n        nfirst = curr\\n        curr = curr.next\\n        pos += 1\\n        while pos < right:\\n            pos += 1\\n            next = curr.next\\n            curr.next = nfirst\\n            nfirst = curr\\n            curr = next\\n        if left > 1:\\n            nleft.next = curr\\n        else:\\n            head = curr\\n        nlast.next = curr.next\\n        curr.next = nfirst\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292254,
                "title": "python-simulation",
                "content": "Approach 1: Simulation\\n```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @param m, an integer\\n    # @param n, an integer\\n    # @return a ListNode\\n    def reverseBetween(self, head, m, n):\\n        dummy, diff = ListNode(0), n - m\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        while m > 1:\\n            prev, curr = curr, curr.next\\n            m -= 1\\n        last_unswapped, first_swapped = prev, curr\\n        while curr and diff >= 0:\\n            curr.next, prev, curr = prev, curr, curr.next\\n            diff -= 1\\n        last_unswapped.next, first_swapped.next = prev, curr\\n        return dummy.next\\n        # Here is an exmple\\n        # 1 --> 2 --> 3 --> 4 --> 5\\n        #       \\n        # Before first while-loop\\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5\\n        #      prev  curr\\n        # After first while-loop \\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5 \\n        #            prev curr \\n        #  last_unswapped, first_swapped = prev, curr\\n        # The following is the details for 2nd while-loop\\n        # diff=2 #   1 <-- 2 --> 3 --> 4 --> 5\\n        #                 prev  curr\\n        # diff=1 #   1 <-- 2 <-- 3 --> 4 --> 5\\n        #                       prev  curr\\n        # diff=0 #   1 <-- 2 <-- 3 <-- 4 --> 5\\n        #                             prev  curr\\n        # last_unswapped.next = prev\\n        # first_swapped.next  = curr\\n        # After impletenting the above two lines, we get:\\n        #         first_swapped.next = curr\\n        #          __________________  \\n        #          ^                 |      \\n        #          |                 V \\n        # 1        2 <-- 3 <-- 4     5\\n        # |                    ^\\n        # V ___________________| \\n        # last_unswapped.next=prev    \\n        # Reverse partial Linked List\\n        # Refer Figure1: http://images.cnitblog.com/i/546654/201404/072244468407048.jpg\\n        # Refer: http://www.cnblogs.com/4everlove/p/3651002.html\\n        # Refer: http://stackoverflow.com/questions/21529359/reversing-a-linked-list-in-python\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @param m, an integer\\n    # @param n, an integer\\n    # @return a ListNode\\n    def reverseBetween(self, head, m, n):\\n        dummy, diff = ListNode(0), n - m\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        while m > 1:\\n            prev, curr = curr, curr.next\\n            m -= 1\\n        last_unswapped, first_swapped = prev, curr\\n        while curr and diff >= 0:\\n            curr.next, prev, curr = prev, curr, curr.next\\n            diff -= 1\\n        last_unswapped.next, first_swapped.next = prev, curr\\n        return dummy.next\\n        # Here is an exmple\\n        # 1 --> 2 --> 3 --> 4 --> 5\\n        #       \\n        # Before first while-loop\\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5\\n        #      prev  curr\\n        # After first while-loop \\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5 \\n        #            prev curr \\n        #  last_unswapped, first_swapped = prev, curr\\n        # The following is the details for 2nd while-loop\\n        # diff=2 #   1 <-- 2 --> 3 --> 4 --> 5\\n        #                 prev  curr\\n        # diff=1 #   1 <-- 2 <-- 3 --> 4 --> 5\\n        #                       prev  curr\\n        # diff=0 #   1 <-- 2 <-- 3 <-- 4 --> 5\\n        #                             prev  curr\\n        # last_unswapped.next = prev\\n        # first_swapped.next  = curr\\n        # After impletenting the above two lines, we get:\\n        #         first_swapped.next = curr\\n        #          __________________  \\n        #          ^                 |      \\n        #          |                 V \\n        # 1        2 <-- 3 <-- 4     5\\n        # |                    ^\\n        # V ___________________| \\n        # last_unswapped.next=prev    \\n        # Reverse partial Linked List\\n        # Refer Figure1: http://images.cnitblog.com/i/546654/201404/072244468407048.jpg\\n        # Refer: http://www.cnblogs.com/4everlove/p/3651002.html\\n        # Refer: http://stackoverflow.com/questions/21529359/reversing-a-linked-list-in-python\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250959,
                "title": "java-linkedlist-0ms-beats-100-t-c-o-n-s-c-o-1",
                "content": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        ListNode temp1 = dummy;\\n        for(int i = 0; i <= left - 2; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = right - left + 1;\\n        \\n        ListNode temp2 = temp1;\\n        for(int i = 0; i < total; i++)\\n            temp2 = temp2.next;\\n                \\n        ListNode end = temp2.next;\\n        temp2.next = null;\\n        ListNode temp = temp1.next;\\n        ListNode rev = reverseList(temp);\\n        temp1.next = rev;\\n        temp.next = end;\\n        \\n        return dummy.next;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        \\n       ListNode pre = head;\\n       ListNode curr = head.next;\\n        \\n       while(curr!=null){\\n           ListNode ahead = curr.next;\\n           curr.next = pre;\\n           pre = curr;\\n           curr = ahead;\\n       } \\n        \\n       head.next = null;\\n        \\n       ListNode temp = head;\\n       return pre;\\n    }",
                "solutionTags": [],
                "code": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        ListNode temp1 = dummy;\\n        for(int i = 0; i <= left - 2; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = right - left + 1;\\n        \\n        ListNode temp2 = temp1;\\n        for(int i = 0; i < total; i++)\\n            temp2 = temp2.next;\\n                \\n        ListNode end = temp2.next;\\n        temp2.next = null;\\n        ListNode temp = temp1.next;\\n        ListNode rev = reverseList(temp);\\n        temp1.next = rev;\\n        temp.next = end;\\n        \\n        return dummy.next;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        \\n       ListNode pre = head;\\n       ListNode curr = head.next;\\n        \\n       while(curr!=null){\\n           ListNode ahead = curr.next;\\n           curr.next = pre;\\n           pre = curr;\\n           curr = ahead;\\n       } \\n        \\n       head.next = null;\\n        \\n       ListNode temp = head;\\n       return pre;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1088300,
                "title": "simple-solution-with-explanation-0ms",
                "content": "**Simple C++ solution:** Simple swapping operation, no recursion\\n**Time: 0 ms**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* left_pos=head,*right_pos=head;\\n        int i=1,temp,diff,j;\\n        while(i!=left)\\n        {\\n            left_pos=left_pos->next;\\n            right_pos=right_pos->next;\\n            i++;\\n        }\\n        while(left<right)\\n        {\\n            right_pos=left_pos;\\n            diff=right-left;\\n            j=0;\\n            while(j!=diff)\\n            {\\n                right_pos=right_pos->next; \\n                j++;\\n            }\\n            //Swapping \\n            temp=left_pos->val;\\n            left_pos->val=right_pos->val;\\n            right_pos->val=temp;\\n            //Updating the pointers\\n            left++;\\n            right--;\\n            left_pos=left_pos->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nRuntime: 0 ms\\n*Time Comp: O(n)*\\n*Space Comp: O(1)*\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* left_pos=head,*right_pos=head;\\n        int i=1,temp,diff,j;\\n        while(i!=left)\\n        {\\n            left_pos=left_pos->next;\\n            right_pos=right_pos->next;\\n            i++;\\n        }\\n        while(left<right)\\n        {\\n            right_pos=left_pos;\\n            diff=right-left;\\n            j=0;\\n            while(j!=diff)\\n            {\\n                right_pos=right_pos->next; \\n                j++;\\n            }\\n            //Swapping \\n            temp=left_pos->val;\\n            left_pos->val=right_pos->val;\\n            right_pos->val=temp;\\n            //Updating the pointers\\n            left++;\\n            right--;\\n            left_pos=left_pos->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981806,
                "title": "java-recursive-beats-100",
                "content": "```\\nclass Solution {\\n    ListNode headTail;\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        return reverseBetween(head,  m,  n, 1);\\n    }\\n    public ListNode reverseBetween(ListNode head, int m, int n, int i) {\\n         if (head==null){\\n            return null;\\n        }\\n        if (i==n){\\n          headTail = reverseBetween(head.next,m,n,i+1);\\n          return head;  \\n        }\\n        else if (i>=m && i<n){\\n            ListNode node = reverseBetween(head.next,m,n,i+1);\\n            if (head.next!=null){\\n                head.next.next = head;\\n                head.next=null;\\n            }\\n            if (i==m){\\n                head.next = headTail;\\n            }\\n            return node;\\n        }\\n        else {\\n            head.next = reverseBetween(head.next,m,n,i+1);\\n            return head;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ListNode headTail;\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        return reverseBetween(head,  m,  n, 1);\\n    }\\n    public ListNode reverseBetween(ListNode head, int m, int n, int i) {\\n         if (head==null){\\n            return null;\\n        }\\n        if (i==n){\\n          headTail = reverseBetween(head.next,m,n,i+1);\\n          return head;  \\n        }\\n        else if (i>=m && i<n){\\n            ListNode node = reverseBetween(head.next,m,n,i+1);\\n            if (head.next!=null){\\n                head.next.next = head;\\n                head.next=null;\\n            }\\n            if (i==m){\\n                head.next = headTail;\\n            }\\n            return node;\\n        }\\n        else {\\n            head.next = reverseBetween(head.next,m,n,i+1);\\n            return head;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902722,
                "title": "java-easy-to-understand",
                "content": "////Please upvote if you like\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n     \\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        for(int i=0;i<m-1;++i)\\n        {\\n            pre=pre.next;\\n        }\\n        ListNode curr=pre.next;\\n        for(int i=0;i<n-m;++i)\\n        {\\n            ListNode Next=curr.next;\\n            curr.next=Next.next;\\n            Next.next=pre.next;\\n            pre.next=Next;\\n        }\\n        \\n       return dummy.next;    \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n     \\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        for(int i=0;i<m-1;++i)\\n        {\\n            pre=pre.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 808421,
                "title": "rust-solution-no-stack-0ms",
                "content": "Pretty straight forward, but as always, very annoying to do in Rust because of the ownership rules.\\n\\nWith `reverse_between` if `m` is 1, then we reverse starting at the beginning, otherwise, walk to one before the right position.\\nWe do one before, so we use `node.next.take()` to transfer ownership. It then links the next node to the reverse of the rest.\\n\\n`reverse`, will reverse `count` number of nodes, and then append the rest to the end. It does it recursively, so we have to pass an accumulator of `None` for the initial call.\\n\\n`append` walks the first list to the end, and then appends the second list. \\n\\n```\\nimpl Solution {\\n    pub fn reverse_between(\\n        mut head: Option<Box<ListNode>>,\\n        m: i32,\\n        n: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if m == 1 {\\n            return Self::reverse(head, None, n - m + 1);\\n        }\\n\\n        let mut count = 1;\\n        let mut current = head.as_mut();\\n        while let Some(node) = current {\\n            count += 1;\\n\\n            if count == m {\\n                node.next = Self::reverse(node.next.take(), None, n - m + 1);\\n                break;\\n            } else {\\n                current = node.next.as_mut();\\n            }\\n        }\\n\\n        head\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        acc: Option<Box<ListNode>>,\\n        count: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            return Self::append(acc, head);\\n        }\\n\\n        if let Some(mut node) = head {\\n            let next = node.next;\\n            node.next = acc;\\n\\n            Self::reverse(next, Some(node), count - 1)\\n        } else {\\n            acc\\n        }\\n    }\\n\\n    fn append(\\n        mut front: Option<Box<ListNode>>,\\n        back: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut current = front.as_mut();\\n        while let Some(node) = current {\\n            if node.next.is_none() {\\n                node.next = back;\\n                break;\\n            }\\n            current = node.next.as_mut();\\n        }\\n\\n        front\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_between(\\n        mut head: Option<Box<ListNode>>,\\n        m: i32,\\n        n: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if m == 1 {\\n            return Self::reverse(head, None, n - m + 1);\\n        }\\n\\n        let mut count = 1;\\n        let mut current = head.as_mut();\\n        while let Some(node) = current {\\n            count += 1;\\n\\n            if count == m {\\n                node.next = Self::reverse(node.next.take(), None, n - m + 1);\\n                break;\\n            } else {\\n                current = node.next.as_mut();\\n            }\\n        }\\n\\n        head\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        acc: Option<Box<ListNode>>,\\n        count: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            return Self::append(acc, head);\\n        }\\n\\n        if let Some(mut node) = head {\\n            let next = node.next;\\n            node.next = acc;\\n\\n            Self::reverse(next, Some(node), count - 1)\\n        } else {\\n            acc\\n        }\\n    }\\n\\n    fn append(\\n        mut front: Option<Box<ListNode>>,\\n        back: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut current = front.as_mut();\\n        while let Some(node) = current {\\n            if node.next.is_none() {\\n                node.next = back;\\n                break;\\n            }\\n            current = node.next.as_mut();\\n        }\\n\\n        front\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560525,
                "title": "simple-python-solution-faster-than-93",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        a = []\\n        for i in range(n): #leave the tail unchanged\\n            a.append(head)\\n            head = head.next\\n            \\n        a = a[:m-1] + a[m-1:][::-1] #reverse the middle part\\n        \\n        for i in range(len(a)-1, -1, -1): #link all nodes\\n            tmp = a[i]\\n            tmp.next = head\\n            head = tmp\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        a = []\\n        for i in range(n): #leave the tail unchanged\\n            a.append(head)\\n            head = head.next\\n            \\n        a = a[:m-1] + a[m-1:][::-1] #reverse the middle part\\n        \\n        for i in range(len(a)-1, -1, -1): #link all nodes\\n            tmp = a[i]\\n            tmp.next = head\\n            head = tmp\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509552,
                "title": "python3-solution-in-single-pass-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        count = 1\\n        prev = None\\n        prev_r = None\\n        temp = head\\n        last = None\\n        while temp:\\n            if count==n:\\n                actual_last = temp\\n                last = temp.next\\n            if count<m:\\n                prev_r = temp\\n            if count==m:\\n                actual = temp\\n            if count>=m and count<=n:\\n                next = temp.next\\n                temp.next = prev\\n                prev = temp\\n                temp = next\\n            else:\\n                prev = temp\\n                temp = temp.next\\n            count+=1\\n        actual.next = last\\n        if prev_r==None:\\n            return actual_last\\n        else:\\n            prev_r.next = actual_last\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        count = 1\\n        prev = None\\n        prev_r = None\\n        temp = head\\n        last = None\\n        while temp:\\n            if count==n:\\n                actual_last = temp\\n                last = temp.next\\n            if count<m:\\n                prev_r = temp\\n            if count==m:\\n                actual = temp\\n            if count>=m and count<=n:\\n                next = temp.next\\n                temp.next = prev\\n                prev = temp\\n                temp = next\\n            else:\\n                prev = temp\\n                temp = temp.next\\n            count+=1\\n        actual.next = last\\n        if prev_r==None:\\n            return actual_last\\n        else:\\n            prev_r.next = actual_last\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319298,
                "title": "easy-to-read-java-beats-100",
                "content": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode back = dummy, front = dummy;\\n        for (int i = 0; i < m - 1; i++) back = back.next;\\n        for (int i = 0; i < n + 1; i++) front = front.next;\\n        \\n        ListNode prev = front;\\n        ListNode curr = back.next;\\n        while (curr != front) {\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        back.next = prev;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode back = dummy, front = dummy;\\n        for (int i = 0; i < m - 1; i++) back = back.next;\\n        for (int i = 0; i < n + 1; i++) front = front.next;\\n        \\n        ListNode prev = front;\\n        ListNode curr = back.next;\\n        while (curr != front) {\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        back.next = prev;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318517,
                "title": "swift-top-97-single-pass-o-n-solution-shorter-shortest",
                "content": "I know it\\'s possible to get it shorter by combining operations.\\n\\nThis is as short as I can get it, using a sentinel node to accommodate reversed first portions...\\n\\n      [1, 2, 3, 4, 5, 6] 1  3\\n=> [3, 2, 1, 4, 5, 6]\\n\\n```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n        \\n        var sentinel = ListNode(0)\\n        sentinel.next = head\\n        var prev: ListNode? = sentinel\\n        var node: ListNode? = head\\n        \\n        var index = 1\\n        while index < m && node != nil {\\n            prev = node\\n            node = node!.next\\n            index += 1\\n        }\\n        \\n        var m_tail: ListNode! = prev\\n        var n_head: ListNode? = node\\n        \\n        var next: ListNode?\\n        while index <= n && node != nil {\\n            next = node!.next\\n            node!.next = prev\\n            prev = node\\n            node = next\\n            index += 1\\n        }\\n        \\n        m_tail.next = prev\\n        n_head?.next = node\\n        \\n        return sentinel.next\\n    }\\n}\\n```\\n\\nPretty good. If you think you can beat it, send me a hatemail. I will not reply. This question is for pleebs and daywalkers.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n        \\n        var sentinel = ListNode(0)\\n        sentinel.next = head\\n        var prev: ListNode? = sentinel\\n        var node: ListNode? = head\\n        \\n        var index = 1\\n        while index < m && node != nil {\\n            prev = node\\n            node = node!.next\\n            index += 1\\n        }\\n        \\n        var m_tail: ListNode! = prev\\n        var n_head: ListNode? = node\\n        \\n        var next: ListNode?\\n        while index <= n && node != nil {\\n            next = node!.next\\n            node!.next = prev\\n            prev = node\\n            node = next\\n            index += 1\\n        }\\n        \\n        m_tail.next = prev\\n        n_head?.next = node\\n        \\n        return sentinel.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264533,
                "title": "go-double-100",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    shadowHead := &ListNode{ Next: head }\\n    prevNode := shadowHead\\n    for i := 1; i < m; i++ {\\n        prevNode = prevNode.Next\\n        head = head.Next\\n    }\\n    mNode := head\\n    nNode := head.Next\\n    for i := m; i < n; i++ {\\n        nextNNode := nNode.Next\\n        nNode.Next = head\\n        head = nNode\\n        nNode = nextNNode\\n    }\\n    mNode.Next = nNode\\n    prevNode.Next = head\\n    return shadowHead.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    shadowHead := &ListNode{ Next: head }\\n    prevNode := shadowHead\\n    for i := 1; i < m; i++ {\\n        prevNode = prevNode.Next\\n        head = head.Next\\n    }\\n    mNode := head\\n    nNode := head.Next\\n    for i := m; i < n; i++ {\\n        nextNNode := nNode.Next\\n        nNode.Next = head\\n        head = nNode\\n        nNode = nextNNode\\n    }\\n    mNode.Next = nNode\\n    prevNode.Next = head\\n    return shadowHead.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216869,
                "title": "c-clean-code-with-explaination-drawing",
                "content": "Try to maintain prev, curr, and next Nodes along the line\\n\\nInitialize: \\nSet dummy and prev nodes point to head of linked list. Then move prev node before current node. \\nCurrent node is set at where reversion occurs\\n![image](https://assets.leetcode.com/users/uyenmnguyen/image_1547165157.png)\\n\\nWhile m++ < n, move pre and current along the line\\n![image](https://assets.leetcode.com/users/uyenmnguyen/image_1547165727.png)\\n\\nFinally, return dummy.next;\\n```\\n public ListNode ReverseBetween(ListNode head, int m, int n) {\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n      \\n      ListNode pre = dummy;\\n      for(int i = 1; i < m; i++)\\n        pre = pre.next;\\n      \\n      ListNode cur = pre.next;\\n      while(m ++ <n)\\n      {\\n          var temp = cur.next;\\n          cur.next = temp.next;\\n          temp.next = pre.next;\\n          pre.next = temp;\\n      }\\n      \\n      return dummy.next;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n public ListNode ReverseBetween(ListNode head, int m, int n) {\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n      \\n      ListNode pre = dummy;\\n      for(int i = 1; i < m; i++)\\n        pre = pre.next;\\n      \\n      ListNode cur = pre.next;\\n      while(m ++ <n)\\n      {\\n          var temp = cur.next;\\n          cur.next = temp.next;\\n          temp.next = pre.next;\\n          pre.next = temp;\\n      }\\n      \\n      return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30801,
                "title": "easy-to-understand-c-solution",
                "content": "This is a partial reversal, we need to find the left interface (let it be `leftI`, `(m-1)th` node) to link the head of reversed list, and the tail of reversed list will link with the right interface(let it be `rightI`, `(n+1)th` node).  This sounds all right, what if `m = 1`? There is nothing left to the head. A common way to do is to introduce a dummy head. So now there are four things to do:\\n\\n    1. Find and record leftI\\n    2. Reverse sublist [m,n] -> [rhead, rtail]\\n    3. Find and record rightI\\n    4. Relink: leftI->next = rhead, rtail->next = rightI \\n    5. Return dummy->next\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode *leftI = dummy;\\n            for(; --m; --n) leftI = leftI->next; \\n    \\n            ListNode *cur = leftI->next, *rtail = cur, *pre = nullptr;\\n            while(n--){\\n                ListNode* nxt = cur->next;\\n                cur->next = pre;\\n                pre = cur;\\n                cur = nxt;\\n            }\\n            rtail->next = cur; leftI->next = pre;\\n    \\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode *leftI = dummy;\\n            for(; --m; --n) leftI = leftI->next; \\n    \\n            ListNode *cur = leftI->next, *rtail = cur, *pre = nullptr;\\n            while(n--){\\n                ListNode* nxt = cur->next;\\n                cur->next = pre;\\n                pre = cur;\\n                cur = nxt;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4014442,
                "title": "beats-100-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n\\n    struct ListNode *p = head,*k=head;\\n    int i = 1,kk=0;\\n    int a[100000];\\n    while(p!=NULL){\\n        if (i>=left && i<=right){\\n            a[kk++]=p->val;\\n        }\\n        p=p->next;\\n        i++;\\n    }\\n    i=1;\\n    while(k!=NULL){\\n        if (i>=left && i<=right){\\n            k->val=a[--kk];\\n        }\\n        k=k->next;\\n        i++;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n\\n    struct ListNode *p = head,*k=head;\\n    int i = 1,kk=0;\\n    int a[100000];\\n    while(p!=NULL){\\n        if (i>=left && i<=right){\\n            a[kk++]=p->val;\\n        }\\n        p=p->next;\\n        i++;\\n    }\\n    i=1;\\n    while(k!=NULL){\\n        if (i>=left && i<=right){\\n            k->val=a[--kk];\\n        }\\n        k=k->next;\\n        i++;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013373,
                "title": "o-ms-beats-100-users-java-easy-approach-for-beginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right)  {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size =0;\\n        ListNode temp = head;\\n        ListNode leftNode  = null;\\n        ListNode rightNode  = null;\\n        List<Integer> arr = new ArrayList<>();\\n        while(temp != null ){\\n            size++;\\n            if(size == left){\\n                leftNode = temp;\\n            }\\n            if(size >= left && size <= right){\\n                arr.add(temp.val);\\n            }\\n            if(size == right){\\n                rightNode= temp;\\n            }\\n            temp = temp.next;\\n        }\\n        int sizes = left;\\n        int arrSize = arr.size()-1;\\n        while(sizes <= right){\\n            leftNode.val = arr.get(arrSize--);\\n            leftNode = leftNode.next;\\n            sizes++;\\n        }\\n\\n\\n        return head;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right)  {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size =0;\\n        ListNode temp = head;\\n        ListNode leftNode  = null;\\n        ListNode rightNode  = null;\\n        List<Integer> arr = new ArrayList<>();\\n        while(temp != null ){\\n            size++;\\n            if(size == left){\\n                leftNode = temp;\\n            }\\n            if(size >= left && size <= right){\\n                arr.add(temp.val);\\n            }\\n            if(size == right){\\n                rightNode= temp;\\n            }\\n            temp = temp.next;\\n        }\\n        int sizes = left;\\n        int arrSize = arr.size()-1;\\n        while(sizes <= right){\\n            leftNode.val = arr.get(arrSize--);\\n            leftNode = leftNode.next;\\n            sizes++;\\n        }\\n\\n\\n        return head;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013213,
                "title": "simplest-ruby-solution-95",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI\\'ve attached the explanation of this problem here if the code isn\\'t clear enough. Super simple using only pointers.\\n[Solution JS/TS](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4013174/simplest-solution-0-n-time-95/)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {ListNode}\\ndef reverse_between(head, left, right)\\n    return head if left == right\\n    dummy = ListNode.new(0, @next=head)\\n    prev = dummy\\n    i = 1\\n\\n    # Set prev to pointer before left\\n    while i < left\\n        prev = prev.next\\n        i += 1\\n    end\\n\\n    curr = prev.next\\n    next_node = curr.next\\n\\n    # Begin reverse process with node at left and its next node \\n    while i < right\\n        temp = next_node.next\\n        next_node.next = curr\\n        curr = next_node\\n\\n        next_node = temp\\n        i += 1\\n    end\\n    \\n    # Set prev (1) next pointers to the in-between reversed list end i.e example1 = 4 -> 3 -> 2 AND\\n    # remaining part of the linked list i.e 5 -> nil\\n    prev.next.next = next_node\\n    prev.next = curr\\n\\n    dummy.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {ListNode}\\ndef reverse_between(head, left, right)\\n    return head if left == right\\n    dummy = ListNode.new(0, @next=head)\\n    prev = dummy\\n    i = 1\\n\\n    # Set prev to pointer before left\\n    while i < left\\n        prev = prev.next\\n        i += 1\\n    end\\n\\n    curr = prev.next\\n    next_node = curr.next\\n\\n    # Begin reverse process with node at left and its next node \\n    while i < right\\n        temp = next_node.next\\n        next_node.next = curr\\n        curr = next_node\\n\\n        next_node = temp\\n        i += 1\\n    end\\n    \\n    # Set prev (1) next pointers to the in-between reversed list end i.e example1 = 4 -> 3 -> 2 AND\\n    # remaining part of the linked list i.e 5 -> nil\\n    prev.next.next = next_node\\n    prev.next = curr\\n\\n    dummy.next\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012897,
                "title": "easy-neat-and-clean-code-for-daily-leetcode-challenge",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseLL(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr!=NULL){\\n            ListNode* currkanext = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = currkanext;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(!head || head->next==NULL){\\n            return head;\\n        }\\n        \\n        left--;\\n        right--;\\n        \\n        ListNode* dummy1 = new ListNode(-1);\\n        ListNode* dummy2 = new ListNode(-1);\\n        ListNode* dummy3 = new ListNode(-1); \\n        \\n        ListNode* head1 = dummy1;\\n        \\n        ListNode* head2 = dummy2;\\n        \\n        ListNode* head3 = dummy3;\\n        \\n        ListNode* temp = head;\\n        for(int i=0;i<left;i++){\\n            dummy1->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        for(int i=left;i<=right;i++){\\n            dummy2->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        while(temp!=NULL){\\n            dummy3->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy3 = dummy3->next;\\n        }\\n        \\n        ListNode* dummy = head2->next;\\n        \\n        ListNode* node = reverseLL(head2->next);\\n        \\n        dummy1->next = node;\\n        \\n        cout<<dummy2->val<<endl;\\n        \\n        dummy->next = head3->next;\\n        \\n        return head1->next;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseLL(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr!=NULL){\\n            ListNode* currkanext = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = currkanext;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(!head || head->next==NULL){\\n            return head;\\n        }\\n        \\n        left--;\\n        right--;\\n        \\n        ListNode* dummy1 = new ListNode(-1);\\n        ListNode* dummy2 = new ListNode(-1);\\n        ListNode* dummy3 = new ListNode(-1); \\n        \\n        ListNode* head1 = dummy1;\\n        \\n        ListNode* head2 = dummy2;\\n        \\n        ListNode* head3 = dummy3;\\n        \\n        ListNode* temp = head;\\n        for(int i=0;i<left;i++){\\n            dummy1->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        for(int i=left;i<=right;i++){\\n            dummy2->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        while(temp!=NULL){\\n            dummy3->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy3 = dummy3->next;\\n        }\\n        \\n        ListNode* dummy = head2->next;\\n        \\n        ListNode* node = reverseLL(head2->next);\\n        \\n        dummy1->next = node;\\n        \\n        cout<<dummy2->val<<endl;\\n        \\n        dummy->next = head3->next;\\n        \\n        return head1->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4012812,
                "title": "beats-100-python-c-java-easy-linked-list",
                "content": "\\n```Python []\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if left >= right:\\n            return head\\n           \\n        ohead = newhd = ListNode(0)\\n        whead = wlast = head\\n        newhd.next = head\\n        for i in range(right-left):\\n            wlast = wlast.next\\n        for i in range(left-1):\\n            ohead, whead, wlast = whead, whead.next, wlast.next \\n        olast, wlast.next = wlast.next, None\\n        revhead, revlast = self.reverse(whead)\\n        ohead.next, revlast.next = revhead, olast\\n        return newhd.next\\n            \\n    def reverse(self, head):\\n        pre, curr, last = None, head, head\\n        while curr:\\n            curr.next, pre, curr = pre, curr, curr.next\\n        return pre, last\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* dummy = new ListNode(0), *pre = dummy , *curr;\\n        dummy->next = head;\\n\\n        for(int i = 0 ; i< left-1 ; i++){\\n            pre = pre->next;\\n        }\\n        curr = pre->next;\\n        pre->next = NULL;\\n        ListNode* l1 = curr;\\n\\n        ListNode* prev = NULL;\\n\\n        for(int i =0 ; i<= right-left ; i++){\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        l1->next = curr;\\n        pre->next = prev;\\n        return dummy->next;\\n\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode curr=head;\\n        int v[]=new int[right-left+1];\\n        int l=0,r=0;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n        while(r<right){  \\n            v[l]=curr.val;\\n            curr=curr.next;\\n            l++;\\n            r++;\\n        }\\n        r=0;l--;\\n        curr=head;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n            while(r<right){\\n                curr.val=v[l];\\n                curr=curr.next;\\n                l--;\\n                r++; \\n            }\\n    return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if left >= right:\\n            return head\\n           \\n        ohead = newhd = ListNode(0)\\n        whead = wlast = head\\n        newhd.next = head\\n        for i in range(right-left):\\n            wlast = wlast.next\\n        for i in range(left-1):\\n            ohead, whead, wlast = whead, whead.next, wlast.next \\n        olast, wlast.next = wlast.next, None\\n        revhead, revlast = self.reverse(whead)\\n        ohead.next, revlast.next = revhead, olast\\n        return newhd.next\\n            \\n    def reverse(self, head):\\n        pre, curr, last = None, head, head\\n        while curr:\\n            curr.next, pre, curr = pre, curr, curr.next\\n        return pre, last\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* dummy = new ListNode(0), *pre = dummy , *curr;\\n        dummy->next = head;\\n\\n        for(int i = 0 ; i< left-1 ; i++){\\n            pre = pre->next;\\n        }\\n        curr = pre->next;\\n        pre->next = NULL;\\n        ListNode* l1 = curr;\\n\\n        ListNode* prev = NULL;\\n\\n        for(int i =0 ; i<= right-left ; i++){\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        l1->next = curr;\\n        pre->next = prev;\\n        return dummy->next;\\n\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode curr=head;\\n        int v[]=new int[right-left+1];\\n        int l=0,r=0;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n        while(r<right){  \\n            v[l]=curr.val;\\n            curr=curr.next;\\n            l++;\\n            r++;\\n        }\\n        r=0;l--;\\n        curr=head;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n            while(r<right){\\n                curr.val=v[l];\\n                curr=curr.next;\\n                l--;\\n                r++; \\n            }\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012776,
                "title": "why-dummy-node-declaration-simplify-the-code-here-is-the-perfect-soln-with-great-explanation",
                "content": "#### The dummy ListNode declaration in this code is used to simplify the code when handling edge cases where the reversal of nodes needs to occur within the given linked list. Specifically, it helps in handling the cases where left is equal to 1 or where left is greater than 1.\\n\\n##### 1.left is equal to 1: In this case, the dummy ListNode (tmep) allows you to insert a new node at the beginning of the linked list to handle the reversal. Without a dummy node, you would need special logic to handle the case where the reversal starts from the head of the linked list.\\n\\n##### 2.left is greater than 1: In this case, the dummy ListNode is used to create a reference (prev) to the node just before the left-th node.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Check if the input list is empty; if so, return it as is.\\n        if (!head) return head;\\n\\n        // Create a dummy node with a value of 0 and set its next to the head.\\n        ListNode *temp = new ListNode(0);\\n        temp->next = head;\\n\\n        // Initialize a \\'prev\\' pointer to the dummy node.\\n        ListNode *prev = temp;\\n\\n        // Move \\'prev\\' to the node just before the \\'left\\' index.\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        // Initialize a \\'curr\\' pointer to \\'prev->next\\'.\\n        ListNode *curr = prev->next;\\n\\n        // Reverse the portion of the list between \\'left\\' and \\'right\\'.\\n        for (int i = 0; i < right - left; i++) {\\n            // Store the next node after \\'curr\\' in \\'nex\\'.\\n            ListNode* nex = curr->next;\\n\\n            // Update the next of \\'curr\\' to point to the node after \\'nex\\',\\n            // effectively detaching \\'curr\\' from the list.\\n            curr->next = nex->next;\\n\\n            // Update \\'nex->next\\' to point to \\'prev->next\\', effectively reversing\\n            // the direction of the next pointer of \\'nex\\'.\\n            nex->next = prev->next;\\n\\n            // Update \\'prev->next\\' to point to \\'nex\\', effectively linking \\'nex\\'\\n            // as the new next node after \\'prev\\'.\\n            prev->next = nex;\\n        }\\n\\n        // Return the modified linked list, starting from \\'temp->next\\'.\\n        return temp->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Check if the input list is empty; if so, return it as is.\\n        if (!head) return head;\\n\\n        // Create a dummy node with a value of 0 and set its next to the head.\\n        ListNode *temp = new ListNode(0);\\n        temp->next = head;\\n\\n        // Initialize a \\'prev\\' pointer to the dummy node.\\n        ListNode *prev = temp;\\n\\n        // Move \\'prev\\' to the node just before the \\'left\\' index.\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        // Initialize a \\'curr\\' pointer to \\'prev->next\\'.\\n        ListNode *curr = prev->next;\\n\\n        // Reverse the portion of the list between \\'left\\' and \\'right\\'.\\n        for (int i = 0; i < right - left; i++) {\\n            // Store the next node after \\'curr\\' in \\'nex\\'.\\n            ListNode* nex = curr->next;\\n\\n            // Update the next of \\'curr\\' to point to the node after \\'nex\\',\\n            // effectively detaching \\'curr\\' from the list.\\n            curr->next = nex->next;\\n\\n            // Update \\'nex->next\\' to point to \\'prev->next\\', effectively reversing\\n            // the direction of the next pointer of \\'nex\\'.\\n            nex->next = prev->next;\\n\\n            // Update \\'prev->next\\' to point to \\'nex\\', effectively linking \\'nex\\'\\n            // as the new next node after \\'prev\\'.\\n            prev->next = nex;\\n        }\\n\\n        // Return the modified linked list, starting from \\'temp->next\\'.\\n        return temp->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012514,
                "title": "video-solution-explanation-with-drawings-in-depth-java-c",
                "content": "# Intuition,approach, and complexity discussed in detail in video solution\\nhttps://youtu.be/OTgS22UDGSY\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummyHead = new ListNode(), *rangeHead = NULL, *prevNode = dummyHead, *currNode = head, *rangeTail = NULL, *rangeHeadPrev = prevNode; \\n        dummyHead->next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode->next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode* nextNode = currNode->next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode->next = (nodeNum != left) ? prevNode : NULL;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }   \\n        rangeHeadPrev->next = rangeTail;\\n        rangeHead->next = currNode;\\n        return dummyHead->next;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode  dummyHead = new ListNode(),  rangeHead = null,  prevNode = dummyHead,  currNode = head,  rangeTail = null,  rangeHeadPrev = prevNode; \\n        dummyHead.next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode.next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode  nextNode = currNode.next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode.next = (nodeNum != left) ? prevNode : null;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }\\n        rangeHeadPrev.next = rangeTail;\\n        rangeHead.next = currNode;\\n        return dummyHead.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummyHead = new ListNode(), *rangeHead = NULL, *prevNode = dummyHead, *currNode = head, *rangeTail = NULL, *rangeHeadPrev = prevNode; \\n        dummyHead->next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode->next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode* nextNode = currNode->next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode->next = (nodeNum != left) ? prevNode : NULL;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }   \\n        rangeHeadPrev->next = rangeTail;\\n        rangeHead->next = currNode;\\n        return dummyHead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode  dummyHead = new ListNode(),  rangeHead = null,  prevNode = dummyHead,  currNode = head,  rangeTail = null,  rangeHeadPrev = prevNode; \\n        dummyHead.next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode.next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode  nextNode = currNode.next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode.next = (nodeNum != left) ? prevNode : null;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }\\n        rangeHeadPrev.next = rangeTail;\\n        rangeHead.next = currNode;\\n        return dummyHead.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012440,
                "title": "beats-100-with-proper-explanation-and-visualisation",
                "content": "\\n# Approach\\nSo firstly return ```null``` if ```head``` doesn\\'t exist.\\n\\n- Now , since we have to reverse the list from ```left to right``` we will first traverse till our ```left``` node, this we will do with the help of our ```prev``` Node, prev would point to the node before (previous) to our left node.\\n- So our ```current``` node would be prev->next.\\n- Create a ```next``` node pointing to ```null```, this will tell us which node to process next.\\n- Now for ```right- left times``` , i.e for the given number of nodes starting left, we reverse the linked list.\\n- This is done by \\n```\\nnext = current->next;\\ncurrent->next = next->next;\\nnext->next = prev->next;\\nprev->next = next;\\n```\\n# Refer to the image below for first test case\\n![image.png](https://assets.leetcode.com/users/images/9402f82d-73a5-4354-9d9e-095c23734f78_1694062838.3300138.png)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Handle the edge case of an empty list\\n    if (!head) return nullptr;\\n    \\n    // Create a dummy node to handle the case when left = 1\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    \\n    // Move to the node before the sublist\\n    ListNode* prev = dummy;\\n    for (int i = 0; i < left - 1; i++) {\\n        prev = prev->next;\\n    }\\n    \\n    // Start reversing the sublist\\n    ListNode* current = prev->next;\\n    ListNode* next = nullptr;\\n    \\n    for (int i = 0; i < right - left; i++) {\\n        next = current->next;\\n        current->next = next->next;\\n        next->next = prev->next;\\n        prev->next = next;\\n    }\\n    \\n    return dummy->next;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```null```\n```head```\n```left to right```\n```left```\n```prev```\n```current```\n```next```\n```null```\n```right- left times```\n```\\nnext = current->next;\\ncurrent->next = next->next;\\nnext->next = prev->next;\\nprev->next = next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Handle the edge case of an empty list\\n    if (!head) return nullptr;\\n    \\n    // Create a dummy node to handle the case when left = 1\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    \\n    // Move to the node before the sublist\\n    ListNode* prev = dummy;\\n    for (int i = 0; i < left - 1; i++) {\\n        prev = prev->next;\\n    }\\n    \\n    // Start reversing the sublist\\n    ListNode* current = prev->next;\\n    ListNode* next = nullptr;\\n    \\n    for (int i = 0; i < right - left; i++) {\\n        next = current->next;\\n        current->next = next->next;\\n        next->next = prev->next;\\n        prev->next = next;\\n    }\\n    \\n    return dummy->next;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012418,
                "title": "reverse-linked-list-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* revList(ListNode* head){\\n        if(head==NULL || head->next==NULL) return head;\\n        ListNode* temp= revList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return temp;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right) return head;\\n        ListNode* prev=NULL;\\n        int l=1;\\n        ListNode* temp=head;\\n        while(l<left){\\n            prev=temp;\\n            temp=temp->next;\\n            l++;\\n        }\\n        int r=1;\\n        ListNode* temp2=head;\\n        while(r<right){\\n            temp2=temp2->next;\\n            r++;\\n        }\\n        ListNode* last=NULL;\\n        if(temp2->next){\\n            last=temp2->next;\\n            temp2->next=NULL;\\n        }\\n        if(prev){\\n            prev->next=revList(temp);\\n        }\\n        else{\\n            head=revList(temp);\\n        }\\n        temp->next=last;\\n        return head;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* revList(ListNode* head){\\n        if(head==NULL || head->next==NULL) return head;\\n        ListNode* temp= revList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return temp;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right) return head;\\n        ListNode* prev=NULL;\\n        int l=1;\\n        ListNode* temp=head;\\n        while(l<left){\\n            prev=temp;\\n            temp=temp->next;\\n            l++;\\n        }\\n        int r=1;\\n        ListNode* temp2=head;\\n        while(r<right){\\n            temp2=temp2->next;\\n            r++;\\n        }\\n        ListNode* last=NULL;\\n        if(temp2->next){\\n            last=temp2->next;\\n            temp2->next=NULL;\\n        }\\n        if(prev){\\n            prev->next=revList(temp);\\n        }\\n        else{\\n            head=revList(temp);\\n        }\\n        temp->next=last;\\n        return head;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2047146,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1734854,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1979285,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1629491,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1988688,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1568918,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047099,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1573713,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047259,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1576002,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047146,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1734854,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1979285,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1629491,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1988688,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1568918,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047099,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1573713,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047259,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1576002,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1569164,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1575680,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047900,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047861,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047595,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047177,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047101,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2019846,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1760998,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1690795,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2075985,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2066868,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048296,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048275,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048183,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048180,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048102,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048066,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047942,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047923,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047891,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047858,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047852,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047809,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047780,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047770,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047755,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047733,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047651,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047612,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047573,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047535,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047516,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047468,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047465,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047436,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047415,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047404,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047336,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047334,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047326,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047209,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047198,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047188,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047179,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047178,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047154,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047133,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047106,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2039661,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 1985697,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1945128,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1940209,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1922705,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1865106,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1848014,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1810623,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1781985,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1773687,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1757416,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Frequency",
        "question_content": "<p>Write a bash script to calculate the <span data-keyword=\"frequency-textfile\">frequency</span> of each word in a text file <code>words.txt</code>.</p>\n\n<p>For simplicity sake, you may assume:</p>\n\n<ul>\n\t<li><code>words.txt</code> contains only lowercase characters and space <code>&#39; &#39;</code> characters.</li>\n\t<li>Each word must consist of lowercase characters only.</li>\n\t<li>Words are separated by one or more whitespace characters.</li>\n</ul>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>words.txt</code> has the following content:</p>\n\n<pre>\nthe day is sunny the the\nthe sunny is is\n</pre>\n\n<p>Your script should output the following, sorted by descending frequency:</p>\n\n<pre>\nthe 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><b>Note:</b></p>\n\n<ul>\n\t<li>Don&#39;t worry about handling ties, it is guaranteed that each word&#39;s frequency count is unique.</li>\n\t<li>Could you write it in one-line using <a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 55443,
                "title": "my-simple-solution-one-line-with-pipe",
                "content": "```\\ncat words.txt | tr -s ' ' '\\\\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'\\n```\\n\\n**tr -s**: truncate the string with target string, but only remaining one instance (e.g. multiple whitespaces)\\n\\n**sort**: To make the same string successive so that `uniq` could count the same string fully and correctly.\\n\\n**uniq -c**: uniq is used to filter out the repeated lines which are successive, -c means counting\\n\\n**sort -r**: -r means sorting in descending order\\n\\n**awk '{ print $2, $1 }'**: To format the output, see [here][1].\\n\\n\\n  [1]: http://linux.cn/article-3945-1.html",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s ' ' '\\\\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849332,
                "title": "one-line-with-pipe-with-explanation",
                "content": "**One Line Solution**\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```\\n**Explanation :**\\n\\nAs per the problem we need to read `words.txt` file and then process it. To practice it by hand, let\\'s create a `words.txt` file giving our test strings.\\n\\n*creating words.txt file*\\n```\\necho \\'the day is sunny the the\\nthe sunny is is\\' > words.txt\\n```\\n\\nNow, we can see what is the output we are getting from each command joined by pipes\\n\\n**cat words.txt**\\nOutputs the content in the file in the standard output\\n```\\n\\u279C  ~ cat words.txt\\nthe day is sunny the the\\nthe sunny is is\\n```\\n\\n**tr -s \\' \\' \\'\\\\n\\'**\\n*tr -s*  uses for truncating the input as per given command followed by it. In our case, we are interested in truncating each whitespace( \\'  \\') and replace it with newline(\\'\\\\n\\') as shown below:\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n```\\n**sort**\\nThis sort the input in `ascending` order so that `uniq` can find duplicate words adjacently (order does not matter for uniq) as shown below:\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n```\\n**uniq --count**\\nThis command provides word frequency as \"count  word\" format.\\nFilter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\nNote: \\'uniq\\' does not detect repeated lines unless they are adjacent.\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n```\\n\\n**sort -r**\\n`sort -r` sorts the input in descending order.\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n```\\n**awk \\'{print $2 \" \" $1}**\\n`awk` formats the input given for each line. In our example, we want the second column ($2) appears first and the first column ($1) appears second separated by whitespace(\" \")\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```\\n*Feel free to provide feedback. *",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```\n```\\necho \\'the day is sunny the the\\nthe sunny is is\\' > words.txt\\n```\n```\\n\\u279C  ~ cat words.txt\\nthe day is sunny the the\\nthe sunny is is\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535836,
                "title": "fully-explained-100-faster-new-edge-case",
                "content": "```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\\n\\n```tr -s```  **translate, squeeze+replace:** replaces [tab, newline, vertical tab, form feed, carriage return, and space] i.e., *space characters* ```[:space:]``` with a newline ```\\\\n```.\\n```sort``` **sort:** sorts alphabetically (ascending order)\\n```uniq -c``` **unique, count:** prints after omitting repeating adjacent lines ```uniq``` along with number of occurrences ```-c```\\n```sort -nr -k 1``` **sort, numeric+reverse, key:** sorts numerically  and in reverse ```-nr``` based on the key - first column ```-k 1```\\n```awk \\'{print $2 $1}\\'``` **awk - split line into fields** splitting each line into specified fields (word first and then frequency). You can find more info on ```awk``` [here](https://www.***.org/awk-command-unixlinux-examples/).\\n\\n***EDGE CASE:***\\n\\nIn case there are **punctuations** in the text:\\n\\n```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | tr -d [:punct:] | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\\n\\n```tr -d```  **translate, delete:** deletes any [! \\u201D # $ % & \\u2018 ( ) * + , \\u2013 . / : ; < = > ? @ [ \\\\ ] ^ _ \\\\` { | } ~. ] i.e., *punctuation characters*  `[:punct:]`\\n\\n---------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------\\n\\n**A shameless plug:**\\nI do enjoy writing detailed explanations of solutions, but I too (like you probably are) am looking for a job right now and am a little short on time. \\nSo, **please give this solution an upvote** if you would like to see more of these for other problems. Thanks! :)\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\n```tr -s```\n```[:space:]```\n```\\\\n```\n```sort```\n```uniq -c```\n```uniq```\n```-c```\n```sort -nr -k 1```\n```-nr```\n```-k 1```\n```awk \\'{print $2 $1}\\'```\n```awk```\n```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | tr -d [:punct:] | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\n```tr -d```",
                "codeTag": "Unknown"
            },
            {
                "id": 55462,
                "title": "solution-using-awk-and-pipes-with-explaination",
                "content": "\\n1. I should count the words. So I chose the `awk` command.\\n  - I use a dictionary in `awk`. For every line I count every word in the dictionary.\\n  - After deal with all lines. At the `END`, use `for (item in Dict) { #do someting# } ` to print every words and its frequency.\\n2. Now the printed words are unsorted. Then I use a `|` pipes and sort it by `sort`\\n  - `sort -n` means \"compare according to string numerical value\".\\n  - `sort -r` means \"reverse the result of comparisons\".\\n  - `sort -k 2` means \"sort by the second word\"\\n\\n---\\n\\n\\n    awk '\\\\\\n    { for (i=1; i<=NF; i++) { ++D[$i]; } }\\\\\\n    END { for (i in D) { print i, D[i] } }\\\\\\n    ' words.txt | sort -nr -k 2\\n\\n---\\n\\nAre there any other solutions without `awk`?  \\nSuch as using `sed` or `grep`.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\n1. I should count the words. So I chose the `awk` command.\\n  - I use a dictionary in `awk`. For every line I count every word in the dictionary.\\n  - After deal with all lines. At the `END`, use `for (item in Dict) { #do someting# } ` to print every words and its frequency.\\n2. Now the printed words are unsorted. Then I use a `|` pipes and sort it by `sort`\\n  - `sort -n` means \"compare according to string numerical value\".\\n  - `sort -r` means \"reverse the result of comparisons\".\\n  - `sort -k 2` means \"sort by the second word\"\\n\\n---\\n\\n\\n    awk '\\\\\\n    { for (i=1; i<=NF; i++) { ++D[$i]; } }\\\\\\n    END { for (i in D) { print i, D[i] } }\\\\\\n    ' words.txt | sort -nr -k 2\\n\\n---\\n\\nAre there any other solutions without `awk`?  \\nSuch as using `sed` or `grep`.",
                "codeTag": "Unknown"
            },
            {
                "id": 2621959,
                "title": "shell-explained-easy-to-understand",
                "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'`\\nExplanation :\\n`tr -s \\' \\' \\'\\\\n\\'`\\n**tr -s** uses for truncating the input as per given command followed by it. In our case, we are interested in truncating each whitespace( \\' \\') and replace it with newline(\\'\\\\n\\') as shown below:\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'` will look like this -\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n`sort`\\nThis sort the input in ascending order so that uniq can find duplicate words adjacently (order does not matter for uniq) as shown below:\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort`\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n`uniq --count`\\nThis command provides word frequency as \"count word\" format.\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count`\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n`sort -r`\\nsort -r sorts the input in descending order.\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r`\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n`awk \\'{print $2 \" \" $1}`\\nawk formats the input given for each line. In our example, we want the second column ($2) appears first and the first column ($1) appears second separated by whitespace(\" \")\\n\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "solutionTags": [],
                "code": "```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559560,
                "title": "bash-192-word-frequency-one-line-0ms-beats-100-sed-sort-uniq-awk",
                "content": "```bash\\nsed -e \\'s/ /\\\\n/g\\' words.txt | sed -e \\'/^$/d\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n### Explanation\\n`sed -e \\'s/ /\\\\n/g\\' word.txt` - converts spaces to newlines to give us one word per line\\n`sed -e \\'/^$/d\\'` - deletes blank lines\\n`sort` - sorts the word alphabetically (this is needed for `uniq -c` to work)\\n`uniq -c` - outputs each word *preceded* by the frequency count\\n`sort -r` - sorts in decreasing frequency order\\n`awk \\'{ print $2\" \"$1}\\'` - swaps the column order to match the question\\'s requirements.\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```bash\\nsed -e \\'s/ /\\\\n/g\\' words.txt | sed -e \\'/^$/d\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218865,
                "title": "192-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- cat words.txt reads the contents of the file\\n- tr -s \\' \\' \\'\\\\n\\' replaces all spaces with newlines to separate each word into its own line\\n- sort sorts the words in alphabetical order\\n- uniq -c counts the frequency of each unique word\\n- sort -rn sorts the words in descending order of frequency\\n- awk \\'{print $2 \" \" $1}\\' prints the output in the desired format of \"word count\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559512,
                "title": "bash-two-solutions-command-script",
                "content": "Method 1 - piping commands (4ms)\\n```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```\\n\\nMethod 2 - associative array in bash script (16ms) \\n```\\ndeclare -A arr #associative array\\n\\nwhile IFS= read -r line\\ndo\\n    for word in $line\\n    do\\n        let arr[$word]=${arr[$word]}+1\\n    done\\ndone < words.txt\\n\\nfor key in ${!arr[@]}\\ndo\\n    echo $key ${arr[$key]}\\ndone | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```\n```\\ndeclare -A arr #associative array\\n\\nwhile IFS= read -r line\\ndo\\n    for word in $line\\n    do\\n        let arr[$word]=${arr[$word]}+1\\n    done\\ndone < words.txt\\n\\nfor key in ${!arr[@]}\\ndo\\n    echo $key ${arr[$key]}\\ndone | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395274,
                "title": "using-cat-tr-sed-sort-uniq-and-awk",
                "content": "```bash\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sed \\'/^$/d\\' -  | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```\\n\\nFor example, consider the words.txt file to consist:\\n```\\na b b c c c c c\\n```\\n\\n1. `cat words.txt` : writes the content of the file `words.txt` onto standard output.\\n2. `tr \\' \\' \\'\\\\n\\'` : converts whitespaces to newlines.\\n3. `sed \\'/^$/d\\'`: removes any empty words.\\n4. `sort`: sort the words\\n5. `uniq -c`: gives the unique words an its count\\n\\nExample output of commands till now.\\n```\\n\\t1 a\\n\\t2 b\\n\\t5 c\\n```\\n\\n6. `sort -nr`: sort the output considering numerical and in descending order.\\nEx, output:\\n```\\n\\t5 c\\n\\t2 b\\n\\t1 a\\n```\\n\\n7. `awk \\'{print $1 \" \" $2}\\'`: print the word first and then the count, also removes the initial whitespaces\\n\\nFinal output: \\n```\\nc 5\\nb 2\\n1 a\\n```\\n\\nI enjoy using the pipelines, and multiple utilities, where each does it own work perfectly!",
                "solutionTags": [],
                "code": "```bash\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sed \\'/^$/d\\' -  | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```\n```\\na b b c c c c c\\n```\n```\\n\\t1 a\\n\\t2 b\\n\\t5 c\\n```\n```\\n\\t5 c\\n\\t2 b\\n\\t1 a\\n```\n```\\nc 5\\nb 2\\n1 a\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55472,
                "title": "share-my-accepted-solution-using-awk-and-sort",
                "content": "    cat words.txt | awk '{for(i=1;i<=NF;++i){count[$i]++}} END{for(i in count) {print i,count[i]}}' | sort -k2nr",
                "solutionTags": [],
                "code": "    cat words.txt | awk '{for(i=1;i<=NF;++i){count[$i]++}} END{for(i in count) {print i,count[i]}}' | sort -k2nr",
                "codeTag": "Unknown"
            },
            {
                "id": 862661,
                "title": "did-this-four-ways-fastest-was-gawk-with-built-in-sort-0ms",
                "content": "My first solution was essentially the same as a bunch of people, pipeline using tr and sort -nr, 4 ms runtime, 3.3MB memory footprint.\\n\\nNext up I figured I would dust off awk, but I still piped it to sort -k2 -nr, and the speed and footprint result was the same of the first solve.\\n\\nThe third result was sort of surprising...  I did it this time using a bash-native associative array. I thought this would be faster, but it ended up being 12 ms runtime, but 3.0 memory footprint (100th percentile). I probably read the file and words in inefficiently.\\n\\nFinally, I ended up looking at the gawk manual and found that it has a pretty sweet extension for built in array sorting, which led to a 0 ms runtime and 3.3 mb footprint, here it is:\\n\\n```\\ngawk -F\\' \\' \\'BEGIN {PROCINFO[\"sorted_in\"]=\"@val_num_desc\"} {for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngawk -F\\' \\' \\'BEGIN {PROCINFO[\"sorted_in\"]=\"@val_num_desc\"} {for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197037,
                "title": "1-line-solution",
                "content": "```\\ncat words.txt | tr [:space:] \"\\\\n\" | sed \\'/^$/d\\' | tr \\'[:upper:]\\' \\'[:lower:]\\'|sort|uniq -c|sort -nr| awk \\'{print $2\" \"$1}\\'\\n```\\n\\n* cat: open content\\n* tr: replace all space with newline ( all words will be as one line )\\n* tr: convert all to lowercase\\n* sort: sort alpha\\n* uniq: count word\\n* sort: sort with reverse order\\n* awk: print by format we want",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr [:space:] \"\\\\n\" | sed \\'/^$/d\\' | tr \\'[:upper:]\\' \\'[:lower:]\\'|sort|uniq -c|sort -nr| awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693026,
                "title": "pipe-solution-single-line",
                "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'`",
                "solutionTags": [],
                "code": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 185847,
                "title": "bash-solution-one-small-line",
                "content": "```\\ncat words.txt | tr -s \\' \\' \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```\\n\\nVery concise and tiny solution, extra good and very small. I love it.",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256787,
                "title": "simple-solution-grep-sort-uniq-awk",
                "content": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997540,
                "title": "one-line-python-horror-solution",
                "content": "# Why learn how to use bash when you can just write Python?\\n***Runtime: 290 ms, faster than 5.16% of Bash online submissions for Word Frequency.\\nMemory Usage: 9.6 MB, less than 37.52% of Bash online submissions for Word Frequency.***\\n\\nI used the Python exec() function to parse through my code written as a string and used here-string (<<<) to send everything to python3.exe in bash\\n```\\npython3 <<< \\'exec(\"import re\\\\na=open(\\\\\"words.txt\\\\\")\\\\nb=a.read().strip()\\\\na.close();z=b.split(\\\\\"\\\\\\\\n\\\\\");y=\\\\\" \\\\\".join(z)\\\\nc=re.split(r\\\\\"\\\\s+\\\\\",y);d=dict()\\\\nfor w in c:x=d.get(w,0);d[w]=x+1\\\\nout=[(w[1],w[0]) for w in list(d.items())];out.sort(reverse=True)\\\\nfor o in out:print(o[1],o[0])\")\\'\\n```\\n\\nMy (human-readable) solution is:\\n```\\nimport re\\na = open(\"words.txt\")\\nb = a.read().strip()\\na.close()\\nz = b.split(\"\\\\n\")\\ny=\" \".join(z)\\n# I used regex to split on any whitespace bc I failed a test case\\nc=re.split(r\"\\\\s+\", y)\\nd=dict()\\nfor w in c:\\n\\tx=d.get(w,0)\\n\\td[w]=x+1\\nout=[(w[1],w[0]) for w in list(d.items())]\\nout.sort(reverse=True)\\nfor o in out:\\n\\tprint(o[1],o[0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\npython3 <<< \\'exec(\"import re\\\\na=open(\\\\\"words.txt\\\\\")\\\\nb=a.read().strip()\\\\na.close();z=b.split(\\\\\"\\\\\\\\n\\\\\");y=\\\\\" \\\\\".join(z)\\\\nc=re.split(r\\\\\"\\\\s+\\\\\",y);d=dict()\\\\nfor w in c:x=d.get(w,0);d[w]=x+1\\\\nout=[(w[1],w[0]) for w in list(d.items())];out.sort(reverse=True)\\\\nfor o in out:print(o[1],o[0])\")\\'\\n```\n```\\nimport re\\na = open(\"words.txt\")\\nb = a.read().strip()\\na.close()\\nz = b.split(\"\\\\n\")\\ny=\" \".join(z)\\n# I used regex to split on any whitespace bc I failed a test case\\nc=re.split(r\"\\\\s+\", y)\\nd=dict()\\nfor w in c:\\n\\tx=d.get(w,0)\\n\\td[w]=x+1\\nout=[(w[1],w[0]) for w in list(d.items())]\\nout.sort(reverse=True)\\nfor o in out:\\n\\tprint(o[1],o[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1776717,
                "title": "using-tr-and-uniq-for-a-simple-one-line-solution-with-explanation",
                "content": "The solution is as follows:\\n```cat words.txt | (tr \\' \\' \\'\\\\n\\' ) | tr -s \\'\\\\n\\' | sort | uniq -c | sort -hr | awk -c \\'{print $2\" \"$1}\\'```\\n\\nThere are a few main commands at work here, all piped into each other. \"The first executed command is ```cat words.txt```, which sends the contents of the file \"word.txt\" to stdout. It\\'s then piped via the operator | into the command  ```tr \\' \\' \\'\\\\n\\'```. tr has the description in \"man\" to translate or delete characters, and is used here to do the first function of that to translate all space characters into endline characters to set up for the next command. That output is piped again into the command ```tr -s \\'\\\\n\\'``` which uses the second feature listed to delete all consecutive occurrences of \\'\\\\n\\' after the first. stdout is then piped yet again into ```sort```, which is used to alphabetically sort the lines which is required for the next command ```uniq -c``` to function properly.  ```uniq -c``` counts the unique lines from its input source and lists them number first followed by the line. This is perfect for the next command it is piped into, ```sort -hr```, which sorts them based on the leading number this time and reverses the list for the required parameter to list the words in descending order based on count. The output stream is then piped final time into the command, ```awk -c \\'{print $2\" \"$1}\\'``` which executes the print function in awk to send both fields of each line in the order of second field, followed by a space, followed by the first field. Since ```uniq -c``` outputted two fields in the form of the count and line, this works nicely to make all outputs follow the constrained format consistently. \\n\\nStats for those who are curious:\\nRuntime: 4 ms\\nMemory Usage: 3.5 MB",
                "solutionTags": [],
                "code": "```cat words.txt | (tr \\' \\' \\'\\\\n\\' ) | tr -s \\'\\\\n\\' | sort | uniq -c | sort -hr | awk -c \\'{print $2\" \"$1}\\'```\n```cat words.txt```\n```tr \\' \\' \\'\\\\n\\'```\n```tr -s \\'\\\\n\\'```\n```sort```\n```uniq -c```\n```uniq -c```\n```sort -hr```\n```awk -c \\'{print $2\" \"$1}\\'```\n```uniq -c```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713062,
                "title": "cat-sort-uniq-awk-runtime-4-ms-faster-than-77-25-of-bash",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258784,
                "title": "awk-one-line-beats-100",
                "content": "```\\nawk \\'{for (i=1;i<=NF;i++){a[$i]++}}END{for (i in a) print i,a[i]}\\' words.txt | sort -k2 -rn\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for (i=1;i<=NF;i++){a[$i]++}}END{for (i in a) print i,a[i]}\\' words.txt | sort -k2 -rn\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180503,
                "title": "1-line-solution-using-xargs-sort-uniq-awk",
                "content": "\\n```\\ncat words.txt |xargs -n 1|sort |uniq -c |sort -r|awk \\'{print $2,$1}\\'\\n```\\nxargs: convert multi lines to one columns\\nsort,uniq : \\nawk: print  output ,  column2 column1",
                "solutionTags": [],
                "code": "```\\ncat words.txt |xargs -n 1|sort |uniq -c |sort -r|awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271687,
                "title": "shell-simple-shell-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 113 ms, faster than 25.39% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.8 MB, less than 90.42% of Bash online submissions for Word Frequency.\\n\\n\\tcat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 113 ms, faster than 25.39% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.8 MB, less than 90.42% of Bash online submissions for Word Frequency.\\n\\n\\tcat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 2211392,
                "title": "bash-solution-using-grep-sort-uniq-awk",
                "content": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039269,
                "title": "used-cat-tr-sort-uniq-sort-awk-78-10-time-37-46-space",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{ print $2, $1 }\\'\\n```\\n* cat words.txt : prints the content into the stdout\\n* tr -s \\' \\' \\'\\\\n\\' : substitutes  spaces by \\'\\\\n\\'\\n* uniq -c : does the count of each word (to work must have the data sorted before)\\n* sort -nr : does the sort by numerical values in reverse order\\n* awk \\'{ print $2, $1 }\\' : switch the order of the columns, leaving the words in the first column and the counter in the second column as is expected.\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832480,
                "title": "one-line-pipeline-using-egrep-o",
                "content": "From the manual of `egrep`, the `-o` option (`--only-matching`) prints only the non-empty matched parts of a matching line with each part printed on a seperate line.\\n```\\negrep \"[a-z]+\" -o words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\negrep \"[a-z]+\" -o words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463081,
                "title": "solution-with-explanation-the-straightforward-50-50-one-liner-solution",
                "content": "```bash\\ncat words.txt | xargs -n1 | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\n# Runtime: 12 ms, faster than 56.12% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.3 MB, less than 44.83% of Bash online submissions for Word Frequency.\\n```\\n\\ncat read file\\ntokenize with line by line output\\nsort the words to prepare for `count -c`\\noutput unique words with count (-c)\\nsort in natural order (-n) descending (-r reverse)\\ntokenize with awk to remove whitespace formatting and reverse the order given by `count -c`",
                "solutionTags": [],
                "code": "```bash\\ncat words.txt | xargs -n1 | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\n# Runtime: 12 ms, faster than 56.12% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.3 MB, less than 44.83% of Bash online submissions for Word Frequency.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304323,
                "title": "readable-bash-native-solution-with-associate-array",
                "content": "I don\\'t know why I am doing this in 2019, but here it is:\\n\\n```\\n#!/bin/bash\\ndeclare -A counts\\nfor i in $(cat words.txt); do\\n    counts[$i]=$((${counts[$i]:-0}+1))\\ndone\\n\\nfor w in ${!counts[*]}; do\\n    echo $w ${counts[$w]}\\ndone | sort -rnk 2\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\ndeclare -A counts\\nfor i in $(cat words.txt); do\\n    counts[$i]=$((${counts[$i]:-0}+1))\\ndone\\n\\nfor w in ${!counts[*]}; do\\n    echo $w ${counts[$w]}\\ndone | sort -rnk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55464,
                "title": "my-16ms-unix-pipe-cat-tr-awk-sort-hash-solution",
                "content": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    \\n    # use cat+tr+awk+sort\\n    # use hashtables\\n    # use Unix pipes\\n    \\n    cat words.txt | \\\\\\n    tr -s ' ' '\\\\n' | \\\\\\n    awk '{nums[$1]++}END{for(word in nums) print word, nums[word]}' | \\\\\\n    sort -rn -k2",
                "solutionTags": [],
                "code": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    \\n    # use cat+tr+awk+sort\\n    # use hashtables\\n    # use Unix pipes\\n    \\n    cat words.txt | \\\\\\n    tr -s ' ' '\\\\n' | \\\\\\n    awk '{nums[$1]++}END{for(word in nums) print word, nums[word]}' | \\\\\\n    sort -rn -k2",
                "codeTag": "Unknown"
            },
            {
                "id": 55449,
                "title": "my-1-line-solution-using-awk-sort-and-pipe",
                "content": "\\nFirst, use awk to count the number for each word.\\nThen sort to sort the result by decreasing order.\\n\\n    awk '{for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}' words.txt | sort -k2 -nr",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\nFirst, use awk to count the number for each word.\\nThen sort to sort the result by decreasing order.\\n\\n    awk '{for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}' words.txt | sort -k2 -nr",
                "codeTag": "Unknown"
            },
            {
                "id": 2373566,
                "title": "faster-than-94-58",
                "content": "![image](https://assets.leetcode.com/users/images/852b682a-665c-42a2-8281-6e5f3ce1f1f6_1659522173.9779828.png)\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A map\\n\\nwhile read line; do\\n    for word in $line; do\\n        ((map[\"$word\"]=${map[\"$word\"]:-0}+1))\\n    done\\ndone < words.txt\\n\\nfor key in ${!map[@]}; do\\n    echo \"$key ${map[$key]}\"\\ndone | sort -rn -k 2\\n```\\n.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A map\\n\\nwhile read line; do\\n    for word in $line; do\\n        ((map[\"$word\"]=${map[\"$word\"]:-0}+1))\\n    done\\ndone < words.txt\\n\\nfor key in ${!map[@]}; do\\n    echo \"$key ${map[$key]}\"\\ndone | sort -rn -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296773,
                "title": "single-line-code",
                "content": "tr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "tr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2053690,
                "title": "easy-one-liner-using-cat-grep-sort-uniq-awk",
                "content": "[59% Better in Time, 87% better in Space]\\n```\\ncat words.txt | grep -wo \\'[[:alnum:]]\\\\+\\' | sort | uniq -c | sort -bnr | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\nParts of the Solution:-\\n* `sort` to prepare as input for uniq\\n* `uniq -c` to count occurrences\\n* `sort -bnr` sorts in numeric reverse order while ignoring whitespace\\n* `awk` for priniting in required format\\n\\nUpvote it, if you like it....",
                "solutionTags": [],
                "code": "```\\ncat words.txt | grep -wo \\'[[:alnum:]]\\\\+\\' | sort | uniq -c | sort -bnr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589385,
                "title": "one-line-with-pipe",
                "content": "`cat words.txt |  awk \\'{for(i=1;i<=NF;i++){printf \"%s\\\\n\", $i}}\\' | sort  | uniq -c  | sort -r | awk \\'{print $2\" \"$1}\\'`\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "`cat words.txt |  awk \\'{for(i=1;i<=NF;i++){printf \"%s\\\\n\", $i}}\\' | sort  | uniq -c  | sort -r | awk \\'{print $2\" \"$1}\\'`\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1073860,
                "title": "100-the-simplest-easiest-and-fastest-solution",
                "content": "```\\ncat words.txt | sed \\'s/\\\\ /\\\\n/g\\' | sort | uniq -c |sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | sed \\'s/\\\\ /\\\\n/g\\' | sort | uniq -c |sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546802,
                "title": "yet-another-similar-one-liner-100-0-faster-no-cat",
                "content": "``` tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{ print $2 \" \" $1}\\'```",
                "solutionTags": [],
                "code": "``` tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{ print $2 \" \" $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 433697,
                "title": "bash-shell-100-fast-with-egrep-and-awk",
                "content": "####             ***** SOLUTION 1 100% FAST 90% Less Space *****    \\n\\n\\t\\t\\t \\n```\\negrep -o [a-z]+ words.txt | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```\\n\\n <br> </br>\\n  ####             ***** SOLUTION 2 ~56% FAST 30% Less Space *****                 \\n  <br>\\n\\t\\t\\t   \\n```\\nawk \\'\\n{for (i = 1; i<=NF; i++) words[$i]++} \\nEND {for (i in words) print i, words[i]}\\' words.txt | \\\\\\nsort -nr -k2\\n\\n```",
                "solutionTags": [],
                "code": "```\\negrep -o [a-z]+ words.txt | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```\n```\\nawk \\'\\n{for (i = 1; i<=NF; i++) words[$i]++} \\nEND {for (i in words) print i, words[i]}\\' words.txt | \\\\\\nsort -nr -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172537,
                "title": "one-liner-solution-4-ms",
                "content": "Used awk to separate by rows:\\n```\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++)print $i}\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++)print $i}\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133594,
                "title": "simple-1-liner",
                "content": "```\\nfor i in `cat text` ; do echo $i ; done | sort | uniq -c\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor i in `cat text` ; do echo $i ; done | sort | uniq -c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3183862,
                "title": "beats-95-submission-using-awk",
                "content": "# Intuition\\n<!-- Very first thought was that we need to increment count each time we see a repeated word. What could be better than an array. -->\\nVery first thought was that we need to increment count each time we see a repeated word. What could be better than an array!\\n\\n# Approach\\n<!-- The best way was using awk associative array as it gives to you liberty to store values as arr[\"the\"]=2 format.  -->\\nThe best way was using awk associative array as it gives to you liberty to store values as arr[\"the\"]=2 format.\\n\\n# Complexity\\n- Time complexity:\\n<!-- $$O(n)$$ : n being number of words in file -->\\n$$O(n)$$ : n being number of words in file\\n- Space complexity:\\n<!-- $$Ohm(n)$$ : less than or equal to number of words in file -->\\n$$Ohm(n)$$ : less than or equal to number of words in file\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\necho -e \"$(cat words.txt)\" | awk \\'{for(i=1;i<=NF;i++){if(arr[$i]==0){arr[$i]=1}else{arr[$i]=arr[$i]+1}}}END{for(i in arr) print i, arr[i]}\\' | sort -k2 -n -r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\necho -e \"$(cat words.txt)\" | awk \\'{for(i=1;i<=NF;i++){if(arr[$i]==0){arr[$i]=1}else{arr[$i]=arr[$i]+1}}}END{for(i in arr) print i, arr[i]}\\' | sort -k2 -n -r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2566791,
                "title": "stupid-shell-script",
                "content": "#!/bin/bash\\ncat word.txt\\ncnt=`wc -l < word.txt`\\n\\ndist=`head -q -n  $cnt  word.txt | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort -u`\\n\\nfor i in $dist\\ndo\\nres=`grep -o -i $i  word.txt | wc -l`\\necho \"$i $res\"\\ndone",
                "solutionTags": [],
                "code": "#!/bin/bash\\ncat word.txt\\ncnt=`wc -l < word.txt`\\n\\ndist=`head -q -n  $cnt  word.txt | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort -u`\\n\\nfor i in $dist\\ndo\\nres=`grep -o -i $i  word.txt | wc -l`\\necho \"$i $res\"\\ndone",
                "codeTag": "Unknown"
            },
            {
                "id": 2149108,
                "title": "one-liner-grep-sort-uniq-awk",
                "content": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort -n | uniq -c | sort -rn | awk \\' {print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort -n | uniq -c | sort -rn | awk \\' {print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057881,
                "title": "my-one-liner",
                "content": "Here is what I did:\\n\\n```bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709659,
                "title": "low-complexity-one-liner-while-read-for-in-sort-uniq-awk",
                "content": "```\\ncat words.txt | while read -r l; do for w in $l; do echo $w; done; done | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | while read -r l; do for w in $l; do echo $w; done; done | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658902,
                "title": "one-more-oneliner-awk-tr-sort",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++) words[$i]++} END {for(word in words) print word,words[word]}\\' words.txt | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++) words[$i]++} END {for(word in words) print word,words[word]}\\' words.txt | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391346,
                "title": "pure-bash-solution-merge-sort",
                "content": "```\\nmergesort() {\\n    local -n _merge_arr=$1\\n    local start=${2:-0}\\n    local end=${3:-${#_merge_arr[@]}}\\n    if ((start >= end - 1)); then\\n        return\\n    fi\\n    local middle=$(( (start + end) / 2 ))\\n    mergesort \"$1\" \"$start\" \"$middle\"\\n    mergesort \"$1\" \"$middle\" \"$end\"\\n\\n    local firsthalf=(\"${_merge_arr[@]:start:middle - start}\")\\n    local secondhalf=(\"${_merge_arr[@]:middle:end - middle}\")\\n    local i=0 j=0 k=$start\\n    while ((i < ${#firsthalf[@]} || j < ${#secondhalf[@]})); do\\n        read -r _ fh <<< \"${firsthalf[i]}\"\\n        read -r _ sh <<< \"${secondhalf[j]}\"\\n        if (( i < ${#firsthalf[@]} && (j >= ${#secondhalf[@]} || fh > sh) )); then\\n            _merge_arr[k++]=${firsthalf[i++]}\\n        else\\n            _merge_arr[k++]=${secondhalf[j++]}\\n        fi\\n    done\\n}\\n\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A words\\nwhile read -r -a line; do\\n    for word in \"${line[@]}\"; do\\n        count=words[\"$word\"]\\n        words[\"$word\"]=$((count + 1))\\n    done\\ndone < words.txt\\n\\ntosort=()\\nfor word in \"${!words[@]}\"; do\\n    tosort+=(\"$word ${words[$word]}\")\\ndone\\n\\nmergesort tosort\\n(IFS=$\\'\\\\n\\'; echo \"${tosort[*]}\")\\n```",
                "solutionTags": [],
                "code": "```\\nmergesort() {\\n    local -n _merge_arr=$1\\n    local start=${2:-0}\\n    local end=${3:-${#_merge_arr[@]}}\\n    if ((start >= end - 1)); then\\n        return\\n    fi\\n    local middle=$(( (start + end) / 2 ))\\n    mergesort \"$1\" \"$start\" \"$middle\"\\n    mergesort \"$1\" \"$middle\" \"$end\"\\n\\n    local firsthalf=(\"${_merge_arr[@]:start:middle - start}\")\\n    local secondhalf=(\"${_merge_arr[@]:middle:end - middle}\")\\n    local i=0 j=0 k=$start\\n    while ((i < ${#firsthalf[@]} || j < ${#secondhalf[@]})); do\\n        read -r _ fh <<< \"${firsthalf[i]}\"\\n        read -r _ sh <<< \"${secondhalf[j]}\"\\n        if (( i < ${#firsthalf[@]} && (j >= ${#secondhalf[@]} || fh > sh) )); then\\n            _merge_arr[k++]=${firsthalf[i++]}\\n        else\\n            _merge_arr[k++]=${secondhalf[j++]}\\n        fi\\n    done\\n}\\n\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A words\\nwhile read -r -a line; do\\n    for word in \"${line[@]}\"; do\\n        count=words[\"$word\"]\\n        words[\"$word\"]=$((count + 1))\\n    done\\ndone < words.txt\\n\\ntosort=()\\nfor word in \"${!words[@]}\"; do\\n    tosort+=(\"$word ${words[$word]}\")\\ndone\\n\\nmergesort tosort\\n(IFS=$\\'\\\\n\\'; echo \"${tosort[*]}\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162726,
                "title": "awk-sort-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++)\\n        words[$i]++\\n}\\n\\nEND {\\n    for (word in words)\\n        print word, words[word]\\n}\\n\\' words.txt | sort -n -r -k 2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++)\\n        words[$i]++\\n}\\n\\nEND {\\n    for (word in words)\\n        print word, words[word]\\n}\\n\\' words.txt | sort -n -r -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099989,
                "title": "just-one-sort-blazing-fast",
                "content": "```\\ndeclare -A word_count\\n\\nfor word in $(sed \\'s/\\\\\\\\n/ /g\\' <words.txt); do\\n    ((word_count[$word]++))\\ndone\\n\\nfor k in ${!word_count[@]}; do\\n    echo $k ${word_count[$k]}\\ndone | sort -rn -k2\\n```\\n\\n1. Create associative array `word_count`\\n2. Count each word occurence\\n3. Print and sort",
                "solutionTags": [],
                "code": "```\\ndeclare -A word_count\\n\\nfor word in $(sed \\'s/\\\\\\\\n/ /g\\' <words.txt); do\\n    ((word_count[$word]++))\\ndone\\n\\nfor k in ${!word_count[@]}; do\\n    echo $k ${word_count[$k]}\\ndone | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047002,
                "title": "piping-6-bash-built-in-commands",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{printf(\"%s %s\\\\n\",$2,$1)}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{printf(\"%s %s\\\\n\",$2,$1)}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007477,
                "title": "faster-than-100",
                "content": "```\\nfor w in $(cat words.txt | cut -d \\' \\' -f1-);do echo $w;done | sort | uniq -c | sort -r| awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor w in $(cat words.txt | cut -d \\' \\' -f1-);do echo $w;done | sort | uniq -c | sort -r| awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992603,
                "title": "one-line-using-tr-s-n-sort-uniq-c-and-awk-print-2-1",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 875893,
                "title": "just-tr-sort-and-awk",
                "content": "tr, sort and awk\\n```tr -s \\' \\' \\'\\\\n\\' < words.txt|sort|uniq -c |sort -rn|awk \\'{print $2,$1}```",
                "solutionTags": [],
                "code": "```tr -s \\' \\' \\'\\\\n\\' < words.txt|sort|uniq -c |sort -rn|awk \\'{print $2,$1}```",
                "codeTag": "Unknown"
            },
            {
                "id": 659537,
                "title": "bash-faster-than-100-1-liner",
                "content": "```\\ncat words.txt | tr $\\'\\\\n\\' \\' \\' | sed -r \"s/ +/\\\\n/g\" | sort | uniq -c | sed \"s/^[ \\\\t]*//\" | cut -d \\' \\' -f 1,2 | sort -rn | sed -r \"s/([0-9]+) ([a-zA-Z]+)/\\\\2 \\\\1/\" \\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr $\\'\\\\n\\' \\' \\' | sed -r \"s/ +/\\\\n/g\" | sort | uniq -c | sed \"s/^[ \\\\t]*//\" | cut -d \\' \\' -f 1,2 | sort -rn | sed -r \"s/([0-9]+) ([a-zA-Z]+)/\\\\2 \\\\1/\" \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615062,
                "title": "simple-c-solution",
                "content": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532985,
                "title": "less-is-better-one-line-with-pipe",
                "content": "```\\nless words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nless words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514519,
                "title": "awk-pipe-sort-faster-than-100",
                "content": "```\\nawk \\'{ for (i=1; i <= NF; i++) {m[$i]++;} } END { for(x in m){ print(x, m[x]) } }\\' words.txt | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ for (i=1; i <= NF; i++) {m[$i]++;} } END { for(x in m){ print(x, m[x]) } }\\' words.txt | sort -rn -k2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 405283,
                "title": "solution-using-sort-uniq-and-awk",
                "content": "```\\nfor word in $(cat test.txt); do echo $word; done | sort | uniq -c | sort -r | awk \\'{ print $2 \" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor word in $(cat test.txt); do echo $word; done | sort | uniq -c | sort -r | awk \\'{ print $2 \" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375927,
                "title": "one-line-solution-using-sed-and-awk-faster-than-100",
                "content": "```\\ncat words.txt | sed \\'s/ /\\\\n/g;\\' | sed \\'/^\\\\s*$/D\\' | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\n- First `sed` replaces all spaces with new lines.\\n- Second `sed` deletes all whitespace-only lines\\n- `sort` sorts all the words\\n- `uniq -c` removes the duplicates and prefixes the frequency of each word\\n- `sort -nr` sorts the input based on the frequency (`-r` is for descending order)\\n- `awk \\'{print $2 \" \" $1}` reverses the ordering of frequency and word in a line",
                "solutionTags": [],
                "code": "```\\ncat words.txt | sed \\'s/ /\\\\n/g;\\' | sed \\'/^\\\\s*$/D\\' | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374679,
                "title": "my-simple-slution",
                "content": "awk \\'{for(i=1;i<=NF;i++) print $i}\\' words.txt | sort | uniq -c |sort -r|awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "awk \\'{for(i=1;i<=NF;i++) print $i}\\' words.txt | sort | uniq -c |sort -r|awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 315510,
                "title": "one-line",
                "content": "```cat words.txt | sed \\'s/ /\\\\n/g\\' | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $NF, $1}\\'```",
                "solutionTags": [],
                "code": "```cat words.txt | sed \\'s/ /\\\\n/g\\' | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $NF, $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 240212,
                "title": "one-line-with-pipe-beats-100",
                "content": "```\\ncat words.txt |awk \\'{for(i=1;i<=NF;i++) print $i;}\\'|sort|uniq -c|sort -r |awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt |awk \\'{for(i=1;i<=NF;i++) print $i;}\\'|sort|uniq -c|sort -r |awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229528,
                "title": "my-one-line-solution",
                "content": "Inspired by @Swordmctster in this [post](https://leetcode.com/problems/word-frequency/discuss/55443/My-simple-solution-(one-line-with-pipe)).\\n```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |sort| grep .| uniq -c | sort -r -n -k 1| awk \\'{print $2,$1}\\' \\n```\\nadd grep . to ignore blank lines.\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |sort| grep .| uniq -c | sort -r -n -k 1| awk \\'{print $2,$1}\\' \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190312,
                "title": "4ms-single-process-no-pipe-solution-using-awk-comments-included",
                "content": "```\nawk 'BEGIN { \n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"   # set array traversal to values in descending order\n} { \n    for (i=1;i<=NF;i++) {   # take each word separately\n        a[$i]++             # populate array a with word count incremented each time\n    }\n} END {\n    for (i in a) {          # array traversal and print which will follow pre-set order\n        print i,a[i]\n    }\n}' words.txt\n```",
                "solutionTags": [],
                "code": "```\nawk 'BEGIN { \n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"   # set array traversal to values in descending order\n} { \n    for (i=1;i<=NF;i++) {   # take each word separately\n        a[$i]++             # populate array a with word count incremented each time\n    }\n} END {\n    for (i in a) {          # array traversal and print which will follow pre-set order\n        print i,a[i]\n    }\n}' words.txt\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186434,
                "title": "easy-to-understand-solution-using-unix-pipeline-and-awk",
                "content": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |awk \\'{for(i=1;i<=NF;i++) a[$i]++}END{for(k in a) print k,a[k]}\\'|sort -k2nr\\n```\\n`cat`: display\\n`tr`: remove newline identifier \\'\\\\n\\'\\n`awk \\'{for(i=1;i<=NF;i++) a[$i]++} `: counting list generation\\n`for(k in a) print k,a[k]}`: printing\\n`sort -k2nr`: sort -n:numerical comparison -r:reversely(descending) -k2:based on column #2\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |awk \\'{for(i=1;i<=NF;i++) a[$i]++}END{for(k in a) print k,a[k]}\\'|sort -k2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114346,
                "title": "use-sed-and-grep",
                "content": "```\\nsed 's/ \\\\{1,\\\\}/\\\\n/g' words.txt | grep -v \"^$\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\\n```",
                "solutionTags": [],
                "code": "```\\nsed 's/ \\\\{1,\\\\}/\\\\n/g' words.txt | grep -v \"^$\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55446,
                "title": "solve-this-problem-in-linux-style",
                "content": "```\\n#!/bin/bash\\n cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'|uniq -c|sort -nr|awk '{print $2,$1}'\\n```\\nwhy use  tr -nr   not   tr -r ?\\n```\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -r\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n     13 can\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -nr\\n     13 can\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n```\\n\\nwhy added awk '{if($0!=\"\")print}' ?\\n\\n```\\n[root@pangu icai]# more words.txt \\na  a   b\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort\\n\\n\\n\\na\\na\\nb\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'\\na\\na\\nb\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'|uniq -c|sort -nr|awk '{print $2,$1}'\\n```\n```\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -r\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n     13 can\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -nr\\n     13 can\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n```\n```\\n[root@pangu icai]# more words.txt \\na  a   b\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort\\n\\n\\n\\na\\na\\nb\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'\\na\\na\\nb\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55459,
                "title": "my-solution-by-sort-tr-sed",
                "content": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    cat words.txt| tr -s \" \" \"\\\\n\" |sort| uniq -c | sort -rk1| sed \"s/\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2\\\\1/\" | tr -s \" \"",
                "solutionTags": [],
                "code": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    cat words.txt| tr -s \" \" \"\\\\n\" |sort| uniq -c | sort -rk1| sed \"s/\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2\\\\1/\" | tr -s \" \"",
                "codeTag": "Unknown"
            },
            {
                "id": 55463,
                "title": "my-solution-using-only-awk",
                "content": "    cat words.txt | awk '{for(i=1;i<=NF;++i) { arr[$i]++; } } END { x=0; for(var in arr) {newarr[arr[var]]=var; if(arr[var]>x) x=arr[var];} for(i=x;i>0;--i) if (newarr[i] > 0) print newarr[i] \" \"i; }'",
                "solutionTags": [],
                "code": "    cat words.txt | awk '{for(i=1;i<=NF;++i) { arr[$i]++; } } END { x=0; for(var in arr) {newarr[arr[var]]=var; if(arr[var]>x) x=arr[var];} for(i=x;i>0;--i) if (newarr[i] > 0) print newarr[i] \" \"i; }'",
                "codeTag": "Unknown"
            },
            {
                "id": 4068579,
                "title": "beats-98-7-dict-and-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/sh\\n\\ndeclare -A dict\\narr=($(cat words.txt))\\nfor i in \"${arr[@]}\";\\ndo\\n    dict[$i]=0\\ndone\\n\\nfor i in \"${arr[@]}\";\\ndo\\n    ((dict[$i]+=1))\\ndone\\n\\nfor i in \"${!dict[@]}\";\\ndo\\n    echo \"$i ${dict[$i]}\"\\ndone | sort -t\\' \\' -k2 -rV\\n\\t \\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\n\\ndeclare -A dict\\narr=($(cat words.txt))\\nfor i in \"${arr[@]}\";\\ndo\\n    dict[$i]=0\\ndone\\n\\nfor i in \"${arr[@]}\";\\ndo\\n    ((dict[$i]+=1))\\ndone\\n\\nfor i in \"${!dict[@]}\";\\ndo\\n    echo \"$i ${dict[$i]}\"\\ndone | sort -t\\' \\' -k2 -rV\\n\\t \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023106,
                "title": "counting-word-frequencies-in-a-text-file-using-unix-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires counting the frequency of each word in a text file. To solve this, we need to read the contents of the file, split it into words, count the occurrences of each word, and then display the words sorted by their frequencies in descending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by reading the contents of the words.txt file using the cat command.\\n2. We use the tr command to replace spaces with newline characters. This effectively splits the text into individual words, as each word is separated by spaces.\\n3. Next, we use the sort command to sort the words alphabetically. This step is essential to prepare the data for counting.\\n4. We use the uniq -c command to count the unique occurrences of each word and prefix each line with its word count.\\n5. After counting, we use sort -nr to sort the lines in reverse order based on the word count. This gives us the words sorted by their frequencies in descending order.\\n6. Finally, we use awk to print the word and its frequency in the desired format.\\n\\n# Complexity\\n- Time complexity:\\n    - Reading the file and splitting it into words takes linear time, so it\\'s O(n), where n is the total number of characters in the file.\\n    - Sorting and counting unique words also takes linear time.\\n    - Sorting the lines based on word count takes O(m log m) time, where m is the number of unique words.\\n    - Overall time complexity is O(n + m log m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - The space complexity is determined by the number of unique words, which is O(m), where m is the number of unique words.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020557,
                "title": "one-line-with-sed-sort-uniq-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nsed -r \\'s/^ +//g;s/ +/ /g;s/ +$//g;s/ /\\\\n/g\\' <words.txt | sort | uniq -c | sort -rn | awk -F\\' \\' \\'{print $2,$1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nsed -r \\'s/^ +//g;s/ +/ /g;s/ +$//g;s/ /\\\\n/g\\' <words.txt | sort | uniq -c | sort -rn | awk -F\\' \\' \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019819,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945872,
                "title": "solution-by-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npython3 -c \"\\nf = open(\\'words.txt\\', \\'r\\')\\nans = []\\n\\nl = f.read().split()\\nwhile len(l) != 0:\\n    c = l.count(l[0])\\n    value = l[0]\\n    pre_ans = [value, c]\\n    ans.append(pre_ans)\\n    for j in range(c):\\n        l.remove(value)\\n\\nans.sort(key = lambda x: x[1], reverse = True)\\nfor k in range(len(ans)):\\n    print(ans[k][0], ans[k][1])\\n\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\npython3 -c \"\\nf = open(\\'words.txt\\', \\'r\\')\\nans = []\\n\\nl = f.read().split()\\nwhile len(l) != 0:\\n    c = l.count(l[0])\\n    value = l[0]\\n    pre_ans = [value, c]\\n    ans.append(pre_ans)\\n    for j in range(c):\\n        l.remove(value)\\n\\nans.sort(key = lambda x: x[1], reverse = True)\\nfor k in range(len(ans)):\\n    print(ans[k][0], ans[k][1])\\n\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3938497,
                "title": "solution-using-bash-associative-arrays",
                "content": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A hash=()\\n\\nfor word in $(cat words.txt); do\\n    hash[\"$word\"]=$(( ${hash[$word]:-0} + 1 ));\\ndone\\n\\n{ for word in \"${!hash[@]}\"; do\\n    printf \\'%s %s\\\\n\\' \"$word\" \"${hash[$word]}\"\\ndone; } | sort -rnk 2\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A hash=()\\n\\nfor word in $(cat words.txt); do\\n    hash[\"$word\"]=$(( ${hash[$word]:-0} + 1 ));\\ndone\\n\\n{ for word in \"${!hash[@]}\"; do\\n    printf \\'%s %s\\\\n\\' \"$word\" \"${hash[$word]}\"\\ndone; } | sort -rnk 2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925305,
                "title": "easy-and-simple-check-it-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/bash\\n\\n# Read the file, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Sort and count unique words\\nsort | uniq -c |\\n# Sort by descending frequency\\nsort -nr |\\n# Format output\\nawk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\n# Read the file, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Sort and count unique words\\nsort | uniq -c |\\n# Sort by descending frequency\\nsort -nr |\\n# Format output\\nawk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893200,
                "title": "quick-script",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# tr - Translate characters. The -s option tells tr to remove all duplicate whitespace characters from the input.\\n# sort - Sort the lines of the input.\\n# uniq -c - Count the number of occurrences of each line in the input.\\n# sort -nr - Sort the output of uniq in descending order.\\n# awk - Print the second and first field of each line, separated by a space. \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# tr - Translate characters. The -s option tells tr to remove all duplicate whitespace characters from the input.\\n# sort - Sort the lines of the input.\\n# uniq -c - Count the number of occurrences of each line in the input.\\n# sort -nr - Sort the output of uniq in descending order.\\n# awk - Print the second and first field of each line, separated by a space. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884740,
                "title": "one-line-using-pipes",
                "content": "# Intuition\\ncat - print out the file\\ntr - truncate on spaces\\nsort - sort the truncated output into lines so it can be read by uniq easily\\nuniq -c - count all unique instances\\nsort -nr - sort in descending order\\nawk - print out the output with the second argument (the letter) after the first arguement (the number)\\n\\n# Approach\\nI honestly just ran it a couple times with uniq and then messed with the formating (tr and awk) until it matched the expected output. It\\'s not exactly optimal with space complexity; I think it could be cut down a bit.\\n\\n# Complexity\\n- Time complexity: 77ms\\n\\n- Space complexity: 3.81mb\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871827,
                "title": "bash-scripting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\n#!/bin/bash\\n\\n# Read the content of words.txt, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Count the frequency of each word\\nsort | uniq -c |\\n# Sort the output by descending frequency\\nsort -nr |\\n# Use awk to format the output as \"word frequency\"\\nawk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\n#!/bin/bash\\n\\n# Read the content of words.txt, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Count the frequency of each word\\nsort | uniq -c |\\n# Sort the output by descending frequency\\nsort -nr |\\n# Use awk to format the output as \"word frequency\"\\nawk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813645,
                "title": "awk-sort-using-space-as-record-separator",
                "content": "My intuition was that take each space as a record separator, so I can have the variable `$0` with the word. \\n\\nThen, with the word in `$0`, I can do the old trick of update an `awk` associative array and incrementing acording the appareances.\\n\\n# Code\\n```\\nawk -v RS=\\'[[:space:]]+\\' \\'{arr[$0]++}END{\\n    for(letra in arr)\\n        printf \"%s %s\\\\n\", letra, arr[letra]\\n}\\' words.txt | sort -k2nr\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk -v RS=\\'[[:space:]]+\\' \\'{arr[$0]++}END{\\n    for(letra in arr)\\n        printf \"%s %s\\\\n\", letra, arr[letra]\\n}\\' words.txt | sort -k2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805456,
                "title": "bash-tr-sort-uniq-awk",
                "content": "```\\n#!/bin/bash\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787110,
                "title": "with-explanation",
                "content": "\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat \"words.txt\" | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# cat words.txt: This command reads the content of the file words.txt and outputs it to the standard output. \\n\\n# tr -s \\'[:space:]\\' \\'\\\\n\\': This command uses the tr (translate) utility to replace sequences of whitespace characters with a single newline character (\\'\\\\n\\'). The option -s stands for \"squeeze,\" which means it will replace multiple consecutive occurrences of the specified character class (in this case, whitespace characters) with a single occurrence.\\n\\n# sort: This command sorts the input data (words) in ascending order by default. Since no specific options are provided, it will use the lexicographic order for sorting.\\n\\n# uniq -c: The uniq command filters out adjacent duplicate lines in the input and only outputs unique lines. The option -c is used to count the occurrences of each unique line and print the count alongside the line.\\n\\n# sort -nr: This command performs a numeric sort (-n) in reverse order (-r). The reverse order (-r) ensures that the words with the highest counts appear first in the output.\\n\\n# awk \\'{print $2, $1}\\': The awk command is a powerful text processing tool. In this specific case, it takes each line of input and prints the second and first fields (columns) in that order.\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat \"words.txt\" | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# cat words.txt: This command reads the content of the file words.txt and outputs it to the standard output. \\n\\n# tr -s \\'[:space:]\\' \\'\\\\n\\': This command uses the tr (translate) utility to replace sequences of whitespace characters with a single newline character (\\'\\\\n\\'). The option -s stands for \"squeeze,\" which means it will replace multiple consecutive occurrences of the specified character class (in this case, whitespace characters) with a single occurrence.\\n\\n# sort: This command sorts the input data (words) in ascending order by default. Since no specific options are provided, it will use the lexicographic order for sorting.\\n\\n# uniq -c: The uniq command filters out adjacent duplicate lines in the input and only outputs unique lines. The option -c is used to count the occurrences of each unique line and print the count alongside the line.\\n\\n# sort -nr: This command performs a numeric sort (-n) in reverse order (-r). The reverse order (-r) ensures that the words with the highest counts appear first in the output.\\n\\n# awk \\'{print $2, $1}\\': The awk command is a powerful text processing tool. In this specific case, it takes each line of input and prints the second and first fields (columns) in that order.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766806,
                "title": "solved-with-combined-powers-of-tr-awk-sort-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to get each word in the file printed per line.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we have each word of the file getting printed per line, using awk utility program, we can arrange to capture the frequency of each word in the file (using associative array approach). We can then pipe the result of awk program to sort utility to maintain the decending order of frequency of words.\\n\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \" \" \"\\\\n\" | awk -F\\' \\' \\'{freq[$0] += 1;}END{for(i in freq){printf(\"%s %d\\\\n\",i, freq[i])}}\\' | sort -nrk 2,2 -t\\' \\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \" \" \"\\\\n\" | awk -F\\' \\' \\'{freq[$0] += 1;}END{for(i in freq){printf(\"%s %d\\\\n\",i, freq[i])}}\\' | sort -nrk 2,2 -t\\' \\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651957,
                "title": "text-utils-tr-sort-uniq-c-do-the-job-sed-to-swap-2-values",
                "content": "# Intuition\\ntext utils tr, sort, uniq -c do the job, sed to swap 2 values\\n\\n# Approach\\nusing awk to swap 2 values is overkill, sed more effective. If run the script as #!/bin/sh, not as bash, it will be the fastest too\\n\\n# Complexity\\n- Time complexity:\\n15.26%\\n\\n- Space complexity:\\n99.91%\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt|\\\\\\ntr \\' \\' \\'\\\\n\\'|\\\\\\ntr -s \\'\\\\n\\'|\\\\\\nsort|\\\\\\nuniq -c|\\\\\\nsort -k1nr|\\\\\\nsed \\'s/^ *\\\\([0-9]*\\\\) \\\\([a-z]*\\\\)$/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt|\\\\\\ntr \\' \\' \\'\\\\n\\'|\\\\\\ntr -s \\'\\\\n\\'|\\\\\\nsort|\\\\\\nuniq -c|\\\\\\nsort -k1nr|\\\\\\nsed \\'s/^ *\\\\([0-9]*\\\\) \\\\([a-z]*\\\\)$/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631223,
                "title": "beat-98-76-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn order to solve the problem of calculating word frequencies in a text file, the initial intuition was to split the words and count their occurrences. Considering that the input file contains only lowercase characters and space characters, we can assume that the words are separated by whitespace.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe chosen approach utilizes awk to process the text file efficiently. The script begins by looping through each line of the file. Within each line, another loop iterates through each word (based on whitespace separation) and increments its count in an array called count. This approach avoids the need for multiple commands and pipes, making it faster.\\n\\nAfter processing all lines, awk enters the END block. In this block, the script iterates over the count array and prints each word along with its corresponding frequency. The output is then piped to the sort command to sort the words based on their frequency in descending order.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach can be considered as linear, or O(n), where n represents the total number of words in the input file. The script reads each word once, incrementing the count in constant time for each word.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity can also be considered as linear, or O(n), where n represents the total number of distinct words in the input file. The count array stores the count for each unique word encountered during processing.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nawk \\'{ for (i=1; i<=NF; i++) count[$i]++ } END { for (word in count) { print word, count[word] } }\\' words.txt | sort -k2,2nr\\n```\\n\\nThe given code snippet uses awk to process the words.txt file. It loops through each line, splitting the words based on whitespace and increments their count in the count array. After processing all lines, the script prints each word along with its count. The output is then piped to the sort command, which sorts the word frequency list based on the second column in descending order.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nawk \\'{ for (i=1; i<=NF; i++) count[$i]++ } END { for (word in count) { print word, count[word] } }\\' words.txt | sort -k2,2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621821,
                "title": "awk-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'\\n{\\n    split($0, arr, \" \");\\n    for (i = 1; i <= length(arr); i += 1) {\\n        words[arr[i]] += 1;\\n    }\\n}\\n\\nEND {\\n    n = 0\\n    for (k in words) {\\n        keys[++n] = k;\\n        vals[k] = words[k];\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        for (j = i + 1; j <= n; ++j) {\\n            if (vals[keys[i]] < vals[keys[j]]) {\\n                tmp = keys[i];\\n                keys[i] = keys[j];\\n                keys[j] = tmp;\\n            }\\n        }\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        print keys[i], vals[keys[i]];\\n    }\\n}\\n\\' words.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'\\n{\\n    split($0, arr, \" \");\\n    for (i = 1; i <= length(arr); i += 1) {\\n        words[arr[i]] += 1;\\n    }\\n}\\n\\nEND {\\n    n = 0\\n    for (k in words) {\\n        keys[++n] = k;\\n        vals[k] = words[k];\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        for (j = i + 1; j <= n; ++j) {\\n            if (vals[keys[i]] < vals[keys[j]]) {\\n                tmp = keys[i];\\n                keys[i] = keys[j];\\n                keys[j] = tmp;\\n            }\\n        }\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        print keys[i], vals[keys[i]];\\n    }\\n}\\n\\' words.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616110,
                "title": "1-word-low-ltncy-shell",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594841,
                "title": "solution-using-associative-arrays-bash-hyder-nabi",
                "content": "# Algorihtm:\\r\\n1. Read input file line by line;\\r\\n2. for each line:\\r\\n3. split the line into words using space as delimeter\\r\\n4. count the frequency of each word and store the frequency in associative array with the word itself as key.\\r\\n5. Repeat the same for every line.\\r\\n6. Finally sort the array using values with descending order.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(NoOfLines*NoOfWordsInEachLine^2)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(NoOfDifferentWords)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\n\\r\\nfile=\"words.txt\"\\r\\ndeclare -A freq\\r\\nwhile read -r line; do\\r\\n    IFS=\\' \\' read -ra Arr <<< \"$line\"\\r\\n    for i in \"${Arr[@]}\"; do\\r\\n        flag=0\\r\\n        for key in \"${!freq[@]}\"; do\\r\\n            if [ \"$i\" == \"$key\" ]; then\\r\\n                var=\"${freq[$i]}\"\\r\\n                freq[$i]=$((var+1))\\r\\n                flag=1\\r\\n            fi\\r\\n        done\\r\\n        if [ \"$flag\" == 0 ]; then\\r\\n            freq[$i]=1\\r\\n        fi\\r\\n    done\\r\\ndone < \"$file\"\\r\\n\\r\\nfor i in \"${!freq[@]}\"; do\\r\\n    echo \"$i ${freq[$i]}\"\\r\\ndone | sort -k2,2rn\\r\\n\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\n\\r\\nfile=\"words.txt\"\\r\\ndeclare -A freq\\r\\nwhile read -r line; do\\r\\n    IFS=\\' \\' read -ra Arr <<< \"$line\"\\r\\n    for i in \"${Arr[@]}\"; do\\r\\n        flag=0\\r\\n        for key in \"${!freq[@]}\"; do\\r\\n            if [ \"$i\" == \"$key\" ]; then\\r\\n                var=\"${freq[$i]}\"\\r\\n                freq[$i]=$((var+1))\\r\\n                flag=1\\r\\n            fi\\r\\n        done\\r\\n        if [ \"$flag\" == 0 ]; then\\r\\n            freq[$i]=1\\r\\n        fi\\r\\n    done\\r\\ndone < \"$file\"\\r\\n\\r\\nfor i in \"${!freq[@]}\"; do\\r\\n    echo \"$i ${freq[$i]}\"\\r\\ndone | sort -k2,2rn\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516417,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514046,
                "title": "one-line-using-unix-pipes",
                "content": "\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490307,
                "title": "unique-solution-beats-98-in-run-time",
                "content": "I guess nobody shared this solution.\\r\\n\\r\\nThis is a bit log and it is different approach\\r\\n\\r\\n\\r\\nIf you liked this **please upvote.**\\r\\n\\r\\n```Bash \\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\ndeclare -A hm\\r\\nmax=0\\r\\nwhile IFS=\\' \\' read -r -a line\\r\\ndo\\r\\n    for value in ${line[@]} \\r\\n        do \\r\\n            # echo $value\\r\\n            if [[ hm[$value] == -1 ]]\\r\\n                then \\r\\n                hm[$value]=1\\r\\n                else \\r\\n                (( hm[$value]+=1 ))\\r\\n                [[ hm[$value] -gt max ]] && (( max=hm[$value] ))\\r\\n            fi \\r\\n        done\\r\\ndone < \"words.txt\"\\r\\ndeclare -A another\\r\\nfor value in ${!hm[@]}; do \\r\\nif [[ another[${hm[$value]}] -eq -1 ]] ; then another[${hm[$value]}]=() ; fi\\r\\nanother[${hm[$value]}]+=$value\\r\\ndone\\r\\nwhile [ $max -gt 0 ] \\r\\ndo\\r\\nif [[ another[$max] -ne -1 ]]\\r\\nthen\\r\\nfor el in ${another[$max]}; do\\r\\necho \"${another[$max]} $max\"\\r\\ndone\\r\\nfi\\r\\n(( max-=1 ))\\r\\ndone\\r\\n```\\r\\n\\r\\nLast but not the least\\r\\nThis is one Liner solution\\r\\n\\r\\n```shell\\r\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\r\\n```\\r\\n\\r\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```Bash \\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\ndeclare -A hm\\r\\nmax=0\\r\\nwhile IFS=\\' \\' read -r -a line\\r\\ndo\\r\\n    for value in ${line[@]} \\r\\n        do \\r\\n            # echo $value\\r\\n            if [[ hm[$value] == -1 ]]\\r\\n                then \\r\\n                hm[$value]=1\\r\\n                else \\r\\n                (( hm[$value]+=1 ))\\r\\n                [[ hm[$value] -gt max ]] && (( max=hm[$value] ))\\r\\n            fi \\r\\n        done\\r\\ndone < \"words.txt\"\\r\\ndeclare -A another\\r\\nfor value in ${!hm[@]}; do \\r\\nif [[ another[${hm[$value]}] -eq -1 ]] ; then another[${hm[$value]}]=() ; fi\\r\\nanother[${hm[$value]}]+=$value\\r\\ndone\\r\\nwhile [ $max -gt 0 ] \\r\\ndo\\r\\nif [[ another[$max] -ne -1 ]]\\r\\nthen\\r\\nfor el in ${another[$max]}; do\\r\\necho \"${another[$max]} $max\"\\r\\ndone\\r\\nfi\\r\\n(( max-=1 ))\\r\\ndone\\r\\n```\n```shell\\r\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409590,
                "title": "beats-86-easy-to-understand-code-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Detailed explanation of the bash script:\\n1. tr -s \\' \\' \\'\\\\n\\' < words.txt\\n\\nThis command uses the tr utility to replace all occurrences of one or more spaces with a newline character (\\\\n). The -s option squeezes repeated characters to a single character, so it ensures that consecutive spaces are treated as a single separator. The input for this command is read from the file words.txt.\\n\\n2. sort :\\n\\nThis command sorts the words alphabetically. Each word appears on a separate line thanks to the tr command.\\n\\n\\n3. uniq -c :\\n\\nThis command counts the frequency of each unique word. The -c option makes uniq output the count of each group of identical lines (i.e., each unique word).\\n\\n4. sort -nr :\\n\\nThis command sorts the output of uniq by frequency in descending order. The -n option tells sort to sort numerically, while the -r option tells it to sort in reverse order (i.e., descending).\\n\\n\\n5. awk \\'{print $2, $1}\\' :\\n\\nThis command uses awk to print the second field (the word) followed by the first field (the frequency), separated by a space. The output is sorted by frequency in descending order.\\n\\nSo overall, the script reads a text file words.txt, replaces all occurrences of one or more spaces with a newline character, sorts the resulting words alphabetically, counts the frequency of each unique word, sorts the words by frequency in descending order, and finally prints each word followed by its frequency separated by a space.\\n*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370688,
                "title": "192-word-frequency",
                "content": "# Intuition\\nHere\\'s a bash script that uses tr, sort, uniq, and awk commands to calculate the frequency of each word in a text file words.txt:\\n\\n# Approach\\nHere\\'s how it works:\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt replaces every space character with a newline character, effectively converting the file into a list of words, one per line.\\nsort sorts the list of words in lexicographic order.\\nuniq -c counts the number of occurrences of each word and outputs the count followed by the word.\\nawk \\'{print $2 \" \" $1}\\' rearranges the output to have the word followed by its count.\\nsort -rn -k2 sorts the output in reverse numerical order based on the second field (the count).\\n\\n# Complexity\\nThe time and space complexity of the bash script to calculate the frequency of each word in a text file words.txt depends on the size of the input file and the number of distinct words in the file.\\n\\nLet\\'s analyze the individual commands used in the script:\\n\\ntr -s \\' \\' \\'\\\\n\\': This command reads the input file and replaces every space character with a newline character. The time complexity of this command is O(n), where n is the size of the input file. The space complexity is O(1), since the command only needs to store a few characters at a time.\\n\\nsort: This command sorts the list of words in lexicographic order. The time complexity of this command is O(n log n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words in memory to perform the sort.\\n\\nuniq -c: This command counts the number of occurrences of each word and outputs the count followed by the word. The time complexity of this command is O(n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nawk \\'{print $2 \" \" $1}\\': This command rearranges the output to have the word followed by its count. The time complexity of this command is O(n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nsort -rn -k2: This command sorts the output in reverse numerical order based on the second field (the count). The time complexity of this command is O(n log n), where n is the number of distinct words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nOverall, the time complexity of the script is O(n log n), where n is the number of words in the input file. The space complexity of the script is O(n), where n is the number of distinct words in the input file.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | awk \\'{print $2 \" \" $1}\\' | sort -rn -k2\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | awk \\'{print $2 \" \" $1}\\' | sort -rn -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368097,
                "title": "using-awk-array",
                "content": "# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'{for(i=1;i<=NF;++i)count[$i]++;}END{for(i in count)print i, count[i]; }\\' words.txt | sort -r -n -k 2\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'{for(i=1;i<=NF;++i)count[$i]++;}END{for(i in count)print i, count[i]; }\\' words.txt | sort -r -n -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3335800,
                "title": "solution-step-by-step-explanation",
                "content": "Here\\'s a bash script to calculate the frequency of each word in a text file named **words.txt**. The script uses **awk** to split the input file into individual words and then uses **sort** and uniq to count the frequency of each word. Finally, **sort** is used again to **sort** the output by descending frequency.\\n\\n\\n> # Code\\n```\\n#!/bin/bash\\n\\n\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++) print $i}\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\n\\n- **Explanation**:\\n\\n1. ***cat words.txt***: The cat command outputs the contents of the words.txt file to the standard output stream.\\n2. **awk {for(i=1;i<=NF;i++) print $i}**: The awk command splits each line of the input stream into individual words and outputs them to the standard output stream, one per line.\\n3. **tr -s \\' \\' \\'\\\\n\\'**: The tr command replaces all occurrences of the space character with a newline character, effectively splitting each line into individual words.\\n4. **sort**: The sort command sorts the input alphabetically.\\n5. **uniq -c**: The uniq command removes consecutive duplicate lines from the input and outputs the count of how many times each line occurred.\\n6. **sort -rn**: The second sort command sorts the output by the count of each word in descending order.\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\n\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++) print $i}\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173372,
                "title": "linux-pipe",
                "content": "# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\\n\\n# Step-by-step\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt\\n```\\n\\n> the\\n> day\\n> is\\n> sunny\\n> the\\n> the\\n> the\\n> sunny\\n> is\\n> is\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort\\n```\\n\\n> day\\n> is\\n> is\\n> is\\n> sunny\\n> sunny\\n> the\\n> the\\n> the\\n> the\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c\\n```\\n> 1 day\\n> 3 is\\n> 2 sunny\\n> 4 the\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r\\n```\\n\\n> 4 the\\n> 3 is\\n> 2 sunny\\n> 1 day\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\\n\\n> the 4\\n> is 3\\n> sunny 2\\n> day 1\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3138563,
                "title": "clean-bash-high-speed-beats-98-9",
                "content": "# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090658,
                "title": "share-my-bash",
                "content": "```bash\\nfor i in $(cat words.txt); do echo $i; done | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```bash\\nfor i in $(cat words.txt); do echo $i; done | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069417,
                "title": "word-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056941,
                "title": "word-frequency-pipe-solution",
                "content": "One Liner || Easy Approach\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974692,
                "title": "one-liner-with-tr-grep-uniq-sort-and-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple one liner to do the job:\\n* read file\\n* replace space with newline\\n* remove blank lines\\n* sort\\n* count unique words\\n* sort descending\\n* reverse word and count\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n  cat words.txt | tr \\' \\' \\'\\\\n\\' | grep  -E \\'\\\\w+\\' | sort -n | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n  cat words.txt | tr \\' \\' \\'\\\\n\\' | grep  -E \\'\\\\w+\\' | sort -n | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955398,
                "title": "simple-on-line-code",
                "content": "\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2943097,
                "title": "my-one-liner-using-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \\'s/ /\\\\\\'\\\\n\\'/g\\' words.txt |sed \\'/^$/d\\'| sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed \\'s/ /\\\\\\'\\\\n\\'/g\\' words.txt |sed \\'/^$/d\\'| sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903345,
                "title": "using-tr-sort-uniq-read-tac-sed-not-in-one-line",
                "content": "```\\n#!/bin/sh\\nt=$(cat words.txt | tr \\'\\\\n\\' \\' \\' | tr -s \\' \\' | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | sed \"s/^[[:blank:]]*//g;s/[[:blank:]]*$//g\")\\nwhile read -r dat\\ndo\\n        echo $(echo $dat | tac -s \\' \\')\\ndone <<< $t\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\nt=$(cat words.txt | tr \\'\\\\n\\' \\' \\' | tr -s \\' \\' | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | sed \"s/^[[:blank:]]*//g;s/[[:blank:]]*$//g\")\\nwhile read -r dat\\ndo\\n        echo $(echo $dat | tac -s \\' \\')\\ndone <<< $t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886807,
                "title": "bash-script-arrays",
                "content": "# Intuition\\r\\nRead word by word the input text file and keep track of words read and update their absolute frequency with a counter.\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\nI used two vectors:\\r\\n1. wordList to keep track of words in the text\\r\\n2. freq to count the absolute freq of the words in wordList\\r\\n\\r\\nFor the same index i, the two vectors show the word with its absolute frequency.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n^2)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "solutionTags": [
                    "Bash",
                    "Array"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2881945,
                "title": "associative-array-bash-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nfile=words.txt\\n\\ndeclare -A array\\ncnt=1\\n\\nwhile read line\\ndo\\n     for word in $line\\n     do\\n       if [ -n \"${array[$word]}\" ]\\n       then\\n          array[\"$word\"]=$((${array[\"$word\"]} + 1))\\n       else\\n         array[\"$word\"]=1\\n       fi\\n     done\\ndone < $file\\n\\nfor key in \"${!array[@]}\"\\ndo\\necho $key ${array[$key]}\\ndone | sort -k2rn\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nfile=words.txt\\n\\ndeclare -A array\\ncnt=1\\n\\nwhile read line\\ndo\\n     for word in $line\\n     do\\n       if [ -n \"${array[$word]}\" ]\\n       then\\n          array[\"$word\"]=$((${array[\"$word\"]} + 1))\\n       else\\n         array[\"$word\"]=1\\n       fi\\n     done\\ndone < $file\\n\\nfor key in \"${!array[@]}\"\\ndo\\necho $key ${array[$key]}\\ndone | sort -k2rn\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812498,
                "title": "solution-using-awk-exclusively-runtime-62ms-beats-100-of-submissions",
                "content": "```bash\\nawk \\'\\nBEGIN {\\n    init = 0;\\n}\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (init == 0) {\\n            t[$i] = 1; #Initialize array that holds the number of times we see a word.\\n            init = 1;\\n        }\\n        else {\\n            if ($i in t) { # If word already in array\\n                t[$i] += 1;\\n            } \\n            else {\\n                t[$i] = 1;\\n            }\\n        }\\n    }\\n}\\nEND {\\n\\t#Traverse array elements values in descending numerical order\\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"; \\n    for (word in t) {\\n        print (word, t[word]);\\n    }\\n}\\n\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\nawk \\'\\nBEGIN {\\n    init = 0;\\n}\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (init == 0) {\\n            t[$i] = 1; #Initialize array that holds the number of times we see a word.\\n            init = 1;\\n        }\\n        else {\\n            if ($i in t) { # If word already in array\\n                t[$i] += 1;\\n            } \\n            else {\\n                t[$i] = 1;\\n            }\\n        }\\n    }\\n}\\nEND {\\n\\t#Traverse array elements values in descending numerical order\\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"; \\n    for (word in t) {\\n        print (word, t[word]);\\n    }\\n}\\n\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629799,
                "title": "solution",
                "content": "```\\nsed -z \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "```\\nsed -z \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2528410,
                "title": "tr-grep-sort-uniq-sed-single-line-with-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ntr \\' \\'  \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```\\n\\nFor explanation please refer:\\nhttps://leet-codes.blogspot.com/2022/09/192-word-frequency.html",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ntr \\' \\'  \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516734,
                "title": "solve-by-a-pipeline",
                "content": "``` bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [],
                "code": "``` bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451304,
                "title": "faster-than-99-42-31-12-space",
                "content": "```\\nawk \\'{ for (i=1;i<=NF;i++) { counts[$i]++ } } END { for (k in counts) { print(k, counts[k]) } }\\' words.txt | sort -nrk2\\n```\\n\\nStores counts in an array in awk and spits them out at the end. `sort -nrk2` sorts numerically, reverse order, on 2nd column.\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nawk \\'{ for (i=1;i<=NF;i++) { counts[$i]++ } } END { for (k in counts) { print(k, counts[k]) } }\\' words.txt | sort -nrk2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2404252,
                "title": "one-simple-and-quick-solution",
                "content": "#!/bin/bash\\n\\na=();\\ndeclare -A hash;\\nwhile IFS=\" \" read -r -a line; do\\n    for word in ${line[*]};do\\n        let \"hash[$word]+=1\";\\n    done\\ndone < words.txt\\n\\nfor i in ${!hash[@]};do\\n    echo $i ${hash[$i]};\\ndone | sort -k 2nr\\n",
                "solutionTags": [],
                "code": "#!/bin/bash\\n\\na=();\\ndeclare -A hash;\\nwhile IFS=\" \" read -r -a line; do\\n    for word in ${line[*]};do\\n        let \"hash[$word]+=1\";\\n    done\\ndone < words.txt\\n\\nfor i in ${!hash[@]};do\\n    echo $i ${hash[$i]};\\ndone | sort -k 2nr\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2184536,
                "title": "sed-with-awk-nf-to-filter-blank-lines",
                "content": "Nothing special, just some syntax simplification ideas.\\n```\\nsed \\'s/ /\\\\n/g\\' w* | awk NF | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/ /\\\\n/g\\' w* | awk NF | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119972,
                "title": "pure-bash-using-associative-arrays-and-sort",
                "content": "```\\ndeclare -A array\\nreadarray -t words < words.txt\\nfor w in ${words[@]}; do\\n    if [ -v \\'array[i]\\' ];then\\n        array[$w]=0\\n    else\\n        ((array[$w]+=1))\\n    fi\\ndone\\n\\nfor key in \"${!array[@]}\"; do\\n    echo $key ${array[$key]}\\ndone | sort -k2 -r -n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -A array\\nreadarray -t words < words.txt\\nfor w in ${words[@]}; do\\n    if [ -v \\'array[i]\\' ];then\\n        array[$w]=0\\n    else\\n        ((array[$w]+=1))\\n    fi\\ndone\\n\\nfor key in \"${!array[@]}\"; do\\n    echo $key ${array[$key]}\\ndone | sort -k2 -r -n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711091,
                "title": "use-tr",
                "content": "```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n\\n1. `tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt ` One word perline\\n2. `sort | uniq -c` Precede each output line with the count of the number of times the line occurred\\n3. `sort -r` Descending sort order\\n4. `awk \\'{print $2\" \"$1}\\'` Output becareful space between two column\\n\\n\\nFor example:\\n\\nwords.txt\\n```txt\\nthe day is sunny the the\\nthe sunny is is\\na  a   b\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt\\n\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\na\\na\\nb\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r\\n   4 the\\n   3 is\\n   2 sunny\\n   2 a\\n   1 day\\n   1 b\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\nthe 4\\nis 3\\nsunny 2\\na 2\\nday 1\\nb 1\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\n```txt\\nthe day is sunny the the\\nthe sunny is is\\na  a   b\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt\\n\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\na\\na\\nb\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r\\n   4 the\\n   3 is\\n   2 sunny\\n   2 a\\n   1 day\\n   1 b\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\nthe 4\\nis 3\\nsunny 2\\na 2\\nday 1\\nb 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411386,
                "title": "one-liner-with-xargs",
                "content": "cat words.txt | xargs | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "cat words.txt | xargs | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1401595,
                "title": "sed-grep-sort-uniq-awk",
                "content": "```\\nsed \\'s/ \\\\+/\\\\n/g\\' words.txt | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/ \\\\+/\\\\n/g\\' words.txt | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388029,
                "title": "pure-awk-implementation-0ms-runtime",
                "content": "```\\nawk \\'\\n{\\n    for(i=1;i<=NF;i++) {\\n        ++map[$i]\\n    }\\n}\\n\\nEND {\\n    n=asorti(map, sorted, \"@val_num_asc\")\\n    for (i=n;i!=0;i--) {\\n        print sorted[i]\" \"map[sorted[i]]\\n    }\\n}\\n\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for(i=1;i<=NF;i++) {\\n        ++map[$i]\\n    }\\n}\\n\\nEND {\\n    n=asorti(map, sorted, \"@val_num_asc\")\\n    for (i=n;i!=0;i--) {\\n        print sorted[i]\" \"map[sorted[i]]\\n    }\\n}\\n\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197490,
                "title": "non-one-liner-s-benefits-memory-usage-3-1-mb-less-than-95-77",
                "content": "```\\ndeclare -r input_file=\"words.txt\"\\n\\nif ! [[ -f \"${input_file}\" ]]; then\\n    exit 1\\nfi\\n\\nunset -v words_freq\\ndeclare -A words_freq\\n\\n# Collect data from file\\nwhile IFS= read -r line || [ -n \"$line\" ]; do\\n    for word in ${line}; do ((words_freq[$word]++)); done\\ndone < ${input_file}\\n\\n# Output data sorted by frequency\\nfor word in ${!words_freq[@]}\\ndo\\n    echo -e \"${word} ${words_freq[$word]}\"\\ndone | sort -rn -k2\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -r input_file=\"words.txt\"\\n\\nif ! [[ -f \"${input_file}\" ]]; then\\n    exit 1\\nfi\\n\\nunset -v words_freq\\ndeclare -A words_freq\\n\\n# Collect data from file\\nwhile IFS= read -r line || [ -n \"$line\" ]; do\\n    for word in ${line}; do ((words_freq[$word]++)); done\\ndone < ${input_file}\\n\\n# Output data sorted by frequency\\nfor word in ${!words_freq[@]}\\ndo\\n    echo -e \"${word} ${words_freq[$word]}\"\\ndone | sort -rn -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174939,
                "title": "fast-tr-awk-sort-pipeline-with-associative-array",
                "content": "I first relied two `sort` with `uniq -c`, but then I thought I could shorten the pipeline to just three processes like this, by using associative arrays from awk:\\n\\n```\\ntr \\' \\\\t\\\\n\\' \\'\\\\n\\' < words.txt | awk \\'(NF==1){count[$1]++} END{for (w in count) {print w, count[w];}}\\' | sort -k 2nr\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\ntr \\' \\\\t\\\\n\\' \\'\\\\n\\' < words.txt | awk \\'(NF==1){count[$1]++} END{for (w in count) {print w, count[w];}}\\' | sort -k 2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144075,
                "title": "pure-bash-one-liner-code",
                "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print($2,$1)}\\'\\n\\ntr is  is a command-line utility in Linux and Unix systems that squezzes string using -s .",
                "solutionTags": [],
                "code": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print($2,$1)}\\'\\n\\ntr is  is a command-line utility in Linux and Unix systems that squezzes string using -s .",
                "codeTag": "Python3"
            },
            {
                "id": 1134791,
                "title": "with-awk-100-faster",
                "content": "```awk \\'{for(i=1;i<=NF;i++){a[$i]++}}END{for(i in a) print i\" \"a[i]}\\' words.txt |sort -k2nr```\\n",
                "solutionTags": [],
                "code": "```awk \\'{for(i=1;i<=NF;i++){a[$i]++}}END{for(i in a) print i\" \"a[i]}\\' words.txt |sort -k2nr```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112216,
                "title": "streamlining-pipe-and-sorting",
                "content": "`cat words.txt  | xargs | sed \\'s/\\\\ /\\\\n/g\\' | sort -d | uniq -c | sort -r | awk \\'{print $2, $1}\\' `",
                "solutionTags": [],
                "code": "`cat words.txt  | xargs | sed \\'s/\\\\ /\\\\n/g\\' | sort -d | uniq -c | sort -r | awk \\'{print $2, $1}\\' `",
                "codeTag": "Unknown"
            },
            {
                "id": 1086387,
                "title": "this-does-not-work-find-the-mistake-try-yourself",
                "content": "```\\nfor i in `cat words.txt`; do echo $i; done | sort | uniq -c | awk \\'FZ=\" \" {print $2,$1}\\' | sort -k2 -r\\n```\\n\\nbut this will run 100% faster \\n\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'FS=\" \"{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `cat words.txt`; do echo $i; done | sort | uniq -c | awk \\'FZ=\" \" {print $2,$1}\\' | sort -k2 -r\\n```\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'FS=\" \"{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056046,
                "title": "simple-and-easy-solution-100-fast",
                "content": "The below solution is 100% fast using awk, tr , sort and uniq.\\n\\n```bash\\ncat words.txt | tr \" \" \"\\\\n\" | awk \\'{print $1\"\\\\n\"}\\' | grep -v ^$ | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "The below solution is 100% fast using awk, tr , sort and uniq.\\n\\n```bash\\ncat words.txt | tr \" \" \"\\\\n\" | awk \\'{print $1\"\\\\n\"}\\' | grep -v ^$ | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1000886,
                "title": "one-line-solution-using-perl",
                "content": "perl -0777 -lape\\'s/\\\\s+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "perl -0777 -lape\\'s/\\\\s+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 966506,
                "title": "works-in-my-bash-shell-but-not-here",
                "content": "Anyone know why?  This runs perfectly on my comp.  Not here tho...  could \\'read\\' be the problem?\\n\\n```\\nwhile read -d \\' \\' word; do echo \"$word\"; done < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n\\nThis produces no output in leetcode environment, but matches the reference output given using the same text on two different machines I tested it on...",
                "solutionTags": [],
                "code": "```\\nwhile read -d \\' \\' word; do echo \"$word\"; done < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965775,
                "title": "easy-one-liner",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871388,
                "title": "just-simple-awk",
                "content": "```\\nfile=\"words.txt\"\\n\\negrep -o \"\\\\b[[:alpha:]]+\\\\b\" $file | \\\\\\nawk \\'{ count[$0]++ }\\nEND {\\nfor(ind in count)\\n{ print ind \" \" count[ind]}\\n}\\' |  sort -k2 -nr\\n```",
                "solutionTags": [],
                "code": "```\\nfile=\"words.txt\"\\n\\negrep -o \"\\\\b[[:alpha:]]+\\\\b\" $file | \\\\\\nawk \\'{ count[$0]++ }\\nEND {\\nfor(ind in count)\\n{ print ind \" \" count[ind]}\\n}\\' |  sort -k2 -nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796172,
                "title": "0-ms-3-1-mb-background-task-with-for-loop",
                "content": "\\n```\\n#!/bin/bash\\nmany=$(sed \\'s/ /\\\\n/g\\' words.txt)\\nfor word in $(printf \"$many\" | sort -u)\\ndo\\n\\tprintf \"%s %d\\\\n\" $word $(printf \"$many\" | grep -w $word | wc -l) &\\ndone | sort -nru -k2\\n```\\n\\nThe key is to add the ```&``` to the end of the grep. This launches it as a background process. Without executing the grep operation as a background task, it takes 4 ms.",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\nmany=$(sed \\'s/ /\\\\n/g\\' words.txt)\\nfor word in $(printf \"$many\" | sort -u)\\ndo\\n\\tprintf \"%s %d\\\\n\" $word $(printf \"$many\" | grep -w $word | wc -l) &\\ndone | sort -nru -k2\\n```\n```&```",
                "codeTag": "Unknown"
            },
            {
                "id": 714583,
                "title": "one-line-use-awk-and-sort-and-uniq-c",
                "content": "```\\ncat words.txt | awk \\'BEGIN{FS=\" \"}{for(i=1;i<=NF;i++){print $i}}\\' | sort | uniq -c | awk \\'BEGIN{FS=\" \"}{print $2,$1}\\' | sort -k2 -rn\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | awk \\'BEGIN{FS=\" \"}{for(i=1;i<=NF;i++){print $i}}\\' | sort | uniq -c | awk \\'BEGIN{FS=\" \"}{print $2,$1}\\' | sort -k2 -rn\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690248,
                "title": "accepted-solution-0ms-run-time",
                "content": "cat words.txt|sed -z \\'s|\\\\n| |g\\'|sed \\'s| \\\\+|\\\\n|g\\' |sort |uniq -c|sort -rn|awk \\'{print $2\" \"$1}\\'\\n",
                "solutionTags": [],
                "code": "cat words.txt|sed -z \\'s|\\\\n| |g\\'|sed \\'s| \\\\+|\\\\n|g\\' |sort |uniq -c|sort -rn|awk \\'{print $2\" \"$1}\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 602366,
                "title": "bash-pipe-solution",
                "content": "\\n\\n`cat words.txt |tr  \\' \\' \\'\\\\n\\' | sort | uniq -c |  sort -k1nr  | awk \\'{print$2\" \"$1}\\'`",
                "solutionTags": [],
                "code": "\\n\\n`cat words.txt |tr  \\' \\' \\'\\\\n\\' | sort | uniq -c |  sort -k1nr  | awk \\'{print$2\" \"$1}\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 543997,
                "title": "1-line-pipe-command",
                "content": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538900,
                "title": "one-line-using-piple",
                "content": "```cat words.txt | tr -s \\' \\' \\'\\\\n\\'  | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2\" \"$1}\\'```\\n\\nanother way(using loop and array) but it is not  the solution for this qustion \\nMy script \\n```\\n\\n#/bin/bash\\n#script will get how many times the word is repeated \\n#there might be other ways much much better than what i wrote\\n#file path\\nfile=$1\\n#store all words in this array\\narr=()\\n#store Unique Words\\narrU=()\\n\\n#loop in file and store the words in this arr\\nfor word in $(cat $file);\\ndo\\narr=(\"${arr[@]}\" \"$word\")\\ndone\\n\\nif [[ \"${#arr[@]}\" -gt 0 ]];then\\narrU=(\"${arr[0]}\")\\n# loop and store value in this arrU if no match was found\\nfor w in \"${arr[@]}\";\\ndo\\n  check=false\\n  for wu in \"${arrU[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcheck=true\\n\\tfi\\n  done\\n \\nif [[ \"$check\" = false ]];then\\n    arrU=(\"${arrU[@]}\" \"$w\")\\nfi\\ndone\\n\\n#count how many time the word is repeated\\nfor wu in \"${arrU[@]}\";\\ndo\\n  count=0\\n  for w in \"${arr[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcount=$((count + 1))\\t\\n\\tfi \\n  done\\n echo \"$wu $count\"\\ndone\\n\\nelse\\necho \"File is empty\"\\nfi\\n\\n```\\n\\nusage\\n\\n```\\n./frequency.sh words.txt | sort -rk 2\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cat words.txt | tr -s \\' \\' \\'\\\\n\\'  | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2\" \"$1}\\'```\n```\\n\\n#/bin/bash\\n#script will get how many times the word is repeated \\n#there might be other ways much much better than what i wrote\\n#file path\\nfile=$1\\n#store all words in this array\\narr=()\\n#store Unique Words\\narrU=()\\n\\n#loop in file and store the words in this arr\\nfor word in $(cat $file);\\ndo\\narr=(\"${arr[@]}\" \"$word\")\\ndone\\n\\nif [[ \"${#arr[@]}\" -gt 0 ]];then\\narrU=(\"${arr[0]}\")\\n# loop and store value in this arrU if no match was found\\nfor w in \"${arr[@]}\";\\ndo\\n  check=false\\n  for wu in \"${arrU[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcheck=true\\n\\tfi\\n  done\\n \\nif [[ \"$check\" = false ]];then\\n    arrU=(\"${arrU[@]}\" \"$w\")\\nfi\\ndone\\n\\n#count how many time the word is repeated\\nfor wu in \"${arrU[@]}\";\\ndo\\n  count=0\\n  for w in \"${arr[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcount=$((count + 1))\\t\\n\\tfi \\n  done\\n echo \"$wu $count\"\\ndone\\n\\nelse\\necho \"File is empty\"\\nfi\\n\\n```\n```\\n./frequency.sh words.txt | sort -rk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535771,
                "title": "one-liner",
                "content": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | egrep \\'[a-zA-Z]+\\' | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | egrep \\'[a-zA-Z]+\\' | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534704,
                "title": "one-liner-solution-faster-than-100",
                "content": "cat words.txt | sed \\'s/ /\\\\n/g\\' | sort | uniq -c | sort -r | sed \\'s/^ *//g\\' | sed \\'/[0-9]\\\\+ $/d\\' | awk \\'{ print $2\" \"$1 }\\'",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "cat words.txt | sed \\'s/ /\\\\n/g\\' | sort | uniq -c | sort -r | sed \\'s/^ *//g\\' | sed \\'/[0-9]\\\\+ $/d\\' | awk \\'{ print $2\" \"$1 }\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 525687,
                "title": "one-liner-0ms-must-be-some-sort-of-bug",
                "content": "```\\ncat words.txt | tr \" \" \"\\\\n\" |grep .|sort|uniq -c|sed \\'s/^ *//\\' | sort -rn | sed \\'s/^\\\\([0-9]\\\\+\\\\) \\\\([a-z]\\\\+\\\\).*/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \" \" \"\\\\n\" |grep .|sort|uniq -c|sed \\'s/^ *//\\' | sort -rn | sed \\'s/^\\\\([0-9]\\\\+\\\\) \\\\([a-z]\\\\+\\\\).*/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524973,
                "title": "one-line-with-sed-and-awk",
                "content": "sed -E -e \\'s/[[:blank:]]+/\\\\n/g\\'  words.txt |sort |awk \\'{myword[$0]++} END {for (x in myword) print x,myword[x]}\\' |sort -k2,2 -r",
                "solutionTags": [],
                "code": "sed -E -e \\'s/[[:blank:]]+/\\\\n/g\\'  words.txt |sort |awk \\'{myword[$0]++} END {for (x in myword) print x,myword[x]}\\' |sort -k2,2 -r",
                "codeTag": "Unknown"
            },
            {
                "id": 524542,
                "title": "one-line-with-grep-sed-and-awk",
                "content": "\\n`cat words.txt  | sed \\'s/\\\\\\\\n/ /g\\' | sed \\'s/ /\\\\n/g\\' | sort | uniq -c  | sort -rn | awk \\'{print $2\" \"$1}\\' | grep -Ev \\'^\\\\s\\'`",
                "solutionTags": [],
                "code": "\\n`cat words.txt  | sed \\'s/\\\\\\\\n/ /g\\' | sed \\'s/ /\\\\n/g\\' | sort | uniq -c  | sort -rn | awk \\'{print $2\" \"$1}\\' | grep -Ev \\'^\\\\s\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 499314,
                "title": "funny-solution",
                "content": "I\\'m not good at bash scripting, but at least can show my funny solution\\n```\\ninput=$(\\nthings=$(cat words.txt); \\nfor thing in $things; \\ndo echo $thing; \\ndone | \\nsort | \\nuniq -c | \\nsort -nr); \\narr=($input); \\nfor ((i=1; i<=${#arr[@] + 1}; i+=2)) do \\necho \"${arr[i]//[$\\'\\\\t\\\\r\\\\n\\']} ${arr[i-1]//[$\\'\\\\t\\\\r\\\\n\\']}\"; \\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ninput=$(\\nthings=$(cat words.txt); \\nfor thing in $things; \\ndo echo $thing; \\ndone | \\nsort | \\nuniq -c | \\nsort -nr); \\narr=($input); \\nfor ((i=1; i<=${#arr[@] + 1}; i+=2)) do \\necho \"${arr[i]//[$\\'\\\\t\\\\r\\\\n\\']} ${arr[i-1]//[$\\'\\\\t\\\\r\\\\n\\']}\"; \\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498257,
                "title": "help-why-did-i-get-wrong-answer-with-the-same-output-as-expected",
                "content": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n#!/bin/bash\\n\\nn=\"$( cat words.txt | tr \\' \\' \\'\\\\n\\' | sort  | uniq -c | tr -s \\' \\' | cut -d \" \" -f 3,2 )\"\\nr=\"\"\\nlet count=0\\nfor i in $n\\ndo\\n\\n    (( $count%2==0 )) && (( $count>1 )) && r=\"\\\\n$r\"\\n    let count++\\n    r=\"$i $r\"\\n\\ndone\\necho -e \"$r\"\\n```\\n![image](https://assets.leetcode.com/users/yyuze/image_1580747168.png)\\n",
                "solutionTags": [],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n#!/bin/bash\\n\\nn=\"$( cat words.txt | tr \\' \\' \\'\\\\n\\' | sort  | uniq -c | tr -s \\' \\' | cut -d \" \" -f 3,2 )\"\\nr=\"\"\\nlet count=0\\nfor i in $n\\ndo\\n\\n    (( $count%2==0 )) && (( $count>1 )) && r=\"\\\\n$r\"\\n    let count++\\n    r=\"$i $r\"\\n\\ndone\\necho -e \"$r\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498144,
                "title": "less-then-100-others-by-memory-usage-for-now",
                "content": "0ms, 3.1mb\\n\\n`sed \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt| sort | uniq -c |sort -nr | sed -e \\'s/\\\\s\\\\+\\\\([0-9]\\\\+\\\\)\\\\s\\\\+\\\\(.\\\\+\\\\)/\\\\2 \\\\1/;t;d\\'` \\n\\nIt was my first try, so I will try to optimize it.",
                "solutionTags": [],
                "code": "0ms, 3.1mb\\n\\n`sed \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt| sort | uniq -c |sort -nr | sed -e \\'s/\\\\s\\\\+\\\\([0-9]\\\\+\\\\)\\\\s\\\\+\\\\(.\\\\+\\\\)/\\\\2 \\\\1/;t;d\\'` \\n\\nIt was my first try, so I will try to optimize it.",
                "codeTag": "Unknown"
            },
            {
                "id": 488733,
                "title": "any-reason-i-m-getting-rbash-prog-sh-permission-denied",
                "content": "rbash: ./prog.sh: Permission denied for:\\n```\\nfor i in `cat words.txt`; do echo $i ; done|sort|uniq -c|sort -nr| awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `cat words.txt`; do echo $i ; done|sort|uniq -c|sort -nr| awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487926,
                "title": "my-solution",
                "content": "```\\nlist=($(cat words.txt | awk \"/[a-z]+/\"))\\nprintf \"%s\\\\n\" \"${list[@]}\" | sort | uniq -c | sort -k2 -r -n | awk \\'{printf \"%s %s\\\\n\", $2, $1}\\'\\n```\\nFirst I put all the lowercase words inside of an array. The OFS will automatically separate the array by space\\nNext I print out sort the array by uniqueness and output the count as well. Since the fields should be switched and not sorted by descending order, I put it through another sort and pipe it to another awk, where I switch the fields.",
                "solutionTags": [],
                "code": "```\\nlist=($(cat words.txt | awk \"/[a-z]+/\"))\\nprintf \"%s\\\\n\" \"${list[@]}\" | sort | uniq -c | sort -k2 -r -n | awk \\'{printf \"%s %s\\\\n\", $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459274,
                "title": "1-line-100-faster",
                "content": "```\\ntr \"\\\\n\" \" \" < words.txt |  tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ntr \"\\\\n\" \" \" < words.txt |  tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456146,
                "title": "one-liner",
                "content": "```\\ntr \\' \\' \\'\\\\12\\' < words.txt  | sed \\'/^$/d\\'| sort |uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntr \\' \\' \\'\\\\12\\' < words.txt  | sed \\'/^$/d\\'| sort |uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432579,
                "title": "easy-to-understand-iteration-associative-array",
                "content": "```bash\\ndeclare -A WORD_FREQ_TABLE\\n\\ncat words.txt |\\n(while read line; do\\n    for word in $line; do\\n\\t# if the word does not exist\\n\\tif [ ${WORD_FREQ_TABLE[\"$word\"]+_} ]; then\\n\\t    WORD_FREQ_TABLE[\"$word\"]=$(( WORD_FREQ_TABLE[\"$word\"] + 1 ))\\n\\telse\\n\\t    WORD_FREQ_TABLE[\"$word\"]=1\\n\\tfi\\n    done\\ndone\\n\\nfor item in \"${!WORD_FREQ_TABLE[@]}\"; do\\n    echo \"$item\"  ${WORD_FREQ_TABLE[\"$item\"]}\\ndone | sort -r -k2 -n)",
                "solutionTags": [],
                "code": "```bash\\ndeclare -A WORD_FREQ_TABLE\\n\\ncat words.txt |\\n(while read line; do\\n    for word in $line; do\\n\\t# if the word does not exist\\n\\tif [ ${WORD_FREQ_TABLE[\"$word\"]+_} ]; then\\n\\t    WORD_FREQ_TABLE[\"$word\"]=$(( WORD_FREQ_TABLE[\"$word\"] + 1 ))\\n\\telse\\n\\t    WORD_FREQ_TABLE[\"$word\"]=1\\n\\tfi\\n    done\\ndone\\n\\nfor item in \"${!WORD_FREQ_TABLE[@]}\"; do\\n    echo \"$item\"  ${WORD_FREQ_TABLE[\"$item\"]}\\ndone | sort -r -k2 -n)",
                "codeTag": "Unknown"
            },
            {
                "id": 432428,
                "title": "my-accepted-solution",
                "content": "```cat words.txt | sed \"s/ /\\\\n/g\" | grep -v \"^$\" | sort | uniq -c | awk \\'{print $2 \" \" $1}\\'```",
                "solutionTags": [],
                "code": "```cat words.txt | sed \"s/ /\\\\n/g\" | grep -v \"^$\" | sort | uniq -c | awk \\'{print $2 \" \" $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 402732,
                "title": "my-accepted-answer-using-for-loop-grep-and-without-using-awk",
                "content": "```\\nfor i in `sed \\'s/ /\\\\n/g\\' words.txt | sort -u`; do echo -ne $i; echo -ne \" \"; sed \\'s/ /\\\\n/g\\' words.txt | grep -wc $i; done | sort -k 2 -nr\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor i in `sed \\'s/ /\\\\n/g\\' words.txt | sort -u`; do echo -ne $i; echo -ne \" \"; sed \\'s/ /\\\\n/g\\' words.txt | grep -wc $i; done | sort -k 2 -nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374308,
                "title": "one-line-solution-using-pipe",
                "content": "```\\nsed \\'s/^  *//g\\' words.txt | sed \\'s/  *$//g\\'| sed \\'s/  */\\\\n/g\\' | sort | uniq -c | sort -rn | sed \\'s/^ *\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2 \\\\1/g\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/^  *//g\\' words.txt | sed \\'s/  *$//g\\'| sed \\'s/  */\\\\n/g\\' | sort | uniq -c | sort -rn | sed \\'s/^ *\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2 \\\\1/g\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355301,
                "title": "common-awk-solution-it-is-very-easy-to-understand",
                "content": "```\\ncat words.txt| awk \\'{for(i=1;i<=NF;i++){count[$i]++}}END{for(k in count){print k \" \"count[k]}}\\'|sort -rnk 2\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt| awk \\'{for(i=1;i<=NF;i++){count[$i]++}}END{for(k in count){print k \" \"count[k]}}\\'|sort -rnk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354236,
                "title": "one-line-with-pipes",
                "content": "```\\ncat words.txt | tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565744,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566014,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1568235,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566764,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570458,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570253,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569478,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569010,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569011,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1575333,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1565744,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566014,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1568235,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566764,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570458,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570253,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569478,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569010,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569011,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1575333,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1574095,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1573493,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572958,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572647,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572449,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1571408,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 2044719,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670646,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670644,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670562,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Nim Game",
        "question_content": "<p>You are playing the following Nim Game with your friend:</p>\n\n<ul>\n\t<li>Initially, there is a heap of stones on the table.</li>\n\t<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>\n\t<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>\n\t<li>The one who removes the last stone is the winner.</li>\n</ul>\n\n<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code><em> if you can win the game assuming both you and your friend play optimally, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> false\n<strong>Explanation:</strong> These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 73749,
                "title": "theorem-all-4s-shall-be-false",
                "content": "> Theorem: The first one who got the number that is multiple of 4 (i.e. n % 4 == 0) will lost, otherwise he/she will win.\\n\\nProof: \\n\\n 1. the base case: when `n = 4`, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number.\\n \\n 2. For `1* 4 < n < 2 * 4, (n = 5, 6, 7)`, the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers 5, 6, 7 are winning numbers for any player who got it first. \\n\\n 3. Now to the beginning of the next cycle, `n = 8`, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, 8 % 4 == 0, again is a death number.\\n\\n 4. Following the second case, for numbers between (2\\\\*4 = 8) and (3\\\\*4=12), which are `9, 10, 11`, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8.\\n\\n\\nFollowing the above theorem and proof, the solution could not be simpler: \\n\\n    public boolean canWinNim(int n) {    \\n        return n % 4 != 0 ;\\n    }",
                "solutionTags": [],
                "code": "> Theorem: The first one who got the number that is multiple of 4 (i.e. n % 4 == 0) will lost, otherwise he/she will win.\\n\\nProof: \\n\\n 1. the base case: when `n = 4`, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number.\\n \\n 2. For `1* 4 < n < 2 * 4, (n = 5, 6, 7)`, the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers 5, 6, 7 are winning numbers for any player who got it first. \\n\\n 3. Now to the beginning of the next cycle, `n = 8`, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, 8 % 4 == 0, again is a death number.\\n\\n 4. Following the second case, for numbers between (2\\\\*4 = 8) and (3\\\\*4=12), which are `9, 10, 11`, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8.\\n\\n\\nFollowing the above theorem and proof, the solution could not be simpler: \\n\\n    public boolean canWinNim(int n) {    \\n        return n % 4 != 0 ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73760,
                "title": "one-line-o-1-solution-and-explanation",
                "content": "suppose there are x stones left for first player (A), he can take 1,2,3 stones away, so second player B will have three cases to deal with (x -1), (x-2), (x-3). after he pick the stones, there will be 9 cases left for A.\\n\\n    B (x-1) -> A: (x-2), (x-3), (x-4)\\n    B (x-2) -> A: (x-3), (x-4), (x-5)\\n    B (x-3) -> A: (x-4), (x-5), (x-6)\\n\\nNow, if A can guarantee he win at either of three groups, then he can force B to into that one of the three states and A can end up in that particular group after B's move. \\n\\n    f(x) = (f(x-2)&&f(x-3)&&f(x-4)) || (f(x-3)&&f(x-4)&&f(x-5)) || (f(x-4)&&f(x-5)&&f(x-6))\\n\\nif we examine the equation a little closer, we can find f(x - 4) is a critical point, if f(x-4) is false, then f(x) will be always false.\\n\\nwe can also find out the initial conditions, f(1), f(2), f(3) will be true (A always win), and f(4) will be false. so\\nbased on previous equation and initial conditions f(5) = f(6) = f(7) = true, f(8) = false;\\nobviously, f(1), f(2), f(3) can make all f(4n + 1), f(4n + 2), f(4n + 3) to be true, only f(4n) will be false then.\\nso here we go our one line solution:\\n\\nreturn (n % 4 != 0);",
                "solutionTags": [
                    "Java"
                ],
                "code": "suppose there are x stones left for first player (A), he can take 1,2,3 stones away, so second player B will have three cases to deal with (x -1), (x-2), (x-3). after he pick the stones, there will be 9 cases left for A.\\n\\n    B (x-1) -> A: (x-2), (x-3), (x-4)\\n    B (x-2) -> A: (x-3), (x-4), (x-5)\\n    B (x-3) -> A: (x-4), (x-5), (x-6)\\n\\nNow, if A can guarantee he win at either of three groups, then he can force B to into that one of the three states and A can end up in that particular group after B's move. \\n\\n    f(x) = (f(x-2)&&f(x-3)&&f(x-4)) || (f(x-3)&&f(x-4)&&f(x-5)) || (f(x-4)&&f(x-5)&&f(x-6))\\n\\nif we examine the equation a little closer, we can find f(x - 4) is a critical point, if f(x-4) is false, then f(x) will be always false.\\n\\nwe can also find out the initial conditions, f(1), f(2), f(3) will be true (A always win), and f(4) will be false. so\\nbased on previous equation and initial conditions f(5) = f(6) = f(7) = true, f(8) = false;\\nobviously, f(1), f(2), f(3) can make all f(4n + 1), f(4n + 2), f(4n + 3) to be true, only f(4n) will be false then.\\nso here we go our one line solution:\\n\\nreturn (n % 4 != 0);",
                "codeTag": "Unknown"
            },
            {
                "id": 73837,
                "title": "o-1-efficient-single-line-java-using-bit-checking",
                "content": "If the two least significant bits of `n` are zeros, you will never win.\\nWhy? Because **whoever is dealt a hand of 4 will never win**. Since your opponent is also very smart, she can reduce any multiple of `4` to `4` for you and you'll never win. Instead of using modulo or division, you can verify if a number is a multiple of `4` by checking its two least significant bits.\\n\\n    public boolean canWinNim(int n) {\\n      return (n & 0b11) != 0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "If the two least significant bits of `n` are zeros, you will never win.\\nWhy? Because **whoever is dealt a hand of 4 will never win**. Since your opponent is also very smart, she can reduce any multiple of `4` to `4` for you and you'll never win. Instead of using modulo or division, you can verify if a number is a multiple of `4` by checking its two least significant bits.\\n\\n    public boolean canWinNim(int n) {\\n      return (n & 0b11) != 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73863,
                "title": "1-line-0-ms-c-solution-with-explanation",
                "content": "**Explanation:** <br>\\nAt first this problem might seems a bit tough but it is easy and has a pattern which is as follow. <br>\\nI have applied the bottom up dynamic programming approach to fill the array and noticed that only number divisible by 4 are the positions where player1(playing first chance) is losing. <br>\\n\\n    class Solution {\\n    public:\\n        bool canWinNim(int n) {\\n            return n%4 ;\\n        }\\n    };\\n\\n 1. **Base case :** <i><br> \\n   If the numbers of stones are 1,2 or 3, then player 1 will win. <br>\\n   If the numbers of stones are 4, then player 1 will lose irrespective of the number of stones he/she remove<br>\\n   So lookup table will look like this : W[1]->W[2]->W[3]->L[4]. <br>\\n 2. For num_stones=5, the player can either remove 1,2 or 3 stones i.e. the other player (player 2) will win if the number of stones left are 1,2 or 3 and will lose only when the number of stones left are 4 ( see the lookup table in step 1) . <br> So, if Player1 remove 1 stone, the number of stones left will be 4, which will defeat player2. So, now the lookup entry for num_stones=5 will be W. \\nLookup now will look like this : W->W->W->L->W (for player 1-> who is taking the first chance). <br>\\n 3. Likewise, we can fill the complete lookup table by looking at the values at last three index. If anyone of them is L => Player 1 will win the game as he will remove only that many number of stones which will bring player 2 to the L position <br>\\n 4. In the end, you will notice that only positions 4->8->12->16 will contain L for player 1 thus answer is simple n%4.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        bool canWinNim(int n) {\\n            return n%4 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 73845,
                "title": "two-java-solution",
                "content": "DP : Line 7: java.lang.OutOfMemoryError: Java heap space\\n\\n    public boolean canWinNim(int n) {\\n        if(n <= 0)\\n            throw new IllegalArgumentException();\\n        if(n < 4)\\n            return true;\\n        boolean[] res = new boolean[n + 1];\\n        res[0] = true;\\n        res[1] = true;\\n        res[2] = true;\\n        res[3] = true;\\n        for(int i = 4 ; i <= n ; i++)\\n            res[i] = !(res[i - 1] && res[i - 2] && res[i - 3]);\\n        return res[n];\\n    }\\n\\nDirectly\\n\\n    if(n <= 0)\\n        throw new IllegalArgumentException();\\n    return !(n % 4 == 0);",
                "solutionTags": [],
                "code": "DP : Line 7: java.lang.OutOfMemoryError: Java heap space\\n\\n    public boolean canWinNim(int n) {\\n        if(n <= 0)\\n            throw new IllegalArgumentException();\\n        if(n < 4)\\n            return true;\\n        boolean[] res = new boolean[n + 1];\\n        res[0] = true;\\n        res[1] = true;\\n        res[2] = true;\\n        res[3] = true;\\n        for(int i = 4 ; i <= n ; i++)\\n            res[i] = !(res[i - 1] && res[i - 2] && res[i - 3]);\\n        return res[n];\\n    }\\n\\nDirectly\\n\\n    if(n <= 0)\\n        throw new IllegalArgumentException();\\n    return !(n % 4 == 0);",
                "codeTag": "Unknown"
            },
            {
                "id": 73774,
                "title": "if-i-m-a-interviewer-i-prefer-the-candidates-using-burte-force-instead-of-math-method",
                "content": "Because it is a \"coding interview\", not acm/icpc or other competitions. Similar to Josephus Cycle, I prefer LinkedList Cycle than Mod-Method during interviews. Here's a backtraking-dp solution.\\n\\n    public class Solution {\\n        public boolean canWinNim(int n) {\\n    \\t\\t    if(n>=134882061){//I have no any other ways,please forgive my unchastity(\\u65e0\\u8282\\u64cd)!\\n    \\t\\t\\t   return n%4 != 0;\\n    \\t\\t    }\\n    \\t\\t    int[] array=new int[n+1];\\n    \\t        return dfs(n, array);\\n    \\t }\\n    \\t public boolean dfs(int n,int[] array){\\n    \\t\\t if(array[n]!=0){\\n    \\t\\t\\t return array[n]==1?true:false;\\n    \\t\\t }\\n    \\t\\t if(n<=3){\\n    \\t        \\tarray[n]=1;\\n    \\t        \\treturn true;\\n    \\t        }else{\\n    \\t        \\tfor(int i=1;i<=3;i++){\\n    \\t        \\t\\tif(!dfs(n-i,array)){\\n    \\t        \\t\\t\\tarray[n-i]=-1;\\n    \\t        \\t\\t\\tarray[n]=1;\\n    \\t        \\t\\t\\treturn true;\\n    \\t        \\t\\t}\\n    \\t        \\t}\\n    \\t        \\tarray[n]=-1;\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t }\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public boolean canWinNim(int n) {\\n    \\t\\t    if(n>=134882061){//I have no any other ways,please forgive my unchastity(\\u65e0\\u8282\\u64cd)!\\n    \\t\\t\\t   return n%4 != 0;\\n    \\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 73851,
                "title": "1-liner-with-explanations",
                "content": "    class Solution(object):\\n        def canWinNim(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: bool\\n            \"\"\"\\n            # strategy: the one with 4 remaining must loose\\n            # A, B players\\n            # if n == 4k, then at each round B can make A+B both take 4, \\n            # eventually leave 4 to A, A lose\\n            # if n == 4k + i (i <= 3), then A can always take i first and B will\\n            # finanly lose as he faces above scenario like A\\n    \\n            return bool(n%4!=0)",
                "solutionTags": [
                    "Math"
                ],
                "code": "    class Solution(object):\\n        def canWinNim(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: bool\\n            \"\"\"\\n            # strategy: the one with 4 remaining must loose\\n            # A, B players\\n            # if n == 4k, then at each round B can make A+B both take 4, \\n            # eventually leave 4 to A, A lose\\n            # if n == 4k + i (i <= 3), then A can always take i first and B will\\n            # finanly lose as he faces above scenario like A\\n    \\n            return bool(n%4!=0)",
                "codeTag": "Java"
            },
            {
                "id": 73793,
                "title": "using-backtrace-and-dynamic-programming",
                "content": "The basic idea is very simple. if the opponent  can win , then the player will lose. The condition is that No matter how many stones the player move, the opponent will win. So the code is \\n\\n    if(canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n\\n\\nHere are the two methods.But they both cannot pass the large test case.\\n\\n    public boolean canWinNim(int n) {\\n        // 1 2 3 (4) 5 6 7 (8) 9 10 11 (12)\\n        if(n <= 0) return false;\\n        if(n == 1 || n == 2 || n== 3) return true;\\n        if(canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n        return true;\\n    }\\n\\n\\n    public boolean canWinNim(int n) {\\n        // 1 2 3 (4) 5 6 7 (8) 9 10 11 (12)\\n        // add this line to pass large test case\\n        if(n >= 134882061) return n%4 != 0;\\n        boolean res = true;\\n        boolean fir = true;\\n        boolean sec = true;\\n        boolean thir = true;\\n        for(int i=4;i<=n;i++){\\n            res = (fir && sec && thir) ? false:true;\\n            fir = sec;\\n            sec = thir;\\n            thir = res;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is very simple. if the opponent  can win , then the player will lose. The condition is that No matter how many stones the player move, the opponent will win. So the code is \\n\\n    if(canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n\\n\\nHere are the two methods.But they both cannot pass the large test case.\\n\\n    public boolean canWinNim(int n) {\\n        // 1 2 3 (4) 5 6 7 (8) 9 10 11 (12)\\n        if(n <= 0) return false;\\n        if(n == 1 || n == 2 || n== 3) return true;\\n        if(canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n        return true;\\n    }\\n\\n\\n    public boolean canWinNim(int n) {\\n        // 1 2 3 (4) 5 6 7 (8) 9 10 11 (12)\\n        // add this line to pass large test case\\n        if(n >= 134882061) return n%4 != 0;\\n        boolean res = true;\\n        boolean fir = true;\\n        boolean sec = true;\\n        boolean thir = true;\\n        for(int i=4;i<=n;i++){\\n            res = (fir && sec && thir) ? false:true;\\n            fir = sec;\\n            sec = thir;\\n            thir = res;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73841,
                "title": "math-proof-for-4k-is-a-sufficient-and-necessary-condition-for-not-win",
                "content": "Sufficient Condition (\"n = 4k => the first guy encounters n = 4k will fail\")\\n\\n  (1) Base case, true;   (2) Assume n = 4k makes one who take the first step from n=4k fail. For n = 4(k+1), you have no strategy to make your opponent be the one take the first step from n'=4k, while he can, thus you will fail. Therefore, for any \"n = 4k\", you will fail.\\n\\nNecessary Condition (\"fail => n = 4k\")\\n\\nIf the statement \"fail => n = 4k\" is true then the statement \"n != 4k => win\" is true. We can prove the later one: if n != 4k, thus n = 4k +1, or 4k + 2, or 4k + 3. For any of n = 4k +1, or 4k + 2, or 4k + 3, you can remove 1, or 2, or 3 stones to make your opponent be the guy who first encounter \"n is a multiple of 4 (n = 4 k' )\" situation in which the opponent is doom to fail, because we have proved \"n = 4k => the first guy encounters n = 4k will fail\". Therefore we've prove \"n != 4k => win\" is true, so \"fail => n = 4k\" is true.\\n\\nSo now we can confirm the one line solution is correct:\\n\\n```\\n    return n%4 == 0? false: true;\\n```",
                "solutionTags": [],
                "code": "```\\n    return n%4 == 0? false: true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73809,
                "title": "simple-java-solution-with-explanation",
                "content": "\\n    public boolean canWinNim(int n) {\\n        if (n <= 0) {return false;}\\n        return n % 4 != 0;\\n    }\\n\\n\\n----------\\n\\n - According to the hint, we know that if n = 4, no matter how many stones I remove, I lose. If n = 5, I can remove one stone and there are 4 stones for another player. Thus, I win. Similarly, if n = 6 or 7, I can remove 2 or 3 stones and i win finally.\\n - If n = 8, no matter how many stones I remove, there are 7 or 6 or 5 stones for another player, s/he can remove stones as we said before and then wins.\\n - If n = 9 or 10 or 11, I can leave 8 stones to another player, then I win.\\n - If n = 12, I can leave 9, 10 or 11 stones to another player. Then, s/he can leave 8 stones to me, then I lose.\\n......\\n - The rule is: if (n % 4 == 0) then I lose.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean canWinNim(int n) {\\n        if (n <= 0) {return false;}\\n        return n % 4 != 0;\\n    }\\n\\n\\n----------\\n\\n - According to the hint, we know that if n = 4, no matter how many stones I remove, I lose. If n = 5, I can remove one stone and there are 4 stones for another player. Thus, I win. Similarly, if n = 6 or 7, I can remove 2 or 3 stones and i win finally.\\n - If n = 8, no matter how many stones I remove, there are 7 or 6 or 5 stones for another player, s/he can remove stones as we said before and then wins.\\n - If n = 9 or 10 or 11, I can leave 8 stones to another player, then I win.\\n - If n = 12, I can leave 9, 10 or 11 stones to another player. Then, s/he can leave 8 stones to me, then I lose.\\n......\\n - The rule is: if (n % 4 == 0) then I lose.",
                "codeTag": "Unknown"
            },
            {
                "id": 73824,
                "title": "this-is-not-a-coding-problem",
                "content": "So far, I have never spent less time to solve a problem than this problem.\\nI honestly feel the problems at the latter part of the 300+ problems are focusing on something else other than coding itself. \\n\\n    return n%4;",
                "solutionTags": [],
                "code": "So far, I have never spent less time to solve a problem than this problem.\\nI honestly feel the problems at the latter part of the 300+ problems are focusing on something else other than coding itself. \\n\\n    return n%4;",
                "codeTag": "Unknown"
            },
            {
                "id": 1216565,
                "title": "c-solution-with-explaination",
                "content": "**Reasoning**\\n\\nLet us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game. So in order to win, you have to ensure that you never reach the situation where there are exactly four stones on the pile on your turn.\\n\\nSimilarly, if there are five, six, or seven stones you can win by taking just enough to leave four stones for your opponent so that they lose. But if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two or three stones from the pile, your opponent can pick three, two or one stone to ensure that, again, four stones will be left to you on your turn.\\n\\nIt is obvious that the same pattern repeats itself for n=4,8,12,16,\\\\dotsn=4,8,12,16,\\u2026, basically all multiples of 44\\n\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```\\n**Complexity Analysis**\\n\\nTime complexity is O(1)O(1), since only one check is performed. No additional space is used, so space complexity is also O(1)O(1).\\n\\n\\n**References**\\n\\nLecture on Nim Games from University of Maryland: MATH 199: Math, Game Theory and the Theory of Games, Summer 2006.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134338,
                "title": "formal-way-of-dynamic-programming-dp",
                "content": "Of course we can write\\n```\\n   return n%4;\\n```\\nto solve the problem.\\n\\nHowever, this is a good chance to use the basic idea of dynamic programming (DP). The idea is that we build the (partial) solution array as the scale of the program goes up, namely, we build res[0,1,2,...,].\\n\\nHere\\'s the code:\\n\\n```\\n\\tbool canWinNim(int n) {\\n\\t\\t\\t//return n%4; // of course we know this one\\n\\t\\t\\tvector<bool> res(n,false); // allocate the vector in advance\\n\\t\\t\\tres[1]=res[2]=res[3]=true; // known knowledge\\n\\t\\t\\tfor(int i=4;i<=n;i++){ // generate new knowledge while the scale goes larger\\n\\t\\t\\t    res[i]=(res[i-1]==false || res[i-2]==false || res[i-3]==false);\\n\\t\\t\\t}\\n\\t\\t\\treturn res[n];\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n   return n%4;\\n```\n```\\n\\tbool canWinNim(int n) {\\n\\t\\t\\t//return n%4; // of course we know this one\\n\\t\\t\\tvector<bool> res(n,false); // allocate the vector in advance\\n\\t\\t\\tres[1]=res[2]=res[3]=true; // known knowledge\\n\\t\\t\\tfor(int i=4;i<=n;i++){ // generate new knowledge while the scale goes larger\\n\\t\\t\\t    res[i]=(res[i-1]==false || res[i-2]==false || res[i-3]==false);\\n\\t\\t\\t}\\n\\t\\t\\treturn res[n];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73829,
                "title": "simple-one-line-code-get-the-result-java",
                "content": "    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n\\nP.s. It passed test case, but it didn't cover negative input\\n\\n    canWinNim(-1);\\n\\n I guess we don't have to care for illegal input when submit solution here.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n\\nP.s. It passed test case, but it didn't cover negative input\\n\\n    canWinNim(-1);\\n\\n I guess we don't have to care for illegal input when submit solution here.",
                "codeTag": "Unknown"
            },
            {
                "id": 73856,
                "title": "2-methods-for-python",
                "content": "    \\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n % 4)\\n\\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n & 3)",
                "solutionTags": [],
                "code": "    \\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n % 4)\\n\\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n & 3)",
                "codeTag": "Java"
            },
            {
                "id": 1141120,
                "title": "bottom-up-dp-python",
                "content": "Using bottom-up programming: \\nWe define function F(x): The capability of  you winning the game with x stones on your first turn.\\nIf you go first and n <= 3: you win.\\nelse F(x) > 3 after your turn, it\\'s your opponents turn\\n\\nWhich means if you go first and each of your three possible moves all land on F(X) => True for you, then it applies to your opponent as well. So F(X) = !F(x-1) and !F(x-2) and !F(x-3)\\n\\nT:O(N) S:O(N) Memory limit exceeded\\n\\nWe can reduce the space complexity by just updating an array of size 3, but an O(N) time is also unacceptable.\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:        \\n        if n <= 3:\\n            return True\\n        new_size = n + 1\\n        memo = [False] * (new_size)\\n        \\n        for i in range(4): \\n            memo[i] = True\\n        \\n        for i in range(4,new_size):\\n            for j in range(1,4):\\n                if memo[i] == True:\\n                    break\\n                if memo[i-j] == True:\\n                    memo[i] = False\\n                else:\\n                    memo[i] = True\\n        \\n        return memo[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:        \\n        if n <= 3:\\n            return True\\n        new_size = n + 1\\n        memo = [False] * (new_size)\\n        \\n        for i in range(4): \\n            memo[i] = True\\n        \\n        for i in range(4,new_size):\\n            for j in range(1,4):\\n                if memo[i] == True:\\n                    break\\n                if memo[i-j] == True:\\n                    memo[i] = False\\n                else:\\n                    memo[i] = True\\n        \\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73861,
                "title": "accepted-c-solution-with-explanation",
                "content": "    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n\\nwell,the code is short and the important part is the idea behind the scene.\\naccording the example,if there are 4 stones,no matter what u do,u will lose. so as a smart guy u should leave 4 stone to yr friend. cos u can remove 3 stones at max, u'd win if there are 5~7 stones in the heap.  \\n\\nhow about 8 stones in the heap? after removed,5~7 stones will be left.and yr smart friend will win by drive u into the 4 stones situation.  \\n\\nso u can win the game by counting the number of the stones, and make sure yr friend face the 4 stones situation.for example when n equal 15, u remove 3 stones,and 12 is 4 multiple 3.no matter how many stones yr friend removed, u can make it 8, and so on~~\\n\\nBTW this is a boring game,u can win when the stones can not be divide by 4.",
                "solutionTags": [],
                "code": "    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n\\nwell,the code is short and the important part is the idea behind the scene.\\naccording the example,if there are 4 stones,no matter what u do,u will lose. so as a smart guy u should leave 4 stone to yr friend. cos u can remove 3 stones at max, u'd win if there are 5~7 stones in the heap.  \\n\\nhow about 8 stones in the heap? after removed,5~7 stones will be left.and yr smart friend will win by drive u into the 4 stones situation.  \\n\\nso u can win the game by counting the number of the stones, and make sure yr friend face the 4 stones situation.for example when n equal 15, u remove 3 stones,and 12 is 4 multiple 3.no matter how many stones yr friend removed, u can make it 8, and so on~~\\n\\nBTW this is a boring game,u can win when the stones can not be divide by 4.",
                "codeTag": "Unknown"
            },
            {
                "id": 3206199,
                "title": "determining-winning-strategy-in-nim-game-using-game-theory",
                "content": "This is a classic example of a game theory problem where both players play optimally. The game\\'s outcome depends on the number of stones in the heap. To determine whether you can win the game or not, we need to look at the number of stones in the heap and find a pattern.\\n\\nLet\\'s consider the base cases first:\\n\\n- If there is only one stone, you can remove it and win the game.\\n- If there are two stones, you can remove one stone and win the game.\\n- If there are three stones, you can remove two stones and win the game.\\n\\nFor n=4, you cannot win the game, as you can remove at most three stones on your turn, and your friend can remove the remaining stones on their turn. Therefore, your friend will win the game.\\n\\nFor n=5,6,7, you can win the game. If there are 5 stones, you can remove one stone and reduce it to four stones, and your friend will be forced to remove one to three stones. In any case, you will be able to remove the last stone and win the game.\\n\\nSimilarly, if there are six stones, you can remove two stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nIf there are seven stones, you can remove three stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nWe can observe that for any n that is a multiple of four, you cannot win the game. For any other value of n, you can win the game.\\n\\nTherefore, to solve this problem, we need to check if n is a multiple of four or not. If it is, return false; otherwise, return true.\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Brainteaser",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596966,
                "title": "python3-16ms-99-faster-one-line",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```\\nif the value of n is divisible by 4 then only friend will win",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73763,
                "title": "java-explanation-code",
                "content": "One of the best ways to derive a solution is by finding the cases when the person who is removing the stones (1, 2 or 3) can be confident of winning the game. We will analyse some cases below and see what happens when I am the taking the first turn to remove the stones.<br />\\n<br />\\n<b>case 1:</b><br />\\nNumber of stones - 1, 2 or 3<br />\\nAnalysis - Since, I am allowed to remove a maximum of 3 stones, I will win this case.<br />\\n<br />\\n<b>case 2:</b><br />\\nNumber of stones - 4<br />\\nAnalysis - If I remove 1, the opposition removes rest 3 and wins the game .<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 2, the opposition removes rest 2 and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 3, the opposition removes the remaining 1 stone and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thus, if the number of initial stones are 4 I will lose the game. We can also conclude that whoever has 4 stones in their turn loses the game.<br />\\n<b><br /></b>\\n<b>case 3:</b><br />\\nNumber of stones - 5<br />\\nAnalysis: If I remove 1, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 4:</b><br />\\nNumber of stones - 6<br />\\nAnalysis: If I remove 2, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 5:</b><br />\\nNumber of stones - 7<br />\\nAnalysis: If I remove 3, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 6:</b><br />\\nNumber of stones - 8<br />\\nAnalysis: If I remove 1, the opposition gets 7 stones and wins the game .<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 2, the opposition gets 6 stones and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 3, the opposition gets 5 stones and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thus, if the number of initial stones are 8 I will lose the game. We can also conclude that whoever has 8 stones in their turn loses the game.<br />\\n<br />\\nFrom the above cases we see that if the number of stones during my turn is a multiple of 4 I will lose the game. Thus the code we will write is:<br />\\n<br />\\n\\n\\n    public boolean canWinNim(int n) {\\n      return !(n%4 == 0);\\n    }",
                "solutionTags": [],
                "code": "One of the best ways to derive a solution is by finding the cases when the person who is removing the stones (1, 2 or 3) can be confident of winning the game. We will analyse some cases below and see what happens when I am the taking the first turn to remove the stones.<br />\\n<br />\\n<b>case 1:</b><br />\\nNumber of stones - 1, 2 or 3<br />\\nAnalysis - Since, I am allowed to remove a maximum of 3 stones, I will win this case.<br />\\n<br />\\n<b>case 2:</b><br />\\nNumber of stones - 4<br />\\nAnalysis - If I remove 1, the opposition removes rest 3 and wins the game .<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 2, the opposition removes rest 2 and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 3, the opposition removes the remaining 1 stone and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thus, if the number of initial stones are 4 I will lose the game. We can also conclude that whoever has 4 stones in their turn loses the game.<br />\\n<b><br /></b>\\n<b>case 3:</b><br />\\nNumber of stones - 5<br />\\nAnalysis: If I remove 1, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 4:</b><br />\\nNumber of stones - 6<br />\\nAnalysis: If I remove 2, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 5:</b><br />\\nNumber of stones - 7<br />\\nAnalysis: If I remove 3, the opposition gets 4 and thus he loses and I win.<br />\\n<b><br /></b>\\n<b>case 6:</b><br />\\nNumber of stones - 8<br />\\nAnalysis: If I remove 1, the opposition gets 7 stones and wins the game .<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 2, the opposition gets 6 stones and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If I remove 3, the opposition gets 5 stones and wins the game.<br />\\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thus, if the number of initial stones are 8 I will lose the game. We can also conclude that whoever has 8 stones in their turn loses the game.<br />\\n<br />\\nFrom the above cases we see that if the number of stones during my turn is a multiple of 4 I will lose the game. Thus the code we will write is:<br />\\n<br />\\n\\n\\n    public boolean canWinNim(int n) {\\n      return !(n%4 == 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73881,
                "title": "short-and-concise-c-solution-with-explanation",
                "content": "Idea is very simple. Let\\'s build the \"win-lose\" strategy. If we can from our current position go to the \"lose\" position then current position is \\'win\\', else it is \\'win\\' position for friend. So the \\'win-lose\\' strategy looks like this:<br>\\n\\n1 => \\'w\\' (we can remove 1 stone)<br>\\n2 => \\'w\\' (we can remove 2 stones)<br>\\n3 => \\'w\\' (we can remove 3 stones)<br>\\n4 => \\'l\\' (no matter how many stones we remove next position(1, 2 or 3) will be \\'w\\' for friend)<br>\\n5 => \\'w\\' (we can remove 1 stone and move to \\'l\\'-position)<br>\\n6 => \\'w\\'<br>\\n7 => \\'w\\'<br>\\n8 => \\'l\\'<br>\\n9 => \\'w\\'<br>\\n10 => \\'w\\'<br>\\n11 => \\'w\\'<br>\\n11 => \\'l\\'<br>\\n....\\n\\nIt\\'s easy to see, that every fourth position is \\'lose\\'. So the answer is (n % 4 != 0).\\nHere the code:\\n\\n    class Solution {\\n    public:\\n        bool canWinNim(int n) \\n        {\\n            return (n % 4);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canWinNim(int n) \\n        {\\n            return (n % 4);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3039643,
                "title": "c-one-liner-simple-math-solution",
                "content": "# Intuition\\n- Suppose we have 1 stone, then we can win the game as we can pick 1,2 or 3 stones at a time. \\n- If we have 2  or 3 stones, then also we can win as we can pick them at once but if we have 4 stones initially then if we pick 1 stone then left 3 can be picked by opponent and opponent will win. \\n- If we pick 2 stone then left 2 can be picked by opponent and opponent will win. \\n- If we pick 3 stones then left 1 can be picked by opponent and opponent will win.\\n- Now, you know that to win the game you should avoid the situation where you are left with 4 stones. \\n- Now, \\n  - If you have 5 stones, then you can pick 1 stone so that opponent is left with 4 stones and you know that now opponenet will lose the game. \\n  - Similarly, for 6 and 7 stones, you can win the game by picking 2 and 3 stones respectively.\\n\\n- But, if you have 8 stones, then again you will lose as you can pick 1, 2, or 3 and opponent will by left with 7, 6 or 5 stones, opponent can use the same approach as above to win the game.\\n\\n**To conclude, we can say to win the game $$ n $$ should be multiple of 4.**\\n\\n# Approach\\nJust check if n is divisible by 4 or not.\\n\\n# Complexity\\n-  Time complexity:$$O(1)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4 ? true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4 ? true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672846,
                "title": "java-python-runtime-100-00-one-line-solution-explaination-and-dp",
                "content": "<hr>\\n\\n***Upvote if you like it!***\\n<hr>\\n\\n**1. Solution: Math - Trick**\\n\\n**Points:**\\n**1.** If n <= 3, you must can win.\\n**2.**  If n = 4, you must lose.\\n**3.** If 4 < n < 8, n = 5, 6, 7, after your turn, you must can make n = 4, so now your friend is facing n = 4, he must lose.\\n**4.**  If n = 8, you only can make n to 7, 6, 5, now your friend is facing n = 5, 6, or 7, he must can win.\\n**5.** If 8 < n < 12, such as n = 9, 10, 11, you must can make n = 8, now your friend is facing n = 8, he must lose.\\n**6.** Now we find the regulation, if n % 4 == 0, you must lost, your friend must win, but if n % 4 != 0, you must can win.\\n\\n**Note:**\\nTime complexity is **O(1)**\\n\\n**Result:** *Accepted*\\n\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return !(n%4==0);\\n    }\\n}\\n```\\n<hr>\\n\\n**2. Solution: Dynamic Programming**\\n\\n**Result:** *Time Limit Exceeded*\\n```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        if n <= 3:\\n            return True\\n\\n        f = [False for _ in xrange(n + 1)]\\n        f[1] = True\\n        f[2] = True\\n        f[3] = True\\n\\n        for num in xrange(4, n + 1):\\n            this_turn_can_win = False\\n            for k in xrange(1, 4):\\n                if not f[num - k]:\\n                    this_turn_can_win = True\\n                    break\\n\\n            f[num] = this_turn_can_win\\n\\n        return f[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return !(n%4==0);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        if n <= 3:\\n            return True\\n\\n        f = [False for _ in xrange(n + 1)]\\n        f[1] = True\\n        f[2] = True\\n        f[3] = True\\n\\n        for num in xrange(4, n + 1):\\n            this_turn_can_win = False\\n            for k in xrange(1, 4):\\n                if not f[num - k]:\\n                    this_turn_can_win = True\\n                    break\\n\\n            f[num] = this_turn_can_win\\n\\n        return f[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501323,
                "title": "c-dp-with-explanation",
                "content": "**Cheating Solution**\\n```\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```\\n\\n**DP Solution**\\n`dp[i]` represents if I am currently landing on `i` and taking a move (1 to 3) can I win or not.\\nApparently `dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3])`, why? Think you are on `dp[4]`, and you can move 1 to 3 places, so if `dp[3]`, `dp[2]` and `dp[1]` are all `true` means your opponent will win because it is your opponent\\'s turn next, so` dp[4] = false`. Assume you are on `dp[5]`, and you know `dp[4] == false`, so you will take 1 step and move to `dp[4]` and then your opponent lose.\\n\\n```\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        var dp = new bool[n + 1];\\n        dp[0] = false;\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        \\n        for(var i = 4; i <= n; i++) {\\n            dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3]);\\n        }\\n        \\n        Console.WriteLine(string.Join(\",\", dp));\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        var dp = new bool[n + 1];\\n        dp[0] = false;\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        \\n        for(var i = 4; i <= n; i++) {\\n            dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3]);\\n        }\\n        \\n        Console.WriteLine(string.Join(\",\", dp));\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302535,
                "title": "dp-explained",
                "content": "This game has maximum of 3 choices at every i.  We should choose the path where opponent doesn\\'t have any \"winning\" choice in any of his turns i.e. which lead him to win at the end. There will be lot of overlapping subproblems, so we memoize it.\\n\\ndp[i] stores the result of the game (win or lose) when there are i stones left for the player whoever asks for it.\\nSo if we build from the bottom, we can always check the last 3 positions to see if we can turn current number into any number from the last 3 positions that gurantees a win for us.\\n\\n**Solution 1 (MLE)**\\n```\\npublic boolean canWinNim(int n) {\\n        boolean[] dp = new boolean[Math.max(n+1,4)];\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        for(int i=4; i <= n; i++)\\n            dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3];\\n        return dp[n];\\n    }\\n```\\n**Solution 2 (TLE)**\\n```\\npublic boolean canWinNim(int n) {\\n        if(n <= 3) return true;\\n        boolean[] dp = new boolean[4];\\n        dp[0] = true;\\n        dp[1] = true;\\n        dp[2] = true;\\n        for(int i=4; i <= n; i++){\\n            dp[3] = !dp[2] || !dp[1] || !dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = dp[3];\\n        }\\n        return dp[3];\\n    }\\n```\\n**Solution3 (MLE)** DP top-down version\\n```\\nclass Solution {\\n    Boolean[] dp = null;\\n    public boolean canWinNim(int n) {\\n        dp = new Boolean[n+1];\\n        dp[0] = false;\\n        dp[1] = true;\\n        return helper(n);        \\n    }\\n    private boolean helper(int n){\\n        if(dp[n] == null)\\n            dp[n] = !helper(n-1) || !helper(n-2) || !helper(n-3); \\n         return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canWinNim(int n) {\\n        boolean[] dp = new boolean[Math.max(n+1,4)];\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        for(int i=4; i <= n; i++)\\n            dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3];\\n        return dp[n];\\n    }\\n```\n```\\npublic boolean canWinNim(int n) {\\n        if(n <= 3) return true;\\n        boolean[] dp = new boolean[4];\\n        dp[0] = true;\\n        dp[1] = true;\\n        dp[2] = true;\\n        for(int i=4; i <= n; i++){\\n            dp[3] = !dp[2] || !dp[1] || !dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = dp[3];\\n        }\\n        return dp[3];\\n    }\\n```\n```\\nclass Solution {\\n    Boolean[] dp = null;\\n    public boolean canWinNim(int n) {\\n        dp = new Boolean[n+1];\\n        dp[0] = false;\\n        dp[1] = true;\\n        return helper(n);        \\n    }\\n    private boolean helper(int n){\\n        if(dp[n] == null)\\n            dp[n] = !helper(n-1) || !helper(n-2) || !helper(n-3); \\n         return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275817,
                "title": "intuition-behind-minimax-problems-with-detailed-explanation-and-code",
                "content": "A particular configuration of the game can be termed as a State. Each state is either losing or winning. If you land on winning state, you win. If you land on losing state, you lose.\\n\\nLet\\u2019s say, you are on a state s. You can make n moves, each transforms the state of the game to p1,p2,p3\\u2026pn.\\n\\nNow,\\n\\nIf any of the pi\\u2019s is a losing state, the current state becomes winning state.\\nWhy?\\n\\nSince you\\u2019ll always optimally and try to land your opponent in a losing state. And if you are able to do so, you can be assured that your current state is a winning state.\\n\\nSimilarly, if all of the pi\\u2019s are winning states, no matter what move you make, your opponent will land in a winning state. So your current state automatically becomes a losing state.\\n\\nSo, for solving any question, you need to identify:\\n\\n1. What exactly is a state in current game\\n2. Which are all the states to which the current state can transition to.\\nSo this way, we\\u2019ll able to build a tree of states.\\n\\nAnd we compute the values bottom up. We know the state of the leaves, whether they are winning or losing. And using that, we compute the value of intermediate states.\\n\\nLet\\u2019s do it step by step:\\n\\n1. Identify the state.\\nState here is just the number itself. State(n) = n.\\n\\n2. Identify transition to other states.\\nAs a player can remove 1\\u20133 stones, state n can transition to three states: n-1, n-2 and n-3.\\n\\nState(n) -> State(n-1), State(n-2) and State(n-3).\\n\\nThis way, we\\u2019ll build the tree.\\n\\n3. Let\\u2019s identify the base cases/leaves.\\nAs we can clearly see,\\n\\nState(1) is a winning state, as I can just pick 1 stone and end the game. Similary, State(2) and State(3) are also winning states.\\n\\nLet\\u2019s talk about State(4) now.\\n\\nState(4) can transition to State(3), State(2) and State(1). All of those are winning states, so as per our rule, State(4) becomes a losing state.\\n\\nTo make it more clear, let\\u2019s talk about State(5).\\n\\nIf there are 5 stones left, I can pick one and land the opponent in State(4), which is a losing state. So State(5) becomes a winning state.\\n\\nThis way, we can calculate upto State(n), the given input number.\\n\\nSample code that implements this approach:\\n\\n```\\npublic boolean canWinNim(int n) {\\n    boolean p1 = true, p2 = true, p3 = true;\\n    for (int i = 4; i <= n; i++) {\\n      if (!p1 || !p2 || !p3) {\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = true;\\n      } else {\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = false;\\n      }\\n    }\\n    return p3;\\n  }\\n```\\n\\nI\\'ve published this here also : https://medium.com/@yashgirdhar/generic-approach-to-solve-minimax-programming-problems-1e39df6583f3",
                "solutionTags": [],
                "code": "```\\npublic boolean canWinNim(int n) {\\n    boolean p1 = true, p2 = true, p3 = true;\\n    for (int i = 4; i <= n; i++) {\\n      if (!p1 || !p2 || !p3) {\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = true;\\n      } else {\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = false;\\n      }\\n    }\\n    return p3;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73770,
                "title": "1-line-0-ms-c-solution-with-mathematic-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n};\\n```\\n\\nLet's look at the basic case. If 1 or 2 or 3 stones left and it's my turn, I'm gonna win.\\n\\nSo how to guarantee this \"win\" status? That must be 4 stones left when it's my friend's turn. Because 4 - 1 = 3, 4 - 2 = 2, 4 - 3 = 1. \\n\\nHow to give the \"lose\" status to my friend? That must be 5 or 6 or 7 stones left when it's my turn. Becuase we have the chance to make the count of left stones be 4: 5 - 1 = 4, 6 - 2 = 4, 7 - 3 = 4. Then You may find 5 = 1 + 4, 6 = 2 + 4, 7 = 3 + 4. Wow, 1, 2, 3 are our basic cases.\\n\\nLet's go on. How to guarantee the \"win\" status of \"5 or 6 or 7 stones left when it's my turn\"? We should give the \"lose\" status to my friend that is \"8 stones left when it's my friend's turn\".Because 8 - 1 = 7, 8 - 2 = 6, 8 - 3 = 5. Again, how to give the \"lose\" status to my friend? We must be at status of 9, 10, 11 stones left when it's my turn. Because then we have the chance to make the count of left stones be 8: 9 - 1 = 8, 10 - 2 = 8, 11 - 3 = 8. We can find 9 = 1 + 8 = (1 + 4) + 4 = 5 + 4, 10 = 2 + 8 = (2 + 4) + 4 = 6 + 4, 11 = (3 + 4) + 4 = 7 + 4. The formula is now going out: T(n) = T(n - 1) + 4. T(n) is the left stones of the n times of my turn. The basic case T(0) = {1, 2, 3}.\\n\\nNow we can write a solution like: Test if the number is one of T(n). If yes, we can win. Otherwise we'd lose. Actually it takes O(n) time complexity.\\n\\nThe above solution is really slow to this problem and will lead to a \"Time Limit Exceeded\" complain.How can we optimize it? Let's expand the formula T(n) = T(n - 1) + 4:\\n\\nT(n) = {(((1 + 4) + 4) + 4 ..., ((2 + 4) +4) + 4 ..., ((3 + 4) +4) + 4 ...}\\n     = {1 + 4*n, 2 + 4*n, 3 + 4*n}\\n\\nCan you get the idea? If T(n) % 4 is 1 or 2 or 3, we can win the game. And beacuse the mod value can only be 0, 1, 2 or 3, that implies if T(n) % 4 != 0, we'll win the game. Now we get the one liner:\\n```\\n return n % 4 != 0;\\n```\\n\\nHappy coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n};\\n```\n```\\n return n % 4 != 0;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688266,
                "title": "easy-one-line-solution-beats-100-simple-math-solution",
                "content": "\\n# Approach\\nCheck modulo 4\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238646,
                "title": "292-time-99-68-and-space-90-42-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution is similar to the previous one, but it is even more concise. Instead of using an if-else statement, it simply returns the result of the boolean expression n % 4 != 0. If n is divisible by 4, the expression will evaluate to False, meaning you cannot win. If n is not divisible by 4, the expression will evaluate to True, meaning you can win. This solution has the same time complexity of O(1) as the previous one.\\n\\n# Complexity\\n- Time complexity:\\n99.68%\\n\\n- Space complexity:\\n90.42%\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688742,
                "title": "javascript-1-liner-with-expaination",
                "content": "- my first appoch was like this using dynamic programming with memoization.\\n- win or lose of `n` depends on `!canWinNim(n - 3) || !canWinNim(n - 2) || !canWinNim(n - 1)`. since `canWinNim(n - c)` means next player\\'s turn.\\n- Time Complexity: **O(n)**\\n- Space Complexity: **O(n)**\\n```JavaScript\\nconst memo = {0: false, 1: true, 2: true, 3: true, 4: false}\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    if (memo[n] === undefined) {\\n        memo[n] = !canWinNim(n - 3) || !canWinNim(n - 2) || !canWinNim(n - 1)\\n    }\\n    return memo[n]\\n};\\n```\\n\\n- It still work if `n` reduced as `n%4`\\n- Time Complexity: **O(1)**\\n- Space Complexity: **O(1)**\\n```JavaScript\\nconst memo = {0: false, 1: true, 2: true, 3: true}\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\nn %= 4\\n    if (memo[n] === undefined) {\\n        memo[n] = !canWinNim(n - 3) || !canWinNim(n - 2) || !canWinNim(n - 1)\\n    }\\n    return memo[n]\\n};\\n```                                                                            \\n- since we can choose 1 to 3, we should avoid 4 for winnning. and if `n` is a multiple of 4, thr player who started first can not avoid 4 on its turn.\\n\\n**n = 4**\\n|player|1|2\\n|:--:|:--:|:--:|:--:|\\n|a| 4 - 1\\n|b||3 - 3\\n\\n|player|1|2\\n|:--:|:--:|:--:|:--:|\\n|a| 4 - 2\\n|b||2 - 2\\n\\n|player|1|2\\n|:--:|:--:|:--:|:--:|\\n|a| 4 - 3\\n|b||1 - 1\\n\\n**n = 8**\\nsecond player always can give number 4 to first player when given number is multiply of 4\\n|player|1|2|3|\\n|:--:|:--:|:--:|:--:|:--:|\\n|a|8-1||4\\n|b||7-3|\\n\\n|player|1|2|3|\\n|:--:|:--:|:--:|:--:|:--:|\\n|a|8-2||4\\n|b||6-2\\n\\n|player|1|2|3|\\n|:--:|:--:|:--:|:--:|:--:|\\n|a|8-3||4\\n|b||5-1\\n\\n- Now the code could be simplified.\\n- Time Complexity: **O(1)**\\n- Space Complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = n => n%4 !== 0\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\nconst memo = {0: false, 1: true, 2: true, 3: true, 4: false}\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    if (memo[n] === undefined) {\\n        memo[n] = !canWinNim(n - 3) || !canWinNim(n - 2) || !canWinNim(n - 1)\\n    }\\n    return memo[n]\\n};\\n```\n```JavaScript\\nconst memo = {0: false, 1: true, 2: true, 3: true}\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\nn %= 4\\n    if (memo[n] === undefined) {\\n        memo[n] = !canWinNim(n - 3) || !canWinNim(n - 2) || !canWinNim(n - 1)\\n    }\\n    return memo[n]\\n};\\n```\n```JavaScript\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = n => n%4 !== 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513635,
                "title": "come-on-dp-should-be-accepted-which-is-the-should-be-solution",
                "content": "**Protest**\\n\\n**It is a so classical DP problems**. But it is so unpleasant to see the most upvoted solution is math solution and give me `Memory Limit Exceeded` error :)\\n\\nWe are not a Mathmatician, we are developer using logical logic to solve problems. DP is our domain, and it is clearly the math solution is **totally 100%** based on the DP solution. It **does not make any sense** DP solution is not accepted! It mislead people like we are using tricks to solve problems not programming techniques which is definitely wrong.\\n\\n---\\n**Thinking Porcess**\\n\\n1. It is clearly that if the piles has less than 3 stones, then you can take all of them, you are the winner. \\n2. If it has more than `3` stones, then we can check if we take `i`: `1`, `2` and `3` stones, if the one with the left stones `n - i` is lose. If so, you are the winner.\\n\\n---\\n**Diagram**\\n`T` represents `true`, i.e. the one with that # of stones is a winner. \\n`F` represents `false`, i.e. the one with that # of stones is a loser.\\n\\n```\\nT   T   T   F   T   T   ?\\n1\\t2\\t3\\t4\\t5\\t6\\t...\\n```\\n\\n---\\n**Key**\\nTo check if we can leave the stones which leads the other loses the game, we need to check if any of `M[i - 1]` , `M[i - 2]` and `M[i - 3]`  is `false`(loser). We have 2 ways:\\n1. `M[i] = !(M[i - 1] & M[i - 2] & M[i - 3]); `\\n2. `M[i] = (!M[i - 1] || !M[i - 2] || !M[i - 3]); `\\n\\n---\\n**Final Code**\\n```java\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n <= 3) return true;\\n        boolean[] M = new boolean[n + 1];\\n        M[1] = true;\\n        M[2] = true;\\n        M[3] = true;\\n        for(int i = 3; i < n + 1; i++){\\n            // M[i] = (!M[i - 1] || !M[i - 2] || !M[i - 3]); \\n            M[i] = !(M[i - 1] & M[i - 2] & M[i - 3]); \\n        }\\n        \\n        return M[n];\\n    }\\n}\\n```\\n\\n---\\n**TC**: `O(n)`\\n**SC**: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nT   T   T   F   T   T   ?\\n1\\t2\\t3\\t4\\t5\\t6\\t...\\n```\n```java\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n <= 3) return true;\\n        boolean[] M = new boolean[n + 1];\\n        M[1] = true;\\n        M[2] = true;\\n        M[3] = true;\\n        for(int i = 3; i < n + 1; i++){\\n            // M[i] = (!M[i - 1] || !M[i - 2] || !M[i - 3]); \\n            M[i] = !(M[i - 1] & M[i - 2] & M[i - 3]); \\n        }\\n        \\n        return M[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876093,
                "title": "one-liner",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298445,
                "title": "easiest-solution-time-o-1-space-o-1-simple-explaination",
                "content": "# Intuition:\\nif both players are playing optimally then , each player at any given point of time will make always an optimal move that will be sending the other player to a postion from where the other player will always lose\\n\\n*At any given point of time :*\\n-> if n=0 i.e. if no stone is there \\n\\tany player at this point of time responsible of making a move **loses**\\n-> if n=1 i.e. if 1 stone is  there \\n\\tany player at this point of time responsible of making a move will surely **wins** the game , as he will optimally Pick 1 stone , leaving other player no stone to pick\\n-> if n=2 i.e. if 2 stone is  there \\n\\tany player at this point of time responsible of making a move will surely **wins** the game, as he will optimally Pick 2 stones , leaving other player no stone to pick\\t\\n-> if n=3 i.e. if 3 stone is  there \\n\\tany player at this point of time responsible of making a move will surely **wins** the game , as he will optimally Pick 3 stones , leaving other player no stone to pick\\t\\t\\n->-> if n=4 i.e. if 4 stone is  there \\n\\tany player at this point of time responsible of making a move will surely **lose** the game, as no matter how many (1,2,or,3) stones he picks optimally , in next turn the other player will also pick stones optimally (3,2,or 1 respectively) , leaving player no stone to pick\\tin subsequent turn.\\n\\nthere every n, has a **predefined** winner, if both players playes optimally\\nfrom above example, we can make an 0 indexed array from observation, where index is the number of stone , and value at an index is where the person required to make a move at when n stone is present would win or lose\\n**[lose, win, win, win , lose]**\\n\\nif we keep continuning our observation for more then 4 stone we will observe a pattern in the array  generated:\\n[lose, win, win, win , lose, win, win, win ,lose, win, win, win ,lose.,.....]\\n\\ntherefore we conclude that if **n%4==0** then player will lose else player will win\\n\\n\\n\\n```\\nvar canWinNim = function(n) {\\n    if(n%4==0) return false;\\n    else return true;\\n};\\n```\\n\\n***Do upvote if it helped! TIA ;)***",
                "solutionTags": [
                    "JavaScript",
                    "Game Theory"
                ],
                "code": "```\\nvar canWinNim = function(n) {\\n    if(n%4==0) return false;\\n    else return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73862,
                "title": "c-straightforward-solution-dp-will-runtime-error",
                "content": "    \\n  \\n    bool canWinNim1(int n) {\\n        return n % 4 != 0;\\n    }\\n    \\n    // TLE\\n    bool canWinNim(int n) {\\n        int *p = new (nothrow) int [n];\\n        if (p!=nullptr) {\\n            p[0] = true;\\n            p[1] = true;\\n            p[2] = true;\\n            for (int i=3; i < n; i++) \\n                p[i] = !(p[i-1] && p[i-2] && p[i-3]);\\n        }\\n       int ret = p[n-1];\\n       delete[] p;\\n       return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "    \\n  \\n    bool canWinNim1(int n) {\\n        return n % 4 != 0;\\n    }\\n    \\n    // TLE\\n    bool canWinNim(int n) {\\n        int *p = new (nothrow) int [n];\\n        if (p!=nullptr) {\\n            p[0] = true;\\n            p[1] = true;\\n            p[2] = true;\\n            for (int i=3; i < n; i++) \\n                p[i] = !(p[i-1] && p[i-2] && p[i-3]);\\n        }\\n       int ret = p[n-1];\\n       delete[] p;\\n       return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2843718,
                "title": "python-simple-solution-one-liner",
                "content": "**time complexity:** o(1)\\n\\n**space complexity:** o(1)\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        # if n is not a multiple of 4, it is possible to win\\n        return n % 4\\n```\\n\\n\\uD83D\\uDD3C please upvote if helpful \\uD83D\\uDD3C",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        # if n is not a multiple of 4, it is possible to win\\n        return n % 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773531,
                "title": "easy-java-solution-beats-100-0ms",
                "content": "```\\nclass Solution {\\npublic boolean canWinNim(int n) {\\n    if(n%4==0)\\n        return false;\\n    else\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic boolean canWinNim(int n) {\\n    if(n%4==0)\\n        return false;\\n    else\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402101,
                "title": "100-java-solution-w-explanation-on-how-to-find-pattern-for-these-types-of-questions",
                "content": "\\tpublic boolean canWinNim(int n) {\\n        return !(n%4 == 0);\\n        // *HOW TO FIND THE PATTERN*\\n        // Notice, if I can send my opponent to a \\'losing\\' position\\n        // then I can win. A \\'losing\\' position is defined \\n        // as a poition where any move I make results in a \\'winning\\' position for the opponent\\n        \\n        // 1 ->    win ( i can take 1 and win)\\n        // 2 ->    win ( i can take 2 and win)\\n        // 3 ->    win ( i can take 3 and win)\\n        // 4 ->    lose (i can only send the second player to a winning position 1,2 or 3)\\n        // 5 ->    win (i can take 1 and send my opponent to 4, a losing position)\\n        // 6 ->    win (i can take 2 and send my opponent to 4, a losing position)\\n        // 7 ->    win ( i can take 3 and send my opponent to 4, a losing position)\\n        // 8 ->    lose ( if i take 1, 2 or 3, my opponent moves to a winning position)\\n        //          ....apply the above logic till we see a pattern....\\n        // 9 ->    win\\n        // 10 ->   win\\n        // 11  ->  win\\n        // 12  ->  lose\\n        // ....etc. etc. it looks like if n is a multiple of 4 we lose\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic boolean canWinNim(int n) {\\n        return !(n%4 == 0);\\n        // *HOW TO FIND THE PATTERN*\\n        // Notice, if I can send my opponent to a \\'losing\\' position\\n        // then I can win. A \\'losing\\' position is defined \\n        // as a poition where any move I make results in a \\'winning\\' position for the opponent\\n        \\n        // 1 ->    win ( i can take 1 and win)\\n        // 2 ->    win ( i can take 2 and win)\\n        // 3 ->    win ( i can take 3 and win)\\n        // 4 ->    lose (i can only send the second player to a winning position 1,2 or 3)\\n        // 5 ->    win (i can take 1 and send my opponent to 4, a losing position)\\n        // 6 ->    win (i can take 2 and send my opponent to 4, a losing position)\\n        // 7 ->    win ( i can take 3 and send my opponent to 4, a losing position)\\n        // 8 ->    lose ( if i take 1, 2 or 3, my opponent moves to a winning position)\\n        //          ....apply the above logic till we see a pattern....\\n        // 9 ->    win\\n        // 10 ->   win\\n        // 11  ->  win\\n        // 12  ->  lose\\n        // ....etc. etc. it looks like if n is a multiple of 4 we lose\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 776137,
                "title": "python-easy-single-line-solution-dp-solution",
                "content": "**Simple Approach**\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4!=0\\n```\\n\\n\\n\\n**DP Approach (gives runtime memory error for input 1348820612)**\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        dp = [True] * n\\n        for i in range(3, n):\\n            dp[i] = not dp[i - 1] or not dp[i - 2] or not dp[i - 3]\\n        return dp[n-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4!=0\\n```\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        dp = [True] * n\\n        for i in range(3, n):\\n            dp[i] = not dp[i - 1] or not dp[i - 2] or not dp[i - 3]\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771268,
                "title": "python3-math-instead-of-dp",
                "content": "At first glance, this looks like a dp problem. This is indeed a dp problem but the scale of the test case is so huge that even `O(N)` dp solution suffers TLE. Upon looking closer, this is really a simple math problem. \\n\\nThe recurrence relation is that \\n\\n`fn(i) = not fn(i-1) or not fn(i-2) or not fn(i-3)`\\n\\nwhere `fn(i)` indicates if player can win with `i` stones left. In other words, given `i` if any of the previous three outcomes is a `False`, it is `True`. Then, this problem really becomes checking if `n` is a multiple of 4. If so, return `False`; otherwise, return `True`. \\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```\\n\\nBelow is the top-down dp with TLE. \\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return True if there is a winning strategy with k stones left.\"\"\"\\n            if k <= 3: return True \\n            for kk in range(1, 4):\\n                if not fn(k - kk): return True #opponent cannot win \\n            return False \\n        \\n        return fn(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return True if there is a winning strategy with k stones left.\"\"\"\\n            if k <= 3: return True \\n            for kk in range(1, 4):\\n                if not fn(k - kk): return True #opponent cannot win \\n            return False \\n        \\n        return fn(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505280,
                "title": "c-hilarious-solution-o-1",
                "content": "Playing around with stones count you will see that whenever you start with number of stones divisible by `4` you loose. For instance:\\n* start with `4`, you take: `3 or 2 or 1` and opponent takes last stones.\\n* start with `8`, you take: `3 or 2 or 1` and you opponent with take amount so you get to your `4` stones again and you loose.\\n\\nOn the contrary, when you start with number not divisible by `4` you take amount so number becomes divisible and now your opponent is in the same trap.\\n\\nSo, the solution is to find if number is not divisible by 4, which is: `return n % 4 != 0` or just `return n % 4`.\\nHow to make it faster? Maybe compiler knows how to make it faster for you, or you just check that 2 least significant bits are not `0s`: `return n & 3 != 0` or just `return n & 3`.\\n\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n & 3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n & 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73831,
                "title": "java-dp-solution-with-explanation-not-acceptable-but-worth-to-share",
                "content": "    public boolean canWinNim(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"n should be greater than 0.\");\\n        }\\n\\n        // For stones less than 4, we are already win, cause we can just take all the stones.\\n        if (n < 4) {\\n            return true;\\n        }\\n\\n        // Then, think about the question in this way: \\n        // after choosing 1 ~ 3 stones in the first round, \\n        // can we left AT LEAST ONE dead-end to another player?\\n\\n        // For 4 stones, if we choose 1 stone, there are 3 stones left;\\n        // choose 2 stones, 2 stones left;\\n        // choose 3 stones, 1 stone left. \\n        // This is a bad situation for us, but a good news for another player,\\n        // because 1, 2, 3 stones are all not dead-ends for him.\\n\\n        // So to determine if we can win the game, we only need to care about if we can left AT LEAST ONE dead-end at first round.\\n\\n        // For example:\\n        //    5 stones: choose 1 stone, left 4 stones, 4 stones is a dead-end so we win;\\n        //    6 stones: choose 2 stones, left 4 stones, win again.\\n        //    7 stones: choose 3 stones, left 4 stones, win again.\\n        //    8 stones: after choosing 1, 2, 3 stones, we left either 5, 6, or 7 stones, and none of them are dead-ends, so we cannot win the game.\\n        //    9 stones: we choose 1 stone, left 8 stones, 8 stones is a dead-end so we win...\\n        //    and so on...\\n        \\n        // So here comes the DP solution.\\n        boolean[] dp = new boolean[n + 1];\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        dp[4] = false;\\n        for (int i = 5; i <= n; i++) {\\n            // We choose stones from 1 to 3.\\n            // If there is at least one dead-end left, then we can be sure that we can win at `i`;\\n            // otherwise we can just left it as false as a dead-end by default.\\n            for (int j = 1; j <= 3; j++) {\\n                if (!dp[i - j]) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "    public boolean canWinNim(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"n should be greater than 0.\");\\n        }\\n\\n        // For stones less than 4, we are already win, cause we can just take all the stones.\\n        if (n < 4) {\\n            return true;\\n        }\\n\\n        // Then, think about the question in this way: \\n        // after choosing 1 ~ 3 stones in the first round, \\n        // can we left AT LEAST ONE dead-end to another player?\\n\\n        // For 4 stones, if we choose 1 stone, there are 3 stones left;\\n        // choose 2 stones, 2 stones left;\\n        // choose 3 stones, 1 stone left. \\n        // This is a bad situation for us, but a good news for another player,\\n        // because 1, 2, 3 stones are all not dead-ends for him.\\n\\n        // So to determine if we can win the game, we only need to care about if we can left AT LEAST ONE dead-end at first round.\\n\\n        // For example:\\n        //    5 stones: choose 1 stone, left 4 stones, 4 stones is a dead-end so we win;\\n        //    6 stones: choose 2 stones, left 4 stones, win again.\\n        //    7 stones: choose 3 stones, left 4 stones, win again.\\n        //    8 stones: after choosing 1, 2, 3 stones, we left either 5, 6, or 7 stones, and none of them are dead-ends, so we cannot win the game.\\n        //    9 stones: we choose 1 stone, left 8 stones, 8 stones is a dead-end so we win...\\n        //    and so on...\\n        \\n        // So here comes the DP solution.\\n        boolean[] dp = new boolean[n + 1];\\n        dp[1] = true;\\n        dp[2] = true;\\n        dp[3] = true;\\n        dp[4] = false;\\n        for (int i = 5; i <= n; i++) {\\n            // We choose stones from 1 to 3.\\n            // If there is at least one dead-end left, then we can be sure that we can win at `i`;\\n            // otherwise we can just left it as false as a dead-end by default.\\n            for (int j = 1; j <= 3; j++) {\\n                if (!dp[i - j]) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73838,
                "title": "1-liner-java-solution-with-nim-game-explanation",
                "content": "    public class Solution {\\n        public boolean canWinNim(int n) {\\n            return n % 4 != 0;\\n        }\\n    }\\n\\nThis is a straightforward code that uses the concept of winning-losing positions. A position is losing if from that position, if you took any number of allowed stones [1,2,3] you would go only to winning positions and a position is considered winning if there's at least one move that can lead you to a losing position.\\n\\nInitially all the available moves [1,2,3] are winning positions, then we can easily derive the following:\\n\\n1 W\\n \\n2 W\\n\\n3 W\\n\\n4 L  (1,2,3 lead to W)\\n\\n5 W (1 leads to L)\\n\\n6 W (2 leads to L)\\n\\n7 W (3 leads to L)\\n\\n8 L\\n\\n9 W\\n\\n10 W\\n\\n..\\n\\nSo we can see that only multiple of 4s are losing positions for the first player, while all other numbers are winning.",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean canWinNim(int n) {\\n            return n % 4 != 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2575645,
                "title": "292-nim-gave-very-very-easy-solution-in-java",
                "content": "class Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4!=0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2392106,
                "title": "python-one-liner-100",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```\\n**Please UPVOTE if you LIKE !!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288081,
                "title": "python-3-one-liner",
                "content": "\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0",
                "codeTag": "Java"
            },
            {
                "id": 492233,
                "title": "1-line-faster-than-99-4-memory-less-than-100",
                "content": "\\n```\\nreturn \\'1\\' in bin(n)[-2:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn \\'1\\' in bin(n)[-2:]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 484990,
                "title": "python-overly-complicated-solution-using-minimax-algorithm",
                "content": "I treated the question as a two-agent game in which each agent tries to maximize their utility. My code unfortunately leads to a TLE which I thought would be fixed if I implemented alpha-beta pruning, but it turns out the solution was much much simpler lol. Just thought I\\'d post what I did to add some variety to the solutions posted.\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        def playNim(n, turn):\\n            if n < 0:\\n                return -2 # Impossible case, so we make utility -2\\n            if n == 0 and turn == \\'M\\':\\n                return -1\\n            elif n == 0 and turn == \\'O\\':\\n                return 1\\n            else:\\n                if turn == \\'M\\':\\n                    return max(playNim(n-1, \\'O\\'), playNim(n-2, \\'O\\'), playNim(n-3, \\'O\\'))\\n                else:\\n                    return min(playNim(n-1, \\'M\\'), playNim(n-2, \\'M\\'), playNim(n-3, \\'M\\'))\\n        \\n        return playNim(n, \\'M\\') == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        def playNim(n, turn):\\n            if n < 0:\\n                return -2 # Impossible case, so we make utility -2\\n            if n == 0 and turn == \\'M\\':\\n                return -1\\n            elif n == 0 and turn == \\'O\\':\\n                return 1\\n            else:\\n                if turn == \\'M\\':\\n                    return max(playNim(n-1, \\'O\\'), playNim(n-2, \\'O\\'), playNim(n-3, \\'O\\'))\\n                else:\\n                    return min(playNim(n-1, \\'M\\'), playNim(n-2, \\'M\\'), playNim(n-3, \\'M\\'))\\n        \\n        return playNim(n, \\'M\\') == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300076,
                "title": "general-solution-to-such-problems-with-explanation",
                "content": "This Problem\\'s Answer with Java:\\n```\\npublic boolean canWinNim(int n) {\\n    return n % 4 != 0;\\n}\\n```\\n\\nlet n = 21.\\nso, if you want win this game, you must get 17.\\nThen, your firend will chose 18 or 19 or 20, and you will chose 21 and you are winner.\\n\\nif you want to get 17, you must get 13,\\nif you want to get 13, you must get 9,\\n...\\nif you want win the game, and you must get these nums:\\n1, 5, 9, 13, 17, 21\\n\\nbut , when the `n` is 20, if you want win the game,\\nyou must get these nums:\\n0, 4, 8, 12,16, 20\\nbut in the first round, you must take a number : 1 or 2 or 3, \\nthen ,you friend will get 4, and your friend will be winner.\\n\\nNow, we can get the law\\uFF1A\\nIn the case where you are the first player\\uFF0C Only when `n` is not a multiple of 4, will you win the game.\\n\\nGeneralization to general conditions\\uFF1A\\nThe goal is `n`, taking `m` number(s) at each time,(in this game , `m` is 3)\\nAnd you are the first player\\nYou will only win the game if `n` meets the following condition\\uFF1A\\n`n % (m + 1) != 0`\\n\\nsome interestings: \\nif `m = (2^k) -1`(k is a positive integer)\\nthe formula: `n % (m + 1) != 0` equals: `(n & m) != 0`\\n\\nso, in this question the answer is also be:\\n`return (n & 3) != 0`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canWinNim(int n) {\\n    return n % 4 != 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282004,
                "title": "beats-79-99-of-1-line-python",
                "content": "1. because 100%4==0\\n2. n%=100\\n```\\nreturn True if n%100%4 else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn True if n%100%4 else False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73826,
                "title": "if-level-out-the-one-line-method-its-maybe-a-dynamic-programming-question",
                "content": "Firstly.\\n\\nWTF.\\n\\nSecondly,\\n\\n in interview ,i perfer use bottom-up method.\\n\\n    bool ret[n];\\n    ret[1]=true;\\n    ret[2]=true;\\n    ret[3]=true;\\n    for(int i =5; i < n; i++){\\n        ret[i] = !ret[i-1] || !ret[i-2] || !ret[i-3];\\n    }\\n    return ret[n];",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Firstly.\\n\\nWTF.\\n\\nSecondly,\\n\\n in interview ,i perfer use bottom-up method.\\n\\n    bool ret[n];\\n    ret[1]=true;\\n    ret[2]=true;\\n    ret[3]=true;\\n    for(int i =5; i < n; i++){\\n        ret[i] = !ret[i-1] || !ret[i-2] || !ret[i-3];\\n    }\\n    return ret[n];",
                "codeTag": "Unknown"
            },
            {
                "id": 73853,
                "title": "my-solution-with-java",
                "content": "\\npublic class Solution {\\n\\n    public boolean canWinNim(int n) {\\n        return n>>2<<2!=n;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean canWinNim(int n) {\\n        return n>>2<<2!=n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 73876,
                "title": "one-liner-solution",
                "content": "\\n    bool canWinNim(int n) {\\n        return n % 4;\\n    }",
                "solutionTags": [],
                "code": "\\n    bool canWinNim(int n) {\\n        return n % 4;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3765570,
                "title": "easy-and-best-java-solution-top-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n     return n%4 !=0;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n     return n%4 !=0;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676151,
                "title": "292-nim-game-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4==0? false:true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4==0? false:true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544509,
                "title": "easy-one-step-python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasically me loses if the num becomes 4 \\nwhen n is a multiple of 4 there a n/4 number of 4\\'s\\nso irrespective of what me chooses the other person can choose a number to fill it up to 4 this goes on and the other person wins\\nexample:\\n4\\nme. other.\\n1    3\\n2    2\\n3    1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck if n is a multiple of 4\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4!=0 \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4!=0 \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472763,
                "title": "one-line-solution-any-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION, I AM A BEGINNER\\n# Approach\\nAtleast one win is enough to conclude so here the range is 1 to 3 stones,if we take 4 as threshold value and try sharing among participants if it has remainder > 0 then the last stone will be picked up by the USER_1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443232,
                "title": "easy-solution-in-every-possible-language-with-easy-explanation-including-racket-erlang-elixir",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif n%4 is not 0 we can take n%4 stones from pile and make n%4 be equal to 0. Watever the other player does n%4 will not be 0 again so we can repeat until we get 0 (As 0%4 = 0).\\nif n%4 is 0 then watever we do on the next step n%4 is not going to be 0. And the other player can \"start\" the game as described above and win.\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nPlease upvote if you like this)\\n```python3 []\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n``` \\n```python []\\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n%4\\n```\\n```java []\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```\\n```c []\\nbool canWinNim(int n){\\n    return n%4;\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    return n%4\\n};\\n```\\n```ruby []\\n# @param {Integer} n\\n# @return {Boolean}\\ndef can_win_nim(n)\\n    return n%4>0\\nend\\n```\\n```swift []\\nclass Solution {\\n    func canWinNim(_ n: Int) -> Bool {\\n        return n%4>0;\\n    }\\n}\\n```\\n$\\\\space$\\n```Go []\\nfunc canWinNim(n int) bool {\\n    return n % 4>0;\\n}\\n```\\n```scala []\\nobject Solution {\\n    def canWinNim(n: Int): Boolean = {\\n        return n%4>0;\\n    }\\n}\\n```\\n```kotlin []\\nclass Solution {\\n    fun canWinNim(n: Int): Boolean {\\n        return n%4>0;\\n    }\\n}\\n```\\n```rust []\\nimpl Solution {\\n    pub fn can_win_nim(n: i32) -> bool {\\n        return n%4>0;\\n    }\\n}\\n```\\n```php []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n        return $n%4>0;\\n    }\\n}\\n```\\n```typescript []\\nfunction canWinNim(n: number): boolean {\\n    return n%4>0;\\n};\\n```\\n```racket []\\n(define/contract (can-win-nim n)\\n  (-> exact-integer? boolean?)\\n    (cond [(> (modulo n 4) 0) true]\\n        [else false])\\n  )\\n```\\n```Erlang []\\n-spec can_win_nim(N :: integer()) -> boolean().\\ncan_win_nim(N) ->\\n  N rem 4 > 0.\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec can_win_nim(n :: integer) :: boolean\\n  def can_win_nim(n) do\\n    rem(n,4)>0\\n  end\\nend\\n```\\n```Dart []\\nclass Solution {\\n  bool canWinNim(int n) {\\n    return n%4>0;\\n  }\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Ruby"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```\n```python []\\n    class Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n%4\\n```\n```java []\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```\n```c []\\nbool canWinNim(int n){\\n    return n%4;\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public bool CanWinNim(int n) {\\n        return n%4>0;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    return n%4\\n};\\n```\n```ruby []\\n# @param {Integer} n\\n# @return {Boolean}\\ndef can_win_nim(n)\\n    return n%4>0\\nend\\n```\n```swift []\\nclass Solution {\\n    func canWinNim(_ n: Int) -> Bool {\\n        return n%4>0;\\n    }\\n}\\n```\n```Go []\\nfunc canWinNim(n int) bool {\\n    return n % 4>0;\\n}\\n```\n```scala []\\nobject Solution {\\n    def canWinNim(n: Int): Boolean = {\\n        return n%4>0;\\n    }\\n}\\n```\n```kotlin []\\nclass Solution {\\n    fun canWinNim(n: Int): Boolean {\\n        return n%4>0;\\n    }\\n}\\n```\n```rust []\\nimpl Solution {\\n    pub fn can_win_nim(n: i32) -> bool {\\n        return n%4>0;\\n    }\\n}\\n```\n```php []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n        return $n%4>0;\\n    }\\n}\\n```\n```typescript []\\nfunction canWinNim(n: number): boolean {\\n    return n%4>0;\\n};\\n```\n```racket []\\n(define/contract (can-win-nim n)\\n  (-> exact-integer? boolean?)\\n    (cond [(> (modulo n 4) 0) true]\\n        [else false])\\n  )\\n```\n```Erlang []\\n-spec can_win_nim(N :: integer()) -> boolean().\\ncan_win_nim(N) ->\\n  N rem 4 > 0.\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec can_win_nim(n :: integer) :: boolean\\n  def can_win_nim(n) do\\n    rem(n,4)>0\\n  end\\nend\\n```\n```Dart []\\nclass Solution {\\n  bool canWinNim(int n) {\\n    return n%4>0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051345,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n % 4) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n % 4) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998420,
                "title": "24ms-97-beats-in-python3-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    We \"75%\" always win if we take 3 stones\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    play this game and you will understand\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    24ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    13.8 MB\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/aed556a8-afcc-4016-9a1f-d1219121ce02_1672843037.5955734.png)\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return False if n%4==0 else True\\n            \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return False if n%4==0 else True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819920,
                "title": "java-explained-o-1-100-faster-1-line",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```\\nExplanation:\\n1 win, 2 win, 3 win, 4 lose.\\n5 win because I can take 1 and there 4 stones left, which is loosing condition.\\n6 win, since I can take 2.\\n7 win, since I can take 3.\\n8 lose, since I can\\'t make it left 4 stones, since my max move is removing only 3 stones.\\nThe rest can be proven by induction.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816589,
                "title": "easy-java-beats-100-0ms",
                "content": "\\u041F\\u043E\\u0431\\u0435\\u0436\\u0434\\u0430\\u0435\\u043C \\u0432 \\u0438\\u0433\\u0440\\u0435 \\u0432 \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0435\\u0441\\u043B\\u0438 \\u043A\\u0430\\u043C\\u043D\\u0435\\u0439 \\u0432 \\u043A\\u0443\\u0447\\u0435 \\u043D\\u0435 \\u0434\\u0435\\u043B\\u0438\\u0442\\u0441\\u044F \\u043D\\u0430 4, \\u0435\\u0441\\u043B\\u0438 \\u0434\\u0435\\u043B\\u0438\\u0442\\u0441\\u044F - \\u043E\\u0434\\u043D\\u043E\\u0437\\u043D\\u0430\\u0447\\u043D\\u0430\\u044F \\u043F\\u043E\\u0431\\u0435\\u0434\\u0430\\n\\nn = 4, 8, 12, 16, \\u2026\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$)$$ -->\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n     return (n % 4 != 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n     return (n % 4 != 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792881,
                "title": "simplest-python-code",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047874,
                "title": "recursion-memorization-c",
                "content": "If constranits were low, this solution shall pass and got accepted \\n```\\nclass Solution {\\nprivate:\\n    bool solve(int n,vector<int> &dp){\\n        if(n <= 3) return true;\\n        if(dp[n] != -1) return dp[n];\\n        \\n        bool op1 = solve(n-1,dp);\\n        bool op2 = solve(n-2,dp);\\n        bool op3 = solve(n-3,dp);\\n        \\n        bool res = op1 and op2 and op3;\\n        return dp[n] = !res;\\n    }\\npublic:\\n    bool canWinNim(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(int n,vector<int> &dp){\\n        if(n <= 3) return true;\\n        if(dp[n] != -1) return dp[n];\\n        \\n        bool op1 = solve(n-1,dp);\\n        bool op2 = solve(n-2,dp);\\n        bool op3 = solve(n-3,dp);\\n        \\n        bool res = op1 and op2 and op3;\\n        return dp[n] = !res;\\n    }\\npublic:\\n    bool canWinNim(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762968,
                "title": "nim-explanation-c",
                "content": "If there are 1,2,3 stones left we can always win immediately, hence 1,2,3 are winning positions and 4 is a losing position.\\nIf there are 5, 6, or 7  stones, we can take 1, 2, or 3 respectively to put our friend into a losing position.\\nContinuing this logic we see that every position with a multiple of 4 stones is a losing position and all others are winning positions.\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n      return n % 4 != 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n      return n % 4 != 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727941,
                "title": "o-1-solution-mathematical-explanation-of-solution",
                "content": "Let us suppose the two players are A(you) and B(other player).\\nWhen \\n* n = 1\\nA = 1 \\nA wins the game as he was the last player to pick the stone(s) from heap.\\n\\n* n = 2\\nA = 2\\nA wins the game as he was the last player to pick the stone(s) from heap.\\n\\n* n = 3\\nA = 3\\nA wins the game as he was the last player to pick the stone(s) from heap.\\n\\n* n = 4\\n\\n\\tThree possibilties are there: \\n\\t1. A = 1, B = 3\\n\\tWinner is B \\n\\n\\t2. A = 2, B = 2\\n\\tWinner is B \\n\\t\\n\\t3. A = 3, B = 1\\n\\tWinner is B \\n\\n\\tSo here we see that no matter what A chooses, B always wins.\\n\\t\\nSo we conclude that :**If there are 4 coins in the heap A will surely Lose**\\n\\nLet\\'s extend this assumpption for more number of coins in multiples of 4.\\n\\n* n = 8\\nPossibilities are\\n1. A = 1, B = 3\\nWinner is B\\n2. A = 2, B = 2\\nWinner is B\\n3. A = 3, B = 1\\nWinner is B\\n**So B will always try to make the number of coins left as 4 or other multiples of 4, so that B will win the game.**\\n\\nTry it out for n = 12, 16, 20 ......\\n\\n=> x = n%4 \\nIf x = 0 , A looses\\nThus if n is a multiple of 4, A will lose.\\n\\nAnd if x = {1,2,3} A wins\\n\\nHence\\n```\\n  bool canWinNim(int n) {\\n        return n%4;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n  bool canWinNim(int n) {\\n        return n%4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608104,
                "title": "python-o-1-one-liner-the-shortest-code",
                "content": "```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        return n & 3\\n```\\nPlease UPVOTE!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        return n & 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299104,
                "title": "c-how-to-stop-panic",
                "content": "Solution:\\n\\nDo not panic, we can always solve concrete case\\n\\nOf course, we have good reason to be panic since the number, n, can be very huge, close to INT_MAX.\\n\\nApproach 1: Begin with the concret xamples might be helpful\\nThinking:\\n     \\n1, 2, 3, 4, 5, 6, 7, 8, 9\\nFirst player only lose on 4, 8, so what we can think?\\nHow to prove? Math induction.\\n\\nBase case: \\nn = 4,  it can be proven that for taking 1, 2, or 3,  you will always lose.\\n\\n\\nInduction case: \\nsuppose for n = 4K, you will lose. For 4 (K + 1), you have 4K + 4, which is 4 more than 4K. For all the possible choice (1, 2, 3), your enemy can take 3, 2, 1 so you must take 4K, which is losing.\\n\\nThus, for all 4K (K is natural number) cases, you will lose.\\n\\nTo prove, please refer to:\\nhttps://leetcode.com/problems/nim-game/discuss/73749/Theorem%3A-all-4s-shall-be-false\\n\\n              \\n\\t\\t\\t  \\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884117,
                "title": "c-math-minimax-solution",
                "content": "**Math Solution:**\\n\\nPlayers can take 1,2,3 stones in each turn and the player who removes last stone wins the game. As both\\nplays optimally they always try to take stones such a way that there are only 4 stones left. If there is only\\n4 stone left then the opponenet player can take at most 3 stones which leaves the player with 1 stone \\nand the player wins. So if the total number of stone mod 4 = 0 then opponenet always make moves such\\nthat at the end player left with only 4 stone and the opponent wins no matter what. So I can only win if\\nn mod 4 !=0.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```\\n\\n**MiniMax Solution:**\\n \\n This solution is provided as it is also a possible solution using DP, also useful for interview. But won\\'t give AC in this problem submission.\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    int takeStone(int n, bool player)\\n    {\\n        // score impossible \\n        if(n<0) return -2;\\n        \\n        // complement score for players => If n=0 and player is me then i lost, so return -1;\\n        // same for opponent and return 1\\n        if(n==0) return player?-1:1;\\n        \\n        // player is me then try to maximize my score\\n        if(player)\\n            return max({takeStone(n-1,!player),takeStone(n-2,!player),takeStone(n-3,!player)});\\n        // player is opponent then try to minimize my score\\n        else \\n            return min({takeStone(n-1,!player),takeStone(n-2,!player),takeStone(n-3,!player)});\\n    }\\n    \\n    bool canWinNim(int n) {\\n        \\n        // last stone picked by me => ME = player TRUE, OPPO = player FLASE\\n        // score 1 means i win, score -1 means i lost\\n        return takeStone(n,true)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int takeStone(int n, bool player)\\n    {\\n        // score impossible \\n        if(n<0) return -2;\\n        \\n        // complement score for players => If n=0 and player is me then i lost, so return -1;\\n        // same for opponent and return 1\\n        if(n==0) return player?-1:1;\\n        \\n        // player is me then try to maximize my score\\n        if(player)\\n            return max({takeStone(n-1,!player),takeStone(n-2,!player),takeStone(n-3,!player)});\\n        // player is opponent then try to minimize my score\\n        else \\n            return min({takeStone(n-1,!player),takeStone(n-2,!player),takeStone(n-3,!player)});\\n    }\\n    \\n    bool canWinNim(int n) {\\n        \\n        // last stone picked by me => ME = player TRUE, OPPO = player FLASE\\n        // score 1 means i win, score -1 means i lost\\n        return takeStone(n,true)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850139,
                "title": "cpp-o-n-time-and-o-1-space-dp-bottom-up-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n < 4) return 1;\\n        vector<int> dp(4, 0);\\n        for(int i = 0; i < dp.size(); i++){\\n            if(i < 3) dp[i] = 1;\\n            else{\\n                for(int j = 1; j < 4; j++){\\n                    if(!dp[(i-j)%4]){\\n                        dp[i%4] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(n-1)%4];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n < 4) return 1;\\n        vector<int> dp(4, 0);\\n        for(int i = 0; i < dp.size(); i++){\\n            if(i < 3) dp[i] = 1;\\n            else{\\n                for(int j = 1; j < 4; j++){\\n                    if(!dp[(i-j)%4]){\\n                        dp[i%4] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(n-1)%4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73807,
                "title": "this-should-be-a-math-not-algorithm-problem",
                "content": "Just one line code can solve this problem.\\n```\\nreturn !(n%4==0);\\n```\\nFirst step try to make the total amount to be a multiple of 4, and no matter how many stones your opponent takes, just make the total to be  a multiple of 4. Finally there will be 4 stones, and obviously you will win at the time.\\nThis problem is a math trick game rather than an algorithm problem.",
                "solutionTags": [],
                "code": "```\\nreturn !(n%4==0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73816,
                "title": "my-one-line-java-solution-with-explanation",
                "content": "The solution is quite simple:\\n\\n    public class Solution {\\n        public boolean canWinNim(int n) {\\n            return !(n%4 == 0);\\n        }\\n    }\\n\\nHowever, it's worth explaining how to come up with it. I came up with this idea by first thinking of DP. Since I take the first turn, and I can pick only 1, 2 or 3 stones, the recursive formula for DP is:\\n\\ndp[ n ] = !dp[ n-1 ] || !dp[ n-2 ] || !dp[ n-3 ]\\n\\nwhere dp[ n ] is a boolean variable, indicating whether I can win or not. If within 3 stones, there exists a way for me to lose the game, then there exists a way for me to win the game for the current number of stones , because I take the first turn.",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean canWinNim(int n) {\\n            return !(n%4 == 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 73864,
                "title": "solution-and-interpretation",
                "content": "      public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n\\nwhy is n%4 ==0 represent losing the game?\\nI figured out two ways to understand.\\n\\n- **Deduction**\\n\\nn  =  1,2,3,4,5,6,7,8,9,10\\nwin=t,t,t,F,t,t,t,F,t,t,t,F....\\n\\n( When you get 5, you can make the strategy to \"give other 4\", and you can always achieve that when n >5 and n<8 . Generally , when n grows, you have 3 winning point after a losing point by \"giving out the losing point\" )\\n\\n\\n - **Divide**\\n\\nDivide the n into n /4 part, and think it n /4 games , you can win the last game ( n - n/4) to let your opponent facing the left game . Because they are all 4-game so he/she would lose them all.",
                "solutionTags": [],
                "code": "      public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n\\nwhy is n%4 ==0 represent losing the game?\\nI figured out two ways to understand.\\n\\n- **Deduction**\\n\\nn  =  1,2,3,4,5,6,7,8,9,10\\nwin=t,t,t,F,t,t,t,F,t,t,t,F....\\n\\n( When you get 5, you can make the strategy to \"give other 4\", and you can always achieve that when n >5 and n<8 . Generally , when n grows, you have 3 winning point after a losing point by \"giving out the losing point\" )\\n\\n\\n - **Divide**\\n\\nDivide the n into n /4 part, and think it n /4 games , you can win the last game ( n - n/4) to let your opponent facing the left game . Because they are all 4-game so he/she would lose them all.",
                "codeTag": "Unknown"
            },
            {
                "id": 73860,
                "title": "a-simple-solution",
                "content": " 1. for n = 1,2,3, you can win because you can take them all for the\\n    first shot \\n 2. for n = 4, you lose\\n 3. for n = 4 * 1 + (1, 2, 3), you can reduce the case to 2), you will\\n        win\\n 4. for n = 4 * 2, you lose\\n\\n\\n    public class Solution {\\n        public boolean canWinNim(int n) {\\n            return (n % 4 != 0);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean canWinNim(int n) {\\n            return (n % 4 != 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3764096,
                "title": "c-with-proper-in-depth-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmentioned in comments in code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust using MODULO OPERATOR\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n % 4 != 0);\\n    }\\n};\\n\\n\\n/*the chances of win is only when the no of stones are less than 4\\nexample if their are 1 ,2,3 stone you pick it you won\\nwhile if their are stonesin multiple of 4 then you lose.\\nhere we returned n&4!=0 which means if the num is not compeletely divisible by 4\\nit will give remainder and the boolean value becomes true \\nelse it becomes false*/\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n % 4 != 0);\\n    }\\n};\\n\\n\\n/*the chances of win is only when the no of stones are less than 4\\nexample if their are 1 ,2,3 stone you pick it you won\\nwhile if their are stonesin multiple of 4 then you lose.\\nhere we returned n&4!=0 which means if the num is not compeletely divisible by 4\\nit will give remainder and the boolean value becomes true \\nelse it becomes false*/\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559845,
                "title": "simple-easy-to-understand-o-1-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n         if(n%4==0)return false;\\n         return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n         if(n%4==0)return false;\\n         return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342437,
                "title": "easy-to-understand-c-100-faster-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342238,
                "title": "c-easy-solution-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887779,
                "title": "c-solution-with-simple-and-detailed-explanation",
                "content": "*The first observation in this question is that if the number of stones is less than or equal to 3 , then you can directly win in the first move because one can remove 1 to 3 stones from the heap , at a go.*\\n\\n*Secondly, if the number of stones is a multiple of 4 , then your friend wins , and if someone is curious to know how this was deduced , then the straight forward answer is that anyone can reach this conclusion via trial and error method , more formally speaking by exploring all possible nooks and corner of the scenario.*\\n$Example$ : \\nInput: n = 4\\nOutput: false\\nExplanation: These are the possible outcomes:\\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\\nIn all outcomes, your friend wins.\\n\\n*And as given in the hint , if there are 5 stones , then if you pick 1 stone at first then only you can win , so from this test case , came to a conclusion that if(number of stones - 1 > 3) and number of stones is not a multiple of 4 then in this can also you can win.*\\n\\n*In all other cases , your friend wins.*\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n\\n       if(n<=3 ) return true;\\n\\n       else if(n%4==0) return false;\\n\\n       else if(n-1>3) return true;\\n\\n       else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n\\n       if(n<=3 ) return true;\\n\\n       else if(n%4==0) return false;\\n\\n       else if(n-1>3) return true;\\n\\n       else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840933,
                "title": "java-o-1-easy",
                "content": "# Approach\\nIf we see the pattern, the we can see than every number which is a divisible of 4 is a lose and else are wins.\\n\\n1 --> win\\n2 --> win\\n3 --> win\\n4 --> lose - because i cant pick more than 3 and even if i pick i stone the other person can pick three and win.\\n5 --> win - i can pick first stone and let the other person pick others and its a win in any case.\\n6 --> win - similar to case of 5 stones\\n7 --> win\\n8 --> lose\\n\\nTherefore if n is divisible by 4 then its a lose, otherwise its a win.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n % 4 != 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n % 4 != 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827819,
                "title": "c-runtime-0-ms-100-faster-time-complexity-o-1-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4!=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4!=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686406,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-for-nim-game",
                "content": "class Solution {\\n    public boolean canWinNim(int n) \\n    {\\n        if(n%4==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canWinNim(int n) \\n    {\\n        if(n%4==0)\\n            return false;\\n        else\\n            return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2525784,
                "title": "1-line-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n       return n&3; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n       return n&3; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284428,
                "title": "java-1-liner-0ms-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/75478e10-bbdf-4b7c-b9e2-ea7fbe573847_1657864732.4351506.png)\\n\\n```\\n/*\\n---------------------------\\n| No. of Stones | Outcome |\\n|     1-3       |  True   |\\n|      4        |  False  |\\n|     5-7       |  True   |\\n|      8        |  False  |\\n|     ..        |  ..     |\\n---------------------------\\n*/\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n---------------------------\\n| No. of Stones | Outcome |\\n|     1-3       |  True   |\\n|      4        |  False  |\\n|     5-7       |  True   |\\n|      8        |  False  |\\n|     ..        |  ..     |\\n---------------------------\\n*/\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111073,
                "title": "fastest-c-100",
                "content": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        \\n        if(n%4==0)\\n            return false;\\n        \\n            return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        \\n        if(n%4==0)\\n            return false;\\n        \\n            return true;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1887570,
                "title": "one-liner-c-code-faster",
                "content": "**Time - O(1), Space - O(1)**\\nAs both the players will play optimally, we can see there is only one possiblity when player 1 will lose if the number is divisible by 4\\uFE0F\\u20E3.\\n\\nWhen the number will be divisible by 4 first player won\\'t be able to win in any condition, so we\\'ll return false, otherwise there must be a possiblity when first player\\'ll always be the last one to remove the last stone ie. the winner. \\u2B50\\u2B50\\u2B50\\n\\n```\\nbool canWinNim(int n) {\\n        return !(n%4==0);\\n}\\n```\\n\\n**For beginners just starting out**\\n\\n*this code is similar to writing this*\\n```\\nbool canWinNim(int n) {\\n        if(n%4==0)\\n\\t\\t\\treturn false;\\n\\t\\telse\\t\\n\\t\\treturn true; \\n}\\n```\\n\\n***NB: If I could be any of your help, kindly upvote the solution that\\'ll motivate me to write more and more solution, Thanks.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canWinNim(int n) {\\n        return !(n%4==0);\\n}\\n```\n```\\nbool canWinNim(int n) {\\n        if(n%4==0)\\n\\t\\t\\treturn false;\\n\\t\\telse\\t\\n\\t\\treturn true; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793618,
                "title": "nim-game-solution-java",
                "content": "class Solution {\\n  public boolean canWinNim(int n) {\\n    return n % 4 != 0;\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "Game Theory"
                ],
                "code": "class Solution {\\n  public boolean canWinNim(int n) {\\n    return n % 4 != 0;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1434046,
                "title": "one-liner-solution-with-explanation-c",
                "content": "Rules:\\n1. Each person can take 1 to 3 stones at a time.\\n2. The person who takes the last stone is the winner.\\n3. I always start first.\\n\\nApproach: \\n1. If there is one stone, then i will start and take the only stone. I will be the winner.\\n2. If there are two stones, i can take both the stone and become the winner since a person is allowed to take upto 3 stones.\\n3. Similarly, if 3 stones are present, i will be the winner.\\n4. But when there are 4 stones and I start first, I can take upto 3 stones only. So after my turn, my friend will be left with the last stone, so he will win.\\n5. Similarly, when there are 8 stones, my friend will take the last stone no matter what.\\nAs you can see this pattern is repeating. When the number of stones present is a multiple of 4, you loose. So, all we have to do is, find if \\'n\\' is a multiple of 4, If yes, return 0 (since you lost) or return 1 (since you won).\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```\\nHope you find my solution useful and if you have any doubts or suggestions feel free to comment below.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353089,
                "title": "nim-game-faster-python-solution-with-str",
                "content": "The concept\\n* This is based on the pattern that the only times the result is false is when ```n``` is a multiple of ```4```\\n* Turn the number into string\\n* Slice the last two digits and check that number is a multiple of ```4``` (if the last two digit is a multiple of ```4```, then the whole number is a multiple of ```4```)\\n* This reduces the ammount of math to be computed on large numbers\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return int(str(n)[-2:]) % 4\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```n```\n```4```\n```4```\n```4```\n```4```\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return int(str(n)[-2:]) % 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305679,
                "title": "simple-python-solution-78-faster-with-how-i-came-up-with-this-solution",
                "content": "like every puzzle i tried playing against myself on simple numbers below 20 to observe and spot the pattern. \\nwhile playing i noticed that if you were able to leave your player with 4 or 8 or 12 or 16 or 20\\nthey lose, starting from 4 i began to notice that in order to win you have to leave your opponent face numbers like 4, 8,12.. so you guarante wining, so, 4 + 4 = 8, 8 + 4 = 12, 12 + 4 = 16, see where i\\'m going? if you started with a number that is divisible by 4, you lose. otherwise you will be able to substract the starting number by up to 3 and make the starting number divisible by 4 and oppenent lose.\\n\\nstarting with 19, goal is to make it divisible by 4, take 3, now he is left with 16, he lose. \\nstarting with 20, you have no other choice no matter how many you substract, he will alwayse be able to leave you with a number divisible by 4 and you lose, and so on...\\n\\n\\n```\\n        if n <= 3:\\n            return True\\n        elif n == 4:\\n            return False\\n        else:\\n            if(n % 4) == 0:\\n                return False\\n            else:\\n                return True\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n        if n <= 3:\\n            return True\\n        elif n == 4:\\n            return False\\n        else:\\n            if(n % 4) == 0:\\n                return False\\n            else:\\n                return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047836,
                "title": "python3-o-1-with-explanation",
                "content": "**We will lose the game if and only if the number is wholly divisible by 4**\\n\\n*n = 8, we can remove 1 n = 7 and our friend will remove 3, so that we left with n = 4 and we lose\\n n = 8, we can remove 2, n = 6 and our friend will remove 2, so that we left with n = 4 and we lose\\n n = 8, we can remove 3, n = 5 and our friend will remove 1, so that we left with n = 4 and we lose again*\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n\\t\\t# we are going to return False i.e 0 if n%4 == 0, otherwise we will return True\\n        return n%4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n\\t\\t# we are going to return False i.e 0 if n%4 == 0, otherwise we will return True\\n        return n%4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016124,
                "title": "java-with-explanation-math-and-recursive-approaches",
                "content": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // for each of the person has choice to take at most 3 stones\\n        // each time a person can pick 1 stone , 2 stone, or 3 stone\\n        // so for n = 1,2,3 the first person wins\\n        // for 4, the first person looses\\n        // so its evident that first person wins if the second person leaves behind 1 or 2 or 3 stones.\\n        \\n\\t\\t//recursive - TLE\\n        if (n <= 0) return false;\\n        if (n == 1 || n == 2 || n == 3) return true;\\n        if (canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n        return true;\\n\\t\\t\\n\\t\\t//modulo - math\\n\\t\\treturn n % 4 != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // for each of the person has choice to take at most 3 stones\\n        // each time a person can pick 1 stone , 2 stone, or 3 stone\\n        // so for n = 1,2,3 the first person wins\\n        // for 4, the first person looses\\n        // so its evident that first person wins if the second person leaves behind 1 or 2 or 3 stones.\\n        \\n\\t\\t//recursive - TLE\\n        if (n <= 0) return false;\\n        if (n == 1 || n == 2 || n == 3) return true;\\n        if (canWinNim(n-1) && canWinNim(n-2) && canWinNim(n-3)) return false;\\n        return true;\\n\\t\\t\\n\\t\\t//modulo - math\\n\\t\\treturn n % 4 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847533,
                "title": "built-in-functions-are-wayyyyy-faster-even-though-the-logic-is-much-more-complicated",
                "content": "This is why I sometimes can\\'t help but hate python.\\n\\nMathematically if n%4 == 0, you lose.  But if you check for this directly, you get abysmal performance.\\n\\nLet\\'s convert n to its binary representation *(as a string)*.  And then check the last two bits *(as substrings)*.  If neither string equals \\'1\\' you win.\\nSounds like a lot of extra useless work, right?\\n\\n```\\ndef canWinNim(self, n: int) -> bool:\\n        b = bin(n)\\n        return b[-1] == \\'1\\' or b[-2] == \\'1\\'\\n```\\n\\nThis is twice as fast as directly checking for n%4.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canWinNim(self, n: int) -> bool:\\n        b = bin(n)\\n        return b[-1] == \\'1\\' or b[-2] == \\'1\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806059,
                "title": "meaningless-question-only-for-math",
                "content": "class Solution:\\n    def canWinNim(self, n: int) -> bool:\\n  \\n        return n%4 !=0",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def canWinNim(self, n: int) -> bool:\\n  \\n        return n%4 !=0",
                "codeTag": "Java"
            },
            {
                "id": 759741,
                "title": "this-is-right-way-for-minmax-python",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if(n>=134882061):\\n\\t        return n%4 != 0;\\n\\t\\t    \\n        table1 = [None for _ in range(n+1)]\\n        table2 = [None for _ in range(n+1)]\\n        def maxMin(n):\\n            if table1[n]!=None: return table1[n]\\n            tmp = []\\n            for i in range(1,4):\\n                if n-i==0:\\n                    return 1\\n                elif n-i>0:\\n                    tmp.append(minMax(n-i))\\n            table1[n] = max(tmp)\\n            return table1[n]\\n        def minMax(n):\\n            if table2[n]!=None: return table2[n]\\n            tmp = []\\n            for i in range(1,4):\\n                if n-i==0:\\n                    return -1\\n                elif n-i>0:\\n                    tmp.append(maxMin(n-i))\\n            table2[n] = min(tmp)\\n            return table2[n]\\n        \\n        return True if maxMin(n)==1 else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if(n>=134882061):\\n\\t        return n%4 != 0;\\n\\t\\t    \\n        table1 = [None for _ in range(n+1)]\\n        table2 = [None for _ in range(n+1)]\\n        def maxMin(n):\\n            if table1[n]!=None: return table1[n]\\n            tmp = []\\n            for i in range(1,4):\\n                if n-i==0:\\n                    return 1\\n                elif n-i>0:\\n                    tmp.append(minMax(n-i))\\n            table1[n] = max(tmp)\\n            return table1[n]\\n        def minMax(n):\\n            if table2[n]!=None: return table2[n]\\n            tmp = []\\n            for i in range(1,4):\\n                if n-i==0:\\n                    return -1\\n                elif n-i>0:\\n                    tmp.append(maxMin(n-i))\\n            table2[n] = min(tmp)\\n            return table2[n]\\n        \\n        return True if maxMin(n)==1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587179,
                "title": "100-100-two-line-solution-with-a-detailed-mathematical-proof",
                "content": "this is the final solution to this question.it\\'s based on the conclusion:**the period of the function is :4**\\n```\\nbool canWinNim(int n){\\n    bool  a[] = {true, true, true, false};\\n    return a[(n - 1) % 4];\\n}\\n```\\nwe can assume that the function **f(n)** indicates whether i can win the game  when there are **n** stones.(just the same as the description in question)\\nclearly, when **n<=3, f(n) = True**. let us focus on the condition when **n>=4**: now i have three choices to remove stone: remove 1,2 or 3 stone ,then your friend begin to remove the stone. **from the perspective of your friend: if you choose to remove 1 stone ,then his game result is :f(n-1) and your game result is !f(n-1),(you and your friend have opposite result), similarly the result of your friend are f(n-2) and f(n-3) corresponding to  when you remove 2 and 3 stones.**\\n\\nthen we can get the following equation:\\n**when n>=4, f(n) = !f(n-1) || !f(n-2) || !f(n-3)**\\n\\nbesed on the above equation, we can get the recursive algorithm:\\n```\\nbool canWinNim(int n){\\n    if(n<=3) return true;\\n    else return !(canWinNim3(n-1) && canWinNim3(n-2) && canWinNim3(n-3));\\n}\\n```\\n\\nobviously it can\\'t pass all test cases since the recursive process have a lot of function value to be repeating calculated.so we can use **dynamic programming(DP)** method to optimize the algorithm:\\nwe can use an array to save the calculated function value.\\n```\\nbool canWinNim(int n) {\\n    if (n<=3) return true;\\n    bool *data = new bool [n];\\n    for(int i=0;i<3;i++) {\\n        data[i] = true;\\n    }\\n    for(int i=3;i<n;i++){\\n        data[i] = !data[i-1] || !data[i-2] || !data[i-3];\\n\\n    }\\n    return data[n-1];\\n}\\n```\\nbut this algorithm can\\'t pass the 50th test case since exceeding time limit.\\n**so by the observation, we can found the function has the period :4**, it\\'s result like:1,1,1,0, 1,1,1,0,...,111,0.\\nso i use basic mathematical proof method : **mathematical induction** to prove the period of function  is 4.\\nthe following image show the process:(because of editer can\\'t use math equation ,so i writed it on another markdown editer.)\\n![image](https://assets.leetcode.com/users/ma_hongying/image_1587291168.png)\\n\\nnow the final version of algorithm is produced:\\n```\\nbool canWinNim(int n){\\n    bool  a[] = {true, true, true, false};\\n    return a[(n - 1) % 4];\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool canWinNim(int n){\\n    bool  a[] = {true, true, true, false};\\n    return a[(n - 1) % 4];\\n}\\n```\n```\\nbool canWinNim(int n){\\n    if(n<=3) return true;\\n    else return !(canWinNim3(n-1) && canWinNim3(n-2) && canWinNim3(n-3));\\n}\\n```\n```\\nbool canWinNim(int n) {\\n    if (n<=3) return true;\\n    bool *data = new bool [n];\\n    for(int i=0;i<3;i++) {\\n        data[i] = true;\\n    }\\n    for(int i=3;i<n;i++){\\n        data[i] = !data[i-1] || !data[i-2] || !data[i-3];\\n\\n    }\\n    return data[n-1];\\n}\\n```\n```\\nbool canWinNim(int n){\\n    bool  a[] = {true, true, true, false};\\n    return a[(n - 1) % 4];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586086,
                "title": "python-simpliest-you-can-t-make-it-simplier",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553328,
                "title": "in-case-you-need-a-dp-thought",
                "content": "Out of all my 3 choices, if there is one I can make opponent false, I will pick that one. Thus \\n```\\nf[i] = !f[i-1] || !f[i-2] || !f[i-3]\\n```\\n\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if (n >=1000000) return n%4 != 0;\\n        boolean[] f = new boolean[n+1];\\n\\n        \\n        for (int i=1; i<=n; i++){\\n            if (i<=3){\\n                f[i] = true;\\n                continue;\\n            }\\n            f[i] = false;\\n            for (int j=1; j<=3; j++){\\n                if (i - j <= 0) break;\\n                f[i] |= !f[i-j];\\n            }\\n        }\\n        \\n        return f[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nf[i] = !f[i-1] || !f[i-2] || !f[i-3]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518960,
                "title": "java-2-solutions",
                "content": "interviewer: WTF is that? You failed   leetcode: pass with beating 100%\\n```\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n```\\n\\ninterviewer: Pass  leetcode: fail\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        boolean[] dp = new boolean[n+1];\\n        if (n == 0) return false;\\n        if (n < 4) return true;        \\n        for (int i = 1; i <= n; i++) {\\n            if (i < 4) dp[i] = true;\\n            else {\\n                dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n```\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        boolean[] dp = new boolean[n+1];\\n        if (n == 0) return false;\\n        if (n < 4) return true;        \\n        for (int i = 1; i <= n; i++) {\\n            if (i < 4) dp[i] = true;\\n            else {\\n                dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474446,
                "title": "0ms-java-interesting-story-related",
                "content": "Saw this trick by the name \"count till 21\" or something like that on the TV once. After the trick they revealed that if you land on numbers divisible by 4, you lose. So, to win the person always made the other say numbers divisible by 4. Never thought that it would be a part of CP.\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if (n%4==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if (n%4==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379819,
                "title": "solution-in-python-3-one-line",
                "content": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n    \\treturn n % 4\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n    \\treturn n % 4\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 350927,
                "title": "simple-explanation-on-why-there-s-a-repeating-sequence",
                "content": "In the first 3 cases when you have 1 or 2 or 3 stones you will always win. so Y=yes for all\\nSo\\n```\\n        stones : 1 2 3\\nperson can win : Y Y Y\\n```\\n\\nNow for 4 we can\\'t win in either case because if consider all the possibilites, i.e. if we take out 1 or if we take out 2 or if we take out 3\\n\\nSo for all the three cases stones left for opponent = (4-1) or (4-2) or (4-3) = 3 or 2 or 1\\nAs we see from table above, opponent will win in all of them, so we can\\'t take any path, thus for 4 we have N=No\\nSo\\n```\\n        stones : 1 2 3 4\\nperson can win : Y Y Y N\\n```\\n\\nNow take n=5, what are the possible options for opponent when we consider all the paths, these are\\n(5-1)=4 or (5-2)=3 or (5-3)=2 i.e.  4 or 3 or 2\\nFrom the table we can see that in one of these options which is 4, if opponent gets 4 stones he can\\'t win, thuse we will always choose the path in which opponent can\\'t win. Hence in this case we can win if we remove 1 stone and the opponent gets 4. So the table becomes\\n```\\n        stones : 1 2 3 4 5\\nperson can win : Y Y Y N Y\\n```\\n\\nIf you continue generating this table you will see that it is similar to\\n```\\n        stones : 1 2 3 4 5 6 7 8 9 10 11 12 13 14...\\nperson can win : Y Y Y N Y Y Y N Y Y  Y  N  Y  Y...\\n```\\nWhich is saying that when n%4==0 we can\\'t win. That\\'s it, it is the answer.",
                "solutionTags": [],
                "code": "```\\n        stones : 1 2 3\\nperson can win : Y Y Y\\n```\n```\\n        stones : 1 2 3 4\\nperson can win : Y Y Y N\\n```\n```\\n        stones : 1 2 3 4 5\\nperson can win : Y Y Y N Y\\n```\n```\\n        stones : 1 2 3 4 5 6 7 8 9 10 11 12 13 14...\\nperson can win : Y Y Y N Y Y Y N Y Y  Y  N  Y  Y...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160474,
                "title": "my-typical-mind-processing-flow-in-an-interview",
                "content": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // just let me solve it\\t\\n\\t\\t\\t\\t\\n        // if(n < 1) {\\n        //     return false;\\n        // } else if(n <= 3) {\\n        //     return true;\\n        // } else {\\n        //     return !canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3);\\n        // }\\n\\t\\t\\t\\t\\n        // okay he/she wants some more\\n        \\n        // boolean[] move = new boolean[n+1 > 3 ? n+1 : 4];\\n        // move[0] = false; move[1] = true; move[2] = true; move[3] = true;\\n        // for(int i = 4; i <= n; i++) {\\n        //     move[i] = !move[i-1] || !move[i-2] || !move[i-3];\\n        // }\\n        // return move[n];\\n        \\n        // well since I can do that, I knew you would ask for this\\n\\t\\t\\t\\t\\n        // boolean m1 = true, m2 = true, m3 = true, m4 = true;\\n        // for(int i = 4; i <= n; i++) {\\n        //     m4 = !m1 || !m2 || !m3;\\n        //     m1 = m2; m2 = m3; m3 = m4;\\n        // }\\n        \\n        // damn, there must be some trick, print out fisrt 100 results to see the pattern. \\n\\t\\t\\t\\t\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // just let me solve it\\t\\n\\t\\t\\t\\t\\n        // if(n < 1) {\\n        //     return false;\\n        // } else if(n <= 3) {\\n        //     return true;\\n        // } else {\\n        //     return !canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3);\\n        // }\\n\\t\\t\\t\\t\\n        // okay he/she wants some more\\n        \\n        // boolean[] move = new boolean[n+1 > 3 ? n+1 : 4];\\n        // move[0] = false; move[1] = true; move[2] = true; move[3] = true;\\n        // for(int i = 4; i <= n; i++) {\\n        //     move[i] = !move[i-1] || !move[i-2] || !move[i-3];\\n        // }\\n        // return move[n];\\n        \\n        // well since I can do that, I knew you would ask for this\\n\\t\\t\\t\\t\\n        // boolean m1 = true, m2 = true, m3 = true, m4 = true;\\n        // for(int i = 4; i <= n; i++) {\\n        //     m4 = !m1 || !m2 || !m3;\\n        //     m1 = m2; m2 = m3; m3 = m4;\\n        // }\\n        \\n        // damn, there must be some trick, print out fisrt 100 results to see the pattern. \\n\\t\\t\\t\\t\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73773,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Nim Game** https://leetcode.com/problems/nim-game/\\n\\n**Dynamic Programming Solution**\\n* Just maintain the last three outcomes.\\n\\n```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        if n <= 3:\\n            return True\\n        win = [True]*3\\n        i = 4\\n        while i <= n:\\n            next_outcome = (not win[0]) or (not win[1]) or (not win[2])\\n            win[0] = win[1]\\n            win[1] = win[2]\\n            win[2] = next_outcome\\n            i = i + 1\\n        return win[-1]\\n```\\n\\n**Mathematical Answer**\\n* Multiple of 4 will always result in loss.\\n\\n```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return False if int(n % 4) == 0 else True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        if n <= 3:\\n            return True\\n        win = [True]*3\\n        i = 4\\n        while i <= n:\\n            next_outcome = (not win[0]) or (not win[1]) or (not win[2])\\n            win[0] = win[1]\\n            win[1] = win[2]\\n            win[2] = next_outcome\\n            i = i + 1\\n        return win[-1]\\n```\n```\\nclass Solution(object):\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return False if int(n % 4) == 0 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73818,
                "title": "solution-on-java",
                "content": "    public class Solution {\\n        public boolean canWinNim(int n) {\\n        \\treturn n%4 != 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean canWinNim(int n) {\\n        \\treturn n%4 != 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 73823,
                "title": "easy-solution-for-java",
                "content": " //we can get that 4 must lose,  5,6,7 must win(because you can make the other at 4), and 8 must //lose(because the other will get  5,6,7)  loop this ,you can get  the result\\npublic boolean canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " //we can get that 4 must lose,  5,6,7 must win(because you can make the other at 4), and 8 must //lose(because the other will get  5,6,7)  loop this ,you can get  the result\\npublic boolean canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73832,
                "title": "a-simple-easy-solution",
                "content": "    class Solution {\\n    public:\\n        bool canWinNim(int n) {\\n            return n % 4 > 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canWinNim(int n) {\\n            return n % 4 > 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 73859,
                "title": "1-line-python-solution",
                "content": "\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n % 4 != 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n % 4 != 0",
                "codeTag": "Python3"
            },
            {
                "id": 73835,
                "title": "one-line-0ms-with-c",
                "content": "    bool canWinNim(int n) {\\n    return n%4;\\n}",
                "solutionTags": [],
                "code": "    bool canWinNim(int n) {\\n    return n%4;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 73886,
                "title": "python-solution",
                "content": "    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n % 4)",
                "solutionTags": [],
                "code": "    def canWinNim(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return bool(n % 4)",
                "codeTag": "Python3"
            },
            {
                "id": 4038668,
                "title": "python-simple-solution-dp-memorization-math",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\ndef can_win(n: int, cache: dict[int, bool]) -> bool:\\n  if n in cache:\\n    return cache[n]\\n  cache[n - 1] = can_win(n - 1, cache)\\n  cache[n - 2] = can_win(n - 2, cache)\\n  cache[n - 3] = can_win(n - 3, cache)\\n  return not (cache[n - 1] and cache[n - 2] and cache[n - 3])\\n\\nclass Solution:\\n  def canWinNim(self, n: int) -> bool:\\n    if n >= 134882061:\\n      return n % 4 != 0\\n    cache = {1: True, 2: True, 3: True, 4: False}\\n    return can_win(n, cache)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\ndef can_win(n: int, cache: dict[int, bool]) -> bool:\\n  if n in cache:\\n    return cache[n]\\n  cache[n - 1] = can_win(n - 1, cache)\\n  cache[n - 2] = can_win(n - 2, cache)\\n  cache[n - 3] = can_win(n - 3, cache)\\n  return not (cache[n - 1] and cache[n - 2] and cache[n - 3])\\n\\nclass Solution:\\n  def canWinNim(self, n: int) -> bool:\\n    if n >= 134882061:\\n      return n % 4 != 0\\n    cache = {1: True, 2: True, 3: True, 4: False}\\n    return can_win(n, cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950649,
                "title": "simple-c-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool canWinNim(int n){\\n    return n % 4 != 0 ? true : false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canWinNim(int n){\\n    return n % 4 != 0 ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656515,
                "title": "nim-game-beats-90-beginners-friendly",
                "content": "# KARRAR\\n>Math...\\n>>Brainteaser...\\n>>>Game theory...\\n>>>>Nim game...\\n>>>>>Optimzed and generalized...\\n>>>>>>Beginners friendly...\\n>>>>>>>Enjoy LeetCode...\\n-     PLEASE UPVOTE...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n            Take the mode of n by 4...\\n            Because the friend only when n is a divisor of 4...\\n            In other cases you can choose numbers like 1,2,3...\\n            If the result is 0, the answer is false...\\n            And true if it\\'s not 0...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Beats 90% (35 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 15% (16 MB)\\n\\n![Screenshot from 2023-06-19 15-53-26.png](https://assets.leetcode.com/users/images/a7cfc9c4-064b-449f-98b0-5dff7737ede7_1687172058.916286.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return True if n%4!=0 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return True if n%4!=0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391784,
                "title": "php",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n\\n        $n = $n % 4;\\n        if ($n==0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n\\n        $n = $n % 4;\\n        if ($n==0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206920,
                "title": "c-100-fast-very-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(1)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991235,
                "title": "simple-java-solution-runtime-0ms-just-one-if-condition",
                "content": "# Intuition\\nif 4 stone is left is that turn player is going to loss\\n first player can remove 1,2,3 stone \\n so player 1 can win if stone left are 4+1 or 4+2 or 4+3\\n player 1 loss when stone left is of multiple of 4\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(1)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // if 4 stone is left is that turn player is going to loss\\n        // first player can remove 1,2,3 stone \\n        // so player 1 can win if stone left are 4+1 or 4+2 or 4+3\\n        // player 1 loss when stone left is of multiple of 4\\n        if(n%4==0){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        // if 4 stone is left is that turn player is going to loss\\n        // first player can remove 1,2,3 stone \\n        // so player 1 can win if stone left are 4+1 or 4+2 or 4+3\\n        // player 1 loss when stone left is of multiple of 4\\n        if(n%4==0){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878940,
                "title": "10-characters-c-2-clean-solutions",
                "content": "# Code\\n```C++ []\\nreturn n % 4;\\n```\\n```C++ []\\nreturn n & 3;\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nreturn n % 4;\\n```\n```C++ []\\nreturn n & 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844313,
                "title": "js-solution-runtime-86-9-memory-92-49",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    if( n % 4 == 0) return false;\\n    else return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar canWinNim = function(n) {\\n    if( n % 4 == 0) return false;\\n    else return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805387,
                "title": "python-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn fact this is how % 4 comes from. This is a very basic game theory problem, and the recursively solution like this. Unfortunately this cannot pass since the recursion times exceeds the limit. But it will be very helpful to understand why %4 comes from (Of course you can derive the dp solution also from this)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    @cache\\n    def canWinNim(self, n: int) -> bool:\\n        if n <= 3:\\n            return True\\n        tmp = []\\n        for i in range(1, 4):\\n            if n - i > 0:\\n                tmp.append(self.canWinNim(n-i))\\n\\n        \\n        return not all(tmp)\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    @cache\\n    def canWinNim(self, n: int) -> bool:\\n        if n <= 3:\\n            return True\\n        tmp = []\\n        for i in range(1, 4):\\n            if n - i > 0:\\n                tmp.append(self.canWinNim(n-i))\\n\\n        \\n        return not all(tmp)\\n        \\n        \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2766689,
                "title": "nim-game-3-approaches-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Nim Game \\uD83D\\uDD25 || || 3 Approaches Simple Fast and Easy || with Explanation\\n\\n## Solution - 1\\n\\n```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    // if the remainder is not 0 because if there is remainder than nim will win\\n    return n % 4 != 0;\\n  }\\n}\\n```\\n\\n## Solution - 2 Recursive\\n\\n```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    // if the number is less than zero or equal nothing to do here\\n    if (n <= 0) return false;\\n    // because we can pick 0-3 pick one time  so true\\n    if (n == 1 || n == 2 || n == 3) return true;\\n    // recursive to see after picking 0,1,2,3 if there is something left we lost\\n    if (canWinNim(n - 1) && canWinNim(n - 2) && canWinNim(n - 3)) return false;\\n    return true;\\n  }\\n}\\n```\\n\\n## Solution - 3\\n\\n```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    if (n >= 134882061) return n % 4 != 0;\\n    bool result = true;\\n    bool first = true;\\n    bool second = true;\\n    bool third = true;\\n    for (int i = 4; i <= n; i++) {\\n      result = (first && second && third) ? false : true;\\n      first = second;\\n      second = third;\\n      third = result;\\n    }\\n    return result;\\n  }\\n}\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    // if the remainder is not 0 because if there is remainder than nim will win\\n    return n % 4 != 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    // if the number is less than zero or equal nothing to do here\\n    if (n <= 0) return false;\\n    // because we can pick 0-3 pick one time  so true\\n    if (n == 1 || n == 2 || n == 3) return true;\\n    // recursive to see after picking 0,1,2,3 if there is something left we lost\\n    if (canWinNim(n - 1) && canWinNim(n - 2) && canWinNim(n - 3)) return false;\\n    return true;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  bool canWinNim(int n) {\\n    if (n >= 134882061) return n % 4 != 0;\\n    bool result = true;\\n    bool first = true;\\n    bool second = true;\\n    bool third = true;\\n    for (int i = 4; i <= n; i++) {\\n      result = (first && second && third) ? false : true;\\n      first = second;\\n      second = third;\\n      third = result;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682913,
                "title": "nim-game-c-100-fast-solution",
                "content": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2572987,
                "title": "just-keep-a-4n-stones-on-the-table",
                "content": "Hi, the easy way to win this game is to always keep a 4n (multiple of four) stones on the table, so when it\\'s your turn, check if the number of stones is not dividible by four (because you can\\'t take 4 stones) ... and that\\'s it.\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n % 4 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496659,
                "title": "c-solution-with-mathematical-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n    /* f(1)=f(2)=f(3)=1;\\n    f(n)=!(f(n-1) && f(n-2) && f(n-3));\\n    \\n    f(4)=!(1 && 1 && 1)=0;\\n    f(5)=!(0 && 1 && 1)=1=f(6)=f(7);\\n    f(8)=!(1 && 1 && 1)=0;\\n    */\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4;\\n    }\\n    /* f(1)=f(2)=f(3)=1;\\n    f(n)=!(f(n-1) && f(n-2) && f(n-3));\\n    \\n    f(4)=!(1 && 1 && 1)=0;\\n    f(5)=!(0 && 1 && 1)=1=f(6)=f(7);\\n    f(8)=!(1 && 1 && 1)=0;\\n    */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489830,
                "title": "simple-algorithm",
                "content": "Just check if the number is divisible by 4 or not , If it is divisible then you lose the game , or else you win the game",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2485733,
                "title": "c-99-faster-smallest-solution-one-line-solution",
                "content": "```\\nbool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378878,
                "title": "almighty-c-100-fast-silly-logic",
                "content": "**Upvote It**\\n\\n```\\nbool canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377567,
                "title": "c-one-line-100-faster-0ms",
                "content": "```\\nreturn n%4!=0;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nreturn n%4!=0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327639,
                "title": "python-solution",
                "content": "When n is the times of 4 the second one will win.\\neg. n=4 --> A take 1-3, The remaining can be taken by B and win the game --> If n > 4, B can win if he can make the rest is 4 --> when n = 8 ---> No matter how many A takes, B can make the rest be 4\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320558,
                "title": "100-faster-solution-comments-included",
                "content": "```\\nbool canWinNim(int n) {\\n        return n & 3;  //Similar to n % 4\\n}\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nbool canWinNim(int n) {\\n        return n & 3;  //Similar to n % 4\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314219,
                "title": "easy-understanding-python-just-one-line",
                "content": "**just one line**\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n    return n%4 != 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n    return n%4 != 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193355,
                "title": "python-3-98-faster-with-explanation-very-simple-understanding",
                "content": "**The optimal way to solve this problem is that in each turn you should remove 1 stone and make other to take maximum 3 stones.This techniques helps you to make less stones available for you to remove at last . So the technique we use is that after 1 round  we remove 4 stones and following this pattern if any stone left then you wins the game. If you take maximum stones at start then definitely you gave a chance to your opponent to win the game by lefting less stone to remove.**\\n\\nHere is the simple python one liner code\\n\\n```\\nRuntime: 26 ms, faster than 97.13% of Python3 online submissions for Nim Game.\\n```\\n\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return int(str(n)[-2::1])%4!=0\\n```\\n\\nHope this will help you. Thankyou  for reading.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nRuntime: 26 ms, faster than 97.13% of Python3 online submissions for Nim Game.\\n```\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return int(str(n)[-2::1])%4!=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176136,
                "title": "o-1-one-line-solution-in-all-languages",
                "content": "First of all, this is not a good question. This is math and not coding, plus the game is called Bash Game not Nim Game.\\n\\n**Python**\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n % 4 != 0);\\n        \\n    }\\n};\\n```\\n\\n**Javascript**\\n```\\nvar canWinNim = function(n) {\\nreturn (n % 4 != 0);    \\n};\\n```\\n\\n**Ruby**\\n```\\ndef can_win_nim(n)\\n    return (n % 4 != 0);  \\nend\\n```\\n\\n**Go**\\n```\\nfunc canWinNim(n int) bool {\\n    return (n % 4 != 0); \\n}\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func canWinNim(_ n: Int) -> Bool {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n        return ($n % 4 != 0);\\n    }\\n}\\n```\\n\\n**Rust**\\n```\\nimpl Solution {\\n    pub fn can_win_nim(n: i32) -> bool {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\\n\\n**Typescript**\\n```\\nfunction canWinNim(n: number): boolean {\\nreturn (n % 4 != 0)\\n};\\n```\\n\\n**Kotlin**\\n```\\nclass Solution {\\n    fun canWinNim(n: Int): Boolean {\\n        return (n % 4 != 0)\\n    }\\n}\\n```\\n\\nI literally don\\'t even know some of these languages such as TypeScript but I still managed to write a solution which just proves how bad this question is.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n%4 != 0\\n```\n```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n % 4 != 0);\\n        \\n    }\\n};\\n```\n```\\nvar canWinNim = function(n) {\\nreturn (n % 4 != 0);    \\n};\\n```\n```\\ndef can_win_nim(n)\\n    return (n % 4 != 0);  \\nend\\n```\n```\\nfunc canWinNim(n int) bool {\\n    return (n % 4 != 0); \\n}\\n```\n```\\nclass Solution {\\n    func canWinNim(_ n: Int) -> Bool {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function canWinNim($n) {\\n        return ($n % 4 != 0);\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn can_win_nim(n: i32) -> bool {\\n        return (n % 4 != 0);\\n    }\\n}\\n```\n```\\nfunction canWinNim(n: number): boolean {\\nreturn (n % 4 != 0)\\n};\\n```\n```\\nclass Solution {\\n    fun canWinNim(n: Int): Boolean {\\n        return (n % 4 != 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135888,
                "title": "c-code-golfed-optimised-bitwise-solution-100-time-0ms-85-space-5-8mb",
                "content": "I was tempted for a moment to use DP to solve this and, while I am sure it would work, I quickly realised it was an overkill in this case:\\n* if I have less than `4` stones, I automatically win by definition, since I can grab all of the in one go;\\n* if I have `4`, I automatically lose, since no matter how many I take, my opponent will be in the winning position described above;\\n* if I have `5-7` stones, I can force my opponent in the losing scenario of the previous bullet point;\\n* if I have `8`, my opponent will end up in the winning scenario above, no matter what;\\n* and so on...\\n\\nNow, this means that basically we lose for every multiple of `4` we face.\\n\\nWe might be tempted to `return` something like `n % 4 != 0` or just `n % 4`, but that would be still doing a relatively expensive operation as dividing two numbers.\\n\\nSince we want the remainder by a power of `2`, we can still do better using bitwise operators: if we do `n & 3`, we will `return` a truthy (ie: `!= 0`) value every time that the least significant bits are not `00`, that is to say we would `return` `true` every time `n` is NOT a multiple of `4`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n & 3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n & 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133581,
                "title": "nim-game-simple-100-faster-o-1",
                "content": "**<<++++++++ press upvote Button !!!!!!!!!!!!**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        \\n        if(n%4>=1)\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/db28c601-d198-4b40-a0a2-51ffcbbb6802_1654839925.1857622.jpeg)\\n\\n\\n**<<++++++++ press upvote Button !!!!!!!!!!!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        \\n        if(n%4>=1)\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114641,
                "title": "c-one-line-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4==0 ? false:true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return n%4==0 ? false:true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084267,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return (n%4==0)?false:true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canWinNim(int n) {\\n        return (n%4==0)?false:true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2045904,
                "title": "solution-in-c",
                "content": "\\nbool canWinNim(int n){\\n    if(n%4==0)\\n    {\\n        return false;\\n    }\\n    return true;\\n \\n    \\n    \\n}",
                "solutionTags": [],
                "code": "\\nbool canWinNim(int n){\\n    if(n%4==0)\\n    {\\n        return false;\\n    }\\n    return true;\\n \\n    \\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1983669,
                "title": "c-very-simple-just-6-word-only",
                "content": "If you like please upvote :)\\n```\\nclass Solution {\\npublic:\\n   \\n    \\n    bool canWinNim(int n) {\\n     \\n     return (n%4!=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    \\n    bool canWinNim(int n) {\\n     \\n     return (n%4!=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978014,
                "title": "one-line-java",
                "content": "public boolean canWinNim(int n) {\\n        \\n       return n%4==0 ? false : true;\\n        \\n    }",
                "solutionTags": [],
                "code": "public boolean canWinNim(int n) {\\n        \\n       return n%4==0 ? false : true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1953073,
                "title": "explanation-easy-to-understand-python",
                "content": "**If n is divisble by 4 then your friend will win the game.**\\nHow let us find out !!\\nlet no. of stones be 12.\\nif you pick any number of stone b/w 1 to 3 then your friend will pick number of stones such that sum of no. of stones picked up by both will becom 4.\\n\\n\\n\\n\\t\\t\\tno. of stones                 no. of stones                 remaing stones\\n\\t\\t\\tpicked by YOU           picked by YOUR FRIEND\\n\\tstep1           2                              2                                 8\\n\\tstep2           1                              3                                 4\\n\\tstep3           3                              1                                 0\\n\\nwhatever no. of stones  you pick, your friend will always pick up to make it 4 and he/she would always get to pick the last stone (if n is divisible by 4), Since both of them play optimally.\\n\\n**If n is NOT divisible by 4 then you will win the game**\\nBut how???\\nYou will pick up n%4 such after picking up Now you end up in position of your friend and your friend end up in your position.\\n\\n You pick n%4 for first time (for example no. of stones are 15 then you will pick up 15%4 ( that is 3) After picking 15%4 balls now the ball left is 15-15%4 = 8, So now the no. of stones is divisible by  4. Now we are in same condition as above but the difference is that position of  player1 and player2 are exchanged.\\n\\tLet no. of stones be 15.\\n\\n\\t\\t\\tno. of stones                 no. of stones                 remaing stones\\n\\t\\t\\tpicked by YOUR FRIEND          picked by YOU\\n\\tstep1           -                              3                                 12\\n\\tstep2           2                              2                                 8\\n\\tstep3           1                              3                                 4\\n\\tstep4           3                              1                                 0\\n\\nSince you play optimally , you\\'ll alway\\'s pickup n%4, Now whatever no. of stones  your friend pick up, you will always pick up to make it 4 and you would always get to pick the last stone , Since both of you play optimally.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if n%4==0:\\n            return False\\n        return True\\n```\\n\\nPlease Upvote, if you find it helpful :)\\n        \\n        \\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if n%4==0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945346,
                "title": "nim-game",
                "content": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)  //only possibility where it shoul return false\\n        {\\n            return 0;\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)  //only possibility where it shoul return false\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1936341,
                "title": "2-lines-of-code-0ms-100ms-faster-easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935564,
                "title": "one-line-of-c-code-0-ms-faster-than-100-00-of-c-online-submissions-for-nim-game",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nbool canWinNim(int n) {\\n        return !(n%4 == 0);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool canWinNim(int n) {\\n        return !(n%4 == 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900055,
                "title": "racket-easy-100",
                "content": "```\\n(define/contract (can-win-nim n)\\n  (-> exact-integer? boolean?)\\n    (not (equal? (modulo n 4) 0))\\n  )\\n```",
                "solutionTags": [],
                "code": "```\\n(define/contract (can-win-nim n)\\n  (-> exact-integer? boolean?)\\n    (not (equal? (modulo n 4) 0))\\n  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840388,
                "title": "c-easy-to-understand",
                "content": "Nim Game -\\n\\n```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)\\n        {\\n            return false;\\n        }\\n       return true; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)\\n        {\\n            return false;\\n        }\\n       return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794851,
                "title": "nim-game-one-line-solution",
                "content": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n%4);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Game Theory"
                ],
                "code": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        return (n%4);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1773001,
                "title": "js-ts-one-line-solution-100-faster-with-explanation-dp-solution",
                "content": "**One-line solution:**\\nImagine these conditions during our move:\\n1. 1-3 stones left -> we can directly remove them all -> win\\n2. 4 stones left -> after our move, there will be 1-3 stones left (the opponent will face condition 1 -> win) -> lose\\n3. 5 or more stones left -> there can more rounds which will lead to either condition 1 or 2\\n```\\nfunction canWinNim(n: number): boolean {\\n    return n % 4 !== 0;\\n};\\n```\\n\\n**Dynamic Programming (DP) solution:**\\n```\\nfunction canWinNim(n: number): boolean {\\n    if (n < 4) return true;\\n    \\n    const prevWin: boolean[] = [true, true, true];\\n    \\n    for (let stone = 4; stone <= n; stone++) {\\n        const optimalRes = !prevWin[0] || !prevWin[1] || !prevWin[2];\\n        prevWin.shift();\\n        prevWin.push(optimalRes);\\n    }\\n    \\n    return prevWin[2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction canWinNim(n: number): boolean {\\n    return n % 4 !== 0;\\n};\\n```\n```\\nfunction canWinNim(n: number): boolean {\\n    if (n < 4) return true;\\n    \\n    const prevWin: boolean[] = [true, true, true];\\n    \\n    for (let stone = 4; stone <= n; stone++) {\\n        const optimalRes = !prevWin[0] || !prevWin[1] || !prevWin[2];\\n        prevWin.shift();\\n        prevWin.push(optimalRes);\\n    }\\n    \\n    return prevWin[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673620,
                "title": "easy-java-solution-for-beginner",
                "content": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n%4==0)// if n comes in multiple of 4 surely friend will win\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        if(n%4==0)// if n comes in multiple of 4 surely friend will win\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660202,
                "title": "easiest-c-solution",
                "content": "```class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)\\n        {\\n            return false;\\n        }\\n        else\\n            return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if(n%4==0)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1596289,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4!=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561919,
                "title": "python3-dp-although-it-cannot-pass-the-test",
                "content": "it is a good idea to use dp\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if n <= 3:\\n            return True\\n        dp = [True] * 3\\n        for i in range(3, n):\\n            new_dp = (not dp[0]) or (not dp[1]) or (not dp[2])\\n            dp.pop(0)\\n            dp.append(new_dp)\\n        return dp[-1]",
                "solutionTags": [],
                "code": "it is a good idea to use dp\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if n <= 3:\\n            return True\\n        dp = [True] * 3\\n        for i in range(3, n):\\n            new_dp = (not dp[0]) or (not dp[1]) or (not dp[2])\\n            dp.pop(0)\\n            dp.append(new_dp)\\n        return dp[-1]",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566254,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1572173,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1566255,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1573350,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1567504,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569862,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569491,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569342,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1567948,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1576716,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1566254,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1572173,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1566255,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1573350,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1567504,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569862,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569491,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569342,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1567948,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1576716,
                "content": [
                    {
                        "username": "舟公子L",
                        "content": "Hello my friends. I come up with a rigorous proof that \"return (n % 4)\" works. Here is my detailed explanation and I apologize if this is wordy or more complex than your own method.\\n\\n**Statement1**\\nwe have a function Win(n) that takes in an input \"n\", and outputs: 0 or 1.\\nFor its output 1, it means \"***you can win in one of the three moves: take 1, 2, 3***\"\\nFor its output 0, it means \"***you cannot win, no matter what moves you take***\" (in the assumption that your opponent is smart).\\n\\n**Statement2**\\nNow I claim that the function Win(n) is:\\n\\n\\n* 1 when n % 4  != 0\\n\\n* 0 when n % 4 == 0\\n\\nIn other words, n = 4k + 4, then **Win(n) = 0**; n = 4k+1, 4k+2, 4k+3, **Win(n) = 1**; \\n\\nNow I prove this by Induction:\\n\\n1. when k = 0.\\n \\n* n = 1, 2, 3, on every of these three case you can win by taking all of them.\\n\\n* n = 4, you simply cannot win in any way.\\n\\n2. Assume this is true for k = x: \\n***n = 4x+1, 4x+2, 4x+3, Win(n) = 1; n = 4x + 4, then Win(n) = 0;*** \\nThen I will prove the following:\\nfor k = x + 1, this is also true:\\n***n = 4x+5, 4x+6, 4x+6, Win(n) = 1; n = 4x + 8, then Win(n) = 0;*** \\n* For n = 4x+5, you can take 1 to leave your opponent n=4x+4, which is 0 in the assumption. Similarly, for n=4x+6, 4x+7, you should take 2, 3 stones from it.\\n* For n = 4x+8, any number of stone (1, 2, 3) you take, will leave your opponent the previous three cases, which in turn leaves you a 4x+4 case, and you lose.\\n\\nIn conclusion, the Win(n) function is:\\n\\n*  **Win(n) = 0**; n = 4k + 4 (k is int)\\n\\n* **Win(n) = 1**; n = 4k+1, 4k+2, 4k+3 (k is int)\\n\\nAnd that is why return n % 4 works."
                    },
                    {
                        "username": "pawelqbc",
                        "content": "Isn\\'t it too much for Description section? Shouldn\\'t it be in Solutions part?"
                    },
                    {
                        "username": "ElectricAvenue",
                        "content": "This is a logic puzzle, not a programming puzzle"
                    },
                    {
                        "username": "会飞的鸵鸟",
                        "content": "I think this thinking way can help us to solve and understand this problem quickly.\\n\\nFirst,Let's begin with some tries.  \\nwhen the rock is 1(win)  2(win) 3(win) 4(lose)   I think everyone can do this,then we stop and think.\\n\\nAfter you take rock and your friend becomes \"you\"  think it carefully\\nfor  example. when there are 4 rocks,after your taking  ,there are three situations.so your friend begin with \\n1,2,or 3 \\nyou lose(when there are 4 rocks)  = your friend win =  start with(4-1),(4-2),(4-3)  win\\n\\nso there must be 3 win before 1 lose  \\n\\nso 4 is a group.\\n\\nin c language we just return  n%4"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "With 8 stone we can win the game but testcase expects false, can some one elaborate"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) But it is written in question that player 2 is also playing optimally, means he is not dumb. So if you pick 1 stone then why would your opponent pick 1 stone, he will pick 3 stones, and then its your turn and there will be 4 stones left in total, hence you can\\'t do anything now as no matter how many stones you pick out of 4 you are guaranteed to loose."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@shalf3y](/shalf3y)  bro we can win the game see if i take 1 and he take also one remainig 6 and then i take 2 he takes 3 and remaining 1 and i take 1 and win the game"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "[@cartesPerforees](/cartesPerforees)  bro we can win the game see if  i take 1 and he take also 2 remainig 5 and then i take 1 he takes 2 and remaining 2 and i take 2 and win the game"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why has anybody upvoted this? You cannot win with 8 stones indeed"
                    },
                    {
                        "username": "shalf3y",
                        "content": "Late reply, but anyway: you can\\'t win the game with 8 stones if your opponent plays optimally, and it\\'s stated in problem description.\\nAssuming you take 1 stone, 7 is left, opponent takes 3 and leaves you with 4. \\nIf you take 2, 6 is left and opponent takes 2 and leaves you with 4.\\nIf you take 1, they take 3 and you are left with 4.\\nAnd 4 stones is an always-lose combination, because you are leaving your opponent with 1-3 stones, which is a guaranteed win."
                    },
                    {
                        "username": "aljorhythm",
                        "content": "Instead of \"Write a function to determine whether you can win the game given the number of stones in the heap\" it should be \"Write a function to determine whether you will win the game\"\\n\\nCan implies whether there are possible LOGICAL paths. \\'Will\\' implies whether there is a path that the opponent can be forced to take to ensure an outcome."
                    },
                    {
                        "username": "iamvraj",
                        "content": "return !(n%4==0);\\n\\nnow who\\'s laughing?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "```return n%4!=0;```"
                    },
                    {
                        "username": "dnt1997",
                        "content": "wth????!?!?!?!?!"
                    },
                    {
                        "username": "gcll",
                        "content": "// \\u627E\\u89C4\\u5F8B\\uFF1A\\u5047\\u8BBE\\u5148\\u62FF\\u7684\\u4EBA\\u4E3A a\\uFF0C\\u540E\\u62FF\\u7684\\u4E3A b\\n// n<=3 \\u65F6\\uFF0Ca win\\n// 1 2 3 4 \\u65F6\\uFF0Ca lose\\n// 1 2 3 4 5 \\u65F6\\uFF0Ca\\u5148\\u62FF1\\uFF0C\\u5269\\u4E0B\\u7684\\u60C5\\u51B5\\u5C31\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\u4E86\\uFF0C\\u6B64\\u65F6\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 \\u65F6\\uFF0Ca\\u5148\\u62FF1 2\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u8F6C\\u5316\\u4E3An=4\\uFF0C\\u53C8\\u76F8\\u5F53\\u4E8Eb\\u5148\\u62FF\\uFF0C\\u90A3\\u4E48b lose\\n// 1 2 3 4 5 6 7 \\u65F6\\uFF0Ca\\u5148\\u62FF 1 2 3\\uFF0C\\u6B64\\u65F6\\u60C5\\u51B5\\u540C\\u6837\\u53EF\\u4EE5\\u8F6C\\u5316\\u4E3An=4\\u7684\\u60C5\\u51B5\\uFF0Cb lose\\uFF1B\\n\\n// 12345678\\u65F6\\uFF0C\\n//a\\u5982\\u679C\\u5148\\u62FF1\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=7\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win\\uFF0C\\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF1\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF2\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=6\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF2\\u4E2A\\uFF1B\\n//a\\u5982\\u679C\\u5148\\u62FF3\\u4E2A\\uFF0C\\u5C31\\u8F6C\\u5316\\u4E3An=5\\u7684\\u60C5\\u51B5\\uFF0C\\u6B64\\u65F6b\\u5148\\u62FF\\uFF0Cb win, \\u6545 a\\u4E0D\\u80FD\\u5148\\u62FF3\\u4E2A\\uFF1B\\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n=8\\u65F6\\uFF0Ca lose\\n  \\n// \\u5F53n=9\\u65F6\\uFF0Ca\\u5148\\u62FF1,\\u8F6C\\u5316\\u4E3An=8\\u7684\\u60C5\\u51B5,b lose\\n  \\n// \\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5F53n\\u4E3A4\\u7684\\u500D\\u6570\\u65F6\\uFF0Ca\\u4E0D\\u80FD\\u8D62"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "For those looking for a simple and general explanation why first player loses if and only if N is a multiple of 4, read on:\\n\\nThe Sprague-Grundy theorem can be used to solve most problems like this. It\\'s somewhat technical, but the basic recipe is easy to memorize and apply: first, for the problem there may be one or more than one \"subgame\". For each \"subgame\", you need to compute the \"min excludant\" (which I will define soon), also known as the \"nimber\". Then, take the cumulative XOR of all the nimbers; if zero, the first player loses, and if non-zero, the first player wins. \\n\\nThe reason XOR works is because a losing position is one in which every reachable position is winning, and a winning position is one in which there is at least one reachable position that is losing. This corresponds exactly to the property of a cumulative XOR: when it\\'s zero, any change in any of the numbers will make it nonzero (easy to see), and if it\\'s nonzero, there exists at least one change to one of the numbers that will make the whole thing zero (this one\\'s not as easy to see, but still doable, though I won\\'t prove it here).\\n\\nNow here\\'s how to get the \"min excludant\", a.k.a. \"nimber\": it is a non-negative integer that is zero for a subgame that is already lost, and otherwise it is the smallest integer that is *not* the nimber for some position that can be reached in one move from the current position. Sounds complicated, but let\\'s look at the example of the current problem:\\n\\nIn this case, there is only one pile, e.g. one \"subgame\", so cumulative XOR is just the min excludant itself. If the pile is empty, then first player has lost, so empty pile has nimber=0. Note each player must remove 1-3 stones. For a pile of 1, only one move is possible: remove 1, so that reaches the nimber of 0, so smallest excluded integer is 1. For a pile of 2, a move can reach 0 or 1, so nimber is 2. For a pile of 3, a move can reach nimbers of 0, 1, or 2, so nimber is 3. Boring so far, but for a pile of 4, a move can only reach nimbers of 1, 2, or 3. Since it cannot reach 0, that is the min excludant, and hence nimber for pile of 4 is 0. Next, for pile of 5, a move can reach piles of 2, 3 or 4. The nimbers for those is 2, 3, and 0, so nimber for 5 is 1.\\n\\nContinuing this way, it is easy to see that nimber for pile of k is k mod 4, and since there\\'s only one pile and thus one subgame, the cumulative XOR is just the nimber itself, so by the Sprague grundy theorem, the first player wins if and only if the k mod 4 != 0.\\n\\n"
                    },
                    {
                        "username": "ra1den",
                        "content": "One line code solution: \\n**return n%4 > 0;**\\n\\nAccepted but it shows beats 22.33% of python submissions. Looks like there is much improvement space for my code. Is there any python trick can make runtime faster?\\n\\nAny veteran experience or help would be appreciated."
                    },
                    {
                        "username": "indolentllama",
                        "content": "Should really be `return n % 4 != 0` for readability, but with type coercion, you can drop the `!= 0` in Python and C/C++.  Anyway, I got to this solution by thinking through some examples and putting myself in the shoes of the players.\\n**4 stones**\\nAs given in the problem description, if you start with 4, you can\\'t win, since your opponent will be left with 1-3 stones, and they can take all of them.\\n**5-7 stones**\\nSince your opponent will lose if they\\'re left with 4 stones, I\\'d take 1-3 stones to reduce the total to 4 and win\\n**8 stones**\\nI can\\'t win!  The total remaining stones after my turn will be 5-7, and then my opponent can just take enough stones to reduce the total to 4, making me lose.\\n**9-11 stones**\\nI\\'ll just take enough stones so only 8 remain, then I\\'ll win, since no matter how many stones my opponent takes, I can knock down the total to 4.\\n\\nAnd so the pattern repeats.  But I still had a hard time really understanding the solution even if I could spot the repeating pattern.\\nSo another way I found to think about it: \\nIf you start the game with a multiple of 4 stones, no matter how many stones you take, your opponent can always take just enough stones so the total stones taken by both of you is 4 (e.g. if I take 1 stone, they\\'ll take 3, or if I take 2, they\\'ll take 2, etc.).  So after each round, your opponent makes it so the total number of stones taken away is 4, so the total remaining will still be a multiple of 4. Your opponent will repeat this process until your left holding the bag with only 4 stones remaining on the board.  \\n\\nIf the board doesn\\'t start with a multiple of 4, you can just take away enough stones to make it a multiple of 4 (e.g. if the board starts with13 stones, you take away 1).  From this point, you use the same strategy your opponent would have used if the game had started with a multiple of 4, forcing your opponent to always start their turn with a multiple of 4.\\n\\nAn example, starting with 16 stones, showing how my opponent can always make me lose by always making me start with a multiple of 4 stones on the board:\\nI take 3 stones; 13 remaining\\nOpponent takes 1 (to make the total remaining a multiple of 4); **12 remaining**\\nI take 2 stones; 10 remaining\\nOpponent takes 2; **8 remaining**\\nI take 1 stone; 7 remaining\\nOpponent takes 3 stones; **4 remaining**\\nNo matter how many stones I take, my opponent will be left with 1-3, and they can take all of them, so I lose :(\\n\\n"
                    },
                    {
                        "username": "Meabu",
                        "content": "[@kartikey_wariyal](/kartikey_wariyal) you take 1 and he should take 3 so its gonna be 4 rock and you lose"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "what if n is 8 and  i take 1 and he also take 1 and then i take 2 he take 3 and i take 1 and i won "
                    }
                ]
            },
            {
                "id": 1569695,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1566494,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1743580,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1576356,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1575468,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1575465,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1574771,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1574755,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1572205,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1571543,
                "content": [
                    {
                        "username": "renato4",
                        "content": "Let\\'s say we choose our dp state as dp[n], where dp[n] tells if **current player wins the game if in his turn there are n stones**, hence this is a boolean array. To answer our current state, we **check if removing 1, 2 or 3 stones from the heap, the next player loses**. This means that our transition would be `dp[i]=!dp[i-1]||!dp[i-2]||!dp[i-3]`. Our base cases are 1, 2 and 3, where the current player wins. Notice that this dp solution is O(n).\\n\\nIf you grab the paper and try the cases starting from 1 and going up to 12, for example, you will notice a pattern. Every multiple of 4, lets call them 4x, the previous three states (4x-1, 4x-2 or 4x-3) are all true, and then our transition function evaluates to false. \\n\\nAt the end, in an interview, if you came up with the dp solution and after that the interviewer said: Hey, I want better than that. Intuitivelly, you would try to think about complexities like O(nlogn), O(logn) or even O(1). Writing the recursive steps on the whiteboard would help you visualize what would be the next best approach. In this case, with only a few cases (12), you would convice yourself of the multiple of 4 pattern."
                    },
                    {
                        "username": "BlackKitty",
                        "content": "    canWinNim(n){return 3&n;}\\n\\nthis is it"
                    },
                    {
                        "username": "kameshwarasekar",
                        "content": "The technique here is simple, you are the first person to take the stones, as you know you can win when there are 1,2,3 stones left and lose when 4 stones are left. It is just forcing your opponent to bring the heap total to 4 at some point(your opponent should have to choose from 4 stones, which means he looses for sure). You can force to 4 remaining stones when the heap contains 4k+1, 4k+2, 4k+3 and not when 4x (where k = x+1). What you are given as an example is just a subgame and very helpful. To solve this question, you just need to understand this logic. Thus \"return n%4\" is the answer to the problem. This code implies return True when n%4 !=0 and False when n%4==0"
                    },
                    {
                        "username": "anuragpandey9",
                        "content": "return !(n%4==0);"
                    },
                    {
                        "username": "VikasChiku",
                        "content": "public boolean canWinNim(int n) {\\n        \\nreturn !(n % 4 == 0);\\n    }"
                    },
                    {
                        "username": "kundankumar4348",
                        "content": "\\treturn n%4;"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn n % 4 != 0"
                    },
                    {
                        "username": "TrueDamage",
                        "content": "Who figured this out without watching others\\' solutions...."
                    },
                    {
                        "username": "wagnze",
                        "content": "Minimum post length is 12 characters...."
                    },
                    {
                        "username": "stalary",
                        "content": "I think it it a Bash Game!\\nIt isn`t a Nim Game"
                    }
                ]
            },
            {
                "id": 1571544,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1569191,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 2058849,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1873111,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1837690,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1833889,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1790661,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1788983,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1772706,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            },
            {
                "id": 1733157,
                "content": [
                    {
                        "username": "Horanol",
                        "content": "&emsp;inspired by [all 4s shall be false](https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false),I generalize the problem to n stones that you can take at once among m stones. it becomes very easy after we find out all the death numbers.  \\n\\n&emsp;Firstly,when we have stones less than or equals n,we are definitely winning. So obviously n+1 is a death number because you cannot take all the stones at once and the remaining stones can all be taken by the opponent. What is the next death number? When we have 2n+2 stones,no matter how many stones you take(assume i,where 1<=i<=n),your opponent can take j stones(1<=j<=n) to make i+j = n+1,so the number reduces to n+1,and it's your turn to meet the death number. So 2n+2 is also a death number.Now we can say:all multiples of n+1 are death numbers."
                    },
                    {
                        "username": "mingqianliu",
                        "content": "\\u56E0\\u4E3A\\u9762\\u5BF94\\u662F\\u4E00\\u79CD\\u5FC5\\u8F93\\u7684\\u60C5\\u5F62\\uFF0C\\u6240\\u4EE5\\u53EA\\u8981\\u628A\\u8FD9\\u79CD\\u60C5\\u5F62\\u63A8\\u7ED9\\u5BF9\\u65B9\\u5C31\\u4F1A\\u8D62\\u4E86\\u3002\\n\\n\\u4E00\\u65B9\\u9762\\u5BF94n\\u4E2A\\u77F3\\u5B50\\u7684\\u65F6\\u5019\\uFF0C\\u53D6\\u5B8C\\u77F3\\u5B50\\u53EF\\u80FD\\u7684\\u60C5\\u51B5\\u662F4n-1,4n-2,4n-3\\uFF0C\\u53E6\\u4E00\\u65B9\\u53EF\\u4EE5\\u5206\\u522B\\u901A\\u8FC7\\u53D63\\u30012\\u30011\\u4E2A\\u77F3\\u5B50\\u4F7F\\u5BF9\\u65B9\\u9762\\u5BF94\\uFF08n-1\\uFF09\\u4E2A\\u77F3\\u5B50\\uFF0C\\u5E76\\u91C7\\u53D6\\u540C\\u6837\\u7B56\\u7565\\u76F4\\u5230\\u5BF9\\u65B9\\u9762\\u5BF94\\u4E2A\\u77F3\\u5B50\\u8F93\\u6389\\u3002\\n\\n\\u6240\\u4EE5\\u9762\\u5BF94\\u7684\\u500D\\u6570\\u7684\\u77F3\\u5B50\\u80AF\\u5B9A\\u4F1A\\u8F93\\u7684\\uFF0C\\u76F8\\u53CD\\u80AF\\u5B9A\\u4F1A\\u8D62\\u3002"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why 12 not win? I find next combination for win. CONDITION \"you CAN win\" \\n12 -2 =10 P1\\n10 - 3 = 7 P2\\n7-2 =5 P1\\n5 - 3 =2 P2\\n2-3 <0 P1 Win\\nExplain,somebody, please."
                    },
                    {
                        "username": "kaur19p",
                        "content": "Your outlook is valid, but it is not an optimal situation. They are playing ‘optimally’…so when P2 will see 5….he will know that he should pick 1 in order to win…because which ever player gets a multiple of 4 to choose from on his turn will lose.\n12 - 2 =10 P1\n10 - 3 = 7 P2\n7- 2 = 5 P1\n5 - 1 = 4 P2\nNow doesn’t matter if P1 picks 1, 2 or 3, he will lose."
                    },
                    {
                        "username": "sklem",
                        "content": "I wrote dynamic programming solution , but it has been got \"Time Limit Exceeded\"  (((  "
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "I can\\'t pass it, but I\\'m happy with my code.\\n ```\\n        function<bool(int,int)> canwin = [&](int player,int remaining)->bool{\\n            if(remaining <= 0)\\n                return false;\\n            if(dp[remaining][player] != -1) {\\n                return dp[remaining][player];\\n            }\\n            for(int i = 1;i<=3;i++){\\n               if(!canwin(!player, remaining - i)){      \\n                   return dp[remaining][player] = true;\\n               }\\n            }\\n            return dp[remaining][player] = false;\\n        };\\n```"
                    },
                    {
                        "username": "2003a54015",
                        "content": " return (n%4!=0); "
                    },
                    {
                        "username": "vigneshrajgopalnayak",
                        "content": "i have a scenario \\nfor n = 4\\nplayer 1 will pick 1stone\\nplayer 2 will pick 1 stone\\nplayer 1 will pick 2 stone\\n\\nso player 1 can technically win\\n\\nwhy is this situation return should be  False???"
                    },
                    {
                        "username": "rjskomal",
                        "content": "It is mentioned in the question that you and your friend play optimally.\\nThat means you both play to win and no blunders are to be made.\\nIf player 1 takes 1 stone.\\nplayer 2 will take 3 stones to win.\\n\\nplayer 2 taking 1 stone is a blunder and is not allowed in optimal play.\\n\\nDo read/solve about Optimal vs optimal \\ngreedy vs greedy  and \\noptimal vs greedy problems.\\nI hope it helped!\\n"
                    },
                    {
                        "username": "akash_2k",
                        "content": "i can guarantee lot of you guys failed at \"n = 8\"."
                    },
                    {
                        "username": "8183K",
                        "content": "What does ```assuming both you and your friend play optimally``` mean here?\\n\\n```Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.```"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "Try to observe the pattern, from 1 to n.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Is Subsequence",
        "question_content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abc\", t = \"ahbgdc\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"axc\", t = \"ahbgdc\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?",
        "solutions": [
            {
                "id": 1811508,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "\\n**Please dont downvote guys if cannot support,We are putting lot of effort in it\\uD83D\\uDE42**\\n\\n```\\nQuestion asking us to return true if s is a subsequence of t, or false otherwise.\\n\\nExample:\\n    s=\\'code\\'\\n    t=\\'leetcode\\'\\n    here s is subsequence of t ,we can get code from leetcode.\\n\\n\\nWhat is subsequence and subString?\\n    Subsequence: a sequence that appears in the same relative order, but not necessarily contiguous.\\n    SubString: a contiguous sequence of symbols that appears in the same relative order as the original string.\\n  \\n  \\n  Big O:\\n    Time: O(n) # n is the length of t\\n    Space: O(1)\\n```\\n![image](https://assets.leetcode.com/users/images/c450ba53-2978-44bc-b11b-6736902c4c16_1646192237.8284814.gif)\\n\\n![image](https://assets.leetcode.com/users/images/94d56cc4-67b6-4fec-884b-e73eea4292d2_1646193232.0056262.png)\\n\\n\\n\\n`JavaScript`\\n\\n```\\nconst isSubsequence = (s, t) => {\\n  //! Edge case\\n  if (s.length > t.length) return false; //! if len of s is greater than len of t, return false because s cant be a subsequence of t\\n  `\\n  Example:\\n    s=\\'Leetcode\\'\\n    t=\\'Code\\'\\n    here we are trying to find if \\'Leetcode\\' is a subsequence of \\'Code\\' which is not possible because \\'Leetcode\\' is longer than \\'Code\\'\\n\\n  `;\\n  const t_length = t.length;\\n  let subsequence = 0;\\n  for (let i = 0; i < t_length; i++) {\\n    if (s[subsequence] === t[i]) {\\n      // ! if it is matching, increment subsequence\\n      subsequence++;\\n    }\\n  }\\n  return subsequence === s.length\\n};\\n```\\n\\n`Python`\\n\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(s) > len(t):return False\\n        if len(s) == 0:return True\\n        subsequence=0\\n        for i in range(0,len(t)):\\n            if subsequence <= len(s) -1:\\n                print(s[subsequence])\\n                if s[subsequence]==t[i]:\\n\\n                    subsequence+=1\\n        return  subsequence == len(s) \\n```\\n\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.\\n`",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nQuestion asking us to return true if s is a subsequence of t, or false otherwise.\\n\\nExample:\\n    s=\\'code\\'\\n    t=\\'leetcode\\'\\n    here s is subsequence of t ,we can get code from leetcode.\\n\\n\\nWhat is subsequence and subString?\\n    Subsequence: a sequence that appears in the same relative order, but not necessarily contiguous.\\n    SubString: a contiguous sequence of symbols that appears in the same relative order as the original string.\\n  \\n  \\n  Big O:\\n    Time: O(n) # n is the length of t\\n    Space: O(1)\\n```\n```\\nconst isSubsequence = (s, t) => {\\n  //! Edge case\\n  if (s.length > t.length) return false; //! if len of s is greater than len of t, return false because s cant be a subsequence of t\\n  `\\n  Example:\\n    s=\\'Leetcode\\'\\n    t=\\'Code\\'\\n    here we are trying to find if \\'Leetcode\\' is a subsequence of \\'Code\\' which is not possible because \\'Leetcode\\' is longer than \\'Code\\'\\n\\n  `;\\n  const t_length = t.length;\\n  let subsequence = 0;\\n  for (let i = 0; i < t_length; i++) {\\n    if (s[subsequence] === t[i]) {\\n      // ! if it is matching, increment subsequence\\n      subsequence++;\\n    }\\n  }\\n  return subsequence === s.length\\n};\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(s) > len(t):return False\\n        if len(s) == 0:return True\\n        subsequence=0\\n        for i in range(0,len(t)):\\n            if subsequence <= len(s) -1:\\n                print(s[subsequence])\\n                if s[subsequence]==t[i]:\\n\\n                    subsequence+=1\\n        return  subsequence == len(s) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811177,
                "title": "c-recursion-and-two-pointer",
                "content": "```\\n1. Both Approaches are 100% faster\\n2. Approach\\nThe idea is simple, we traverse both strings from one side to another side \\n(say from rightmost character to leftmost). If we find a matching character\\n, we move ahead in both strings. Otherwise, we move ahead only in t. \\n```\\n\\n* **Code 1**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.length(),m=t.length();\\n        int j = 0; \\n    // For index of s (or subsequence\\n \\n    // Traverse s and t, and\\n    // compare current character\\n    // of s with first unmatched char\\n    // of t, if matched\\n    // then move ahead in s\\n    for (int i = 0; i < m and j < n; i++)\\n        if (s[j] == t[i])\\n            j++;\\n \\n    // If all characters of s were found in t\\n    return (j == n);\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/224e75bb-f96f-4367-83c0-6f4620742bb8_1646182844.234336.png)\\n\\n\\n* **Code 2**\\n```\\nclass Solution {\\n    int isSubSequence(string& s1, string& s2, int i, int j)\\n{\\n    if (i == 0 || j == 0) {\\n        return 0;\\n    }\\n    if (s1[i - 1] == s2[j - 1]) {\\n        return  1 + isSubSequence(s1, s2, i - 1, j - 1);\\n    }\\n    else {\\n        return  isSubSequence(s1, s2, i, j - 1);\\n    }\\n}\\n \\npublic:\\n    bool isSubsequence(string s, string t) {\\n         int m = s.size();\\n    int n = t.size();\\n    if (m > n) {\\n        return false;\\n    }\\n    if (isSubSequence(s, t, m, n) == m) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/f81f3c8d-bc98-4cbf-b313-a680ecc32036_1646182866.6313102.png)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Both Approaches are 100% faster\\n2. Approach\\nThe idea is simple, we traverse both strings from one side to another side \\n(say from rightmost character to leftmost). If we find a matching character\\n, we move ahead in both strings. Otherwise, we move ahead only in t. \\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.length(),m=t.length();\\n        int j = 0; \\n    // For index of s (or subsequence\\n \\n    // Traverse s and t, and\\n    // compare current character\\n    // of s with first unmatched char\\n    // of t, if matched\\n    // then move ahead in s\\n    for (int i = 0; i < m and j < n; i++)\\n        if (s[j] == t[i])\\n            j++;\\n \\n    // If all characters of s were found in t\\n    return (j == n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    int isSubSequence(string& s1, string& s2, int i, int j)\\n{\\n    if (i == 0 || j == 0) {\\n        return 0;\\n    }\\n    if (s1[i - 1] == s2[j - 1]) {\\n        return  1 + isSubSequence(s1, s2, i - 1, j - 1);\\n    }\\n    else {\\n        return  isSubSequence(s1, s2, i, j - 1);\\n    }\\n}\\n \\npublic:\\n    bool isSubsequence(string s, string t) {\\n         int m = s.size();\\n    int n = t.size();\\n    if (m > n) {\\n        return false;\\n    }\\n    if (isSubSequence(s, t, m, n) == m) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811180,
                "title": "c-easy-3-approaches-brute-force-recursive-memoization",
                "content": "# 392. Is Subsequence\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Brute force & dynamic Programming Apprach.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)    **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**BruteForce Approach**\\n\\n* Just we need to compare both string by traversing\\n* if t[i] == s[i] , we will increase the count.\\n* if cnt == s.length() this means t is the subsequence of s\\n* As, it contains alll the characters.\\n\\n**CODE**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        \\n    int j = 0; // For index of str1 (or subsequence\\n \\n    // Traverse str2 and str1, and\\n    // compare current character\\n    // of str2 with first unmatched char\\n    // of str1, if matched\\n    // then move ahead in str1\\n    for (int i = 0; i < t.length() && j < s.length(); i++)\\n        if (s[j] == t[i])\\n            j++;\\n \\n    // If all characters of str1 were found in str2\\n    return (j == s.length());\\n    }\\n};\\n```\\n\\n**RECURSIVE IMPLEMENTATION**\\n\\n* The idea is simple, we traverse both strings from one side to another side\\n* (say from rightmost character to leftmost).\\n*  If we find a matching character, we move ahead in both strings.\\n*   Otherwise, we move ahead only in str2. \\n\\n\\n**CODE**\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    \\n    bool isSubs(string& s, string& t, int m, int n)\\n    {\\n        if(m == 0)\\n            return true;\\n        if(n == 0)\\n            return false;\\n        \\n        // If last characters of two\\n        // strings are matching\\n        if (s[m - 1] == t[n - 1])\\n            return isSubs(s, t, m - 1, n - 1);\\n \\n        // If last characters are\\n        // not matching\\n        return isSubs(s, t, m, n - 1);\\n    }\\n    \\n    \\n    bool isSubsequence(string s, string t) {\\n        \\n       if( isSubs(s,t,s.length(),t.length()))\\n           return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**MEMOIZATION TECHNIQUE**\\n* Here the idea is to check whether the size of the longest common subsequence is equal to the size of str1.\\n*  If it\\u2019s equal it means there is a subsequence that exists in str2. \\n\\n**CODE**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    \\n    // returns the length of longest common subsequence\\n    int isSubs(string& s1, string& s2, int i , int j,vector<vector<int>> &t)\\n    {\\n        if(i == 0 || j == 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(s1[i-1] == s2[j-1])\\n            return t[i][j] = 1 + isSubs(s1,s2,i-1,j-1,t);\\n        else\\n            return t[i][j] = isSubs(s1,s2,i,j-1,t);\\n    }\\n    \\n    \\n    bool isSubsequence(string s1, string s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        // intialising dp matrix with -1\\n        \\n        if(m >  n)\\n            return false;\\n        \\n        vector<vector<int>> t(m+1,vector<int> (n+1,-1));\\n    \\n        if(isSubs(s1,s2,m,n,t) == m)\\n            return true;\\n        return false;\\n    }\\n};\\n``\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Brute force & dynamic Programming Apprach.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        \\n    int j = 0; // For index of str1 (or subsequence\\n \\n    // Traverse str2 and str1, and\\n    // compare current character\\n    // of str2 with first unmatched char\\n    // of str1, if matched\\n    // then move ahead in str1\\n    for (int i = 0; i < t.length() && j < s.length(); i++)\\n        if (s[j] == t[i])\\n            j++;\\n \\n    // If all characters of str1 were found in str2\\n    return (j == s.length());\\n    }\\n};\\n```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    \\n    bool isSubs(string& s, string& t, int m, int n)\\n    {\\n        if(m == 0)\\n            return true;\\n        if(n == 0)\\n            return false;\\n        \\n        // If last characters of two\\n        // strings are matching\\n        if (s[m - 1] == t[n - 1])\\n            return isSubs(s, t, m - 1, n - 1);\\n \\n        // If last characters are\\n        // not matching\\n        return isSubs(s, t, m, n - 1);\\n    }\\n    \\n    \\n    bool isSubsequence(string s, string t) {\\n        \\n       if( isSubs(s,t,s.length(),t.length()))\\n           return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87302,
                "title": "binary-search-solution-for-follow-up-with-detailed-comments",
                "content": "Re: [Java binary search using TreeSet got TLE](/topic/57994/java-binary-search-using-treeset-got-tle) \\n\\nI think the Map and TreeSet could be simplified by Array and binarySearch. Since we scan T from beginning to the end (index itself is in increasing order), List will be sufficient. Then we can use binarySearch to replace with TreeSet ability which is a little overkill for this problem. Here is my solution.\\n\\n```java\\n    // Follow-up: O(N) time for pre-processing, O(Mlog?) for each S.\\n    // Eg-1. s=\"abc\", t=\"bahbgdca\"\\n    // idx=[a={1,7}, b={0,3}, c={6}]\\n    //  i=0 ('a'): prev=1\\n    //  i=1 ('b'): prev=3\\n    //  i=2 ('c'): prev=6 (return true)\\n    // Eg-2. s=\"abc\", t=\"bahgdcb\"\\n    // idx=[a={1}, b={0,6}, c={5}]\\n    //  i=0 ('a'): prev=1\\n    //  i=1 ('b'): prev=6\\n    //  i=2 ('c'): prev=? (return false)\\n    public boolean isSubsequence(String s, String t) {\\n        List<Integer>[] idx = new List[256]; // Just for clarity\\n        for (int i = 0; i < t.length(); i++) {\\n            if (idx[t.charAt(i)] == null)\\n                idx[t.charAt(i)] = new ArrayList<>();\\n            idx[t.charAt(i)].add(i);\\n        }\\n        \\n        int prev = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (idx[s.charAt(i)] == null) return false; // Note: char of S does NOT exist in T causing NPE\\n            int j = Collections.binarySearch(idx[s.charAt(i)], prev);\\n            if (j < 0) j = -j - 1;\\n            if (j == idx[s.charAt(i)].size()) return false;\\n            prev = idx[s.charAt(i)].get(j) + 1;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    // Follow-up: O(N) time for pre-processing, O(Mlog?) for each S.\\n    // Eg-1. s=\"abc\", t=\"bahbgdca\"\\n    // idx=[a={1,7}, b={0,3}, c={6}]\\n    //  i=0 ('a'): prev=1\\n    //  i=1 ('b'): prev=3\\n    //  i=2 ('c'): prev=6 (return true)\\n    // Eg-2. s=\"abc\", t=\"bahgdcb\"\\n    // idx=[a={1}, b={0,6}, c={5}]\\n    //  i=0 ('a'): prev=1\\n    //  i=1 ('b'): prev=6\\n    //  i=2 ('c'): prev=? (return false)\\n    public boolean isSubsequence(String s, String t) {\\n        List<Integer>[] idx = new List[256]; // Just for clarity\\n        for (int i = 0; i < t.length(); i++) {\\n            if (idx[t.charAt(i)] == null)\\n                idx[t.charAt(i)] = new ArrayList<>();\\n            idx[t.charAt(i)].add(i);\\n        }\\n        \\n        int prev = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (idx[s.charAt(i)] == null) return false; // Note: char of S does NOT exist in T causing NPE\\n            int j = Collections.binarySearch(idx[s.charAt(i)], prev);\\n            if (j < 0) j = -j - 1;\\n            if (j == idx[s.charAt(i)].size()) return false;\\n            prev = idx[s.charAt(i)].get(j) + 1;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87254,
                "title": "straight-forward-java-simple-solution",
                "content": "Just use two pointers:\\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        int indexS = 0, indexT = 0;\\n        while (indexT < t.length()) {\\n            if (t.charAt(indexT) == s.charAt(indexS)) {\\n                indexS++;\\n                if (indexS == s.length()) return true;\\n            }\\n            indexT++;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        int indexS = 0, indexT = 0;\\n        while (indexT < t.length()) {\\n            if (t.charAt(indexT) == s.charAt(indexS)) {\\n                indexS++;\\n                if (indexS == s.length()) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 87258,
                "title": "2-lines-python",
                "content": "```\\ndef isSubsequence(self, s, t):\\n    t = iter(t)\\n    return all(c in t for c in s)\\n```\\nJust testing whether all characters in s are also in t (in order).\\n\\nTakes O(|s| + |t|) time and O(1) space.\\n\\nBased on falsetru\\'s code on StackOverflow which I improved a while ago, [see here](http://stackoverflow.com/a/24017747).\\n\\nIt works the same as this, in case you prefer that style:\\n```\\ndef isSubsequence(self, s, t):\\n    remainder_of_t = iter(t)\\n    for letter in s:\\n        if letter not in remainder_of_t:\\n            return False\\n    return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSubsequence(self, s, t):\\n    t = iter(t)\\n    return all(c in t for c in s)\\n```\n```\\ndef isSubsequence(self, s, t):\\n    remainder_of_t = iter(t)\\n    for letter in s:\\n        if letter not in remainder_of_t:\\n            return False\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 678389,
                "title": "python-3-solutions-dp-2-pointers-follow-up-bs-explained",
                "content": "### Solution 1: dynamic programming \\nThe first solution I think when I see this problem is dynamic programming. Let `dp[i][j] = 1` if `s[:j]` is substring of `t[:i]`. How can we find it:\\n1. If `s[j] == t[i]`, then we need to search string `s[:j-1]` in `t[:i-1]`\\n2. If `s[j] != t[i]`, then we need to search string `s[:j]` in `t[:i-1]`\\n\\nHere we use also `s = \"!\" + s` trick which allows as to handle border cases with empty strings.\\n\\n**Complexity**: time and space complexity is `O(nm)`, because we need to iterate over all table once.\\n\\n```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        s, t = \"!\" + s, \"!\" + t\\n        m, n = len(s), len(t)\\n        dp = [[0] * m for _ in range(n)] \\n        for i in range(n): dp[i][0] = 1\\n   \\n        for i,j in product(range(1, n), range(1, m)):\\n            if s[j] == t[i]:\\n                dp[i][j] = dp[i-1][j-1]\\n            else:\\n                dp[i][j] = dp[i-1][j]\\n                    \\n        return dp[-1][-1]\\n```\\n\\n### Solution 2: two pointers\\nYou can notice, that actually we update only one element in each row of or `dp` table, so we do a lot of job which is not neccesary. Each moment of time we need to keep only two pointers: one for stirng `s` and one for string `t`. Then if we found new symbol in string `t`, which is equal to symbol in `s`, we move two pointers by one. If we did not found, then we move onle pointer for `t`.\\n\\n**Complexity** is now only `O(n + m) = O(n)`, because we traverse both strings only once. \\n\\n```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        s_i, t_i = 0, 0\\n        \\n        while s_i < len(s) and t_i < len(t):\\n            s_i, t_i = s_i + (s[s_i] == t[t_i]), t_i + 1\\n            \\n        return s_i == len(s)\\n```\\n\\n### Solution 3: binary search for follow-up question.\\n\\nIf we have a lot strings `S1, S2, ... , Sk`, where `k` is big number we want to find faster method. Let us create for each symbol sorted list of indexes for this symbol.\\n\\n**Complexity**, both time and space of preprocessing is `O(n)`, we iterate once over our list. \\n\\n**Complexity** of one search for string `S_i` is `O(m_i)*log(n)`, where `m_i` is length of string and we have `log(n)` factor, because we potentially can have list of indexes with length `n`. So if `m` is the longest length of `S_i`, we have complexity `O(k m log n)`, when two-pointer approach has `O(k n)` complexity. So, if length of original string `n` is big and `m` is small, it is worth to use this method.\\n\\n```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        places = defaultdict(list)\\n        for i, symbol in enumerate(t):\\n            places[symbol].append(i)\\n        \\n        current_place = 0\\n        for symbol in s:\\n            current_ind = bisect.bisect_left(places[symbol], current_place)\\n            if current_ind >= len(places[symbol]):\\n                return False\\n            current_place = places[symbol][current_ind] + 1\\n            \\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        s, t = \"!\" + s, \"!\" + t\\n        m, n = len(s), len(t)\\n        dp = [[0] * m for _ in range(n)] \\n        for i in range(n): dp[i][0] = 1\\n   \\n        for i,j in product(range(1, n), range(1, m)):\\n            if s[j] == t[i]:\\n                dp[i][j] = dp[i-1][j-1]\\n            else:\\n                dp[i][j] = dp[i-1][j]\\n                    \\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        s_i, t_i = 0, 0\\n        \\n        while s_i < len(s) and t_i < len(t):\\n            s_i, t_i = s_i + (s[s_i] == t[t_i]), t_i + 1\\n            \\n        return s_i == len(s)\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s, t):\\n        places = defaultdict(list)\\n        for i, symbol in enumerate(t):\\n            places[symbol].append(i)\\n        \\n        current_place = 0\\n        for symbol in s:\\n            current_ind = bisect.bisect_left(places[symbol], current_place)\\n            if current_ind >= len(places[symbol]):\\n                return False\\n            current_place = places[symbol][current_ind] + 1\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87272,
                "title": "3-lines-c",
                "content": "```\\nbool isSubsequence(char* s, char* t) {\\n    while (*t)\\n        s += *s == *t++;\\n    return !*s;\\n}\\n```\\nJust go through t and \"cross off\" the matching characters in s. Then return whether there's nothing left in s.\\n\\nSometimes, C makes things easier... here it's helpful that C strings are null terminated and that I can easily pop off a string's first character in constant time just by incrementing the pointer.",
                "solutionTags": [],
                "code": "```\\nbool isSubsequence(char* s, char* t) {\\n    while (*t)\\n        s += *s == *t++;\\n    return !*s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678426,
                "title": "c-3-approaches-1-recursion-2-two-pointer-3-dynamic-programming",
                "content": "```\\n**# Recursive Approach**\\n\\nThe idea is simple, we traverse both strings from one side to other side (say from rightmost character to leftmost). If we find a matching character, we move ahead in both strings. Otherwise we move ahead only in str2.\\n\\nCode:\\nclass Solution {\\npublic:\\n    bool isSubSeq(string str1, string str2, int m, int n) \\n{ \\n    // Base Cases \\n    if (m == 0) return true; \\n    if (n == 0) return false; \\n    // If last characters of two strings are matching \\n    if (str1[m-1] == str2[n-1]) \\n        return isSubSeq(str1, str2, m-1, n-1); \\n    // If last characters are not matching \\n    return isSubSeq(str1, str2, m, n-1); \\n} \\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        return isSubSeq(s,t,m,n);\\n    }\\n};\\n\\n\\n// Approach Using TWO POINTER\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == m ? 1 : 0;\\n    }\\n};\\n\\n\\n//  USING DYNAMIC PROGRAMMING \\n// if LCS of string A  nd B is equal to Size of String A then its True else false;\\n\\nclass Solution {\\npublic:\\n    int helper(string x, string y) {\\n        int m = x.size();\\n        int n = y.size();\\n        int dp[m+1][n+1];\\n        for(int i = 0; i<=m; i++)\\n        {\\n            dp[i][0]=0;\\n        }\\n        for(int i = 0; i<=n; i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i = 1; i<=m; i++){\\n            for(int j = 1; j<=n; j++){\\n                if(x[i-1]==y[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    bool isSubsequence(string smaller, string larger) {\\n\\n        int x  = helper(smaller,larger);\\n        if(x == smaller.size()){\\n            return true;\\n        }\\n        return false;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n**# Recursive Approach**\\n\\nThe idea is simple, we traverse both strings from one side to other side (say from rightmost character to leftmost). If we find a matching character, we move ahead in both strings. Otherwise we move ahead only in str2.\\n\\nCode:\\nclass Solution {\\npublic:\\n    bool isSubSeq(string str1, string str2, int m, int n) \\n{ \\n    // Base Cases \\n    if (m == 0) return true; \\n    if (n == 0) return false; \\n    // If last characters of two strings are matching \\n    if (str1[m-1] == str2[n-1]) \\n        return isSubSeq(str1, str2, m-1, n-1); \\n    // If last characters are not matching \\n    return isSubSeq(str1, str2, m, n-1); \\n} \\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        return isSubSeq(s,t,m,n);\\n    }\\n};\\n\\n\\n// Approach Using TWO POINTER\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == m ? 1 : 0;\\n    }\\n};\\n\\n\\n//  USING DYNAMIC PROGRAMMING \\n// if LCS of string A  nd B is equal to Size of String A then its True else false;\\n\\nclass Solution {\\npublic:\\n    int helper(string x, string y) {\\n        int m = x.size();\\n        int n = y.size();\\n        int dp[m+1][n+1];\\n        for(int i = 0; i<=m; i++)\\n        {\\n            dp[i][0]=0;\\n        }\\n        for(int i = 0; i<=n; i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i = 1; i<=m; i++){\\n            for(int j = 1; j<=n; j++){\\n                if(x[i-1]==y[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    bool isSubsequence(string smaller, string larger) {\\n\\n        int x  = helper(smaller,larger);\\n        if(x == smaller.size()){\\n            return true;\\n        }\\n        return false;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173050,
                "title": "simple-java-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        // 1 ms code beat 53% \\n        // int si=0;\\n        // if(s.length()<1)\\n        //     return true;\\n        // for(int i=0;i<t.length();i++){\\n        //     if(s.charAt(si)==t.charAt(i))\\n        //         si++;\\n\\n        //     if(si==s.length())\\n        //         return true;\\n        // }\\n\\n\\n    // 1 ms beat 100\\n    int i=0,j=0;\\n    int n=t.length();\\n    int m=s.length();\\n    char ss[]=s.toCharArray();\\n    char tt[]=t.toCharArray();\\n\\n    if(m<1)\\n        return true;\\n\\n    while(i<n){\\n        if(tt[i]==ss[j]){\\n            j++;\\n        }\\n        i++;\\n        \\n    if(j==m)\\n        return true;\\n    }\\n\\n        return false;\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/0943f3d6-8a2a-4109-9537-dd2d92d31529_1676139657.6176376.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        // 1 ms code beat 53% \\n        // int si=0;\\n        // if(s.length()<1)\\n        //     return true;\\n        // for(int i=0;i<t.length();i++){\\n        //     if(s.charAt(si)==t.charAt(i))\\n        //         si++;\\n\\n        //     if(si==s.length())\\n        //         return true;\\n        // }\\n\\n\\n    // 1 ms beat 100\\n    int i=0,j=0;\\n    int n=t.length();\\n    int m=s.length();\\n    char ss[]=s.toCharArray();\\n    char tt[]=t.toCharArray();\\n\\n    if(m<1)\\n        return true;\\n\\n    while(i<n){\\n        if(tt[i]==ss[j]){\\n            j++;\\n        }\\n        i++;\\n        \\n    if(j==m)\\n        return true;\\n    }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87268,
                "title": "java-code-for-the-follow-up-question",
                "content": "    /**\\n     * Follow-up\\n     * If we check each sk in this way, then it would be O(kn) time where k is the number of s and t is the length of t. \\n     * This is inefficient. \\n     * Since there is a lot of s, it would be reasonable to preprocess t to generate something that is easy to search for if a character of s is in t. \\n     * Sounds like a HashMap, which is super suitable for search for existing stuff. \\n     */\\n    public boolean isSubsequence(String s, String t) {\\n        if (s == null || t == null) return false;\\n        \\n        Map<Character, List<Integer>> map = new HashMap<>(); //<character, index>\\n        \\n        //preprocess t\\n        for (int i = 0; i < t.length(); i++) {\\n            char curr = t.charAt(i);\\n            if (!map.containsKey(curr)) {\\n                map.put(curr, new ArrayList<Integer>());\\n            }\\n            map.get(curr).add(i);\\n        }\\n        \\n        int prev = -1;  //index of previous character\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (map.get(c) == null)  {\\n                return false;\\n            } else {\\n                List<Integer> list = map.get(c);\\n                prev = binarySearch(prev, list, 0, list.size() - 1);\\n                if (prev == -1) {\\n                    return false;\\n                }\\n                prev++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int binarySearch(int index, List<Integer> list, int start, int end) {\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (list.get(mid) < index) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return start == list.size() ? -1 : list.get(start);\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Follow-up\\n     * If we check each sk in this way, then it would be O(kn) time where k is the number of s and t is the length of t. \\n     * This is inefficient. \\n     * Since there is a lot of s, it would be reasonable to preprocess t to generate something that is easy to search for if a character of s is in t. \\n     * Sounds like a HashMap, which is super suitable for search for existing stuff. \\n     */\\n    public boolean isSubsequence(String s, String t) {\\n        if (s == null || t == null) return false;\\n        \\n        Map<Character, List<Integer>> map = new HashMap<>(); //<character, index>\\n        \\n        //preprocess t\\n        for (int i = 0; i < t.length(); i++) {\\n            char curr = t.charAt(i);\\n            if (!map.containsKey(curr)) {\\n                map.put(curr, new ArrayList<Integer>());\\n            }\\n            map.get(curr).add(i);\\n        }\\n        \\n        int prev = -1;  //index of previous character\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (map.get(c) == null)  {\\n                return false;\\n            } else {\\n                List<Integer> list = map.get(c);\\n                prev = binarySearch(prev, list, 0, list.size() - 1);\\n                if (prev == -1) {\\n                    return false;\\n                }\\n                prev++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int binarySearch(int index, List<Integer> list, int start, int end) {\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (list.get(mid) < index) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return start == list.size() ? -1 : list.get(start);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 87264,
                "title": "easy-to-understand-binary-search-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    \\n    def createMap(self, s):\\n        # create a map. key is char. value is index of apperance in acending order. \\n        posMap = defaultdict(list)\\n        for i, char in enumerate(s):\\n            posMap[char].append(i)\\n        return posMap\\n        \\n    \\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        posMap = self.createMap(t)\\n        # lowBound is the minimum index the current char has to be at.\\n        lowBound = 0\\n        for char in s:\\n            if char not in posMap: return False\\n            charIndexList = posMap[char]\\n            # try to find an index that is larger than or equal to lowBound\\n            i = bisect_left(charIndexList, lowBound)\\n            if i == len(charIndexList): return False\\n            lowBound = charIndexList[i] + 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    \\n    def createMap(self, s):\\n        # create a map. key is char. value is index of apperance in acending order. \\n        posMap = defaultdict(list)\\n        for i, char in enumerate(s):\\n            posMap[char].append(i)\\n        return posMap\\n        \\n    \\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        posMap = self.createMap(t)\\n        # lowBound is the minimum index the current char has to be at.\\n        lowBound = 0\\n        for char in s:\\n            if char not in posMap: return False\\n            charIndexList = posMap[char]\\n            # try to find an index that is larger than or equal to lowBound\\n            i = bisect_left(charIndexList, lowBound)\\n            if i == len(charIndexList): return False\\n            lowBound = charIndexList[i] + 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87421,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) == 0:\\n            return True\\n        if len(t) == 0:\\n            return False \\n        i, j = 0, 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return True if i == len(s) else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) == 0:\\n            return True\\n        if len(t) == 0:\\n            return False \\n        i, j = 0, 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return True if i == len(s) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289922,
                "title": "python-implement-follow-up-questions-clean-concise",
                "content": "**\\u2714\\uFE0F Main problem: Straight-forward Solution**\\n```python\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        for c in t:\\n            if i == len(s): return True  # If match full s -> then s is a subsequence\\n            if s[i] == c:\\n                i += 1\\n        return i == len(s)\\n```\\n\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 100` is length of `s` string, `N <= 10^4` is length of `t` string.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 10^9`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?\\n- Since we use `t` multiple times, we can pre-compute `t` string to jump to the next index faster.\\n- The following code, I modify to assume we process `k` string `s1, s2,..., sk`, where `|s| <= 100`, `|t| <= 10^4`.\\n```python\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapIndices = defaultdict(list)\\n        for i, c in enumerate(t):\\n            mapIndices[c].append(i)\\n            \\n        def findNextIndex(arr, startIdx):  # Find next index which start from `startIdx`\\n            # For example: [1, 3, 4, 5], startIdx = 3 -> Expect: idx = 1\\n            # For example: [1, 3, 4, 5], startIdx = 2 -> Expect: idx = 1\\n            # For example: [1, 3, 4, 5], startIdx = 0 -> Expect: idx = 0\\n            # For example: [1, 3, 4, 5], startIdx = 6 -> Expect: idx = 4\\n            idx = bisect_left(arr, startIdx)\\n            if idx == len(arr): return -1\\n            return arr[idx] + 1\\n            \\n        def isSubsequence(s, t):\\n            nextIdx = 0\\n            for i, c in enumerate(s):\\n                if nextIdx == len(t):\\n                    return False\\n                nextIdx = findNextIndex(mapIndices[c], nextIdx)\\n                if nextIdx == -1: return False\\n            return True\\n                    \\n        k = 10000  # Assume we process k string s1, s2,..., sk, where |s| <= 100\\n        ans = False\\n        for _ in range(k):\\n            ans = isSubsequence(s, t)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(K * M * logN + N)`, where `K` is the number of `s` strings, `M <= 100` is length of each `s` string, `N <= 10^4` is length of `t` string.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        for c in t:\\n            if i == len(s): return True  # If match full s -> then s is a subsequence\\n            if s[i] == c:\\n                i += 1\\n        return i == len(s)\\n```\n```python\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapIndices = defaultdict(list)\\n        for i, c in enumerate(t):\\n            mapIndices[c].append(i)\\n            \\n        def findNextIndex(arr, startIdx):  # Find next index which start from `startIdx`\\n            # For example: [1, 3, 4, 5], startIdx = 3 -> Expect: idx = 1\\n            # For example: [1, 3, 4, 5], startIdx = 2 -> Expect: idx = 1\\n            # For example: [1, 3, 4, 5], startIdx = 0 -> Expect: idx = 0\\n            # For example: [1, 3, 4, 5], startIdx = 6 -> Expect: idx = 4\\n            idx = bisect_left(arr, startIdx)\\n            if idx == len(arr): return -1\\n            return arr[idx] + 1\\n            \\n        def isSubsequence(s, t):\\n            nextIdx = 0\\n            for i, c in enumerate(s):\\n                if nextIdx == len(t):\\n                    return False\\n                nextIdx = findNextIndex(mapIndices[c], nextIdx)\\n                if nextIdx == -1: return False\\n            return True\\n                    \\n        k = 10000  # Assume we process k string s1, s2,..., sk, where |s| <= 100\\n        ans = False\\n        for _ in range(k):\\n            ans = isSubsequence(s, t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811546,
                "title": "simple-code-3-lines",
                "content": "\\n        int i = 0;\\n        for(int j = 0;j<t.length() && i<s.length();j++)\\n         if(t.charAt(j) == s.charAt(i)) i++;\\n        return i == s.length();  \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n        int i = 0;\\n        for(int j = 0;j<t.length() && i<s.length();j++)\\n         if(t.charAt(j) == s.charAt(i)) i++;\\n        return i == s.length();  \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2701674,
                "title": "5-liner-solution-in-java-python-c-beats-100-easy-to-understand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q392. Is Subsequence***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)) i++;\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n     int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s[i] == t[j]) i++;\\n            j++;\\n        }\\n        return i == s.length();   \\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)) i++;\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n     int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s[i] == t[j]) i++;\\n            j++;\\n        }\\n        return i == s.length();   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699823,
                "title": "python-simple-solution-using-2-pointers",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        ## RC ##\\n        ## APPROACH : 2 POINTERS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        p1 = p2 = 0\\n        while p1 < len(s) and p2 < len(t):\\n            # move both pointers or just the right pointer\\n            if s[p1] == t[p2]:\\n                p1 += 1\\n            p2 += 1\\n        return p1 == len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        ## RC ##\\n        ## APPROACH : 2 POINTERS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        p1 = p2 = 0\\n        while p1 < len(s) and p2 < len(t):\\n            # move both pointers or just the right pointer\\n            if s[p1] == t[p2]:\\n                p1 += 1\\n            p2 += 1\\n        return p1 == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87402,
                "title": "c-4-lines-simple-solution",
                "content": "Iterate t, advance index of s when we found a matched char in t.\\nStop the loop whenever it reaches the end of t or we found all characters  in s.\\nAfter the loop, return true if index of s is equal to its length. Otherwise, return false.\\n    \\n    bool isSubsequence(string s, string t) {\\n        int sLen = s.length(), sIdx = 0, tLen = t.length();\\n        for (int i=0; i<tLen && sIdx<sLen; i++) \\n            if (t[i]==s[sIdx]) sIdx++;\\n        return sIdx==sLen;\\n    }",
                "solutionTags": [],
                "code": "Iterate t, advance index of s when we found a matched char in t.\\nStop the loop whenever it reaches the end of t or we found all characters  in s.\\nAfter the loop, return true if index of s is equal to its length. Otherwise, return false.\\n    \\n    bool isSubsequence(string s, string t) {\\n        int sLen = s.length(), sIdx = 0, tLen = t.length();\\n        for (int i=0; i<tLen && sIdx<sLen; i++) \\n            if (t[i]==s[sIdx]) sIdx++;\\n        return sIdx==sLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4074367,
                "title": "93-76-two-pointers-dp",
                "content": "# Explanation of the \"Is Subsequence\" Problem and Solutions\\n\\n## Introduction & Problem Statement\\n\\nGiven two strings, `s` and `t`, the challenge is to determine if `s` is a subsequence of `t`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\\n\\n## Key Concepts:\\n\\n### What Makes This Problem Unique?\\n\\n1. **String Constraints**:  \\n    - The length of `s` can range from 0 to 100.\\n    - The length of `t` can vary between 0 and 10,000.\\n    - Both `s` and `t` consist only of lowercase English letters.\\n\\n2. **Solution Techniques**:  \\n    This problem can be approached using various techniques, including iterative (two-pointers) methods and dynamic programming.\\n\\n---\\n\\n# Strategy to Solve the Problem:\\n\\n## Live Coding Two Pointers\\nhttps://youtu.be/gg7hnmSmhkw?si=Bqtwz-8skqwiP8YJ\\n\\n### Two Pointers Approach:\\n\\nThe two-pointers technique is an iterative approach that uses two indices, one for each string. The idea is to traverse the longer string `t` and whenever a character matches the current character of string `s`, the index for `s` is moved to the right.\\n\\n#### Key Data Structures:\\n\\n- `i` and `j`: Two pointers initialized to 0. `i` is used for string `s` and `j` for string `t`.\\n\\n#### Enhanced Breakdown:\\n\\n1. **Traverse and Match**:\\n   - Traverse string `t` using pointer `j`.\\n   - If the current character of `t` matches the current character of `s`, increment `i`.\\n   - Continue until the end of string `t` or until all characters of `s` are found in `t`.\\n\\n2. **Check Subsequence**:\\n   - At the end of traversal, if `i` is equal to the length of `s`, then `s` is a subsequence of `t`.\\n\\n#### Complexity Analysis:\\n\\n**Time Complexity**: \\n- The algorithm traverses the string `t` once, resulting in a time complexity of $$ O(\\\\text{len}(t)) $$.\\n\\n**Space Complexity**: \\n- Constant space is used, leading to a space complexity of $$ O(1) $$.\\n\\n# Code Two Pointers\\n``` Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j = 0, 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return i == len(s)\\n```\\n``` Go []\\nfunc isSubsequence(s string, t string) bool {\\n    i, j := 0, 0\\n    for i < len(s) && j < len(t) {\\n        if s[i] == t[j] {\\n            i++\\n        }\\n        j++\\n    }\\n    return i == len(s)\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let mut i = 0;\\n        let mut j = 0;\\n        let s_chars: Vec<char> = s.chars().collect();\\n        let t_chars: Vec<char> = t.chars().collect();\\n        \\n        while i < s.len() && j < t.len() {\\n            if s_chars[i] == t_chars[j] {\\n                i += 1;\\n            }\\n            j += 1;\\n        }\\n        i == s.len()\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(std::string s, std::string t) {\\n        int i = 0, j = 0;\\n        while (i < s.size() && j < t.size()) {\\n            if (s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.size();\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n        let i = 0, j = 0;\\n        while (i < s.length && j < t.length) {\\n            if (s[i] === t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i === s.length;\\n    }\\n```\\n``` PHP []\\nclass Solution {\\n    public function isSubsequence($s, $t) {\\n        $i = 0;\\n        $j = 0;\\n        while ($i < strlen($s) && $j < strlen($t)) {\\n            if ($s[$i] == $t[$j]) {\\n                $i++;\\n            }\\n            $j++;\\n        }\\n        return $i == strlen($s);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while (i < s.Length && j < t.Length) {\\n            if (s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.Length;\\n    }\\n}\\n```\\n\\n---\\n\\n### Dynamic Programming Approach:\\n\\nFor the dynamic programming solution, the idea is to preprocess string `t` to understand the next occurrence of every character after each position. This approach is particularly useful when there are numerous subsequences to be checked against `t`, as it can check each subsequence in linear time.\\n\\n#### Key Data Structures:\\n\\n- `nxt`: A list of dictionaries to store the next occurrence of every character after each position in `t`.\\n\\n#### Enhanced Breakdown:\\n\\n1. **Preprocess string `t`**:\\n   - Create a list of dictionaries `nxt` to store the next occurrence of every character after each position in `t`.\\n   - Traverse string `t` in reverse. For each position, copy the next position\\'s dictionary and update the current character\\'s next occurrence.\\n\\n2. **Check Subsequence**:\\n   - Traverse string `s` and for each character, check its next occurrence in `t` using the `nxt` list.\\n   - If any character of `s` doesn\\'t have a next occurrence in `t`, return False. Otherwise, continue.\\n\\n#### Complexity Analysis:\\n\\n**Time Complexity** (for checking one subsequence `s`): \\n- The algorithm traverses the string `s` once, resulting in a time complexity of $$ O(\\\\text{len}(s)) $$.\\n\\n**Space Complexity**: \\n- The algorithm creates a list of dictionaries `nxt` of size $$ \\\\text{len}(t) $$, leading to a space complexity of $$ O(\\\\text{len}(t)) $$.\\n\\n\\n# Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        nxt = [{} for _ in range(len(t) + 1)]\\n        for i in range(len(t) - 1, -1, -1):\\n            nxt[i] = nxt[i + 1].copy()\\n            nxt[i][t[i]] = i + 1\\n        \\n        i = 0\\n        for c in s:\\n            if c in nxt[i]:\\n                i = nxt[i][c]\\n            else:\\n                return False\\n        return True\\n```\\n\\n## Performance\\n\\n| Language   | Execution Time (ms) | Memory Usage | Technique |\\n|------------|---------------------|--------------|-----------|\\n| Rust       | 0                   | 2.1 MB       | Two Pointers |\\n| Go         | 1                   | 2 MB         | Two Pointers |\\n| Java       | 1                   | 40.5 MB      | Two Pointers |\\n| C++        | 3                   | 6.7 MB       | Two Pointers |\\n| PHP        | 6                   | 19 MB        | Two Pointers |\\n| JavaScript | 37                  | 41.1 MB      | Two Pointers |\\n| Python3    | 34                  | 16.2 MB      | Two Pointers |\\n| Python3 (DP) | 43               | 19.7 MB      | DP |\\n| C#         | 64                  | 37.9 MB      | Two Pointers |\\n\\n![s2.png](https://assets.leetcode.com/users/images/8ef25e95-27a5-43b8-8e58-b019f22bdb7f_1695344157.8251.png)\\n\\n\\n## Conclusion\\n\\nBoth strategies provided here tackle the problem effectively. The two-pointers approach is straightforward and intuitive, making it easy to implement and understand. The dynamic programming approach, on the other hand, is more sophisticated but offers the advantage of efficiently checking multiple subsequences against a single string `t`. Depending on the scenario, one can choose the appropriate strategy to solve the problem.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j = 0, 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return i == len(s)\\n```\n``` Go []\\nfunc isSubsequence(s string, t string) bool {\\n    i, j := 0, 0\\n    for i < len(s) && j < len(t) {\\n        if s[i] == t[j] {\\n            i++\\n        }\\n        j++\\n    }\\n    return i == len(s)\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let mut i = 0;\\n        let mut j = 0;\\n        let s_chars: Vec<char> = s.chars().collect();\\n        let t_chars: Vec<char> = t.chars().collect();\\n        \\n        while i < s.len() && j < t.len() {\\n            if s_chars[i] == t_chars[j] {\\n                i += 1;\\n            }\\n            j += 1;\\n        }\\n        i == s.len()\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(std::string s, std::string t) {\\n        int i = 0, j = 0;\\n        while (i < s.size() && j < t.size()) {\\n            if (s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.size();\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n        let i = 0, j = 0;\\n        while (i < s.length && j < t.length) {\\n            if (s[i] === t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i === s.length;\\n    }\\n```\n``` PHP []\\nclass Solution {\\n    public function isSubsequence($s, $t) {\\n        $i = 0;\\n        $j = 0;\\n        while ($i < strlen($s) && $j < strlen($t)) {\\n            if ($s[$i] == $t[$j]) {\\n                $i++;\\n            }\\n            $j++;\\n        }\\n        return $i == strlen($s);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while (i < s.Length && j < t.Length) {\\n            if (s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.Length;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        nxt = [{} for _ in range(len(t) + 1)]\\n        for i in range(len(t) - 1, -1, -1):\\n            nxt[i] = nxt[i + 1].copy()\\n            nxt[i][t[i]] = i + 1\\n        \\n        i = 0\\n        for c in s:\\n            if c in nxt[i]:\\n                i = nxt[i][c]\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87408,
                "title": "binary-search-solution-to-cope-with-input-with-many-ss-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        //build a record the index of each char in t\\n        vector<vector<int>> record(26);\\n        //add indexs\\n        for(int i = 0; i < t.size(); i++) {\\n            record[t[i]-'a'].push_back(i);\\n        }\\n        //check if each char in s is in the legal place\\n        int index = -1;\\n        for(int i = 0; i < s.size(); i++) {\\n            auto iter = upper_bound(record[s[i]-'a'].begin(), record[s[i]-'a'].end(), index);\\n            if(iter == record[s[i]-'a'].end()) return false;\\n            index = *iter;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        //build a record the index of each char in t\\n        vector<vector<int>> record(26);\\n        //add indexs\\n        for(int i = 0; i < t.size(); i++) {\\n            record[t[i]-'a'].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 389580,
                "title": "simple-and-intuitive-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410577,
                "title": "javascript-2-pointer-solution",
                "content": "```\\nvar isSubsequence = function(s, t) {\\n    let i = 0, j = 0;\\n    while( j < t.length) {\\n        if(s[i] === t[j]) {\\n            i++;\\n        }\\n        j++;        \\n    }\\n    return i === s.length ? true: false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSubsequence = function(s, t) {\\n    let i = 0, j = 0;\\n    while( j < t.length) {\\n        if(s[i] === t[j]) {\\n            i++;\\n        }\\n        j++;        \\n    }\\n    return i === s.length ? true: false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4074388,
                "title": "video-how-i-think-about-a-solution-o-t-time-o-1-space-python-javascript-java-c",
                "content": "This artcle starts with \"How I think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\nCheck both strings one by one.\\n\\n---\\n\\n# Solution Video\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/ILymZPILqDs\\n\\n\\u25A0 Timeline\\n`0:00` Read the question of Is Subsequence\\n`1:26` Explain a basic idea to solve Is Subsequence\\n`4:04` Coding\\n`5:28` Time Complexity & Space Complexity \\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,437\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n**How I think about a solution:**\\n\\nSimply, all we have to do is just to count characters for each string `s` and `t` and check if `t` has all characters of `s`, but problem is there is an order to find the characters.\\n\\n```\\nInput: s = \"abc\", t = \"ahbgdc\"\\n```\\nIn this case, we need to find `a` in `t` at first. The next character we must find is `b` at the position after `a`, the last character is `c` at the position after `b`. That is kind of a challenging part of this question. It might be tough to use simple `HashMap` or `Set` because they don\\'t have order of data.\\n\\nThat\\'s why I just started thinking it with a very simple example like this.\\n```\\nInput: s = \"abc\", t = \"abc\"\\n```\\nIn this case, if we check each character one by one in the both strings from beginning, we can return `true` and this simple example gave me a hint to solve this question.\\n\\nI realized that if I have the same index number as length of `s` after I iterate though all characters, I can prove that I have subsequence in `t`. \\n\\nTo prove that, I also check a simple `false` case like this.\\n```\\nInput: s = \"abc\", t = \"abd\"\\n```\\nIn this case, when I iterate thorugh both strings from beginning, I stopped at index `2` in `s` which means I didn\\'t find the last character `c` in `t`, so this is a `false` case because `index number for s(2)` is not equal to `length of s(3)`. I couldn\\'t get to `the last position of s`. \\n\\n`The last position` means `the last index number + 1` because index usually starts from `0` and counting length of string starts from `1`.\\n\\nFrom my thought process above, I tried to iterate thorough both strings from beginning at the same time. \\n\\nLet\\'s recap what I said with this example.\\n```\\nInput: s = \"abc\", t = \"ahbgdc\"\\n```\\n\\n```\\ntarget: a\\ns index: 0\\nt index: 0\\n```\\nThe first target is `a`. Luckily, the first character of `t` is also `a`. \\n\\n```\\nfound: a\\nNow I can think inputs like this Input: s = \"bc\", t = \"hbgdc\"\\n\\nafter the above,\\n\\ns index: 1\\nt index: 1\\n```\\n\\nThen, the next target is `b` but the next character of `t` is `h`, so now \\n```\\ntarget: b\\n\\nfound: a\\nNow I can think inputs like this Input: s = \"bc\", t = \"bgdc\"\\n\\nafter the above,\\n\\ns index: 1\\nt index: 2\\n\\n```\\n\\nThe next character of `t` is `b`, I found `b` in `t`.\\n```\\ntarget: b\\n\\nfound: ab\\nNow I can think inputs like this Input: s = \"c\", t = \"gdc\"\\n\\nafter the above,\\n\\ns index: 2\\nt index: 3\\n```\\n\\nThe next and next next character in `t` are `g` and `d`, so just increment `t index` from `3` to `5`.\\n\\nFinally, I reached the last character in `t` and found `c`\\n\\n```\\ntarget: c\\n\\nfound abc\\nNow I can think inputs like this Input: s = \"\", t = \"\"\\n\\nafter the above,\\n\\ns index: 3\\nt index: 6\\n```\\n\\nAfter the process, all I have to do is just to check if `s index(3)` is equal to `length of s(3)`.\\n\\n```\\nOutput: true\\n```\\n\\nThat\\'s how I think about my solution. Let\\'s see a real algorithm below.\\n\\n\\n**Algorithm Overview:**\\n\\n1. Initialize two pointers, `s_idx` and `t_idx`, to 0 to represent the starting positions of the strings `s` and `t` respectively.\\n2. Iterate through the characters of both strings `s` and `t`, comparing characters at the corresponding positions.\\n3. If a matching character is found, move the pointer in `s` forward.\\n4. Always move the pointer in `t` forward.\\n5. Check if all characters in `s` have been matched in `t`.\\n6. Return `True` if `s` is a subsequence of `t`, `False` otherwise.\\n\\n**Detailed Explanation:**\\n\\n1. Set `s_idx` and `t_idx` to 0, indicating the starting positions of `s` and `t` respectively.\\n\\n2. Iterate through the characters of `s` and `t` using a while loop until either all characters in `s` have been matched or we reach the end of `t`.\\n\\n   a. Check if the characters at `s_idx` in `s` and `t_idx` in `t` are equal.\\n\\n   b. If they are equal, increment `s_idx` to move to the next character in `s`.\\n\\n   c. Always increment `t_idx` to move forward in `t`.\\n\\n3. After the loop, check if all characters in `s` have been matched. If `s_idx` is equal to the length of `s`, then `s` is a subsequence of `t`.\\n\\n   a. Return `True` if `s` is a subsequence of `t`.\\n\\n   b. Return `False` if `s` is not a subsequence of `t`.\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(t)\\n`t` is length of input string `t`.\\n\\n- Space complexity: O(1)\\n\\n\\n```python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_idx = t_idx = 0\\n\\n        while s_idx < len(s) and t_idx < len(t):\\n            if s[s_idx] == t[t_idx]:\\n                s_idx += 1\\n            t_idx += 1\\n        \\n        return s_idx == len(s)\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n    let sIdx = 0;\\n    let tIdx = 0;\\n\\n    while (sIdx < s.length && tIdx < t.length) {\\n        if (s[sIdx] === t[tIdx]) {\\n            sIdx++;\\n        }\\n        tIdx++;\\n    }\\n\\n    return sIdx === s.length;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIdx = 0;\\n        int tIdx = 0;\\n\\n        while (sIdx < s.length() && tIdx < t.length()) {\\n            if (s.charAt(sIdx) == t.charAt(tIdx)) {\\n                sIdx++;\\n            }\\n            tIdx++;\\n        }\\n\\n        return sIdx == s.length();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int sIdx = 0;\\n        int tIdx = 0;\\n\\n        while (sIdx < s.length() && tIdx < t.length()) {\\n            if (s[sIdx] == t[tIdx]) {\\n                sIdx++;\\n            }\\n            tIdx++;\\n        }\\n\\n        return sIdx == s.length();        \\n    }\\n};\\n```\\n\\n---\\n\\nThank you for reading such a long article.\\n\\n\\u2B50\\uFE0F Please upvote it if you learned something and don\\'t forget to subsctibe to my channel!\\n\\nMy next post for daily coding challenge on Sep 23, 2023\\nhttps://leetcode.com/problems/longest-string-chain/solutions/4080044/how-we-think-about-a-solution-beats-9749-python-javascript-java-c/\\n\\nHave a nice day!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: s = \"abc\", t = \"ahbgdc\"\\n```\n```\\nInput: s = \"abc\", t = \"abc\"\\n```\n```\\nInput: s = \"abc\", t = \"abd\"\\n```\n```\\nInput: s = \"abc\", t = \"ahbgdc\"\\n```\n```\\ntarget: a\\ns index: 0\\nt index: 0\\n```\n```\\nfound: a\\nNow I can think inputs like this Input: s = \"bc\", t = \"hbgdc\"\\n\\nafter the above,\\n\\ns index: 1\\nt index: 1\\n```\n```\\ntarget: b\\n\\nfound: a\\nNow I can think inputs like this Input: s = \"bc\", t = \"bgdc\"\\n\\nafter the above,\\n\\ns index: 1\\nt index: 2\\n\\n```\n```\\ntarget: b\\n\\nfound: ab\\nNow I can think inputs like this Input: s = \"c\", t = \"gdc\"\\n\\nafter the above,\\n\\ns index: 2\\nt index: 3\\n```\n```\\ntarget: c\\n\\nfound abc\\nNow I can think inputs like this Input: s = \"\", t = \"\"\\n\\nafter the above,\\n\\ns index: 3\\nt index: 6\\n```\n```\\nOutput: true\\n```\n```python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_idx = t_idx = 0\\n\\n        while s_idx < len(s) and t_idx < len(t):\\n            if s[s_idx] == t[t_idx]:\\n                s_idx += 1\\n            t_idx += 1\\n        \\n        return s_idx == len(s)\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n    let sIdx = 0;\\n    let tIdx = 0;\\n\\n    while (sIdx < s.length && tIdx < t.length) {\\n        if (s[sIdx] === t[tIdx]) {\\n            sIdx++;\\n        }\\n        tIdx++;\\n    }\\n\\n    return sIdx === s.length;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIdx = 0;\\n        int tIdx = 0;\\n\\n        while (sIdx < s.length() && tIdx < t.length()) {\\n            if (s.charAt(sIdx) == t.charAt(tIdx)) {\\n                sIdx++;\\n            }\\n            tIdx++;\\n        }\\n\\n        return sIdx == s.length();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int sIdx = 0;\\n        int tIdx = 0;\\n\\n        while (sIdx < s.length() && tIdx < t.length()) {\\n            if (s[sIdx] == t[tIdx]) {\\n                sIdx++;\\n            }\\n            tIdx++;\\n        }\\n\\n        return sIdx == s.length();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075403,
                "title": "simple-c-java-python-solution",
                "content": "# Approach\\nUse two pointer to iterate over both the strings when there is a match increment both the pointer else in other case just increment pointer for \\'t\\' string. \\n\\n# Complexity\\n- Time complexity:\\n**O(n+m)** where n - length of s String, m - length of t String\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()) {\\n            if(s.charAt(i) == t.charAt(j)) {\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return (i == s.length())?true:false;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n            j+=1\\n        return True if i == len(s) else False\\n        \\n```\\n```C++ []\\nClass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() and j < t.size()) {\\n            if(s[i] == t[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return (i == s.size())?true:false;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length()) {\\n            if(s.charAt(i) == t.charAt(j)) {\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return (i == s.length())?true:false;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n            j+=1\\n        return True if i == len(s) else False\\n        \\n```\n```C++ []\\nClass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() and j < t.size()) {\\n            if(s[i] == t[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return (i == s.size())?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473010,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3-two-pointers-approach",
                "content": "# **Two-Pointers Approach:**\\n----------------------------------------------------------------------------\\n# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Is Subsequence.\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        // Base case: if the s string is empty...\\n        if(s.length() == 0)\\n            return true;\\n        // Initialize pointers for both strings\\n        int i = 0;\\n        int j = 0;\\n        // We can iterate until either of them becomes zero...\\n        while(i < s.length() && j < t.length()){\\n            // Compare characters, increment i pointer...\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n            }j++;\\n            // If the pointer is equal to the size of s, the match is found...\\n            if(i == s.length()) return true;\\n        }\\n        return false;       // Otherwise return false...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        // Initialize two pointers i and j storing the last indices of both the strings...\\n        int i = s.size() , j = t.size();\\n        i-- , j--;\\n        // Iterate until either of them becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            // Compare characters...\\n            if(s[i] == t[j])\\n                i-- , j--;\\n            else\\n                j--;\\n        }\\n        // If i (pointer of the first string) is greater than or equal to 0...\\n        // we have not been able to traverse the first string completely...\\n        // Hence, it is not a subsequence of the second...\\n        if(i >= 0)\\n            return false;\\n        return true;        // Otherwise, return true...\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        # Base case\\n        if not s:\\n            return True\\n        i = 0\\n        # Traverse elements of t string\\n        for j in t:\\n            # If this index matches to the index of s string, increment i pointer...\\n            if j == s[i]:\\n                i += 1\\n            # If the pointer is equal to the size of s...\\n            if i == len(s):\\n                break\\n        return i == len(s)\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar isSubsequence = function(s, t) {\\n    // Base case: if the s string is empty...\\n    if(s.length == 0)\\n        return true;\\n    // Initialize pointers for both strings\\n    let i = 0;\\n    let j = 0;\\n    // We can iterate until either of them becomes zero...\\n    while(i < s.length && j < t.length){\\n        // Compare characters, increment i pointer...\\n        if(s.charAt(i) == t.charAt(j)){\\n            i++;\\n        }j++;\\n        // If the pointer is equal to the size of s, the match is found...\\n        if(i == s.length)  return true;\\n    }\\n    return false;       // Otherwise return false...\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool isSubsequence(char * s, char * t){\\n    // Initialize two pointers i and j storing the last indices of both the strings...\\n        int i = strlen(s) , j = strlen(t);\\n        i-- , j--;\\n        // Iterate until either of them becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            // Compare characters...\\n            if(s[i] == t[j])\\n                i-- , j--;\\n            else\\n                j--;\\n        }\\n        // If i (pointer of the first string) is greater than or equal to 0...\\n        // we have not been able to traverse the first string completely...\\n        // Hence, it is not a subsequence of the second...\\n        if(i >= 0)\\n            return false;\\n        return true;        // Otherwise, return true...\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Is Subsequence.\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        // Base case: if the s string is empty...\\n        if(s.length() == 0)\\n            return true;\\n        // Initialize pointers for both strings\\n        int i = 0;\\n        int j = 0;\\n        // We can iterate until either of them becomes zero...\\n        while(i < s.length() && j < t.length()){\\n            // Compare characters, increment i pointer...\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n            }j++;\\n            // If the pointer is equal to the size of s, the match is found...\\n            if(i == s.length()) return true;\\n        }\\n        return false;       // Otherwise return false...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        // Initialize two pointers i and j storing the last indices of both the strings...\\n        int i = s.size() , j = t.size();\\n        i-- , j--;\\n        // Iterate until either of them becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            // Compare characters...\\n            if(s[i] == t[j])\\n                i-- , j--;\\n            else\\n                j--;\\n        }\\n        // If i (pointer of the first string) is greater than or equal to 0...\\n        // we have not been able to traverse the first string completely...\\n        // Hence, it is not a subsequence of the second...\\n        if(i >= 0)\\n            return false;\\n        return true;        // Otherwise, return true...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        # Base case\\n        if not s:\\n            return True\\n        i = 0\\n        # Traverse elements of t string\\n        for j in t:\\n            # If this index matches to the index of s string, increment i pointer...\\n            if j == s[i]:\\n                i += 1\\n            # If the pointer is equal to the size of s...\\n            if i == len(s):\\n                break\\n        return i == len(s)\\n```\n```\\nvar isSubsequence = function(s, t) {\\n    // Base case: if the s string is empty...\\n    if(s.length == 0)\\n        return true;\\n    // Initialize pointers for both strings\\n    let i = 0;\\n    let j = 0;\\n    // We can iterate until either of them becomes zero...\\n    while(i < s.length && j < t.length){\\n        // Compare characters, increment i pointer...\\n        if(s.charAt(i) == t.charAt(j)){\\n            i++;\\n        }j++;\\n        // If the pointer is equal to the size of s, the match is found...\\n        if(i == s.length)  return true;\\n    }\\n    return false;       // Otherwise return false...\\n};\\n```\n```\\nbool isSubsequence(char * s, char * t){\\n    // Initialize two pointers i and j storing the last indices of both the strings...\\n        int i = strlen(s) , j = strlen(t);\\n        i-- , j--;\\n        // Iterate until either of them becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            // Compare characters...\\n            if(s[i] == t[j])\\n                i-- , j--;\\n            else\\n                j--;\\n        }\\n        // If i (pointer of the first string) is greater than or equal to 0...\\n        // we have not been able to traverse the first string completely...\\n        // Hence, it is not a subsequence of the second...\\n        if(i >= 0)\\n            return false;\\n        return true;        // Otherwise, return true...\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87297,
                "title": "java-only-2ms-much-faster-than-normal-2-pointers",
                "content": "Actually another way of 2 pointers, guess indexOf() performs better.\\n\\nTested with other 2-pointers methods in discussion, both took 30ms+.\\n\\nThe one below only takes 2ms.\\n\\n```Java\\npublic class Solution \\n{\\n    public boolean isSubsequence(String s, String t) \\n    {\\n        if(t.length() < s.length()) return false;\\n        int prev = 0;\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char tempChar = s.charAt(i);\\n            prev = t.indexOf(tempChar,prev);\\n            if(prev == -1) return false;\\n            prev++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nThanks to @Ankai.Liang who looked into both functions and provided us the answer.\\n\\nIn case you guys do not notice, I post Liang Ankai's answer.\\n\\n\\n@Ankai.Liang said \\n> Hi, good solution.\\n> I checked the origin code of func \"indexOf\" and \"charAt\". These two solution both traversed the char of String one by one to search the first occurrence specific char.\\n> The difference is that indexOf only call once function then traversed in \"String.value[]\" arr, but we used multiple calling function \"charAt\" to get the value in \"String.value[]\" arr.\\n> The time expense of calling function made the difference.",
                "solutionTags": [],
                "code": "```Java\\npublic class Solution \\n{\\n    public boolean isSubsequence(String s, String t) \\n    {\\n        if(t.length() < s.length()) return false;\\n        int prev = 0;\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char tempChar = s.charAt(i);\\n            prev = t.indexOf(tempChar,prev);\\n            if(prev == -1) return false;\\n            prev++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87307,
                "title": "do-we-really-need-dp-bs",
                "content": "I was shocked by the tags of this problem. Then when I looked at it I found without using these fancy algorithms, there is a rather straight-forward solution with linear time complexity. \\n\\nMaybe I'm wrong and I would appreciate it if someone can tell me how to reduce it into logN using DP or BS?\\n\\nBelow is my Java solution:\\n\\n'''\\npublic boolean isSubsequence(String s, String t) {\\n\\n        if (t.length() == 0 && s.length() == 0) return true;\\n        if (t.length() == 0) return false;\\n        if (s.length() == 0) return true;\\n        \\n        int target_index = 0;\\n        for (int i = 0; i < t.length(); i ++) {\\n            if (s.charAt(target_index) == t.charAt(i)) {\\n                if (target_index == s.length()-1) return true;\\n                target_index ++;\\n            }\\n        }\\n        return false;\\n    }\\n'''",
                "solutionTags": [],
                "code": "I was shocked by the tags of this problem. Then when I looked at it I found without using these fancy algorithms, there is a rather straight-forward solution with linear time complexity. \\n\\nMaybe I'm wrong and I would appreciate it if someone can tell me how to reduce it into logN using DP or BS?\\n\\nBelow is my Java solution:\\n\\n'''\\npublic boolean isSubsequence(String s, String t) {\\n\\n        if (t.length() == 0 && s.length() == 0) return true;\\n        if (t.length() == 0) return false;\\n        if (s.length() == 0) return true;\\n        \\n        int target_index = 0;\\n        for (int i = 0; i < t.length(); i ++) {\\n            if (s.charAt(target_index) == t.charAt(i)) {\\n                if (target_index == s.length()-1) return true;\\n                target_index ++;\\n            }\\n        }\\n        return false;\\n    }\\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 678467,
                "title": "c-follow-up-solution-using-maps-86-faster",
                "content": "***Please upvote, if you found this helpful :)***\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        unordered_map<char, vector<int>> hg; \\n        for(int i=0; i<t.length();i++) hg[t[i]].push_back(i);\\n        \\n        int prev = -1;\\n        for(auto c : s){\\n            auto it = hg.find(c);\\n            if(it == hg.end()) return false;\\n            auto vec = it->second;\\n            int pos = upper_bound(vec.begin(), vec.end(), prev) - vec.begin(); \\n            if(pos == vec.size()) return false;\\n            prev = vec[pos];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        unordered_map<char, vector<int>> hg; \\n        for(int i=0; i<t.length();i++) hg[t[i]].push_back(i);\\n        \\n        int prev = -1;\\n        for(auto c : s){\\n            auto it = hg.find(c);\\n            if(it == hg.end()) return false;\\n            auto vec = it->second;\\n            int pos = upper_bound(vec.begin(), vec.end(), prev) - vec.begin(); \\n            if(pos == vec.size()) return false;\\n            prev = vec[pos];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385275,
                "title": "easiest-python-solution-beats-98-explanation",
                "content": "```\\nclass Solution:\\n\\tdef isSubsequence(self, s: str, t: str) -> bool:\\n\\t\\tfor i in range (0, len(s)):    \\n\\t\\t\\ttry:\\n\\t\\t\\t\\tindex = t.index(s[i])\\n\\t\\t\\texcept ValueError: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tt = t[index+1:]\\n\\n\\t\\treturn True\\n```\\n\\t\\t\\nWhat this code does is it looks for the index of a letter and if it can\\'t find it, returns False. ```The t = t[index+1:]``` part will start the search from the place where the last character was found added by one so it doesn\\'t keep the last found character.\\n\\nAs of writing, this beats 97% of Python 3 solutions!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef isSubsequence(self, s: str, t: str) -> bool:\\n\\t\\tfor i in range (0, len(s)):    \\n\\t\\t\\ttry:\\n\\t\\t\\t\\tindex = t.index(s[i])\\n\\t\\t\\texcept ValueError: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tt = t[index+1:]\\n\\n\\t\\treturn True\\n```\n```The t = t[index+1:]```",
                "codeTag": "Java"
            },
            {
                "id": 87344,
                "title": "greedy-alg-dynamic-programming-binary-search-plus-follow-up-analysis",
                "content": "Methods:\\n1. Greedy Algorithm\\n2. Dynamic Programming\\n3. Binary Search\\n\\nSuppose string s length is m, string t length is n , n>>m\\n\\nFollow up: If we have k string s, and a super long string t, which method is better:\\nAnswer: Binary Search Way beats greedy and DP\\n\\nGreedy Alg: k* O(m+n)\\nBinary Searc < O(n) + k* O(mlogn) --Best\\nDP: k * O(m*n)\\n\\n\\nGreedy Algorithm: O(m+n) Time, O(1) Space\\n\\n```\\nGreedy Algorithm Solution:\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int p = 0;\\n        int q = 0;\\n        while(p < s.length() && q < t.length())\\n        {\\n            if(s.charAt(p) == t.charAt(q))\\n            {\\n                p++;\\n                q++;\\n            }\\n            else\\n            {\\n                q++;\\n            }\\n        }\\n        return (p == s.length());\\n    }\\n}\\n```\\n\\nDynamic Programming: O(n) space + O(m*n) time\\n\\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        boolean[] mem1 = new boolean[t.length()];\\n        boolean[] mem2 = new boolean[t.length()];\\n        if(s.length() == 0) return true;\\n        if(t.length() == 0) return false;\\n        mem1[0] = (s.charAt(0) == t.charAt(0));\\n        for(int j = 1; j < t.length(); j++)\\n        {\\n            mem1[j] = (s.charAt(0) == t.charAt(j))?true:mem1[j-1];\\n        }\\n\\n        for(int i = 1 ; i < s.length() ; i++)\\n        {\\n            for(int j = 1 ; j < t.length(); j++)\\n            {\\n                if(s.charAt(i) == t.charAt(j))\\n                    mem2[j] = mem2[j-1] || mem1[j-1];\\n                else\\n                    mem2[j] = mem2[j-1];\\n            }\\n            mem1 = mem2;\\n            mem2 = new boolean[t.length()];\\n        }   \\n        return mem1[t.length()-1];\\n    }\\n}\\n```\\n\\n\\nBinary Search: O(n) + O(mlogn) at most (Actually far less than mlogn)\\n```\\nTips: Please refer java collection.binarysearch function doc to understand the return value meaning if you can't understand \"insertion point\"\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        HashMap<Character, List<Integer>> hash = new HashMap<>();\\n        for(int i = 0 ; i < t.length(); i++)\\n        {\\n            if(!hash.containsKey(t.charAt(i)))\\n            {\\n                List<Integer> list = new ArrayList<Integer>();\\n                list.add(i);\\n                hash.put(t.charAt(i),list);\\n            }\\n            else\\n            {\\n                hash.get(t.charAt(i)).add(i);\\n            }\\n        }\\n        \\n        int preIndex = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(hash.containsKey(s.charAt(i)))\\n            {\\n                int nextIndex = Collections.binarySearch(hash.get(s.charAt(i)), preIndex);\\n                if(nextIndex < 0)\\n                {\\n                    int insertion_point = (-1)* (nextIndex+1);\\n                    if(insertion_point == hash.get(s.charAt(i)).size())\\n                        return false;\\n                    nextIndex = insertion_point;\\n                }\\n                preIndex = hash.get(s.charAt(i)).get(nextIndex)+1;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nGreedy Algorithm Solution:\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int p = 0;\\n        int q = 0;\\n        while(p < s.length() && q < t.length())\\n        {\\n            if(s.charAt(p) == t.charAt(q))\\n            {\\n                p++;\\n                q++;\\n            }\\n            else\\n            {\\n                q++;\\n            }\\n        }\\n        return (p == s.length());\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        boolean[] mem1 = new boolean[t.length()];\\n        boolean[] mem2 = new boolean[t.length()];\\n        if(s.length() == 0) return true;\\n        if(t.length() == 0) return false;\\n        mem1[0] = (s.charAt(0) == t.charAt(0));\\n        for(int j = 1; j < t.length(); j++)\\n        {\\n            mem1[j] = (s.charAt(0) == t.charAt(j))?true:mem1[j-1];\\n        }\\n\\n        for(int i = 1 ; i < s.length() ; i++)\\n        {\\n            for(int j = 1 ; j < t.length(); j++)\\n            {\\n                if(s.charAt(i) == t.charAt(j))\\n                    mem2[j] = mem2[j-1] || mem1[j-1];\\n                else\\n                    mem2[j] = mem2[j-1];\\n            }\\n            mem1 = mem2;\\n            mem2 = new boolean[t.length()];\\n        }   \\n        return mem1[t.length()-1];\\n    }\\n}\\n```\n```\\nTips: Please refer java collection.binarysearch function doc to understand the return value meaning if you can't understand \"insertion point\"\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        HashMap<Character, List<Integer>> hash = new HashMap<>();\\n        for(int i = 0 ; i < t.length(); i++)\\n        {\\n            if(!hash.containsKey(t.charAt(i)))\\n            {\\n                List<Integer> list = new ArrayList<Integer>();\\n                list.add(i);\\n                hash.put(t.charAt(i),list);\\n            }\\n            else\\n            {\\n                hash.get(t.charAt(i)).add(i);\\n            }\\n        }\\n        \\n        int preIndex = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(hash.containsKey(s.charAt(i)))\\n            {\\n                int nextIndex = Collections.binarySearch(hash.get(s.charAt(i)), preIndex);\\n                if(nextIndex < 0)\\n                {\\n                    int insertion_point = (-1)* (nextIndex+1);\\n                    if(insertion_point == hash.get(s.charAt(i)).size())\\n                        return false;\\n                    nextIndex = insertion_point;\\n                }\\n                preIndex = hash.get(s.charAt(i)).get(nextIndex)+1;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257054,
                "title": "392-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two pointers i and j to 0, representing the indices of the first characters in s and t, respectively.\\n```\\ni = 0  # pointer for s\\nj = 0  # pointer for t\\n```\\n2. Loop through the characters in s and t until either i reaches the end of s or j reaches the end of t.\\n\\n```\\nwhile i < len(s) and j < len(t):\\n```\\n3. If the current character in s matches the current character in t, move the pointer for s to the next character.\\n```\\nif s[i] == t[j]:  # if the characters match, move the pointer for s\\n    i += 1\\n```\\n4. Move the pointer for t to the next character regardless.\\n```\\nj += 1  # move the pointer for t regardless\\n```\\n5. If i has reached the end of s, s is a subsequence of t, so return True. Otherwise, s is not a subsequence of t, so return False.\\n```\\nreturn i == len(s)  # if i has reached the end of s, s is a subsequence of t, else not\\n```\\nOverall, the solution works by iterating through both strings and comparing their characters. If the current characters match, it moves the pointer for s to the next character. If s is a subsequence of t, the pointer for s will reach the end of s before the pointer for t reaches the end of t.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(m+n), where m is the length of s and n is the length of t. This is because we iterate through both strings at most once.\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1), as we only use two pointers and do not use any additional data structures.\\n\\n# Code\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0  # pointer for s\\n        j = 0  # pointer for t\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:  # if the characters match, move the pointer for s\\n                i += 1\\n            j += 1  # move the pointer for t regardless\\n        return i == len(s)  # if i has reached the end of s, s is a subsequence of t, else not\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\ni = 0  # pointer for s\\nj = 0  # pointer for t\\n```\n```\\nwhile i < len(s) and j < len(t):\\n```\n```\\nif s[i] == t[j]:  # if the characters match, move the pointer for s\\n    i += 1\\n```\n```\\nj += 1  # move the pointer for t regardless\\n```\n```\\nreturn i == len(s)  # if i has reached the end of s, s is a subsequence of t, else not\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0  # pointer for s\\n        j = 0  # pointer for t\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:  # if the characters match, move the pointer for s\\n                i += 1\\n            j += 1  # move the pointer for t regardless\\n        return i == len(s)  # if i has reached the end of s, s is a subsequence of t, else not\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426347,
                "title": "c-c-java-python-js-go-kotlin-c-easy-and-short-solutions",
                "content": "Cuz I was just in the mood of trying out almost every optional language in LeetCode ;)\\n\\uD83D\\uDE09\\n**C:**\\n```\\nbool isSubsequence(char * s, char * t){\\n    while (*s && *t) if (*s == *t++) s++;\\n    return !(*s);\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.size() && t_i < t.size()) {\\n            if (s[s_i] == t[t_i]) s_i++; \\n            t_i++;\\n        }\\n        \\n        return s_i == s.size();\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.length() && t_i < t.length()) {\\n            if (s.charAt(s_i) == t.charAt(t_i)) s_i++;\\n            t_i++;\\n        }\\n        \\n        return s_i == s.length();\\n    }\\n}\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_i, t_i = 0, 0\\n        while s_i < len(s) and t_i < len(t):\\n            if s[s_i] == t[t_i]:\\n                s_i += 1\\n            t_i += 1\\n        return s_i == len(s)\\n        \\n```\\n**Javascript:**\\n```\\nvar isSubsequence = function(s, t) {\\n    let s_i = 0, t_i = 0;\\n    while (s_i < s.length && t_i < t.length) {\\n        if (s[s_i] == t[t_i]) s_i++;\\n        t_i++;\\n    }\\n    return s_i == s.length;\\n};\\n```\\n**Go:**\\n```\\nfunc isSubsequence(s string, t string) bool {\\n    s_i, t_i := 0, 0\\n    \\n    for s_i < len(s) && t_i < len(t) {\\n        if s[s_i] == t[t_i] { s_i++ }\\n        t_i++\\n    }\\n    return s_i == len(s)\\n}\\n```\\n**Kotlin:**\\n```\\nclass Solution {\\n    fun isSubsequence(s: String, t: String): Boolean {\\n        var s_i = 0\\n        var t_i = 0\\n        while (s_i < s.length && t_i < t.length) {\\n            if (s[s_i] == t[t_i]) s_i++\\n            t_i++\\n        }\\n        return s_i == s.length\\n    }\\n}\\n```\\n**C#:**\\n```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.Length && t_i < t.Length) {\\n            if (s[s_i] == t[t_i]) s_i++; \\n            t_i++;\\n        }\\n        \\n        return s_i == s.Length;\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nbool isSubsequence(char * s, char * t){\\n    while (*s && *t) if (*s == *t++) s++;\\n    return !(*s);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.size() && t_i < t.size()) {\\n            if (s[s_i] == t[t_i]) s_i++; \\n            t_i++;\\n        }\\n        \\n        return s_i == s.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.length() && t_i < t.length()) {\\n            if (s.charAt(s_i) == t.charAt(t_i)) s_i++;\\n            t_i++;\\n        }\\n        \\n        return s_i == s.length();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_i, t_i = 0, 0\\n        while s_i < len(s) and t_i < len(t):\\n            if s[s_i] == t[t_i]:\\n                s_i += 1\\n            t_i += 1\\n        return s_i == len(s)\\n        \\n```\n```\\nvar isSubsequence = function(s, t) {\\n    let s_i = 0, t_i = 0;\\n    while (s_i < s.length && t_i < t.length) {\\n        if (s[s_i] == t[t_i]) s_i++;\\n        t_i++;\\n    }\\n    return s_i == s.length;\\n};\\n```\n```\\nfunc isSubsequence(s string, t string) bool {\\n    s_i, t_i := 0, 0\\n    \\n    for s_i < len(s) && t_i < len(t) {\\n        if s[s_i] == t[t_i] { s_i++ }\\n        t_i++\\n    }\\n    return s_i == len(s)\\n}\\n```\n```\\nclass Solution {\\n    fun isSubsequence(s: String, t: String): Boolean {\\n        var s_i = 0\\n        var t_i = 0\\n        while (s_i < s.length && t_i < t.length) {\\n            if (s[s_i] == t[t_i]) s_i++\\n            t_i++\\n        }\\n        return s_i == s.length\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.Length && t_i < t.Length) {\\n            if (s[s_i] == t[t_i]) s_i++; \\n            t_i++;\\n        }\\n        \\n        return s_i == s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098557,
                "title": "is-subsequence-c-0-ms-fastest-100",
                "content": "In my last post on the same ques where i discussed my DP approach which was just for the reference for the ones who wanted DP solution was not too impressive in terms of the complexity... So here is the best solution in O(n) where we just check the count of characters that are common in both the strings and then just compare that count with the length of the s.... Check it out its fairly easy approach...\\n\\n#nevergiveup\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m=s.size();\\n        int n=t.size();\\n        \\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[j]==t[i]){\\n                j++;\\n            }\\n        }\\n        return j==m;\\n    }\\n};\\n```\\n\\n**Some small optimisation**\\n\\nWe can run out of loop as soon as our s string gets completely traversed.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int index=0;\\n        for(int i=0;i<t.size() && index<s.size();i++){\\n            if(s[index]==t[i]){\\n                index++;\\n            }\\n        }\\n        return index==s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m=s.size();\\n        int n=t.size();\\n        \\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[j]==t[i]){\\n                j++;\\n            }\\n        }\\n        return j==m;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int index=0;\\n        for(int i=0;i<t.size() && index<s.size();i++){\\n            if(s[index]==t[i]){\\n                index++;\\n            }\\n        }\\n        return index==s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811692,
                "title": "c-detailed-explanation-w-three-different-approaches-two-pointer-recursion-memoziation",
                "content": "***Brief note about Question-***\\n* We are given two strings and we have to find whether one string is subsequence of anthor is not.\\n* A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\\n```\\nLet\\'s take an example not given in question -\\nSuppose they are given strings like s = \"abcd\" and t = \"aghsnbjijyoucyehd\"\\n\\nSo, the answer should be true\\nbecause we are able to find string s in our string t\\n\\nsee, t = \"aghsnbjijyoucyehd\"\\n          \\u2191    \\u2191      \\u2191   \\u2191 \\n\\t\\t  a    b      c   d  \\n```\\n________________\\n***Solution - I (Using First Thought, Accepted)-***\\n* The first and very basic thing we will say that we move from in our `string t` and whenever we matches a character of the same as string s, we will `increase our j pointer` which covers all the character of string s.\\n* And lastly if we our` j pointer becomes equal to the length of s pointer`, we definately say we find string s in our string t.\\n* See code for below, it is too easy u got that just by seeing it.\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n1 = s.length(); // extracting length of string s\\n        int n2 = t.length(); // extracting length of string t\\n        \\n        // if length of string s is greater than string t, then it is impossible to find out s in t\\n        // say s = \"abcdef\" and t = \"ab\"\\n        if(n1 > n2)\\n        {\\n            return false;\\n        }\\n        \\n        // if both strings are empty, then definately return true\\n        if(n1 == 0 && n2 == 0)\\n        {\\n            return true;\\n        }\\n        \\n        int j = 0; // declaring j pointer which moves in string s\\n        \\n        // find variable which tells us whether we ae able to find string s in string t\\n        bool find = false; \\n        \\n        // traverse from string t\\n        for(int i = 0; i < n2; i++)\\n        {\\n            // if character matches\\n            if(t[i] == s[j])\\n            {\\n                j++; // increase j pointer\\n            }\\n            \\n            // if at any point j pointer becomes equal the length of string s,\\n\\t\\t\\t//then we will say yes!! we find a string therefore,\\n\\t\\t\\t//put find as true and from now we don\\'t need to travel, so break\\n            if(j == n1)\\n            {\\n                find = true;\\n                break;\\n            }\\n        }\\n        \\n        // and lastly if we are not able to find string s in string t,\\n        // then my find variable remains false, so \\n        \\n        return find;  // so simply return find\\n    }\\n};\\n```\\n________\\n***Solution - II(Using Recursion , Accepted)-***\\n* We are also able to find the soloution using recursion.\\n* First, again put eye on statement, we have to find whether string s is subsequence of string t or not.\\n* So, we may start from either sides of the strings and start matching character.\\n* Here we start from last and match character.\\n* **How we will know whether we are able to apply recursion here or not?**\\n* For recursion, we will always have some choices, so question arieses whether choices are present here or not.\\n* We will say yess, we have choices, what choices? \\n* We will say for every character of string t we have two choices, first, whether it matches with the character of string s and second whether it does not matches with the character of string s.\\n* So, We will do this only, for every character of string t and string s, we simply checks whether they both matches or not.\\n* **Anthor question arises, if recursion is their then when we stop?**\\n* Suppose at any point our came to know that no more character of string s is left to be matched then at that point we will say, since no character of string s is left to check, that means all characters of string s are now matched so we will return true.\\n* Again, suppose any point camw when string t is exhausted that means we don\\'t have more characters left in string t, so we will return false.\\n* That\\'s all, see code for better understanding.\\n```\\nclass Solution {\\npublic:\\n    bool solve(string &s, string &t, int n1, int n2)\\n    {\\n        if(n1 == 0) // if string s have no characters to left for comparing\\n        {\\n            return true; // then we easily say, all characters are now matched, so return true\\n        }\\n        \\n        if(n2 == 0) //  if string t have no characters to left for comparing\\n        {\\n            return false; // then we will say, it is not possible to find whether s is a subsequence of string t, so we will return false\\n        }\\n        \\n        // if last both characters are matched then,\\n        // decrease charcters in both the strigs\\n        if(s[n1 - 1] == t[n2 - 1])\\n        {\\n            return solve(s, t, n1 - 1, n2 - 1);\\n        }\\n        \\n        // if last both characters are not matched, \\n        //then only decreae string t character\\n        return solve(s, t, n1, n2 - 1);\\n        \\n    }\\n    bool isSubsequence(string s, string t) {\\n        int n1 = s.length(); // extracting length of string s\\n        int n2 = t.length(); // extracting length of string t\\n        \\n        // return solve that tells us answer\\n       return solve(s, t, n1, n2);\\n    }\\n};\\n```\\n____________\\n***Solution - III(Using DP, memoziation , Accepted)-***\\n* We can further optimize our recursion by memoziation.\\n* We find the longest common subsequence (LCS) of string s and string t.\\n* **If the length of both LCS and string s is equal, we will say that yess!!, string s is a subsequence of string t**.\\n```\\nclass Solution {\\npublic:\\n    int t[1001][10001];\\n    \\n    int solve(string& first, string& sec, int n1, int n2)\\n    {\\n        // if length of any one of the string becomes zero, simply return 0\\n        if(n1 == 0 || n2 == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        // if we already store this result\\n        if(t[n1][n2] != -1) \\n            return t[n1][n2];\\n        \\n        // if last character matches of both strings, then add 1 to length\\n        if(first[n1 - 1] == sec[n2 - 1])\\n        {\\n            return t[n1][n2]  = 1 + solve(first, sec, n1 - 1, n2 - 1);\\n        }\\n        \\n        // if result is not alredy store, then we need to calculate\\n        if(t[n1 - 1][n2] == -1)\\n        {\\n            t[n1 - 1][n2] = solve(first, sec, n1 - 1, n2);\\n        }\\n        \\n        // if result is not alredy store, then we need to calculate\\n        if(t[n1][n2 - 1] == -1)\\n        {\\n            t[n1][n2 - 1] = solve(first, sec, n1, n2 - 1);\\n        }\\n        \\n        //return max of them\\n        return max(t[n1 - 1][n2], t[n1][n2 - 1]);\\n    }\\n    \\n    bool isSubsequence(string first, string second) {\\n        int n1 = first.length(); // extracting length of string s\\n        int n2 = second.length(); // extracting length of string t\\n        \\n        if(n1 > n2)\\n            return false;\\n        \\n        if(n1 == 0 && n2 == 0)\\n            return true;\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int LCS = solve(first, second, n1, n2);\\n        \\n        // if LCS is equal to length of string s, then return true\\n        if(LCS == n1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose they are given strings like s = \"abcd\" and t = \"aghsnbjijyoucyehd\"\\n\\nSo, the answer should be true\\nbecause we are able to find string s in our string t\\n\\nsee, t = \"aghsnbjijyoucyehd\"\\n          \\u2191    \\u2191      \\u2191   \\u2191 \\n\\t\\t  a    b      c   d  \\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n1 = s.length(); // extracting length of string s\\n        int n2 = t.length(); // extracting length of string t\\n        \\n        // if length of string s is greater than string t, then it is impossible to find out s in t\\n        // say s = \"abcdef\" and t = \"ab\"\\n        if(n1 > n2)\\n        {\\n            return false;\\n        }\\n        \\n        // if both strings are empty, then definately return true\\n        if(n1 == 0 && n2 == 0)\\n        {\\n            return true;\\n        }\\n        \\n        int j = 0; // declaring j pointer which moves in string s\\n        \\n        // find variable which tells us whether we ae able to find string s in string t\\n        bool find = false; \\n        \\n        // traverse from string t\\n        for(int i = 0; i < n2; i++)\\n        {\\n            // if character matches\\n            if(t[i] == s[j])\\n            {\\n                j++; // increase j pointer\\n            }\\n            \\n            // if at any point j pointer becomes equal the length of string s,\\n\\t\\t\\t//then we will say yes!! we find a string therefore,\\n\\t\\t\\t//put find as true and from now we don\\'t need to travel, so break\\n            if(j == n1)\\n            {\\n                find = true;\\n                break;\\n            }\\n        }\\n        \\n        // and lastly if we are not able to find string s in string t,\\n        // then my find variable remains false, so \\n        \\n        return find;  // so simply return find\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(string &s, string &t, int n1, int n2)\\n    {\\n        if(n1 == 0) // if string s have no characters to left for comparing\\n        {\\n            return true; // then we easily say, all characters are now matched, so return true\\n        }\\n        \\n        if(n2 == 0) //  if string t have no characters to left for comparing\\n        {\\n            return false; // then we will say, it is not possible to find whether s is a subsequence of string t, so we will return false\\n        }\\n        \\n        // if last both characters are matched then,\\n        // decrease charcters in both the strigs\\n        if(s[n1 - 1] == t[n2 - 1])\\n        {\\n            return solve(s, t, n1 - 1, n2 - 1);\\n        }\\n        \\n        // if last both characters are not matched, \\n        //then only decreae string t character\\n        return solve(s, t, n1, n2 - 1);\\n        \\n    }\\n    bool isSubsequence(string s, string t) {\\n        int n1 = s.length(); // extracting length of string s\\n        int n2 = t.length(); // extracting length of string t\\n        \\n        // return solve that tells us answer\\n       return solve(s, t, n1, n2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int t[1001][10001];\\n    \\n    int solve(string& first, string& sec, int n1, int n2)\\n    {\\n        // if length of any one of the string becomes zero, simply return 0\\n        if(n1 == 0 || n2 == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        // if we already store this result\\n        if(t[n1][n2] != -1) \\n            return t[n1][n2];\\n        \\n        // if last character matches of both strings, then add 1 to length\\n        if(first[n1 - 1] == sec[n2 - 1])\\n        {\\n            return t[n1][n2]  = 1 + solve(first, sec, n1 - 1, n2 - 1);\\n        }\\n        \\n        // if result is not alredy store, then we need to calculate\\n        if(t[n1 - 1][n2] == -1)\\n        {\\n            t[n1 - 1][n2] = solve(first, sec, n1 - 1, n2);\\n        }\\n        \\n        // if result is not alredy store, then we need to calculate\\n        if(t[n1][n2 - 1] == -1)\\n        {\\n            t[n1][n2 - 1] = solve(first, sec, n1, n2 - 1);\\n        }\\n        \\n        //return max of them\\n        return max(t[n1 - 1][n2], t[n1][n2 - 1]);\\n    }\\n    \\n    bool isSubsequence(string first, string second) {\\n        int n1 = first.length(); // extracting length of string s\\n        int n2 = second.length(); // extracting length of string t\\n        \\n        if(n1 > n2)\\n            return false;\\n        \\n        if(n1 == 0 && n2 == 0)\\n            return true;\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int LCS = solve(first, second, n1, n2);\\n        \\n        // if LCS is equal to length of string s, then return true\\n        if(LCS == n1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306875,
                "title": "awesome-logic-with-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i=0\\n        for let in t:\\n            if i==len(s):\\n                return True\\n            if s[i]==let:\\n                i+=1\\n        return i==len(s)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i=0\\n        for let in t:\\n            if i==len(s):\\n                return True\\n            if s[i]==let:\\n                i+=1\\n        return i==len(s)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811858,
                "title": "3-methods-2-pointer-dp-follow-up-c",
                "content": "***If you find this post helpful, show some love in the form of upvote. It motivate us to write more post in the future.***\\n\\n------------------------------------------------------------------------------------------------------------\\n**\\u27051. Two Pointer**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0, m = s.length(), n = t.length();\\n        while(i < m and j < n){\\n            if(s[i] == t[j])\\n                i++;\\n            j++;\\n        }\\n        return i == m;\\n    }\\n};\\n```\\n<b> Dry Run </b>\\n<a href=\"https://ibb.co/yQw127h\"><img src=\"https://i.ibb.co/jrc2tsV/Whats-App-Image-2022-03-02-at-09-46-33.jpg\" alt=\"Whats-App-Image-2022-03-02-at-09-46-33\" border=\"0\" height = \"500\" width = \"400\"></a>\\n- Time Complexity = **O(N)**\\n- Space Complexity = **O(1)**\\n----------------------------------------------------------------------\\n**\\u27052. Dynamic Programming**\\n* dp[i][j] means s[0 : i-1] is a subsequence of t[0 : j-1] where i and j are the current length of substring.\\n* Base case is all the empty strings are subsequence of t[0 : j] for all 0 <= j <= len(t) since if we delete all the characters in t, it forms an empty string.\\n* Another base case is if t is an empty string, then only subsequence possible is an empty string. So s cannot be an non-empty subsequence.\\n* if i<sup>th</sup> character of s and j<sup>th</sup> character of t are equal, check whether 0 to (i-1)<sup>th</sup> characters of s and 0 to (j-1)<sup>th</sup> characters of t form a subsequence. ie., check dp[i-1][j-1]\\n* else check whether already 0 to (i)<sup>th</sup> characters of s and 0 to (j-1)<sup>th</sup> characters of t formed a subsequence. ie., check dp[i][j-1]\\n\\n<b> Dry Run </b>\\n\\n<a href=\"https://ibb.co/Tt1JSFG\"><img src=\"https://i.ibb.co/CQ64ZTy/Screenshot-2022-03-02-104552.jpg\" alt=\"Screenshot-2022-03-02-104552\" border=\"0\"></a>\\n```\\nbool isSubsequence(string s, string t) {\\n        int m = s.length(), n = t.length();\\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        for(int j=0; j<=n; j++)\\n            dp[0][j] = true;\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n                if(s[i-1] == t[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n- Time Complexity = **O(M * N)**\\n- Space Complexity = **O(M * N)**,  The space complexity can be improved to O(N) since we only required to know the previously computed array.\\n----------------------------------------------------------------------\\n**\\u27053. Follow up : Binary Search**\\n* If we apply two pointer approach, then the time complexity for follow up question will be O(K * N) where k <= 10<sup>9</sup> which is the no of subsequences we have to check. Inorder to optimize, we are going to use binary search approach.\\n* Map all the character to it\\'s indices in an array.\\n* Now for each character the corresponding array is in increasing order which helps us to apply binary search.\\n* if s(0 to i) is a subsequence of t where i<sup>th</sup> character is matching with j<sup>th</sup> character. Then the last character matching position = j, Now for s(0 to i+1) is a subsequece of t, we apply a binary search on the array mapped to s[i+1] for finding whether there is any index greater then last character matching position.  If we found any such index, then s(0 to i+1) is a subsequence of t otherwise return false.\\n* In C++, upper_bound() returns the pointer to the index where the value is greater than key value. If not able to find such index, then it returns the end(array).\\n```\\n    bool isSubsequence(string s, string t) {\\n        unordered_map<char, vector<int>> map;\\n        int m = s.length(), n = t.length();\\n        \\n        for(int i=0; i<n; i++)\\n            map[t[i]].push_back(i);\\n        \\n        int lastCharPos = -1;\\n        for(char ch : s){\\n            auto pos = upper_bound(begin(map[ch]), end(map[ch]), lastCharPos);\\n            if(pos == end(map[ch]))\\n                return false;\\n            else\\n                lastCharPos = *pos;\\n        }\\n        return true;\\n    }\\n};\\n```\\n- Time Complexity = **O(K * M * Log(N))** where k is the no of subsequences and M is the max length of subsequence. If you are confusing that why binary search is a good approach here that two pointer only have O(K * N) time complexity. Let me explain it. given k<=10<sup>9</sup> and N <= 10<sup>4</sup>, suppose you are given a string s of length  100 and t of length 10000. By using two pointer, you have to do 10000 steps. (since O(N)). But in binary search time complexity is O(M * Log(N)) ~ 100 * 14 = 1400 steps. concider N to be even greater say 100,000. Then in 2 pointer, it takes 100,000 steps. In binary search it takes, 100 * log2(100,000) ~ 100 * 17 = 1700.\\n- Space Complexity = **O(N)**\\n--------------------------------------------------------------------------------------------------------------\\n***If you have any queries or doubts, please ask in comment section. If you find this post helpful, show some love in the form of upvote.***\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0, m = s.length(), n = t.length();\\n        while(i < m and j < n){\\n            if(s[i] == t[j])\\n                i++;\\n            j++;\\n        }\\n        return i == m;\\n    }\\n};\\n```\n```\\nbool isSubsequence(string s, string t) {\\n        int m = s.length(), n = t.length();\\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        for(int j=0; j<=n; j++)\\n            dp[0][j] = true;\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n                if(s[i-1] == t[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\n    bool isSubsequence(string s, string t) {\\n        unordered_map<char, vector<int>> map;\\n        int m = s.length(), n = t.length();\\n        \\n        for(int i=0; i<n; i++)\\n            map[t[i]].push_back(i);\\n        \\n        int lastCharPos = -1;\\n        for(char ch : s){\\n            auto pos = upper_bound(begin(map[ch]), end(map[ch]), lastCharPos);\\n            if(pos == end(map[ch]))\\n                return false;\\n            else\\n                lastCharPos = *pos;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811547,
                "title": "0ms-3-line-solution-explanation-o-n-time-o-1-space-complexity",
                "content": "```\\n//Upvote if helpful\\n```\\n### **Intuition:**\\n1. We treat subsequence string as stack and travel from end of base string.\\n1. When the top() of stack matches current element in base string we pop().\\n1. We continue till we reach end of base string or till stick becomes empty. <br><br>\\n\\n**Time complexity O(n)**\\nAs we iterate only once in base string and till the end in worst case \\n\\n**Space Complexity O(1)**\\nAs the only extra space required is of iteration variable\\n\\n### **Dry Run:**\\nConsider **base string t: \"bdaecf\"** \\n\\n![image](https://assets.leetcode.com/users/images/fdeef7f3-7dd1-4a83-8809-17cca30c2dc7_1646194851.7933378.png)\\n\\n<br>\\n\\n### CODE:\\n```\\nclass Solution {\\n    public:\\n        bool isSubsequence(string s, string t) \\n        {        \\n            for(int x=t.size()-1; x>=0 && !s.empty(); x--)\\n                if (t[x]==s[s.size()-1]) s.pop_back();   //treating subsequence string as a stack\\n            return s.empty();\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n//Upvote if helpful\\n```\n```\\nclass Solution {\\n    public:\\n        bool isSubsequence(string s, string t) \\n        {        \\n            for(int x=t.size()-1; x>=0 && !s.empty(); x--)\\n                if (t[x]==s[s.size()-1]) s.pop_back();   //treating subsequence string as a stack\\n            return s.empty();\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811560,
                "title": "java-recursive-dp-two-pointer-3-approaches",
                "content": "```\\nclass Solution {\\n    //TWO POINTER \\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0 , j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return (i == s.length());\\n    }\\n    \\n    //DP TOP DOWN LCS APPROACH\\n    public boolean isSubsequence_DP(String s, String t) {\\n        int n = s.length() , m = t.length();\\n        int[][] dp = new int[n+1][m+1];\\n        for(int i = 1; i <= n;i++){\\n            for(int j = 1; j <= m;j++){\\n                if(s.charAt(i-1) == t.charAt(j-1)){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // System.out.println(dp[n][m] + \" \" + dp[n-1][m-1]);\\n        return dp[n][m] == n;\\n    }\\n    \\n    \\n    //RECURSIVE SOLUTION\\n    public boolean isSubsequence_(String s, String t) {\\n        return solve(s , 0 , t, 0);\\n    }\\n    \\n    private boolean solve(String s , int i , String t, int j){\\n        if(i == s.length()){\\n            return true;\\n        }\\n        if(i < s.length() && j == t.length()) return false;\\n        if(s.charAt(i) == t.charAt(j)){\\n            return solve(s , i+1, t , j+1);\\n        }else {\\n            return solve(s , i, t, j+1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    //TWO POINTER \\n    public boolean isSubsequence(String s, String t) {\\n        int i = 0 , j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return (i == s.length());\\n    }\\n    \\n    //DP TOP DOWN LCS APPROACH\\n    public boolean isSubsequence_DP(String s, String t) {\\n        int n = s.length() , m = t.length();\\n        int[][] dp = new int[n+1][m+1];\\n        for(int i = 1; i <= n;i++){\\n            for(int j = 1; j <= m;j++){\\n                if(s.charAt(i-1) == t.charAt(j-1)){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // System.out.println(dp[n][m] + \" \" + dp[n-1][m-1]);\\n        return dp[n][m] == n;\\n    }\\n    \\n    \\n    //RECURSIVE SOLUTION\\n    public boolean isSubsequence_(String s, String t) {\\n        return solve(s , 0 , t, 0);\\n    }\\n    \\n    private boolean solve(String s , int i , String t, int j){\\n        if(i == s.length()){\\n            return true;\\n        }\\n        if(i < s.length() && j == t.length()) return false;\\n        if(s.charAt(i) == t.charAt(j)){\\n            return solve(s , i+1, t , j+1);\\n        }else {\\n            return solve(s , i, t, j+1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661948,
                "title": "0-ms-2-lines-code",
                "content": "```\\n\\tbool isSubsequence(string s, string t, int i = 0) {\\n        for(int j = 0; j < t.length(); j++) if(s[i] == t[j])i++;\\n        return i == s.length();\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tbool isSubsequence(string s, string t, int i = 0) {\\n        for(int j = 0; j < t.length(); j++) if(s[i] == t[j])i++;\\n        return i == s.length();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811345,
                "title": "easy-to-understand-solution-with-2-different-approaches",
                "content": "***USING POINTER ***\\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        int iS = 0, iT = 0;\\n        while (iT < t.length()) {\\n            if (t.charAt(iT) == s.charAt(iS)) {\\n                iS++;\\n                if (iS == s.length()) return true;\\n            }\\n            iT++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n***USING MAP***\\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n    if (s == null || t == null) return false;\\n    \\n    Map<Character, List<Integer>> map = new HashMap<>(); //<character, index>\\n    \\n    //preprocess t\\n    for (int i = 0; i < t.length(); i++) {\\n        char current = t.charAt(i);\\n        if (!map.containsKey(current)) {\\n            map.put(current, new ArrayList<Integer>());\\n        }\\n        map.get(current).add(i);\\n    }\\n    \\n    int prev = -1;  //index of previous character\\n    for (int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        \\n        if (map.get(c) == null)  {\\n            return false;\\n        } else {\\n            List<Integer> list = map.get(c);\\n            prev = binarySearch(prev, list, 0, list.size() - 1);\\n            if (prev == -1) {\\n                return false;\\n            }\\n            prev++;\\n        }\\n    }\\n    \\n    return true;\\n}\\n\\nprivate int binarySearch(int index, List<Integer> list, int start, int end) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (list.get(mid) < index) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return start == list.size() ? -1 : list.get(start);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        int iS = 0, iT = 0;\\n        while (iT < t.length()) {\\n            if (t.charAt(iT) == s.charAt(iS)) {\\n                iS++;\\n                if (iS == s.length()) return true;\\n            }\\n            iT++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n    if (s == null || t == null) return false;\\n    \\n    Map<Character, List<Integer>> map = new HashMap<>(); //<character, index>\\n    \\n    //preprocess t\\n    for (int i = 0; i < t.length(); i++) {\\n        char current = t.charAt(i);\\n        if (!map.containsKey(current)) {\\n            map.put(current, new ArrayList<Integer>());\\n        }\\n        map.get(current).add(i);\\n    }\\n    \\n    int prev = -1;  //index of previous character\\n    for (int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        \\n        if (map.get(c) == null)  {\\n            return false;\\n        } else {\\n            List<Integer> list = map.get(c);\\n            prev = binarySearch(prev, list, 0, list.size() - 1);\\n            if (prev == -1) {\\n                return false;\\n            }\\n            prev++;\\n        }\\n    }\\n    \\n    return true;\\n}\\n\\nprivate int binarySearch(int index, List<Integer> list, int start, int end) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (list.get(mid) < index) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return start == list.size() ? -1 : list.get(start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87384,
                "title": "java-1ms-solution",
                "content": "```\\npublic boolean isSubsequence(String s, String t) {\\n        int fromIndex = 0;\\n        for (char c : s.toCharArray()) {\\n            fromIndex = t.indexOf(c, fromIndex);\\n            if (fromIndex++ < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isSubsequence(String s, String t) {\\n        int fromIndex = 0;\\n        for (char c : s.toCharArray()) {\\n            fromIndex = t.indexOf(c, fromIndex);\\n            if (fromIndex++ < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 87417,
                "title": "c-two-pointers-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int idx = 0;\\n        for (int i = 0; i < t.size(); i++) {\\n            if (s[idx] == t[i]) {\\n                idx++;\\n            }\\n        }\\n        return idx == s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int idx = 0;\\n        for (int i = 0; i < t.size(); i++) {\\n            if (s[idx] == t[i]) {\\n                idx++;\\n            }\\n        }\\n        return idx == s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679763,
                "title": "python-easy-solution-99-faster-is-subsequence",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE**\\n\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        sl, tl = 0, 0\\n        \\n        while sl<len(s) and tl<len(t):\\n            if s[sl] == t[tl]:\\n                sl+=1\\n                tl+=1\\n            else:\\n                tl+=1\\n        if sl==len(s):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        sl, tl = 0, 0\\n        \\n        while sl<len(s) and tl<len(t):\\n            if s[sl] == t[tl]:\\n                sl+=1\\n                tl+=1\\n            else:\\n                tl+=1\\n        if sl==len(s):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87324,
                "title": "python-clean-binary-search",
                "content": "Time complexity: O(T + SlogT)\\n```\\nimport collections\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        d = collections.defaultdict(list)\\n        for i in xrange(0, len(t)):\\n            d[t[i]].append(i)\\n        start = 0\\n        for c in s:\\n            idx = bisect.bisect_left(d[c], start)\\n            if len(d[c]) == 0 or idx >= len(d[c]):\\n                return False\\n            start = d[c][idx] + 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        d = collections.defaultdict(list)\\n        for i in xrange(0, len(t)):\\n            d[t[i]].append(i)\\n        start = 0\\n        for c in s:\\n            idx = bisect.bisect_left(d[c], start)\\n            if len(d[c]) == 0 or idx >= len(d[c]):\\n                return False\\n            start = d[c][idx] + 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074374,
                "title": "java-simple-clean-code-beats-89",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isSubsequence(String s, String t) {\\n    int i = 0, j = 0;\\n    \\n    while (i < s.length() && j < t.length())\\n      if (s.charAt(i) == t.charAt(j++))\\n        i++;\\n\\n    return i == s.length();\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isSubsequence(String s, String t) {\\n    int i = 0, j = 0;\\n    \\n    while (i < s.length() && j < t.length())\\n      if (s.charAt(i) == t.charAt(j++))\\n        i++;\\n\\n    return i == s.length();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047706,
                "title": "is-subsequence-beats-99-98",
                "content": "# Intuition\\nTwo pointer approach\\n# Approach\\n1. use two pointers i and j for s and t respectively\\n2. increment j if no match between current element of string\\n3. else increment both if matched\\n4. loop till j is less than length of t\\n5. if i has been incremented till length of s(all elements identified)\\n6. then reuturn True or return False\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(1)\\n# Code\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        j = 0\\n        while(j < len(t) and i < len(s)):\\n            if(s[i] == t[j]):\\n                i = i + 1\\n                j = j + 1\\n            else:\\n                j = j + 1\\n        if(i == len(s)):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        j = 0\\n        while(j < len(t) and i < len(s)):\\n            if(s[i] == t[j]):\\n                i = i + 1\\n                j = j + 1\\n            else:\\n                j = j + 1\\n        if(i == len(s)):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448001,
                "title": "javascript-simple-solution-with-two-pointers-100",
                "content": "```\\nvar isSubsequence = function(s, t) {\\n    if (!s) return true;\\n    let cursorS = 0;\\n    \\n    for (let i = 0; i < t.length; i++) {\\n        if (t[i] === s[cursorS]) cursorS++;\\n        \\n        if (cursorS === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar isSubsequence = function(s, t) {\\n    if (!s) return true;\\n    let cursorS = 0;\\n    \\n    for (let i = 0; i < t.length; i++) {\\n        if (t[i] === s[cursorS]) cursorS++;\\n        \\n        if (cursorS === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270385,
                "title": "java-0-ms-time-complexity-94-space-simple-java-code",
                "content": "**Intiution : We can utilise string method string.indexOf(Character value,Start index)\\nBy using the above method we can get the index Of any char starting with any index.**\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        char cur[]=s.toCharArray();\\n\\t\\t//Initial value of past is -2 to avoid match at 0th index\\n        int past=-2;\\n        for(char c:cur){\\n\\t\\t//Every time we update the last match index +1 in past\\n            past=t.indexOf(c,past+1);\\n\\t\\t\\t//If no match found -1 will be returned,so returning false\\n            if(past==-1)\\n                return false;\\n        }\\n\\t\\t//If the string s is traversed completely ,then return true\\n        return true;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        char cur[]=s.toCharArray();\\n\\t\\t//Initial value of past is -2 to avoid match at 0th index\\n        int past=-2;\\n        for(char c:cur){\\n\\t\\t//Every time we update the last match index +1 in past\\n            past=t.indexOf(c,past+1);\\n\\t\\t\\t//If no match found -1 will be returned,so returning false\\n            if(past==-1)\\n                return false;\\n        }\\n\\t\\t//If the string s is traversed completely ,then return true\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678940,
                "title": "c-solution-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int ps=0, pt=0;\\n        while(ps<s.size() && pt<t.size()){\\n           if(s[ps]==t[pt]) ps++;\\n            pt++;\\n        }\\n        return ps==s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int ps=0, pt=0;\\n        while(ps<s.size() && pt<t.size()){\\n           if(s[ps]==t[pt]) ps++;\\n            pt++;\\n        }\\n        return ps==s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961792,
                "title": "python3-simple-code",
                "content": "\\nhttps://leetcode.com/submissions/detail/866798308/\\nRuntime: 31 ms  \\nMemory Usage: 13.9 MB  \\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if not s: \\n            return True\\n        matched = 0\\n        for l in t:\\n            if s[matched]==l:\\n                matched += 1\\n            if matched==len(s): \\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if not s: \\n            return True\\n        matched = 0\\n        for l in t:\\n            if s[matched]==l:\\n                matched += 1\\n            if matched==len(s): \\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765474,
                "title": "easy-python-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281168,
                "title": "follow-up-is-leetcode-792",
                "content": "The follow-up question is the leetcode problem 792 at https://leetcode.com/problems/number-of-matching-subsequences/description/\\n\\n```\\nclass Solution {\\npublic:\\n    int numMatchingSubseq(string S, vector<string>& words) {\\n        int size = S.size();\\n        charToIdx.resize(26);\\n        for(int i=0; i<size; i++) charToIdx[S[i]-\\'a\\'].push_back(i);\\n        int ret = 0; for(auto& word : words) {if(isSubsequence(word)) ret += 1;}\\n        return ret;\\n    }\\nprivate:\\n    vector<vector<int>> charToIdx;\\n    bool isSubsequence(string& word) {\\n        int wsize = word.size();\\n        int idx = -1;\\n        for(int i = 0; i<wsize; i++) {\\n            char c = word[i];\\n            int offset = c-\\'a\\';\\n            auto& range = charToIdx[offset];\\n            if(range.empty()) return false;\\n            //binary search for the first index in the range that is more the running \\'idx\\'\\n            int left = 0; int right = (int)range.size() - 1; int mid; int result = -1;\\n            while(left <= right) {\\n                mid = left + (right-left)/2;\\n                if(range[mid]>idx) {result = range[mid]; right = mid-1;}\\n                else {left = mid+1;}\\n            }\\n            if(result == -1) return false;\\n            else idx = result;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMatchingSubseq(string S, vector<string>& words) {\\n        int size = S.size();\\n        charToIdx.resize(26);\\n        for(int i=0; i<size; i++) charToIdx[S[i]-\\'a\\'].push_back(i);\\n        int ret = 0; for(auto& word : words) {if(isSubsequence(word)) ret += 1;}\\n        return ret;\\n    }\\nprivate:\\n    vector<vector<int>> charToIdx;\\n    bool isSubsequence(string& word) {\\n        int wsize = word.size();\\n        int idx = -1;\\n        for(int i = 0; i<wsize; i++) {\\n            char c = word[i];\\n            int offset = c-\\'a\\';\\n            auto& range = charToIdx[offset];\\n            if(range.empty()) return false;\\n            //binary search for the first index in the range that is more the running \\'idx\\'\\n            int left = 0; int right = (int)range.size() - 1; int mid; int result = -1;\\n            while(left <= right) {\\n                mid = left + (right-left)/2;\\n                if(range[mid]>idx) {result = range[mid]; right = mid-1;}\\n                else {left = mid+1;}\\n            }\\n            if(result == -1) return false;\\n            else idx = result;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387711,
                "title": "easy-and-fast",
                "content": "\\n\\n\\nfunction isSubsequence(s: string, t: string): boolean {\\n\\n    let counter = 0\\n    \\n    for(let i = 0; i < t.length; i++) {\\n      if(t[i] === s[counter]) {\\n          counter++\\n      }  \\n    }\\n\\n    return counter === s.length\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n\\nfunction isSubsequence(s: string, t: string): boolean {\\n\\n    let counter = 0\\n    \\n    for(let i = 0; i < t.length; i++) {\\n      if(t[i] === s[counter]) {\\n          counter++\\n      }  \\n    }\\n\\n    return counter === s.length\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1811624,
                "title": "simple-2-pointer-python-solution",
                "content": "This problem is quite straightforward. Basically traverse thorugh the two strings S and T using two pointers. If character on both pointers are same then update both the pointers. If not then update only string T\\'s pointer.\\n1. Maintain 2 pointers i and j meaning i\\'th index of string S and j is j\\'th index of string T respectively. \\n2. Now we loop i and j until one of strings is fully traversed. At each step we check if `T[j] == S[i]` is true or not. \\n3. If the check is true then that means that we found the ith character of S in T, hence look for the i+1\\'th character in T. If any of the strings is fully traversd we exit the loop. \\n4. Now if i == len(T) then we successfully found a subsequence of S in T. If not then we did\\'nt find a complete subsequence of S in T.\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j, n, m = 0, 0, len(s), len(t)\\n        while i < n and j < m: # Loop till any of the strings is fully traversed\\n\\t\\t\\tif s[i] == t[j]: # If char at i and j are equal then update i\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\t# Could also write i += s[i]==t[j]\\n            j += 1 # Update j always.\\n        return i == n \\n```\\n**Time Complexity = O(m)** {m is the length of string t}\\n**Space Complexity = O(1)** {as we maintain only 4 variables)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j, n, m = 0, 0, len(s), len(t)\\n        while i < n and j < m: # Loop till any of the strings is fully traversed\\n\\t\\t\\tif s[i] == t[j]: # If char at i and j are equal then update i\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\t# Could also write i += s[i]==t[j]\\n            j += 1 # Update j always.\\n        return i == n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129170,
                "title": "python-easy-simple-solution-19ms",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution, I begin with empty string `sub = \"\"` to put all subsequence of `s` that appear in `t`. and for every iteration in loop, I checked if every charcter in string `t` appear in string `s` and to check the arrangement of appearing this character, I made this condition `t[i] == s[len(sub)]` to check if this character appears in the correct location or not by `len(sub)` and if this condtion was true I added this character in string `sub`. After all iterations in loop,if string `sub=\\'abc\\'` and still charchters in string `t`,then I don\\'t have to complete the rest of string `t`, so I will break from the loop. And then I checked if `sub == s` , then `s` is subsequence of `t` otherwise `s` is not subsequence of `t`\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        sub = \"\"\\n        for i in range(len(t)):\\n            if t[i] in s and t[i] == s[len(sub)]:\\n                sub += t[i]\\n            if sub == s:\\n                break\\n        \\n        return sub == s\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        sub = \"\"\\n        for i in range(len(t)):\\n            if t[i] in s and t[i] == s[len(sub)]:\\n                sub += t[i]\\n            if sub == s:\\n                break\\n        \\n        return sub == s\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086102,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == m ? 1 : 0;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i == m ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069251,
                "title": "java-0ms",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take a pointer to compare each character of string s with each character of string t.\\n2. Compare character of s with character of t, if they match then increment the pointer otherwise cotinue the process.\\n3. At the end if the pointer becomes equal or greater than length of s ,then it means that the string s is successfully checked and it is a subsequence of t hence return true.  \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int count=0;\\n        int len_s = s.length();\\n        int len_t = t.length();\\n        if(len_s == 0) return true;\\n        if(len_t == 0) return false;\\n        for(int i=0 ; i<len_t ; i++){\\n            if(s.charAt(count) == t.charAt(i)){\\n                count++;\\n                if(count>=len_s){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int count=0;\\n        int len_s = s.length();\\n        int len_t = t.length();\\n        if(len_s == 0) return true;\\n        if(len_t == 0) return false;\\n        for(int i=0 ; i<len_t ; i++){\\n            if(s.charAt(count) == t.charAt(i)){\\n                count++;\\n                if(count>=len_s){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396678,
                "title": "swift-simplest-solution",
                "content": "Please, upvote if you found the solution useful.\\n```\\nclass Solution {\\n\\t/// Time: O(n). Space: O(n).\\n    func isSubsequence(_ s: String, _ t: String) -> Bool {\\n        let sArray = Array(s)\\n        var index = 0\\n\\n        for char in t {\\n            guard index < sArray.count, sArray[index] == char else { continue }\\n            index += 1\\n        }\\n        return index == sArray.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t/// Time: O(n). Space: O(n).\\n    func isSubsequence(_ s: String, _ t: String) -> Bool {\\n        let sArray = Array(s)\\n        var index = 0\\n\\n        for char in t {\\n            guard index < sArray.count, sArray[index] == char else { continue }\\n            index += 1\\n        }\\n        return index == sArray.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811293,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\nwhere n is length of t.\\n**Java**\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0;\\n        for(int i=0; i<t.length() && j<s.length(); i++){\\n            if(s.charAt(j) == t.charAt(i))  j++;\\n        }\\n        return j == s.length();\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar isSubsequence = function(s, t) {\\n    let j = 0\\n    for(let i=0; i<t.length && j<s.length; i++){\\n         if(t[i] == s[j])   j++;\\n    }\\n    return j == s.length\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        j = 0\\n        for i in range(0, len(t)):\\n            if j >= len(s):\\n                break;\\n            if s[j] == t[i]:\\n                j += 1\\n        return j == len(s)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0;\\n        for(int i=0; i<t.length() && j<s.length(); i++){\\n            if(s.charAt(j) == t.charAt(i))  j++;\\n        }\\n        return j == s.length();\\n    }\\n}\\n```\n```\\nvar isSubsequence = function(s, t) {\\n    let j = 0\\n    for(let i=0; i<t.length && j<s.length; i++){\\n         if(t[i] == s[j])   j++;\\n    }\\n    return j == s.length\\n};\\n```\n```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        j = 0\\n        for i in range(0, len(t)):\\n            if j >= len(s):\\n                break;\\n            if s[j] == t[i]:\\n                j += 1\\n        return j == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791262,
                "title": "javascript-solution-392",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nlet isSubsequence = function(s, t) {\\n    let i=0;\\n    let j=0;\\n    while(i<s.length){\\n        if(j===t.length){\\n            return false;\\n        }\\n        if(s[i]===t[j]){\\n            i++;\\n        }\\n        j++;\\n    }\\nreturn true;\\n};\\n```\\n\\n**Runtime: 76 ms, faster than 60.24% of JavaScript online submissions for Is Subsequence.**\\n\\n**Memory Usage: 37.1 MB, less than 16.74% of JavaScript online submissions for Is Subsequence.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nlet isSubsequence = function(s, t) {\\n    let i=0;\\n    let j=0;\\n    while(i<s.length){\\n        if(j===t.length){\\n            return false;\\n        }\\n        if(s[i]===t[j]){\\n            i++;\\n        }\\n        j++;\\n    }\\nreturn true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678755,
                "title": "two-solutions-in-rust",
                "content": "These solutions are Rust implementations of these awesome solutions:\\n1. https://leetcode.com/problems/is-subsequence/discuss/87258/2-lines-Python\\n2. https://leetcode.com/problems/is-subsequence/discuss/87302/Binary-search-solution-for-follow-up-with-detailed-comments\\n\\n## Solution 1\\nIterator based approach\\n```\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let mut iter = t.chars();\\n        for c in s.chars() {\\n          match iter.find(|&p| p == c) {\\n            Some(_) => (),\\n            None => return false\\n          }\\n        }\\n        true\\n    }\\n}\\n```\\n\\n## Solution 2\\nBinary search solution\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n      let mut map: HashMap<char, Vec<usize>> = HashMap::new();\\n      for (i, c) in t.chars().enumerate() {\\n        match map.get_mut(&c) {\\n          Some(li) => { li.push(i); },\\n          None => { map.insert(c, vec![i]); }\\n        }\\n      }\\n      let mut prev = 0;\\n      for c in s.chars() {\\n        match map.get(&c) {\\n          None => return false,\\n          Some(li) => {\\n            match li.binary_search(&prev) {\\n              Ok(idx) => prev = li[idx] + 1,\\n              Err(ins_idx) => {\\n                if ins_idx == li.len() {\\n                  return false;\\n                }\\n                prev = li[ins_idx] + 1;\\n              }\\n            }\\n          }\\n        }\\n      }\\n      true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let mut iter = t.chars();\\n        for c in s.chars() {\\n          match iter.find(|&p| p == c) {\\n            Some(_) => (),\\n            None => return false\\n          }\\n        }\\n        true\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n      let mut map: HashMap<char, Vec<usize>> = HashMap::new();\\n      for (i, c) in t.chars().enumerate() {\\n        match map.get_mut(&c) {\\n          Some(li) => { li.push(i); },\\n          None => { map.insert(c, vec![i]); }\\n        }\\n      }\\n      let mut prev = 0;\\n      for c in s.chars() {\\n        match map.get(&c) {\\n          None => return false,\\n          Some(li) => {\\n            match li.binary_search(&prev) {\\n              Ok(idx) => prev = li[idx] + 1,\\n              Err(ins_idx) => {\\n                if ins_idx == li.len() {\\n                  return false;\\n                }\\n                prev = li[ins_idx] + 1;\\n              }\\n            }\\n          }\\n        }\\n      }\\n      true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87322,
                "title": "hashmap-binary-search-solution-for-the-follow-up-question",
                "content": "```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            char c = t.charAt(i);\\n            if (!map.containsKey(c)){\\n                map.put(c, new ArrayList<>());\\n            }\\n            map.get(c).add(i);\\n        }\\n        \\n        int prev = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!map.containsKey(c)) return false;\\n            int j = binarySearch(map.get(c), prev);\\n            if (j == map.get(c).size()) return false;\\n            prev = map.get(c).get(j) + 1;//search larger index\\n        }\\n        return true;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int target){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<=end){\\n            int middle = start + (end-start)/2;\\n            if(list.get(middle) < target){\\n                start = middle+1;\\n            }else if(list.get(middle) > target){\\n                end = middle-1;\\n            }else{\\n                return middle;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            char c = t.charAt(i);\\n            if (!map.containsKey(c)){\\n                map.put(c, new ArrayList<>());\\n            }\\n            map.get(c).add(i);\\n        }\\n        \\n        int prev = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!map.containsKey(c)) return false;\\n            int j = binarySearch(map.get(c), prev);\\n            if (j == map.get(c).size()) return false;\\n            prev = map.get(c).get(j) + 1;//search larger index\\n        }\\n        return true;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int target){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<=end){\\n            int middle = start + (end-start)/2;\\n            if(list.get(middle) < target){\\n                start = middle+1;\\n            }else if(list.get(middle) > target){\\n                end = middle-1;\\n            }else{\\n                return middle;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238316,
                "title": "python3-very-easy-solution",
                "content": "\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_index = 0\\n        t_index = 0\\n        \\n        while s_index < len(s) and t_index < len(t):\\n            if s[s_index] == t[t_index]:\\n                s_index += 1\\n            \\n            t_index += 1\\n        \\n        return s_index == len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        s_index = 0\\n        t_index = 0\\n        \\n        while s_index < len(s) and t_index < len(t):\\n            if s[s_index] == t[t_index]:\\n                s_index += 1\\n            \\n            t_index += 1\\n        \\n        return s_index == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678463,
                "title": "rust-2-liner",
                "content": "```\\npub fn is_subsequence(s: String, t: String) -> bool {\\n    let mut ti = t.chars();\\n    s.chars().all(|sc| ti.any(|tc| tc == sc))\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npub fn is_subsequence(s: String, t: String) -> bool {\\n    let mut ti = t.chars();\\n    s.chars().all(|sc| ti.any(|tc| tc == sc))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410816,
                "title": "java-two-approaches-linear-and-binary-search",
                "content": "```\\n// Linear: O(max(m,n))\\n    public boolean isSubsequence(String s, String t) {\\n        int i=0, j=0, m=s.length(), n=t.length(); \\n        while(i<m && j<n) {\\n            if(s.charAt(i) == t.charAt(j)) i++; \\n            j++; \\n        }\\n        return i == m; \\n    } \\n```\\n\\n```\\n// Binary Search: O(mlogn)\\n    private int binarySearch(List<Integer> list, int last) {\\n        int start=0, end=list.size()-1; \\n        int idx = -1; \\n        while(start<=end) {\\n            int mid = start + (end-start)/2;\\n            if(last < list.get(mid)) {\\n                idx = list.get(mid); \\n                end = mid-1; \\n            } else {\\n                start = mid+1; \\n            }\\n        }\\n        return idx; \\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n        List<Integer>[] indices = new ArrayList[256]; \\n        for(int i=0; i<t.length(); i++) {\\n            char ch = t.charAt(i); \\n            if(indices[ch] == null) indices[ch] = new ArrayList<Integer>(); \\n            indices[ch].add(i); \\n        }\\n        int last = -1; \\n        for(char ch : s.toCharArray()) {\\n            if(indices[ch] == null) return false; \\n            int idx = binarySearch(indices[ch], last); \\n            if(idx == -1) return false; \\n            last = idx; \\n        }\\n        return true; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// Linear: O(max(m,n))\\n    public boolean isSubsequence(String s, String t) {\\n        int i=0, j=0, m=s.length(), n=t.length(); \\n        while(i<m && j<n) {\\n            if(s.charAt(i) == t.charAt(j)) i++; \\n            j++; \\n        }\\n        return i == m; \\n    } \\n```\n```\\n// Binary Search: O(mlogn)\\n    private int binarySearch(List<Integer> list, int last) {\\n        int start=0, end=list.size()-1; \\n        int idx = -1; \\n        while(start<=end) {\\n            int mid = start + (end-start)/2;\\n            if(last < list.get(mid)) {\\n                idx = list.get(mid); \\n                end = mid-1; \\n            } else {\\n                start = mid+1; \\n            }\\n        }\\n        return idx; \\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n        List<Integer>[] indices = new ArrayList[256]; \\n        for(int i=0; i<t.length(); i++) {\\n            char ch = t.charAt(i); \\n            if(indices[ch] == null) indices[ch] = new ArrayList<Integer>(); \\n            indices[ch].add(i); \\n        }\\n        int last = -1; \\n        for(char ch : s.toCharArray()) {\\n            if(indices[ch] == null) return false; \\n            int idx = binarySearch(indices[ch], last); \\n            if(idx == -1) return false; \\n            last = idx; \\n        }\\n        return true; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076396,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-392-is-subsequence/\\n\\nExplanation Example with handwritten.\\nRecursive Approach\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article https://www.nileshblog.tech/leetcode-392-is-subsequence/\\n![image](https://assets.leetcode.com/users/images/c1505fec-1862-449f-905b-c2ae06e360cb_1695382603.2800555.png)\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-392-is-subsequence/\\n\\nExplanation Example with handwritten.\\nRecursive Approach\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article https://www.nileshblog.tech/leetcode-392-is-subsequence/\\n![image](https://assets.leetcode.com/users/images/c1505fec-1862-449f-905b-c2ae06e360cb_1695382603.2800555.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3756336,
                "title": "easy-algo",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sLen = s.length();\\n        int tLen = t.length();\\n        int j = 0;\\n        \\n        for (int i = 0; i < tLen && j < sLen; i++) {\\n            if (s.charAt(j) == t.charAt(i)) j++;\\n        }\\n\\n        return j == sLen;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sLen = s.length();\\n        int tLen = t.length();\\n        int j = 0;\\n        \\n        for (int i = 0; i < tLen && j < sLen; i++) {\\n            if (s.charAt(j) == t.charAt(i)) j++;\\n        }\\n\\n        return j == sLen;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478238,
                "title": "very-easy-o-n-intutive-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)   or O(size of t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0,c=0;\\n        while(i<s.size() and j<t.size()){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i<s.size())\\n        return 0;\\n\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0,c=0;\\n        while(i<s.size() and j<t.size()){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i<s.size())\\n        return 0;\\n\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479397,
                "title": "python-easy-solution",
                "content": "```\\ndef isSubsequence(self, s: str, t: str) -> bool:\\n        if not s:\\n            return True\\n        j=0\\n        for i in range(len(t)):\\n            if j<len(s) and t[i]==s[j]:\\n                j+=1     \\n            if j == len(s):\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isSubsequence(self, s: str, t: str) -> bool:\\n        if not s:\\n            return True\\n        j=0\\n        for i in range(len(t)):\\n            if j<len(s) and t[i]==s[j]:\\n                j+=1     \\n            if j == len(s):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1677865,
                "title": "easy-c-two-pointer-solution-faster-than-100-00-of-c-online-submissions",
                "content": "# Intution\\n\\nThe intution behind this is that we can **use two pointers, one for tracking the String s and another one for tracking String t.**\\nWe will iterate for both pointers while the are not reached till end. Lets take example -> \\ns = \"abc\", t = \"ahbgdc\"\\ni = 0,  j = 0\\nSo iteration will look something like this ->\\ncheck if s[i] = t[j] -> true, increment i\\ni = 1, j = 1\\ncheck if s[i] = t[j] -> false\\ni = 1, j = 2\\ncheck if s[i] = t[j] -> true, increment i\\ni = 2, j = 3\\ncheck if s[i] = t[j] -> false\\ni = 2, j = 4\\ncheck if s[i] = t[j] -> false\\ni = 2, j = 5\\ncheck if s[i] = t[j] -> true, increment i\\nbreak;\\n##### Now return true if i == s.length() else false -> this means that if we reached till end we have found a substring other wise t doesn\\'t had a substring.\\n\\n# Solution\\nBelow is the C++ Code ->\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length())\\n        {\\n            if(s[i] == t[j]) i++;\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n};\\n```\\n### If you liked the solution. Please Upvote it.\\uD83D\\uDE00\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.length() && j < t.length())\\n        {\\n            if(s[i] == t[j]) i++;\\n            j++;\\n        }\\n        return i == s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678797,
                "title": "straightforward-python-solution",
                "content": "Some of the most popular python solutions are a bit convoluted, so this is an attempt to write one that is easy to understand.\\n\\nWe use `index` to track our position in `s`. Whenever we encounter a letter in `t` which is the same as our current letter in `s` we increment `index`. If `index` reaches the length of `s` we know all of `s`\\'s characters were present in `t` in order.\\n\\n```\\ndef isSubsequence(self, s: str, t: str) -> bool:\\n    n = len(s)\\n    index = 0;\\n    for c in t:\\n        if index == n:\\n            break\\n        if c == s[index]:\\n            index += 1\\n    return n == index\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSubsequence(self, s: str, t: str) -> bool:\\n    n = len(s)\\n    index = 0;\\n    for c in t:\\n        if index == n:\\n            break\\n        if c == s[index]:\\n            index += 1\\n    return n == index\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 586348,
                "title": "simple-java-bottom-up-dp-solution",
                "content": "Recurrance Relation of isSubsequence will be \\n\\ndp[i][j] = { dp[i-1][j-1]  if s[i] == t[j]\\n                  dp[i-1][j-1] if s[i] != t[j]\\n\\n```\\npublic boolean isSubsequence(String s, String t) {\\n        boolean[][] dp = new boolean[s.length()+1][t.length()+1];\\n        \\n        //Empty string is subsequence of empty string\\n        dp[0][0] = true;\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            dp[i][0] = false; \\n        }\\n        \\n        for(int j=1; j<=t.length(); j++) {\\n            dp[0][j] = true;\\n        }\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            for(int j=1; j<=t.length(); j++) {\\n                if(s.charAt(i-1) == t.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = dp[i][j-1];\\n                }  \\n            }\\n        }\\n        \\n        return dp[s.length()][t.length()];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic boolean isSubsequence(String s, String t) {\\n        boolean[][] dp = new boolean[s.length()+1][t.length()+1];\\n        \\n        //Empty string is subsequence of empty string\\n        dp[0][0] = true;\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            dp[i][0] = false; \\n        }\\n        \\n        for(int j=1; j<=t.length(); j++) {\\n            dp[0][j] = true;\\n        }\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            for(int j=1; j<=t.length(); j++) {\\n                if(s.charAt(i-1) == t.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = dp[i][j-1];\\n                }  \\n            }\\n        }\\n        \\n        return dp[s.length()][t.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87327,
                "title": "simple-c-code-as-well-as-the-followup-solution",
                "content": "```\\n    bool isSubsequence(string s, string t) {\\n        int si= 0;\\n        for(int ti = 0; ti < t.size() && si < s.size(); ti++) {\\n            if(t[ti] == s[si]) si++;\\n        }\\n        return si == s.size();\\n    }\\n```\\nFollow up:\\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\\n\\nMy solution is to preprocessing, exactly constructing a hash map to store the positions for every character. Then scan the incoming string one by one, for every character, if there is no such character in the hash map, or the number of such character is greater than the original string, or most critically, the position is not behind the position of its previous character, it will return false. So I need another array to record the index for every character. The time complexity is just the sum of length of  incoming strings. If you have better solution, welcome to discuss!\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(string t):target(t) {\\n        for(int i = 0; i < t.length(); ++i) {\\n            posMap[t[i] - 'a'].push_back(i);\\n        }\\n    }\\n    \\n    vector<bool> isSubsequence(vector<string> strs) {\\n        int pre = -1;\\n        int index[26];\\n        vector<bool> ans;\\n        for(string str: strs) {\\n            memset(index, -1, sizeof(index));\\n            pre = -1;\\n            int i = 0;\\n            for(;i < str.size(); ++i) {\\n                int j = str[i] - 'a';\\n                if(posMap.find(j) == posMap.end() || posMap[j].size()<= index[j] + 1 || posMap[j][index[j] + 1] <= pre) {\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                pre = posMap[j][index[j] + 1];\\n                index[j]++;\\n            }\\n            if(i == str.size()) ans.push_back(true);\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    string target;\\n    unordered_map<int, vector<int> > posMap;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isSubsequence(string s, string t) {\\n        int si= 0;\\n        for(int ti = 0; ti < t.size() && si < s.size(); ti++) {\\n            if(t[ti] == s[si]) si++;\\n        }\\n        return si == s.size();\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(string t):target(t) {\\n        for(int i = 0; i < t.length(); ++i) {\\n            posMap[t[i] - 'a'].push_back(i);\\n        }\\n    }\\n    \\n    vector<bool> isSubsequence(vector<string> strs) {\\n        int pre = -1;\\n        int index[26];\\n        vector<bool> ans;\\n        for(string str: strs) {\\n            memset(index, -1, sizeof(index));\\n            pre = -1;\\n            int i = 0;\\n            for(;i < str.size(); ++i) {\\n                int j = str[i] - 'a';\\n                if(posMap.find(j) == posMap.end() || posMap[j].size()<= index[j] + 1 || posMap[j][index[j] + 1] <= pre) {\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                pre = posMap[j][index[j] + 1];\\n                index[j]++;\\n            }\\n            if(i == str.size()) ans.push_back(true);\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    string target;\\n    unordered_map<int, vector<int> > posMap;\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87443,
                "title": "1-liner-in-ruby",
                "content": "```\\ndef is_subsequence(s, t)\\n  File.fnmatch(s.gsub(//, \"*\"), t)\\nend\\n```\\nFor example I turn `ace` into `*a*c*e*`, which I can just feed to `fnmatch`.",
                "solutionTags": [],
                "code": "```\\ndef is_subsequence(s, t)\\n  File.fnmatch(s.gsub(//, \"*\"), t)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4074623,
                "title": "c-2-pointers-with-a-for-loop-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 pointers with a for loop\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code runtime 0ms Beats 100.00%\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n=s.size(), m=t.size();\\n        int i=0;\\n        for(int j=0; j<m; j++)  \\n            if (t[j]==s[i]) i++;\\n        if (i==n)   return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n=s.size(), m=t.size();\\n        int i=0;\\n        for(int j=0; j<m; j++)  \\n            if (t[j]==s[i]) i++;\\n        if (i==n)   return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074414,
                "title": "beats-100-and-easy-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = s.size();\\n        int j = t.size();\\n        int first=0;\\n        int second = 0;\\n\\n        while(second<j){\\n            if(s[first]==t[second]){\\n                first++; second++;\\n            }\\n            else\\n            second++;\\n        }\\n        if(first == i)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = s.size();\\n        int j = t.size();\\n        int first=0;\\n        int second = 0;\\n\\n        while(second<j){\\n            if(s[first]==t[second]){\\n                first++; second++;\\n            }\\n            else\\n            second++;\\n        }\\n        if(first == i)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074339,
                "title": "daily-leetcoding-challenge-september-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3669758,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        if(s==t)\\n        return true;\\n        int j=0;\\n        for(int i=0;i<t.length();i++){\\n            if(s[j]==t[i])\\n                j++;\\n            if(j==s.length())\\n               return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        if(s==t)\\n        return true;\\n        int j=0;\\n        for(int i=0;i<t.length();i++){\\n            if(s[j]==t[i])\\n                j++;\\n            if(j==s.length())\\n               return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525870,
                "title": "kotlin-2-pointer-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun isSubsequence(s: String, t: String): Boolean {\\n        var sIndex = 0\\n        var tIndex = 0\\n        while (sIndex < s.length && tIndex < t.length) {\\n            if (s[sIndex] == t[tIndex]) {\\n                sIndex++\\n            }\\n            tIndex++\\n        }\\n        return sIndex == s.length\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isSubsequence(s: String, t: String): Boolean {\\n        var sIndex = 0\\n        var tIndex = 0\\n        while (sIndex < s.length && tIndex < t.length) {\\n            if (s[sIndex] == t[tIndex]) {\\n                sIndex++\\n            }\\n            tIndex++\\n        }\\n        return sIndex == s.length\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440357,
                "title": "c-two-pointers-fast-and-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        if(s == \"\")\\n            return true;\\n        int idx = 0;\\n        for(int i = 0; i < t.Length && idx < s.Length; i++)\\n            if(t[i] == s[idx])\\n                ++idx;\\n        return idx == s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        if(s == \"\")\\n            return true;\\n        int idx = 0;\\n        for(int i = 0; i < t.Length && idx < s.Length; i++)\\n            if(t[i] == s[idx])\\n                ++idx;\\n        return idx == s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043803,
                "title": "golang-0ms-0mb-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc isSubsequence(s string, t string) bool {\\n\\n\\tk := 0\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\tif k < len(s) && s[k] == t[i] {\\n\\t\\t\\tk++\\n\\t\\t}\\n\\n\\t}\\n\\treturn len(s) == k\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSubsequence(s string, t string) bool {\\n\\n\\tk := 0\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\tif k < len(s) && s[k] == t[i] {\\n\\t\\t\\tk++\\n\\t\\t}\\n\\n\\t}\\n\\treturn len(s) == k\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930790,
                "title": "simple-1ms-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length() == 0){\\n            return true;\\n        }\\n        int is=0,it=0;\\n        while(it < t.length()){\\n            if(t.charAt(it) == s.charAt(is)){\\n                is++;\\n                if(is == s.length()){\\n                    return true;\\n                }\\n            }\\n            it++;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length() == 0){\\n            return true;\\n        }\\n        int is=0,it=0;\\n        while(it < t.length()){\\n            if(t.charAt(it) == s.charAt(is)){\\n                is++;\\n                if(is == s.length()){\\n                    return true;\\n                }\\n            }\\n            it++;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866107,
                "title": "supper-simply-readable",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public bool IsSubsequence(string s, string t) \\n    {\\n        if (s == String.Empty) \\n            return true;\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < t.Length; i++)\\n            if (count < s.Length && s[count] == t[i])\\n                count++;\\n                    \\n        return count == s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsSubsequence(string s, string t) \\n    {\\n        if (s == String.Empty) \\n            return true;\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < t.Length; i++)\\n            if (count < s.Length && s[count] == t[i])\\n                count++;\\n                    \\n        return count == s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782964,
                "title": "java-runtime-1ms-faster-than-92-49-memory-usage-less-than-94-72",
                "content": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sub = 0, word = 0;\\n        while (sub < s.length() && word < t.length()) {\\n            if (s.charAt(sub) == t.charAt(word)) {\\n                sub++;\\n            }\\n            word++;\\n        }\\n        return sub == s.length();\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2d127fc3-7e94-4427-aea4-e7782520c8e2_1667703561.1194513.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sub = 0, word = 0;\\n        while (sub < s.length() && word < t.length()) {\\n            if (s.charAt(sub) == t.charAt(word)) {\\n                sub++;\\n            }\\n            word++;\\n        }\\n        return sub == s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327604,
                "title": "ruby-simple-two-cursors",
                "content": "```\\n# @param {String} s\\n# @param {String} t\\n# @return {Boolean}\\ndef is_subsequence(s, t)\\n    i = 0\\n    n = 0\\n    \\n    while i < s.length && n < t.length\\n        if s[i] == t[n]\\n            i += 1\\n        end\\n        n += 1\\n    end\\n    i == s.length\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Two Pointers"
                ],
                "code": "```\\n# @param {String} s\\n# @param {String} t\\n# @return {Boolean}\\ndef is_subsequence(s, t)\\n    i = 0\\n    n = 0\\n    \\n    while i < s.length && n < t.length\\n        if s[i] == t[n]\\n            i += 1\\n        end\\n        n += 1\\n    end\\n    i == s.length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2195456,
                "title": "2-lines-solution-with-linear-time-and-description-99-46-48-40",
                "content": "Code:\\n```\\nconst isSubsequence = (s: string, t: string): boolean => {\\n  const counter = t.split(\\'\\').reduce<number>((acc, el) => s[acc] === el ? acc += 1 : acc, 0)\\n\\n  return counter === s.length\\n};\\n```\\nDescription:\\nThe main logic is understood how many times we met each element of the subsequence at the string and compare the number with subsequence\\'s length.\\nTo first iteration `counter` is 0 and we are comparing first letter of the subsequence by first letter of the string.\\nIf we find equality, we increase the counter. (It means that on the second iteration ` counter` will be 1 and we\\'ll compare second letter of the subsequence with the second letter of the string)\\nIf not, just skip this iteration. (It means that on the second iteration ` counter` will be 0 and we\\'ll compare first letter of the subsequence with the second letter of the string)\\n\\nI did all logic at `reduce` but you can do the same with a variable and `for` loop\\n```\\nconst isSubsequence = (s: string, t: string): boolean => {\\n  let counter = 0;\\n  \\n  for (let i = 0; i < t.length; i++) {\\n\\t  if (s[counter] === t[i]) counter++\\n  }\\n  \\n  return counter === s.length\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst isSubsequence = (s: string, t: string): boolean => {\\n  const counter = t.split(\\'\\').reduce<number>((acc, el) => s[acc] === el ? acc += 1 : acc, 0)\\n\\n  return counter === s.length\\n};\\n```\n```\\nconst isSubsequence = (s: string, t: string): boolean => {\\n  let counter = 0;\\n  \\n  for (let i = 0; i < t.length; i++) {\\n\\t  if (s[counter] === t[i]) counter++\\n  }\\n  \\n  return counter === s.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816972,
                "title": "c-best-solution-100-fast-with-easy-code",
                "content": "```\\n  bool isSubsequence(string s, string t) {\\n        int count=0;\\n       int i=0;\\n           for(int j=0; j<t.length();j++)\\n           {\\n               if(s[i]==t[j])\\n               {\\n                   count++;\\n                   i++;\\n               }\\n           }  \\n       \\n        if(count==s.length())\\n            return true;\\n     return false;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  bool isSubsequence(string s, string t) {\\n        int count=0;\\n       int i=0;\\n           for(int j=0; j<t.length();j++)\\n           {\\n               if(s[i]==t[j])\\n               {\\n                   count++;\\n                   i++;\\n               }\\n           }  \\n       \\n        if(count==s.length())\\n            return true;\\n     return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283046,
                "title": "dynamic-programming-0ms",
                "content": "**DO UPVOTE IF USEFUL**\\n```\\nclass Solution {\\npublic:\\n    string LCS(string x, string y){\\n        int n=x.size(),m=y.size();\\n        int t[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0)\\n                    t[i][j]=0;\\n            }\\n        \\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++){\\n                if(x[i-1]==y[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        \\n        int i=n,j=m;\\n        string S=\"\";\\n        while(i>0 && j>0){\\n\\t\\tif(x[i-1]==y[j-1]){\\n\\t\\t\\tS.push_back(x[i-1]);\\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(t[i][j-1]>t[i-1][j])\\n\\t\\t\\t\\tj--;\\n\\t\\t\\telse\\n\\t\\t\\t\\ti--;\\n\\t\\t}\\n\\t}\\n\\treverse(S.begin(),S.end());\\n\\treturn S;\\n    }\\n    bool isSubsequence(string s, string t) {\\n        if(LCS(s,t)==s)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string LCS(string x, string y){\\n        int n=x.size(),m=y.size();\\n        int t[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0)\\n                    t[i][j]=0;\\n            }\\n        \\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++){\\n                if(x[i-1]==y[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        \\n        int i=n,j=m;\\n        string S=\"\";\\n        while(i>0 && j>0){\\n\\t\\tif(x[i-1]==y[j-1]){\\n\\t\\t\\tS.push_back(x[i-1]);\\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(t[i][j-1]>t[i-1][j])\\n\\t\\t\\t\\tj--;\\n\\t\\t\\telse\\n\\t\\t\\t\\ti--;\\n\\t\\t}\\n\\t}\\n\\treverse(S.begin(),S.end());\\n\\treturn S;\\n    }\\n    bool isSubsequence(string s, string t) {\\n        if(LCS(s,t)==s)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129670,
                "title": "java-2-approches",
                "content": "**Approch 1:** `Two-Pointers`\\n**CODE:**\\n```\\n    public boolean isSubsequence(String s, String t) {\\n         int i=0;\\n         int j=0;\\n        \\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.length()) return true;\\n        return false;\\n    }\\n```\\t\\n**Complexity :** `Time:O(n) and Space:O(1)`\\n\\n**Approch 2:** Application of [LCS](https://leetcode.com/problems/longest-common-subsequence/)\\n-> just find LCS and check if its equal to s.length() then s is subsequence of t\\n**CODE:**\\n```\\npublic int isSubsequence(String s,String t){\\n   int lcs=LCS(s,t);\\n   return lcs==s.length();\\n}\\n\\nprivate int LCS(String text1, String text2) {\\n        int[][] dp=new int[text1.length()+1][text2.length()+1];\\n        \\n        for(int i=1;i<dp.length;i++){\\n            for(int j=1;j<dp[0].length;j++){\\n                if(text1.charAt(i-1)==text2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[text1.length()][text2.length()];\\n    }\\n```\\t\\n**COMPLEXITY:** `Time:O(n^2) and Space:O(n^2)\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public boolean isSubsequence(String s, String t) {\\n         int i=0;\\n         int j=0;\\n        \\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.length()) return true;\\n        return false;\\n    }\\n```\n```\\npublic int isSubsequence(String s,String t){\\n   int lcs=LCS(s,t);\\n   return lcs==s.length();\\n}\\n\\nprivate int LCS(String text1, String text2) {\\n        int[][] dp=new int[text1.length()+1][text2.length()+1];\\n        \\n        for(int i=1;i<dp.length;i++){\\n            for(int j=1;j<dp[0].length;j++){\\n                if(text1.charAt(i-1)==text2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[text1.length()][text2.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014566,
                "title": "java-0ms-greedy",
                "content": "```\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.isEmpty()) return true;\\n        int match = 0;\\n        for (char ch: t.toCharArray()) {\\n            if (s.charAt(match) == ch && ++match >= s.length()) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.isEmpty()) return true;\\n        int match = 0;\\n        for (char ch: t.toCharArray()) {\\n            if (s.charAt(match) == ch && ++match >= s.length()) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678943,
                "title": "simple-python-solution-using-2-pointers",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n\\n        pS=0\\n        pT=0\\n        \\n        while pT<len(t) and pS<len(s) :\\n            if s[pS] == t[pT]:\\n                pS+=1\\n            pT+=1\\n\\t\\t\\t\\n        return pS==len(s)          \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n\\n        pS=0\\n        pT=0\\n        \\n        while pT<len(t) and pS<len(s) :\\n            if s[pS] == t[pT]:\\n                pS+=1\\n            pT+=1\\n\\t\\t\\t\\n        return pS==len(s)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 678577,
                "title": "java-100-faster-easy-solution-using-indexof",
                "content": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t){\\n        int curidx = -1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            curidx = t.indexOf(s.charAt(i),curidx+1);\\n                if(curidx==-1)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nDO UPVOTE IF THIS HELPS",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t){\\n        int curidx = -1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            curidx = t.indexOf(s.charAt(i),curidx+1);\\n                if(curidx==-1)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678311,
                "title": "two-pointer-approach-o-1-memory-o-n-time",
                "content": "we need to find whether \"s\" is subsequence of \"t\" or not, \\nmaintain two pointers, one for string_S and another for String_T and while traversing string_T check the presence of characters of string_S in string_T in order, ( SUBSEQUESNCE - ie may not be continous)\\n```\\nbool isSubsequence(string s, string t) {\\n        \\n        int i,j,n,m;\\n        n = s.size();\\n        m = t.size();\\n        i=j=0;\\n        \\n        while(i<n and j<m)\\n        {\\n            if(s[i]==t[j])       // increment i pointer as we have found a match\\n                i++;\\n            j++;\\n        }\\n        \\n        return i==n;    // return whether we have found all the matches or not\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSubsequence(string s, string t) {\\n        \\n        int i,j,n,m;\\n        n = s.size();\\n        m = t.size();\\n        i=j=0;\\n        \\n        while(i<n and j<m)\\n        {\\n            if(s[i]==t[j])       // increment i pointer as we have found a match\\n                i++;\\n            j++;\\n        }\\n        \\n        return i==n;    // return whether we have found all the matches or not\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423566,
                "title": "python3-4-solutions-quickest-99-98-shortest-two-lines",
                "content": "There are 4+ ways in Python to do string search\\n1) `in` operator\\n2) `string.find()` method\\n3) `string.index()` method\\n4) regex\\n\\nTo utilize `in` operator (80.12%), we can leverage on Python iterator. As an iterator can only be used once, we can sequentially look for characters of `s` in `t` as below, which guarantees that two characters `c1` and `c2` in `s` whose positions `i1` and `i2` satisfying `i1 < i2` have the same order in `t` if found. \\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        it = iter(t)\\n        return all(ch in it for ch in s)\\n```\\nThe `string.find()` method (99.54%) provides an optional `start` argument which indicates the position from which the search begins. When searching for next character in `s`, we can update the `start` to be position of last character shifted by 1. \\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        k = 0\\n        for c in s:\\n            k = t.find(c, k) + 1\\n            if k == 0: return False\\n        return True \\n```\\nThe `string.index()` method (99.54%) is identical to `string.find()` method except that it raises `ErrorValue` if search fails while `string.find()` returns -1. \\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        k = 0\\n        for c in s:\\n            try: k = t.index(c, k) + 1\\n            except: return False\\n        return True \\n```\\nThis problem shouldn\\'t be the best example of using regex, and yet this gives the quickest solution (99.98%). Using regex, we have to copy a shorter substring to `t` to reflect that a character is found. \\n```\\nimport re\\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            try: k = re.search(c, t).start()\\n            except: return False\\n            t = t[k+1:]\\n        return True \\n```\\nThe performance statistics surprise me \\n1) `in`, `string.find()` and `string.index()` really implement the same method (Boyer-Moore-Horspool I believe), and yet `in` is systematically slower than the other two;\\n2) with all the overhead of regex and repeated string copying, I\\'d expect regex to be the slowest solution and yet it is the fastest here. \\n\\nIf anyone has any opinion to explain these observations, please share. Thanks!\\n\\nA naive solution is added below \\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        for c in t: \\n            if i < len(s) and s[i] == c: i += 1\\n        return i == len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        it = iter(t)\\n        return all(ch in it for ch in s)\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        k = 0\\n        for c in s:\\n            k = t.find(c, k) + 1\\n            if k == 0: return False\\n        return True \\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        k = 0\\n        for c in s:\\n            try: k = t.index(c, k) + 1\\n            except: return False\\n        return True \\n```\n```\\nimport re\\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            try: k = re.search(c, t).start()\\n            except: return False\\n            t = t[k+1:]\\n        return True \\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        for c in t: \\n            if i < len(s) and s[i] == c: i += 1\\n        return i == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87321,
                "title": "java-code-for-the-problem-two-pointer-and-the-follow-up-binary-search",
                "content": "```\\npublic class Solution {\\n    //two pointer: only one input string\\n    public boolean isSubsequence(String s, String t) {\\n        if(s == null) return true;\\n        if(t == null) return false;\\n        \\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            j = t.indexOf(s.charAt(i), j);\\n            if (j < 0) return false;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    //Follow up: Binary search for multiple coming string\\n    public boolean isSubsequence(String s, String t) {\\n        //O(t.length())\\n        Map<Character, List<Integer>> myMap = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            if (!myMap.containsKey(t.charAt(i))) {\\n                myMap.put(t.charAt(i), new ArrayList<Integer>());\\n            }\\n            myMap.get(t.charAt(i)).add(i);\\n        }\\n        \\n        //search: O(s.length() * log(t.length()))\\n        int index = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch= s.charAt(i);\\n\\n            int nextIndex = getNextIndex(myMap.get(ch), index);\\n            if (nextIndex < 0) return false;\\n            index = nextIndex;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int getNextIndex(List<Integer> list, int index) {\\n        if (list == null) return -1;\\n        int left = 0, right = list.size() - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid) <= index) left = mid + 1;\\n            else right = mid;\\n        }\\n        \\n        return list.get(left) > index ? list.get(left) : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //two pointer: only one input string\\n    public boolean isSubsequence(String s, String t) {\\n        if(s == null) return true;\\n        if(t == null) return false;\\n        \\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            j = t.indexOf(s.charAt(i), j);\\n            if (j < 0) return false;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    //Follow up: Binary search for multiple coming string\\n    public boolean isSubsequence(String s, String t) {\\n        //O(t.length())\\n        Map<Character, List<Integer>> myMap = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            if (!myMap.containsKey(t.charAt(i))) {\\n                myMap.put(t.charAt(i), new ArrayList<Integer>());\\n            }\\n            myMap.get(t.charAt(i)).add(i);\\n        }\\n        \\n        //search: O(s.length() * log(t.length()))\\n        int index = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch= s.charAt(i);\\n\\n            int nextIndex = getNextIndex(myMap.get(ch), index);\\n            if (nextIndex < 0) return false;\\n            index = nextIndex;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int getNextIndex(List<Integer> list, int index) {\\n        if (list == null) return -1;\\n        int left = 0, right = list.size() - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid) <= index) left = mid + 1;\\n            else right = mid;\\n        }\\n        \\n        return list.get(left) > index ? list.get(left) : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87301,
                "title": "a-possible-solution-regarding-to-t-is-very-long-and-the-follow-up-lots-of-incoming-s",
                "content": "I think this basic idea is to reuse string T and make the complexity of each query of S mainly dominated by the length of S. Here is the summary of my solution:\\n\\n1. We record the position indexs of every letter appearing in T separately and naturally in ascending order. (This only need to be done once for multiple queries.)\\n2. For an incoming S, we iterate through every char in S. For char S[i], we go to its position index list and see if we can find a feasible index, i.e., a position that is beyond the position chose for S[i-1] (maintained by endPos). If yes, we update endPos and move to S[i+1]; otherwise, we fail. \\n3. Further improvement: We can accelerate the creation of index lists from T by using paralleling processing. Every machine is responsible for a part of T and generate a paritial index lists. After all machines finish, we merge those partial index lists together, which is actually easy. \\n\\n\\nHere is the code:\\n```\\npublic class Solution {\\n    // Position index list for each letter appearing in t. \\n    // These lists can be reused for multiple queries with different input string s.\\n    List<List<Integer>> charIndexLists = new ArrayList<List<Integer>>();\\n    \\n    public boolean isSubsequence(String s, String t) {\\n        // Create position index list for each letter in t.\\n        // IMPORTANT: This part only need to be done ONCE for multiple queries.\\n        for (int i=0;i<26;i++){\\n            charIndexLists.add(new ArrayList<Integer>());\\n        }\\n        char[] tCharArr = t.toCharArray();\\n        for (int i=0;i<t.length();i++){\\n            charIndexLists.get(tCharArr[i]-'a').add(i);\\n        }\\n        \\n        // Check if we can find a feasible sequence of indexs in charIndexLists mathcing to s.\\n        char[] sCharArr = s.toCharArray();\\n        int[] pLists = new int[26];\\n        int endPos = -1;\\n        for (int i=0;i<s.length();i++){\\n            // Find out the next available position of current char, i.e., \\n            // sCharArr[i] should appeear somewhere after endPos. \\n            int curIndex = sCharArr[i]-'a';\\n            List<Integer> curIndexList = charIndexLists.get(curIndex);\\n            while (pLists[curIndex] < curIndexList.size() && curIndexList.get(pLists[curIndex]) <= endPos){\\n                pLists[curIndex]++;\\n            }\\n            // Cannot find any required char that appears after endPos, fails\\n            if (pLists[curIndex] == curIndexList.size()){\\n                return false;\\n            }\\n            // Update endPos.\\n            endPos = curIndexList.get(pLists[curIndex]);\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // Position index list for each letter appearing in t. \\n    // These lists can be reused for multiple queries with different input string s.\\n    List<List<Integer>> charIndexLists = new ArrayList<List<Integer>>();\\n    \\n    public boolean isSubsequence(String s, String t) {\\n        // Create position index list for each letter in t.\\n        // IMPORTANT: This part only need to be done ONCE for multiple queries.\\n        for (int i=0;i<26;i++){\\n            charIndexLists.add(new ArrayList<Integer>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4090380,
                "title": "two-simple-java-solutions-runtime-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```Java\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0 , count = 0;\\n            for (char c : s.toCharArray())\\n            {\\n                for ( ;j < t.length(); j++) {\\n                    if (c == t.charAt(j))\\n                    {\\n                        count++;\\n                        j++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return (count == s.length());\\n    }\\n}\\n```\\n\\n# Code2\\n```Java\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIndex = 0, tIndex = 0;\\n        \\n        while (sIndex < s.length() && tIndex < t.length()) {\\n            if (s.charAt(sIndex) == t.charAt(tIndex)) {\\n                sIndex++;\\n            }\\n            tIndex++;\\n        }\\n        \\n        return sIndex == s.length();\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/25f63b39-b6d0-403f-bf78-b5873d3d4aed_1695673809.8211854.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0 , count = 0;\\n            for (char c : s.toCharArray())\\n            {\\n                for ( ;j < t.length(); j++) {\\n                    if (c == t.charAt(j))\\n                    {\\n                        count++;\\n                        j++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return (count == s.length());\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIndex = 0, tIndex = 0;\\n        \\n        while (sIndex < s.length() && tIndex < t.length()) {\\n            if (s.charAt(sIndex) == t.charAt(tIndex)) {\\n                sIndex++;\\n            }\\n            tIndex++;\\n        }\\n        \\n        return sIndex == s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074836,
                "title": "easy-solution-c-explanation-beat-99-7",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply check is `s[i] == t[j]` \\nIf yes then do `i++`\\nIf `i == s.size()` then return true\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0;\\n        int n = s.size();\\n        int m = t.size();\\n\\n        if(n == 0)\\n            return true;\\n        if(n > m)\\n            return false;\\n\\n        for(int j = 0; j < m; j++){\\n            if(s[i] == t[j])\\n                i++;\\n            if(i == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/088487e1-6241-404f-bc6b-abb48ade2aa0_1695356805.1028326.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0;\\n        int n = s.size();\\n        int m = t.size();\\n\\n        if(n == 0)\\n            return true;\\n        if(n > m)\\n            return false;\\n\\n        for(int j = 0; j < m; j++){\\n            if(s[i] == t[j])\\n                i++;\\n            if(i == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657332,
                "title": "faster-than-100-in-cpp-java-python-tc-o-n-sc-o-1-two-pointer-easy-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code checks if string s is a subsequence of string t. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code iterates through each character of both strings s and t. It uses two pointers, i and j, to keep track of the current position in t and s, respectively.\\n\\nThe code compares s[j] with t[i] at each iteration. If they are equal, it means that the character s[j] is present in t, so it moves the pointer j to the next character in s.\\n\\nAfter iterating through all characters in t or s, it checks if j is equal to the length of s. If j is equal to s.length(), it means all characters of s have been found in t in the same order, and hence s is a subsequence of t.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of string t. The code iterates through each character of t once, and the iteration stops if all characters of s have been found or if the end of t is reached.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1), as it only uses a constant amount of additional space for the two integer variables i and j.\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0;\\n        for (int i = 0; i < t.length() && j < s.length(); i++) {\\n            if (s.charAt(j) == t.charAt(i)) {\\n                j++;\\n            }\\n        }\\n        return j == s.length();\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int sl=s.length(), tl = t.length();\\n       int j =0;\\n       for(int i =0; i<tl and j<sl; i++)\\n       {\\n           if(s[j]==t[i]) j++;\\n       }\\n       return (j==sl);\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        j = 0\\n        for i in range(len(t)):\\n            if j < len(s) and s[j] == t[i]:\\n                j += 1\\n        return j == len(s)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "String"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j = 0;\\n        for (int i = 0; i < t.length() && j < s.length(); i++) {\\n            if (s.charAt(j) == t.charAt(i)) {\\n                j++;\\n            }\\n        }\\n        return j == s.length();\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int sl=s.length(), tl = t.length();\\n       int j =0;\\n       for(int i =0; i<tl and j<sl; i++)\\n       {\\n           if(s[j]==t[i]) j++;\\n       }\\n       return (j==sl);\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        j = 0\\n        for i in range(len(t)):\\n            if j < len(s) and s[j] == t[i]:\\n                j += 1\\n        return j == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347967,
                "title": "simple-javascript-100-easy-explanation-90-beats",
                "content": "\\n# Approach\\nThis code checks whether a given string s is a subsequence of another string t.\\n\\nIt does so by iterating over each character in s and searching for it in t. The indexOf method is used to search for the current character, starting from the index of the most recent occurrence of the previous character in t. If the current character is found at an index greater than the index of the previous occurrence, then it is a valid subsequence. If not, then s is not a subsequence of t.\\n\\nThe code keeps track of the index of the most recent occurrence of the previous character in t using the currentIndex variable. If the index of the current character in t is greater than currentIndex, then currentIndex is updated to the index of the current character. If the index of the current character in t is less than or equal to currentIndex, then s is not a subsequence of t.\\n\\nFinally, if all characters in s are found in t in the correct order, the function returns true. Otherwise, it returns false.\\n\\n# Complexity\\n\\nTime complexity: O(s+t), where s and t are the length of the string s and t.\\n\\nSpace complexity: O(1).\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function (s, t) {\\n  let currentIndex = -1;\\n  for (let i = 0; i < s.length; i++) {\\n    const target = t.indexOf(s[i], currentIndex + 1);\\n    if (target > currentIndex) {\\n      currentIndex = target;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function (s, t) {\\n  let currentIndex = -1;\\n  for (let i = 0; i < s.length; i++) {\\n    const target = t.indexOf(s[i], currentIndex + 1);\\n    if (target > currentIndex) {\\n      currentIndex = target;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3284716,
                "title": "stack-method-2ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        Stack <Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++){\\n            stack.push(s.charAt(i));\\n        }\\n        for(int i = t.length() - 1; i >= 0 && stack.size() > 0; i--){\\n            if (t.charAt(i) == stack.peek()){\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        Stack <Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++){\\n            stack.push(s.charAt(i));\\n        }\\n        for(int i = t.length() - 1; i >= 0 && stack.size() > 0; i--){\\n            if (t.charAt(i) == stack.peek()){\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243215,
                "title": "javascript-easy-solution-62ms-for-loop",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n```\\n\\nconst isSubsequence = (s, t, index = 0) => {\\n\\n    if (s.length > t.length) return false;\\n\\n    for (let i = 0; i < t.length; i++) {\\n        if (s[index] == t[i]) {\\n            index++;\\n            if (index == s.length) break;\\n        }\\n    }\\n    return s.length === index;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n\\nconst isSubsequence = (s, t, index = 0) => {\\n\\n    if (s.length > t.length) return false;\\n\\n    for (let i = 0; i < t.length; i++) {\\n        if (s[index] == t[i]) {\\n            index++;\\n            if (index == s.length) break;\\n        }\\n    }\\n    return s.length === index;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3136431,
                "title": "beats-100-2-lines-code-beginer-friendly-very-easy-understanding-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length()){\\n            if(t[j++]==s[i]) i++;\\n        }\\n        if(i==s.length()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length()){\\n            if(t[j++]==s[i]) i++;\\n        }\\n        if(i==s.length()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039760,
                "title": "simplest-c-code-0ms-runtime-beats-100",
                "content": "# Intuition\\nBasic Linear Searching with some conditions will do the trick\\n\\n# Approach\\n- Create a new string ***str***\\n- Then, search linearly and see if any character in ***s string* **matches the one with ***t string\\'s*** character.\\n- if it does, then ***push_back*** it to the ***str* **string\\n- after the loop completes, check if ***str==s***\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int strCount = 0;\\n        int start = 0,end = t.length();\\n\\n        string str;\\n\\n        while(start < end && strCount < s.length()){\\n            if(s[strCount] == t[start]){\\n                str.push_back(t[start]);\\n                strCount++;\\n            }\\n\\n            start++;\\n\\n        }\\n\\n        if(s==str)\\n            return true;\\n        else\\n            return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int strCount = 0;\\n        int start = 0,end = t.length();\\n\\n        string str;\\n\\n        while(start < end && strCount < s.length()){\\n            if(s[strCount] == t[start]){\\n                str.push_back(t[start]);\\n                strCount++;\\n            }\\n\\n            start++;\\n\\n        }\\n\\n        if(s==str)\\n            return true;\\n        else\\n            return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276751,
                "title": "java-solution-with-clear-comments-faster-93-memory-less-94",
                "content": "We will use the two-pointer approach. One pointer is fast, i, which is needed to walk through the text. The second pointer is slow, j, which is needed to pass through the sample. Detailed and step-by-step explanation can be found in the code comments. \\nThank you for taking the time to see my solution. \\n**If you like it, please upvote it :)**\\n\\n\\n\\tpublic static boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0){\\n            return true; // if length of sample equals 0, we return true, because any text includes \"\";\\n        }\\n        if(s.length() > t.length()){\\n            return false; // If sample length larger than text length, we return false, because a smaller string cannot contain a larger string\\n        }\\n        int j = 0; // slow pointer for sample string\\n        for(int i = 0; i<t.length() ; i++){ // for loop for text string, we check every char of text string\\n            if(t.charAt(i) == s.charAt(j)){ // if we find a char which equals j char at sample string, then we increase our slow pointer,\\n                // for find the next character in sample, which equals character in text\\n                j++;\\n            }\\n            /*\\n            If our slow pointer j is equal to the length of sample,\\n             it means that the number of occurrences in text in order was equal to the number of characters in sample,\\n              so text contains sample\\n             */\\n            if(j == s.length()) { //if\\n                return true;\\n            }\\n\\n        }\\n        /*\\n        If, after going through each character of text, our slow pointer does not equal the length of sample,\\n         then text definitely doesn\\'t contain sample and we return false\\n         */\\n        return false;\\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "We will use the two-pointer approach. One pointer is fast, i, which is needed to walk through the text. The second pointer is slow, j, which is needed to pass through the sample. Detailed and step-by-step explanation can be found in the code comments. \\nThank you for taking the time to see my solution. \\n**If you like it, please upvote it :)**\\n\\n\\n\\tpublic static boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0){\\n            return true; // if length of sample equals 0, we return true, because any text includes \"\";\\n        }\\n        if(s.length() > t.length()){\\n            return false; // If sample length larger than text length, we return false, because a smaller string cannot contain a larger string\\n        }\\n        int j = 0; // slow pointer for sample string\\n        for(int i = 0; i<t.length() ; i++){ // for loop for text string, we check every char of text string\\n            if(t.charAt(i) == s.charAt(j)){ // if we find a char which equals j char at sample string, then we increase our slow pointer,\\n                // for find the next character in sample, which equals character in text\\n                j++;\\n            }\\n            /*\\n            If our slow pointer j is equal to the length of sample,\\n             it means that the number of occurrences in text in order was equal to the number of characters in sample,\\n              so text contains sample\\n             */\\n            if(j == s.length()) { //if\\n                return true;\\n            }\\n\\n        }\\n        /*\\n        If, after going through each character of text, our slow pointer does not equal the length of sample,\\n         then text definitely doesn\\'t contain sample and we return false\\n         */\\n        return false;\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2166528,
                "title": "javascript-solution-with-5-lines",
                "content": "```\\nvar isSubsequence = function(s, t) {\\n    let cnt=0;\\n    for(let char of t)\\n        if(char === s[cnt])\\n            cnt++;        \\n    return cnt===s.length?true:false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSubsequence = function(s, t) {\\n    let cnt=0;\\n    for(let char of t)\\n        if(char === s[cnt])\\n            cnt++;        \\n    return cnt===s.length?true:false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1835429,
                "title": "python-easy-solution-o-n-97-faster",
                "content": "```\\nl,r=0,0 # l will iterate over s and r will iterate over t\\n        count = 0\\n        while l<len(s) and r<len(t):\\n            if s[l] == t[r]: #if char of s matches with that of t, increment counter and move to next char of s\\n                l +=1\\n                count +=1\\n            r+=1\\n        return count == len(s) #count will be equal to len of s when the char of s come in same order in t\\n```\\nUpvote if u found it helpful",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nl,r=0,0 # l will iterate over s and r will iterate over t\\n        count = 0\\n        while l<len(s) and r<len(t):\\n            if s[l] == t[r]: #if char of s matches with that of t, increment counter and move to next char of s\\n                l +=1\\n                count +=1\\n            r+=1\\n        return count == len(s) #count will be equal to len of s when the char of s come in same order in t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813592,
                "title": "c-easy-solution",
                "content": "```\\n    public bool IsSubsequence(string s, string t) {\\n            if (s.Length == 0)\\n                return true;\\n\\n            int j = 0;\\n            for (int i = 0; i < t.Length; i++){\\n                if (t[i] == s[j]) j++;\\n                if(j == s.Length)  return true;\\n            } \\n                \\n            return j == s.Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool IsSubsequence(string s, string t) {\\n            if (s.Length == 0)\\n                return true;\\n\\n            int j = 0;\\n            for (int i = 0; i < t.Length; i++){\\n                if (t[i] == s[j]) j++;\\n                if(j == s.Length)  return true;\\n            } \\n                \\n            return j == s.Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1812281,
                "title": "c-o-n-easy-understanding",
                "content": "The idea is to check whether elements of s are presentt inside t one after other without traversing whole string t several times to maintain the order.\\n```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n      int count=0; \\n      int i=0,j=0;\\n      \\n      \\n      while(j<t.length())\\n      {\\n        if(s[i]==t[j])\\n        {\\n          count++;\\n          i++;\\n          \\n        }\\n        j++;\\n      }\\n      \\n     return (count==s.length());         // if its true it will return true else false\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n      int count=0; \\n      int i=0,j=0;\\n      \\n      \\n      while(j<t.length())\\n      {\\n        if(s[i]==t[j])\\n        {\\n          count++;\\n          i++;\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1811512,
                "title": "100-faster-c-bigo-n-easy-approach",
                "content": "**Approach:** we will iterate the string t and take an integer pos (intialize to 0) which will take the postion in \\'s\\' substring.\\n\\n*in iteration*: if t[i] == s[pos], the we will increase the pos.\\n\\nat the end we just return if (pos == s.length) or not.\\n\\n```\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int pos = 0;\\n        for(int i = 0;i <t.length();i++){\\n            if(t[i]==s[pos]){\\n                pos++;\\n\\t\\t\\t\\tif(pos==s.length())return true;\\n            }\\n        }\\n        return (pos == s.length());\\n    }\\n};\\n```\\nupvote if you like",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int pos = 0;\\n        for(int i = 0;i <t.length();i++){\\n            if(t[i]==s[pos]){\\n                pos++;\\n\\t\\t\\t\\tif(pos==s.length())return true;\\n            }\\n        }\\n        return (pos == s.length());\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307812,
                "title": "2-solutions-dp-two-pointers-asked-by-amazon-visa-zoho-with-complexities",
                "content": "* ### **DP SOLUTION: BOTTOM-UP or TABULATION (Accepted)` [NAIVE SOLUTION]`**\\n* **Runtime : 40ms**\\n*  **PREREQUISITE : `LONGEST COMMON SUBSEQUENCE (LCS)`**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for(int i = 1; i <= n; ++i){\\n            for(int j = 1; j <= m; ++j){\\n                if(s[i - 1] == t[j - 1])\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        int lcslen = dp[n][m];\\n        return lcslen == n? true : false;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where,, n = size of string1 & m = size of string2** \\n**SPACE COMPLEXITY : `O(n * m)`, For using 2D array Aux space**\\n```\\n```\\n* ### **TWO POINTERS  APPROACH (Accepted)` [Efficient Solution]`**\\n* **Runtime : 0ms**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.size(),  m = t.size();\\n        int i = 0, j = 0;\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return i == n? true : false;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n + m) == O(m)`, Where,, n = size of string1 & m = size of string2** \\n**SPACE COMPLEXITY : `O(constant)`**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to **Upvote**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for(int i = 1; i <= n; ++i){\\n            for(int j = 1; j <= m; ++j){\\n                if(s[i - 1] == t[j - 1])\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        int lcslen = dp[n][m];\\n        return lcslen == n? true : false;\\n    }\\n};\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n = s.size(),  m = t.size();\\n        int i = 0, j = 0;\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return i == n? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306934,
                "title": "simple-javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n    const sStack = new Array()\\n    for (const ch of s) {\\n        sStack.push(ch)\\n    }\\n    for (const ch of t) {\\n        if (ch === sStack[0]) {\\n            sStack.shift()\\n        }\\n    }\\n    \\n    return sStack.length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isSubsequence = function(s, t) {\\n    const sStack = new Array()\\n    for (const ch of s) {\\n        sStack.push(ch)\\n    }\\n    for (const ch of t) {\\n        if (ch === sStack[0]) {\\n            sStack.shift()\\n        }\\n    }\\n    \\n    return sStack.length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077869,
                "title": "python-faster-than-99-45-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j, m, n = 0, 0, len(s), len(t)\\n        while i < m and j < n and n - j >= m - i:\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return i == m",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i, j, m, n = 0, 0, len(s), len(t)\\n        while i < m and j < n and n - j >= m - i:\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return i == m",
                "codeTag": "Java"
            },
            {
                "id": 1013823,
                "title": "0ms-runtime-c-solution-100-faster",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i,f=0,j=0;\\n        for(i=0;i<t.size();i++)\\n        {\\n            if(s[j]==t[i])\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        if(j>=s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nFeel free to comment if have any doubt.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i,f=0,j=0;\\n        for(i=0;i<t.size();i++)\\n        {\\n            if(s[j]==t[i])\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        if(j>=s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008409,
                "title": "c-2-easy-solutions",
                "content": "Solution 1 no  extra sapce:\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int  m =s.length() , n=t.length();\\n        if(m>n) return 0;\\n        //string temp;\\n        int i=0,j=0;\\n        while(i<m && j<n) {\\n            if(s[i] == t[j]) {\\n           //     temp += s[i];\\n                i++;\\n                j++;\\n            }\\n            else \\n                j++;\\n        }\\n        return i==m;\\n    }\\n};\\n```\\nSolution using dynamic programming:\\n```\\n/* If s is a subsequence of t then LCS of s ,t would be s. Hence find the length of LCS and comapre with length  of s.  If they are  equal return true. Else return false\\n*/\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.length() , n=t.length(); \\n        vector<vector<int>> lcs(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++) {\\n            for(int j=1;j<=n;j++) {\\n               if(s[i-1]==t[j-1])  \\n                    lcs[i][j] = 1+lcs[i-1][j-1];\\n                else \\n                    lcs[i][j] = max(lcs[i-1][j],lcs[i][j-1]);\\n            }\\n        }\\n        return lcs[m][n] == m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int  m =s.length() , n=t.length();\\n        if(m>n) return 0;\\n        //string temp;\\n        int i=0,j=0;\\n        while(i<m && j<n) {\\n            if(s[i] == t[j]) {\\n           //     temp += s[i];\\n                i++;\\n                j++;\\n            }\\n            else \\n                j++;\\n        }\\n        return i==m;\\n    }\\n};\\n```\n```\\n/* If s is a subsequence of t then LCS of s ,t would be s. Hence find the length of LCS and comapre with length  of s.  If they are  equal return true. Else return false\\n*/\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.length() , n=t.length(); \\n        vector<vector<int>> lcs(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++) {\\n            for(int j=1;j<=n;j++) {\\n               if(s[i-1]==t[j-1])  \\n                    lcs[i][j] = 1+lcs[i-1][j-1];\\n                else \\n                    lcs[i][j] = max(lcs[i-1][j],lcs[i][j-1]);\\n            }\\n        }\\n        return lcs[m][n] == m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678545,
                "title": "cpp-easiest-solution-using-dp-both-recursive-and-bottom-up-approach",
                "content": "Don\\'t forget to upvote if you like this kind of approach of recognising new questions based on your previously done questions. \\n#  Parent Question\\n\\n**This question is a application of LCS(Longest Common Sequence) pattern. There is a slight change in the main function.**\\nLet\\'s take an example\\ns=\"abc\"              t=\"aebdc\"\\nLCS(s,t)=\"abc\" (longest common sequence of both the strings)\\n\\nSo according to this question we have to check whether the **length of LCS** is equal to **length of string s** or not. *If equal then return true else false.*\\n\\n# Recursive Code \\n```\\n class Solution {\\npublic:\\n    int LCS(string s, string t, int m,int n)\\n    {\\n\\t\\t\\t//If one of the string is empty.\\n            if(m==0 || n==0)\\n                return 0;\\n\\t\\t\\t\\t\\n             //If last charcter of both strings are same.  \\n            if(s[m-1]==t[n-1])                                     \\n                return 1+LCS(s,t,m-1,n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t//If not same then check both string by not considering one of these characters each time for both strings.\\t\\n            else                                        \\n\\t\\t\\t\\t   return max(LCS(s,t,m-1,n),LCS(s,t,m,n-1));\\n    }\\n\\t\\n    bool isSubsequence(string s, string t) \\n    {\\n        int m=s.length();\\n        int n=t.length();\\n        int len=LCS(s,t,m,n);\\n        if(len==m)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n```\\n\\n# Bottom up DP\\nTake the recursive code and apply bottom up dp. Create a table of size m+1 x n+1.\\n```\\nclass Solution {\\npublic:\\n    int LCS(string s, string t, int m,int n)\\n    {\\n        int dp[m+1][n+1],i=0,j=0;\\n        for(i=0;i<=m;i++)\\n        for(j=0;j<=n;j++)\\n        {    \\n            if(i==0 || j==0)\\n                dp[i][j]=0;\\n        }\\n        for(i=1;i<=m;i++)\\n        for(j=1;j<=n;j++)  \\n        {    \\n            if(s[i-1]==t[j-1])\\n                dp[i][j]=1+dp[i-1][j-1];\\n            else\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        }\\n        return dp[m][n];\\n    }\\n    bool isSubsequence(string s, string t) \\n    {\\n        int m=s.length();\\n        int n=t.length();\\n        int len=LCS(s,t,m,n);\\n\\n        if(len==m)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int LCS(string s, string t, int m,int n)\\n    {\\n\\t\\t\\t//If one of the string is empty.\\n            if(m==0 || n==0)\\n                return 0;\\n\\t\\t\\t\\t\\n             //If last charcter of both strings are same.  \\n            if(s[m-1]==t[n-1])                                     \\n                return 1+LCS(s,t,m-1,n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t//If not same then check both string by not considering one of these characters each time for both strings.\\t\\n            else                                        \\n\\t\\t\\t\\t   return max(LCS(s,t,m-1,n),LCS(s,t,m,n-1));\\n    }\\n\\t\\n    bool isSubsequence(string s, string t) \\n    {\\n        int m=s.length();\\n        int n=t.length();\\n        int len=LCS(s,t,m,n);\\n        if(len==m)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int LCS(string s, string t, int m,int n)\\n    {\\n        int dp[m+1][n+1],i=0,j=0;\\n        for(i=0;i<=m;i++)\\n        for(j=0;j<=n;j++)\\n        {    \\n            if(i==0 || j==0)\\n                dp[i][j]=0;\\n        }\\n        for(i=1;i<=m;i++)\\n        for(j=1;j<=n;j++)  \\n        {    \\n            if(s[i-1]==t[j-1])\\n                dp[i][j]=1+dp[i-1][j-1];\\n            else\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        }\\n        return dp[m][n];\\n    }\\n    bool isSubsequence(string s, string t) \\n    {\\n        int m=s.length();\\n        int n=t.length();\\n        int len=LCS(s,t,m,n);\\n\\n        if(len==m)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678510,
                "title": "python-two-pointer-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        if s == \"\":\\n            return True\\n        \\n        ptr = 0\\n        for c in t:\\n            if s[ptr] == c:\\n                ptr += 1\\n                if ptr == len(s):\\n                    return True\\n        return False",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        if s == \"\":\\n            return True\\n        \\n        ptr = 0\\n        for c in t:\\n            if s[ptr] == c:\\n                ptr += 1\\n                if ptr == len(s):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 87311,
                "title": "two-pointers-solution-in-java",
                "content": "Two pointers solution in Java.\\n```java\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sPtr = 0;\\n        int tPtr = 0;\\n\\n        while (sPtr<s.length() && tPtr<t.length()) {\\n            if (s.charAt(sPtr) == t.charAt(tPtr)) {\\n                sPtr++;\\n            }\\n            tPtr++;\\n        }\\n\\n        return sPtr == s.length();\\n    }\\n}\\n```\\n\\nI'm not sure how to adapt my code for the follow up question yet. \\n>Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\\n\\nMaybe use some cache, like caching the latest 100 S?",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sPtr = 0;\\n        int tPtr = 0;\\n\\n        while (sPtr<s.length() && tPtr<t.length()) {\\n            if (s.charAt(sPtr) == t.charAt(tPtr)) {\\n                sPtr++;\\n            }\\n            tPtr++;\\n        }\\n\\n        return sPtr == s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87316,
                "title": "3ms-java-solution",
                "content": "```\\n\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n\\t        \\n\\t        int j = 0;\\n\\t        int i = 0;\\n\\t        for(;i<s.length();i++)\\n\\t        {\\n\\t            \\n\\t            char c = s.charAt(i);\\n\\t       \\n\\t            if(t.indexOf(c,j) ==-1) return false;\\n\\t            else j = t.indexOf(c,j)+1;\\n\\t            \\n\\t        }\\n\\t        return i==s.length();\\n\\t    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n\\t        \\n\\t        int j = 0;\\n\\t        int i = 0;\\n\\t        for(;i<s.length();i++)\\n\\t        {\\n\\t            \\n\\t            char c = s.charAt(i);\\n\\t       \\n\\t            if(t.indexOf(c,j) ==-1) return false;\\n\\t            else j = t.indexOf(c,j)+1;\\n\\t            \\n\\t        }\\n\\t        return i==s.length();\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075085,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> n is the length of string t\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        int i = 0, j = 0;\\n        while (i < m && j < n) {\\n            if (s[i] == t[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (i == m) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        int i = 0, j = 0;\\n        while (i < m && j < n) {\\n            if (s[i] == t[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (i == m) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074676,
                "title": "java-time-o-n-space-o-1-easy-understanding-explanation-loop-and-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Using two pointers to iterate through both strings.\\n2. Comparing characters in both strings, moving the pointers accordingly.\\n2. If all characters in the first string are found in the second string in the same order, it\\'s a subsequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Here\\'s the step-by-step approach:**\\n\\n1. Initialize variables `slen` and `tlen` to store the lengths of both strings.\\n2. Initialize an index variable `j` to keep track of the current character in string `s` being checked.\\n3. Handle special cases when either string is empty.\\n4. Use a loop to iterate through the characters of string `t`.\\n5. Check for character matches between `s` and `t`and update the `j` pointer.\\n6. If `j` reaches the length of `s`, return `true` as all characters in `s` are found in `t` in the same order.\\n7. If the loop completes without finding a subsequence, return `false`.\\n\\n# Complexity\\n- Time complexity: O(N) \\n    - The time complexity of this solution is O(n) where n is the length of string t because we iterate through t once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n    - The space complexity is O(1) because we use a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nGuys do watch and subscribe my youtube channel as well.\\n\\n[https://youtu.be/Ejlubfsrpok]()\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int slen= s.length();\\n        int tlen = t.length();\\n        int j=0;\\n        if(slen==0)\\n            return true;\\n        if(tlen==0)\\n            return false;\\n        for(int i=0;i<tlen;i++)\\n        {\\n            if(s.charAt(j)==t.charAt(i))\\n                j++;\\n            if(j==slen)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nThank You!\\nPlease upvote if you liked it.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int slen= s.length();\\n        int tlen = t.length();\\n        int j=0;\\n        if(slen==0)\\n            return true;\\n        if(tlen==0)\\n            return false;\\n        for(int i=0;i<tlen;i++)\\n        {\\n            if(s.charAt(j)==t.charAt(i))\\n                j++;\\n            if(j==slen)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066725,
                "title": "100-faster-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n``isSubsequence`` that takes two strings, s and t, as input. The function checks whether string s is a subsequence of string t and returns true if it is, or false otherwise.\\n\\nHere\\'s an explanation of the approach used in this code:\\n\\n- Initialize an integer variable j to 0. This variable will keep track of the current position in string s that we are trying to match.\\n\\n- Check if string s is an empty string. If it is, return true because an empty string is considered a subsequence of any string.\\n\\n- Iterate through the characters of string t using a for loop with index i.\\n\\n- Inside the loop, compare the character s[j] with the character t[i].If they are equal, it means we have found a character in t that matches the current character we are looking for in s.\\n\\n- If there is a match, increment the j index by 1. This moves us to the next character we need to find in s.\\n\\n- Check if j has reached the length of string s (s.size()). If it has, it means we have successfully matched all characters in s to a subsequence of t, so we return true.\\n\\n- If the loop completes without finding all characters in s, return false because s is not a subsequence of t.\\n\\nThis code effectively iterates through both strings, s and t, in a single pass and checks if s is a subsequence of t. If all characters in s are found in t in the same order, the function returns true; otherwise, it returns false.\\n\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t)\\n    {\\n        int j =0;\\n        if(s==\"\")return true;\\n        for(int i =0 ; i < t.size();i++)\\n        {\\n            if(s[j]==t[i])\\n            {\\n                j++;\\n            }\\n            if(j==s.size())\\n            {\\n                return true;\\n            }\\n        }  \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t)\\n    {\\n        int j =0;\\n        if(s==\"\")return true;\\n        for(int i =0 ; i < t.size();i++)\\n        {\\n            if(s[j]==t[i])\\n            {\\n                j++;\\n            }\\n            if(j==s.size())\\n            {\\n                return true;\\n            }\\n        }  \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955737,
                "title": "very-easy-6-line-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i==s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i==s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855814,
                "title": "java-easy-solution-kindergarten-kid-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHope this can help beginners like me.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet up an index for string s called si(s\\' index), then we loop through string t, each time we find that the char at i position of t is equal to s.charAt(si), we increment si. In the end, if we successfully catch all the chars from s in t, the si will be the same value with the length of s.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length()==0)\\n        {\\n            return true;\\n        }\\n        int si = 0;\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(si<s.length()&&t.charAt(i)==s.charAt(si))\\n            {\\n                si++;\\n            }\\n        }\\n        if(si == s.length()) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length()==0)\\n        {\\n            return true;\\n        }\\n        int si = 0;\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(si<s.length()&&t.charAt(i)==s.charAt(si))\\n            {\\n                si++;\\n            }\\n        }\\n        if(si == s.length()) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808767,
                "title": "100-faster-easy-line-by-line-explained-string-matching-with-two-pointer",
                "content": "**I have commented line by line explanation , sure you will understand if you go through my commented code line by line\\uD83D\\uDCAF**\\n\\n  **you can go through best video for the same \\uD83D\\uDCAF** \\n[https://www.youtube.com/watch?v=Gkz3SwtdSes]()\\n\\n\\n**if you find helpful\\uD83D\\uDCAF ... Kindly upvote**\\n   THANKING YOU\\n# Complexity**\\n- Time complexity:\\n  0(n*n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0 ;// take two pointer staring from both string\\n        int j = 0;\\n        while(i<s.length() && j < t.length()){//if any on pointer goes out of size of any string that means false\\n            if(s[i]==t[j]){// checking same characters they have or not \\n            i++;// if both character will same we increment both pointer for checking next \\n            j++;//character equal or not\\n            }\\n            else j++;\\n        }\\n        return (i==s.length()); //if i becomes same size of string s , means we find all charcter\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0 ;// take two pointer staring from both string\\n        int j = 0;\\n        while(i<s.length() && j < t.length()){//if any on pointer goes out of size of any string that means false\\n            if(s[i]==t[j]){// checking same characters they have or not \\n            i++;// if both character will same we increment both pointer for checking next \\n            j++;//character equal or not\\n            }\\n            else j++;\\n        }\\n        return (i==s.length()); //if i becomes same size of string s , means we find all charcter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718431,
                "title": "beats-100-most-optimised-o-n-simple-straight-forward-solution",
                "content": "# Intuition\\nHere we have first compared the lenghts of \"s\" and \"t\" and if the lenght of s is greater than t then we will return false.\\nOtherwise we will keep just one pointer because the other pointer won;t move as it is set is 0.\\n\\n\\n# Approach\\nWe will start iterating in the loop and compare the characters of s and t and if they are same we will delete the character of s and this will go on untill the for loop runs.After that if the string s is empty then it means all the characters of s can be formed from string t hence we will return true,otherwise we will return false.\\n\\n# Complexity\\n- Time complexity:\\nThe Time Complexity is O(N), where N is the length of the string t.\\n\\n- Space complexity:\\nSpace Complexiy is O(1) as we are not using any extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n1= s.size();\\n        int t1 = t.size();\\n        if(s.empty())return true;\\n        if(n1>t1)return false;\\n        for(int i = 0; i < t1;i++)\\n        {\\n            if(s[0]==t[i])s.erase(s.begin());\\n        }\\n        return s.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int n1= s.size();\\n        int t1 = t.size();\\n        if(s.empty())return true;\\n        if(n1>t1)return false;\\n        for(int i = 0; i < t1;i++)\\n        {\\n            if(s[0]==t[i])s.erase(s.begin());\\n        }\\n        return s.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629058,
                "title": "java-easy-solution-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolving problem using java by simply using one while loop\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSubsequence means the all possible strings that be created from given string without altering the positions or index of any character...in this question two strings will be given and we need to find the whether the first string(i.e s) is a substring of another string (i.e. t) for example..if s=ace and t=abbeced we should return true as we can create s from t whereas when s=abc and t=acb we should return false as cant take abc from acb without changing their indexes\\nfollow these steps for better understanding of my code:\\n1.Initialise both sIndex and tIndex to 0 as we need to start comparing from first index of both strings\\n2.Create a while loop and run until we reach end of any string and inside loop check whether we found the character of s under each loop and increment the index of s only if we found the same character\\n3. Whereas after every loop increment the index of t to check at what place our desired character present\\n4. if loop ends before the index means its not a subsequence.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIndex = 0;\\n        int tIndex = 0;\\n\\n        while (sIndex < s.length() && tIndex < t.length()) {\\n            if (s.charAt(sIndex) == t.charAt(tIndex)) {\\n                sIndex++;\\n            }\\n            tIndex++;\\n        }\\n        return sIndex==s.length();\\n    }\\n}\\n```\\n\\nGuys please upvote if you feel my code worth !!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int sIndex = 0;\\n        int tIndex = 0;\\n\\n        while (sIndex < s.length() && tIndex < t.length()) {\\n            if (s.charAt(sIndex) == t.charAt(tIndex)) {\\n                sIndex++;\\n            }\\n            tIndex++;\\n        }\\n        return sIndex==s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551463,
                "title": "easy-1-line-python-solution-using-re-library",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n.* in the code tells the search function that there might be 0 or more char in its place\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport re\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n\\n        return re.search(\".*\".join(list(s)),t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n\\n        return re.search(\".*\".join(list(s)),t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954106,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length()>t.length())\\n        return false;\\n        int i=0;\\n        int j=0;\\n        while(i<s.length() && j<t.length()){\\n        if(t.charAt(j)==s.charAt(i))i++;\\n        j++;\\n        }\\n        return (i==s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length()>t.length())\\n        return false;\\n        int i=0;\\n        int j=0;\\n        while(i<s.length() && j<t.length()){\\n        if(t.charAt(j)==s.charAt(i))i++;\\n        j++;\\n        }\\n        return (i==s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789319,
                "title": "python-easy-2-line-solution",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        it = iter(t)\\n        return all(c in it for c in s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        it = iter(t)\\n        return all(c in it for c in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770032,
                "title": "the-most-readable-solution-in-python-for-392-is-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is that we just need to find the same letters with the same order. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the simplest solution that comes to our mind is to look through the second string and increase one variable by one if the letter we are looking for matches the order of the first string.\\n\\nIn the end we return `True`, if the length of `s` equals to our variable `j`, which was declared to check the order of letter in both string\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        j = 0\\n        for letter in t:\\n            if j == n:\\n                return True\\n            if letter == s[j]:\\n                j += 1\\n        return j == n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        j = 0\\n        for letter in t:\\n            if j == n:\\n                return True\\n            if letter == s[j]:\\n                j += 1\\n        return j == n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763906,
                "title": "two-pointers-100-fast-easiest-of-all-approach-o-n",
                "content": "class Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0;\\n        while(j<t.length()){\\n            if(s[i] == t[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i==s.length()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i=0,j=0;\\n        while(j<t.length()){\\n            if(s[i] == t[j]){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2742124,
                "title": "is-subsequence-100-faster-solution-very-easy-to-understand-upvote-plz",
                "content": "**Main idea is to find Longest Common Subsequence of S  In String T**\\n```\\nclass Solution {\\npublic:\\n    \\n    int LCS(string s,string t,int n,int m)\\n    {\\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if((i==0)||(j==0))\\n                {\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                {\\n                   dp[i][j]=1+dp[i-1][j-1]; \\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n    }\\n    \\n    bool isSubsequence(string s, string t)\\n    {\\n        int  n=s.size();\\n        int m=t.size();\\n        \\n        int x=LCS(s,t,n,m);\\n        \\n        if(x==s.size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int LCS(string s,string t,int n,int m)\\n    {\\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if((i==0)||(j==0))\\n                {\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                {\\n                   dp[i][j]=1+dp[i-1][j-1]; \\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n    }\\n    \\n    bool isSubsequence(string s, string t)\\n    {\\n        int  n=s.size();\\n        int m=t.size();\\n        \\n        int x=LCS(s,t,n,m);\\n        \\n        if(x==s.size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605418,
                "title": "100-fast-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int l = 0;\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[l]){\\n                l++;\\n            }\\n            if(l == s.size())break;\\n        }\\n        if(l == s.size())return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int l = 0;\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[l]){\\n                l++;\\n            }\\n            if(l == s.size())break;\\n        }\\n        if(l == s.size())return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550133,
                "title": "java-simple-solution-in-6-different-ways",
                "content": "**Optimal Solution**\\n\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint idx = -1;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tidx = t.indexOf(c, idx + 1);\\n\\t\\tif (idx == -1) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n---\\n\\n**Two Pointer approach**\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint i = 0, j = 0;\\n\\twhile (i < s.length() && j < t.length()) {\\n\\t\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\t\\ti += 1;\\n\\t\\t}\\n\\t\\tj += 1;\\n\\t}\\n\\treturn i == s.length();\\n}\\n```\\n\\n---\\n**Using Binary Search solution for Large (S+T) Strings**\\n\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tList<Integer>[] idx = new List[256];\\n\\t// Pre-process of t\\n\\tint i = 0;\\n\\tfor (char c : t.toCharArray()) {\\n\\t\\tif (idx[c] == null) {\\n\\t\\t\\tidx[c] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tidx[c].add(i++);\\n\\t}\\n\\tint prev = -1;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (idx[c] == null) return false;\\n\\t\\tprev = binarySearch(idx[c], prev);\\n\\t\\tif (prev == -1) return false;\\n\\t}\\n\\treturn true;\\n}\\n\\npublic int binarySearch(List<Integer> list, int index) {\\n\\tint start = 0, mid = 0, end = list.size() - 1;\\n\\twhile (start <= end) {\\n\\t\\tmid = start + (end - start) / 2;\\n\\t\\tif (index < list.get(mid)) {\\n\\t\\t\\tend = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn start == list.size() ? -1 : list.get(start) + 1;\\n}\\n```\\n---\\n\\n**Using DP with Memoization**\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint[][] memo = new int[s.length()][t.length()];\\n\\tint length = lcsRecursion(s, t, s.length() - 1, t.length() - 1, memo);\\n\\treturn length == s.length();\\n}\\n\\npublic int lcsRecursion(String s, String t, int i, int j, int[][] memo) {\\n\\tint result = 0;\\n\\tif (memo[i][j] > 0) return memo[i][j];\\n\\tif (i == 0 || j == 0) return result;\\n\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\tresult = 1 + lcsRecursion(s, t, i - 1, j - 1, memo);\\n\\t} else {\\n\\t\\tresult = Math.max(lcsRecursion(s, t, i - 1, j, memo), lcsRecursion(s, t, i, j - 1, memo));\\n\\t}\\n\\tmemo[i][j] = result;\\n\\treturn result;\\n}\\n```\\n\\n---\\n\\n**Using DP with Bottom-up Approach**\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint[][] table = new int[s.length()][t.length()];\\n\\tArrays.setAll(table, r -> {\\n\\t\\tArrays.fill(table[r], -1);\\n\\t\\treturn table[r];\\n\\t});\\n\\tint length = lcsBottomUp(s, t, s.length() - 1, t.length() - 1, table);\\n\\treturn length == s.length();\\n}\\n\\npublic int lcsBottomUp(String s, String t, int i, int j, int[][] table) {\\n\\tif (i < 0 || j < 0) return 0;\\n\\tif (table[i][j] != -1) {\\n\\t\\treturn table[i][j];\\n\\t}\\n\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\treturn table[i][j] = 1 + lcsBottomUp(s, t, i - 1, j - 1, table);\\n\\t}\\n\\treturn table[i][j] = Math.max(lcsBottomUp(s, t, i - 1, j, table), lcsBottomUp(s, t, i, j - 1, table));\\n}\\n```\\n\\n---\\n**Using Stack Approach**\\n\\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tStack<Character> stack = new Stack<>();\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tstack.push(s.charAt(i));\\n\\t}\\n\\tfor (char c : t.toCharArray()) {\\n\\t\\tif (stack.isEmpty()) return true;\\n\\t\\tif (c == stack.peek()) {\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn stack.isEmpty();\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint idx = -1;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tidx = t.indexOf(c, idx + 1);\\n\\t\\tif (idx == -1) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint i = 0, j = 0;\\n\\twhile (i < s.length() && j < t.length()) {\\n\\t\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\t\\ti += 1;\\n\\t\\t}\\n\\t\\tj += 1;\\n\\t}\\n\\treturn i == s.length();\\n}\\n```\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tList<Integer>[] idx = new List[256];\\n\\t// Pre-process of t\\n\\tint i = 0;\\n\\tfor (char c : t.toCharArray()) {\\n\\t\\tif (idx[c] == null) {\\n\\t\\t\\tidx[c] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tidx[c].add(i++);\\n\\t}\\n\\tint prev = -1;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (idx[c] == null) return false;\\n\\t\\tprev = binarySearch(idx[c], prev);\\n\\t\\tif (prev == -1) return false;\\n\\t}\\n\\treturn true;\\n}\\n\\npublic int binarySearch(List<Integer> list, int index) {\\n\\tint start = 0, mid = 0, end = list.size() - 1;\\n\\twhile (start <= end) {\\n\\t\\tmid = start + (end - start) / 2;\\n\\t\\tif (index < list.get(mid)) {\\n\\t\\t\\tend = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn start == list.size() ? -1 : list.get(start) + 1;\\n}\\n```\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint[][] memo = new int[s.length()][t.length()];\\n\\tint length = lcsRecursion(s, t, s.length() - 1, t.length() - 1, memo);\\n\\treturn length == s.length();\\n}\\n\\npublic int lcsRecursion(String s, String t, int i, int j, int[][] memo) {\\n\\tint result = 0;\\n\\tif (memo[i][j] > 0) return memo[i][j];\\n\\tif (i == 0 || j == 0) return result;\\n\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\tresult = 1 + lcsRecursion(s, t, i - 1, j - 1, memo);\\n\\t} else {\\n\\t\\tresult = Math.max(lcsRecursion(s, t, i - 1, j, memo), lcsRecursion(s, t, i, j - 1, memo));\\n\\t}\\n\\tmemo[i][j] = result;\\n\\treturn result;\\n}\\n```\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tint[][] table = new int[s.length()][t.length()];\\n\\tArrays.setAll(table, r -> {\\n\\t\\tArrays.fill(table[r], -1);\\n\\t\\treturn table[r];\\n\\t});\\n\\tint length = lcsBottomUp(s, t, s.length() - 1, t.length() - 1, table);\\n\\treturn length == s.length();\\n}\\n\\npublic int lcsBottomUp(String s, String t, int i, int j, int[][] table) {\\n\\tif (i < 0 || j < 0) return 0;\\n\\tif (table[i][j] != -1) {\\n\\t\\treturn table[i][j];\\n\\t}\\n\\tif (s.charAt(i) == t.charAt(j)) {\\n\\t\\treturn table[i][j] = 1 + lcsBottomUp(s, t, i - 1, j - 1, table);\\n\\t}\\n\\treturn table[i][j] = Math.max(lcsBottomUp(s, t, i - 1, j, table), lcsBottomUp(s, t, i, j - 1, table));\\n}\\n```\n```\\npublic boolean isSubsequence(String s, String t) {\\n\\tStack<Character> stack = new Stack<>();\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tstack.push(s.charAt(i));\\n\\t}\\n\\tfor (char c : t.toCharArray()) {\\n\\t\\tif (stack.isEmpty()) return true;\\n\\t\\tif (c == stack.peek()) {\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn stack.isEmpty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281159,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int pointerS = 0, pointerT = 0;\\n        while(pointerS < s.length() && pointerT < t.length()){\\n            char charS = s.charAt(pointerS);\\n            char charT = t.charAt(pointerT);\\n            if(charS == charT)\\n                pointerS++;\\n            \\n            pointerT++;\\n        }\\n        return pointerS == s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int pointerS = 0, pointerT = 0;\\n        while(pointerS < s.length() && pointerT < t.length()){\\n            char charS = s.charAt(pointerS);\\n            char charT = t.charAt(pointerT);\\n            if(charS == charT)\\n                pointerS++;\\n            \\n            pointerT++;\\n        }\\n        return pointerS == s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177909,
                "title": "python-c-easy-solution-two-pointer-approach",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int x=0;\\n        for(int i=0;i<t.size() && x<s.size();i++)\\n        {\\n            if(s[x]==t[i])\\n            {\\n                x++;\\n            }\\n        }\\n        return(x==s.size());\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        x=0\\n        for i in range(len(t)):\\n            if(x<len(s)):\\n                if(s[x]==t[i]):\\n                    x+=1\\n        return(x==len)       \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int x=0;\\n        for(int i=0;i<t.size() && x<s.size();i++)\\n        {\\n            if(s[x]==t[i])\\n            {\\n                x++;\\n            }\\n        }\\n        return(x==s.size());\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        x=0\\n        for i in range(len(t)):\\n            if(x<len(s)):\\n                if(s[x]==t[i]):\\n                    x+=1\\n        return(x==len)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867084,
                "title": "rust-easy-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let s: Vec<char> = s.chars().collect();    \\n        let t: Vec<char> = t.chars().collect();    \\n        let mut i = 0;\\n        for j in 0..t.len() {\\n            if i == s.len() {\\n                break;\\n            }\\n            if (s[i] == t[j]) {\\n                i += 1;\\n            }\\n        }\\n        i == s.len()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_subsequence(s: String, t: String) -> bool {\\n        let s: Vec<char> = s.chars().collect();    \\n        let t: Vec<char> = t.chars().collect();    \\n        let mut i = 0;\\n        for j in 0..t.len() {\\n            if i == s.len() {\\n                break;\\n            }\\n            if (s[i] == t[j]) {\\n                i += 1;\\n            }\\n        }\\n        i == s.len()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813957,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        if (t.length() == 0) return false;\\n        int letter = 0;\\n        for (int i = 0; i < t.length(); i++) {\\n            if (s.charAt(letter) == t.charAt(i)) {\\n                letter++;\\n                if (letter >= s.length()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if (s.length() == 0) return true;\\n        if (t.length() == 0) return false;\\n        int letter = 0;\\n        for (int i = 0; i < t.length(); i++) {\\n            if (s.charAt(letter) == t.charAt(i)) {\\n                letter++;\\n                if (letter >= s.length()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811561,
                "title": "easy-c-sol-100-fast-explanation-dp-less-optimized-to-two-pointer-most-optimized",
                "content": "Both the Dynamic Programming O(N* M) and the Two Pointer O(N) Solution ideas are discussed below.\\n##### Dynamic Programming Approach\\n> Dp Sol is Less Optimized.\\n\\n**Idea:** We can determine the `longest common subsequence` of `s` and `t` and return `true` if the size of the longest common subsequence is equal to`s.size()`, otherwise `false`.\\n>Time: O(N * M), Space: O(N * M)\\n\\n**C++ Code:**\\n```\\nbool isSubsequence(string s, string t) {\\n        int n = t.size(), m = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1, 0));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[j-1] == t[i-1])\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m] == m;\\n    }\\n```\\n\\n##### Two pointer Approach | O(N) Time Solution\\n> Most optimized sol for this problem.\\n\\n**Idea:** Taking two index pointers, one for each of the two input strings (`s_ptr` for `s` and `t_ptr` for `t` string) and simply iterate over  `t` and `s` together. If there is a common character in both the strings, then move both `s_ptr` and `t_ptr` forward by one, else move only the `t ptr` forward.\\nOnce the loop terminates (when either `s_ptr` has reached the end of `s` string, or the `t_ptr` has reached the end of `t` string), we check if the `s_ptr` has reached the end of the `s` string. If yes then `s` is a subsequence of `t` and we return `true`, otherwise return `false`. \\n> Time: O(N), Space: O(1)\\n \\n**C++ Code:**\\n```\\n bool isSubsequence(string s, string t){\\n     int t_ptr = 0, s_ptr = 0;\\n     if(s.size()>t.size())\\n\\t\\t return false;\\n\\t while(t_ptr < t.size() and s_ptr<s.size()){\\n\\t\\t if(t[t_ptr] == s[s_ptr]){\\n\\t\\t\\t s_ptr++;\\n\\t\\t\\t t_ptr++;\\n         }else\\n\\t\\t\\t t_ptr++;\\n      }\\n     return (s_ptr == s.size());\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool isSubsequence(string s, string t) {\\n        int n = t.size(), m = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1, 0));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[j-1] == t[i-1])\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m] == m;\\n    }\\n```\n```\\n bool isSubsequence(string s, string t){\\n     int t_ptr = 0, s_ptr = 0;\\n     if(s.size()>t.size())\\n\\t\\t return false;\\n\\t while(t_ptr < t.size() and s_ptr<s.size()){\\n\\t\\t if(t[t_ptr] == s[s_ptr]){\\n\\t\\t\\t s_ptr++;\\n\\t\\t\\t t_ptr++;\\n         }else\\n\\t\\t\\t t_ptr++;\\n      }\\n     return (s_ptr == s.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811499,
                "title": "c-two-pointers-o-m-n-simple-approach",
                "content": "```\\n bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(j < t.size() and i < s.size()) {\\n            if(s[i] == t[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }\\n        \\n        return i == s.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(j < t.size() and i < s.size()) {\\n            if(s[i] == t[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }\\n        \\n        return i == s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1806573,
                "title": "java-most-easy-solution",
                "content": "\\n    class Solution {\\n      public boolean isSubsequence(String s, String t) {\\n        int i =0;\\n        int j =0;\\n        while(i<s.length() && j<t.length()){\\n            \\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n                j++;\\n            }else\\n                j++;\\n        }\\n        if(i==s.length()){\\n            return true;\\n          }\\n\\t\\t  return false;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public boolean isSubsequence(String s, String t) {\\n        int i =0;\\n        int j =0;\\n        while(i<s.length() && j<t.length()){\\n            \\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1771465,
                "title": "use-two-pointer-c-easy-solution-o-n-time",
                "content": "1. Use two Pointer approach. One for subsequent string and one for main string.\\n2. Iterate though all the character of main string.\\n3. Once the subsequent Pointer reaches to the subsequent length, just break the loop and return true.\\n\\n\\n```\\npublic bool IsSubsequence(string s, string t)\\n{\\n\\t\\tif (s.Length == 0) return true;\\n\\n\\t\\tint s_pointer = 0;\\n\\t\\tfor (int t_pointer = 0; t_pointer < t.Length; t_pointer++)\\n\\t\\t{\\n\\t\\t\\tif (s[s_pointer] == t[t_pointer])\\n\\t\\t\\t{\\n\\t\\t\\t\\ts_pointer++;\\n\\t\\t\\t\\tif (s_pointer == s.Length) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\npublic bool IsSubsequence(string s, string t)\\n{\\n\\t\\tif (s.Length == 0) return true;\\n\\n\\t\\tint s_pointer = 0;\\n\\t\\tfor (int t_pointer = 0; t_pointer < t.Length; t_pointer++)\\n\\t\\t{\\n\\t\\t\\tif (s[s_pointer] == t[t_pointer])\\n\\t\\t\\t{\\n\\t\\t\\t\\ts_pointer++;\\n\\t\\t\\t\\tif (s_pointer == s.Length) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605659,
                "title": "simple-java-solution",
                "content": "Simple Java Solution\\n```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j=0;\\n        for(int i=0;j<s.length() && i<t.length();i++){\\n            if(t.charAt(i) == s.charAt(j)){\\n                j++;\\n            }    \\n        }\\n        return j==s.length();\\n    }\\n}\\n```\\n\\nSimilar to [https://leetcode.com/problems/assign-cookies/](http://)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        int j=0;\\n        for(int i=0;j<s.length() && i<t.length();i++){\\n            if(t.charAt(i) == s.charAt(j)){\\n                j++;\\n            }    \\n        }\\n        return j==s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379181,
                "title": "detailed-explanation-java-code-3-approaches",
                "content": "**Approach 1: Divide and Conquer with Greedy**\\n\\nIntuition\\n\\nThe problem concerns the string matching issues, for which often one can apply a technique called divide and conquer.\\n\\nThe general idea of the divide and conquer technique is to reduce the problem down into subproblems with smaller scales recursively until the problem becomes small enough to tackle with. We then use the results of subproblems to construct the solution for the original problem.\\n    \\nHere we show how to break down our problem step by step. Given two strings source and target, we are asked to determine if the source string is a subsequence of the \\\\text{target}target string, i.e. isSubsequence(source, target)\\n    \\nLet us start from the first characters of each string, i.e. source[0], target[0]. By comparing them, there could be two cases as follows:\\n\\n```\\nCase 1): they are identical, i.e. source[0]=target[0]\\n```\\nIn this case, the best strategy would be to cross out the first characters in both strings, and then continue with the matching job.\\n\\n```\\nCase 2): they are not identical, i.e. source[0]  != target[0]\\n```\\n\\nIn this case, the only thing we can do is to skip (cross out) the first character in the target string, and keep on searching in the target string in the hope that we would find a letter that could match the first character in the source string.\\n    \\nTo make the recursion complete, we should also define the base cases properly. In this problem, we have two particular base cases:\\n\\nThe source becomes empty, i.e. we found matches for all the letters in the source string. Hence, the source string is a subsequence of the target string.\\n\\nThe  target becomes empty, i.e. we exhaust the target string, yet there are still some letters left unmatched in the source string. Hence, the source string is not a subsequence of the target string.\\n    \\n```\\nclass Solution {\\n    String source, target;\\n    Integer leftBound, rightBound;\\n\\n    private boolean rec_isSubsequence(int leftIndex, int rightIndex) {\\n        // base cases\\n        if (leftIndex == leftBound)\\n            return true;\\n        if (rightIndex == rightBound)\\n            return false;\\n\\n        // consume both strings or just the target string\\n        if (source.charAt(leftIndex) == target.charAt(rightIndex))\\n            ++leftIndex;\\n        ++rightIndex;\\n\\n        return rec_isSubsequence(leftIndex, rightIndex);\\n    }\\n\\n    public boolean isSubsequence(String s, String t) {\\n        this.source = s;\\n        this.target = t;\\n        this.leftBound = s.length();\\n        this.rightBound = t.length();\\n\\n        return rec_isSubsequence(0, 0);\\n    }\\n}\\n```\\n**Complexity Analysis**\\n\\n*Let \\u2223S\\u2223 be the length of the source string, and \\u2223T\\u2223 be the length of the target string.\\n\\nTime Complexity: O(\\u2223T\\u2223).\\n\\nSpace Complexity: O(\\u2223T\\u2223)*\\n    \\n    \\n    \\n**Approach 2: Two-Pointers**\\n\\nIntuition\\n\\nFollowing the same intuition above, we could further optimize the space complexity of the previous solutions, by replacing the recursion with the iteration\\n```\\nMore specifically, we iterate through the source and target strings, respectively with a pointer.\\n```\\n\\nEach pointer marks a position that we progress on the matching of the characters.\\n\\n*Algorithm*\\n\\nWe designate two pointers for iteration, with the left pointer referring to the source string and the right pointer to the target string.\\n    \\nWe move the pointers accordingly on the following two cases:\\n\\nIf source[left] == target[right]: we found a match. Hence, we move both pointers one step forward.\\n\\nIf source[left] != target[right]: no match is found. We then move only the right pointer on the target string.\\n    \\n\\nThe iteration would terminate, when either of the pointers exceeds its boundary.\\n\\nAt the end of the iteration, the result solely depends on the fact that whether we have consumed all the characters in the source string. If so, we have found a suitable match for each character in the source string. Therefore, the source string is a subsequence of the target string.\\n    \\n```    \\nclass Solution {\\n\\n    public boolean isSubsequence(String s, String t) {\\n        Integer leftBound = s.length(), rightBound = t.length();\\n        Integer pLeft = 0, pRight = 0;\\n\\n        while (pLeft < leftBound && pRight < rightBound) {\\n            // move both pointers or just the right pointer\\n            if (s.charAt(pLeft) == t.charAt(pRight)) {\\n                pLeft += 1;\\n            }\\n            pRight += 1;\\n        }\\n        return pLeft == leftBound;\\n    }\\n}\\n```\\n\\n**Complexity Analysis**\\n\\n*Let |S| be the length of the source string, and |T| be the length of the target string.\\n\\nTime Complexity: O(\\u2223T\\u2223)\\n    \\nSpace Complexity: O(1)*\\n\\n**Approach 3:  Character Indices Hashmap**\\n\\nWith the above two approaches under the belt, let us now look at the follow-up question raised in the problem description, which we cite as follows:\\n\\n```\\nIf there are lots of incoming S, say S1 , S2 ...  you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\\n```\\n\\nIn the above scenario, we would expect several incoming source strings, but a constant target string. We are asked to match each of the source strings against the target string.\\n\\nIf we apply our previous algorithms, for each match, the overall time complexity would be O(|T|).\\n\\nIn other words, regardless of the source strings, in the worst case, we have to scan the target string repeatedly, even though the target string remains the same.\\n\\nNow with the bottleneck identified, we could ask ourselves if we could do something about it.\\n\\n\\nThe reason why we scan the target string is to look for the next character that matches a given character in the source string. In essence, this is a lookup operation in the array data structure.\\n    \\nTo speed up the lookup operation, the data structure of hashmap could come in handy, since it has a O(1) time complexity for its lookup operation.\\n    \\nIndeed, we could build a hashmap out of the target string, with each unique character as key and the indices of its appearance as value.\\n    \\nMoreover, we should pre-compute this hashmap once and then reuse it for all the following matches.\\n\\nWith this hashmap, rather than scanning through the entire target string, we could instantly retrieve all the relevant positions in the target string to look at, given a character from the source string.\\n    \\n```\\nclass Solution {\\n\\n    public boolean isSubsequence(String s, String t) {\\n\\n        // precomputation, build the hashmap out of the target string\\n        HashMap<Character, List<Integer>> letterIndicesTable = new HashMap<>();\\n        for (int i = 0; i < t.length(); ++i) {\\n            if (letterIndicesTable.containsKey(t.charAt(i)))\\n                letterIndicesTable.get(t.charAt(i)).add(i);\\n            else {\\n                ArrayList<Integer> indices = new ArrayList<Integer>();\\n                indices.add(i);\\n                letterIndicesTable.put(t.charAt(i), indices);\\n            }\\n        }\\n\\n        Integer currMatchIndex = -1;\\n        for (char letter : s.toCharArray()) {\\n            if (!letterIndicesTable.containsKey(letter))\\n                return false; // no match, early exist\\n\\n            boolean isMatched = false;\\n            // greedy match with linear search\\n            for (Integer matchIndex : letterIndicesTable.get(letter)) {\\n                if (currMatchIndex < matchIndex) {\\n                    currMatchIndex = matchIndex;\\n                    isMatched = true;\\n                    break;\\n                }\\n            }\\n\\n            if (!isMatched)\\n                return false;\\n        }\\n\\n        // consume all characters in the source string\\n        return true;\\n    }\\n}\\n```\\n\\n**Complexity Analysis**\\n\\n*Let |T| be the length of the target string, and |S| be the length of the source string.\\n\\nTime Complexity: O(\\u2223T\\u2223). (I HAVE DOUBT IN THIS NOT SURE PLEASE COMMENT IF U KNOW)\\n    \\nSpace Complexity: O(\\u2223T\\u2223)*\\n\\n\\n    \\n    \\n\\n",
                "solutionTags": [],
                "code": "```\\nCase 1): they are identical, i.e. source[0]=target[0]\\n```\n```\\nCase 2): they are not identical, i.e. source[0]  != target[0]\\n```\n```\\nclass Solution {\\n    String source, target;\\n    Integer leftBound, rightBound;\\n\\n    private boolean rec_isSubsequence(int leftIndex, int rightIndex) {\\n        // base cases\\n        if (leftIndex == leftBound)\\n            return true;\\n        if (rightIndex == rightBound)\\n            return false;\\n\\n        // consume both strings or just the target string\\n        if (source.charAt(leftIndex) == target.charAt(rightIndex))\\n            ++leftIndex;\\n        ++rightIndex;\\n\\n        return rec_isSubsequence(leftIndex, rightIndex);\\n    }\\n\\n    public boolean isSubsequence(String s, String t) {\\n        this.source = s;\\n        this.target = t;\\n        this.leftBound = s.length();\\n        this.rightBound = t.length();\\n\\n        return rec_isSubsequence(0, 0);\\n    }\\n}\\n```\n```\\nMore specifically, we iterate through the source and target strings, respectively with a pointer.\\n```\n```    \\nclass Solution {\\n\\n    public boolean isSubsequence(String s, String t) {\\n        Integer leftBound = s.length(), rightBound = t.length();\\n        Integer pLeft = 0, pRight = 0;\\n\\n        while (pLeft < leftBound && pRight < rightBound) {\\n            // move both pointers or just the right pointer\\n            if (s.charAt(pLeft) == t.charAt(pRight)) {\\n                pLeft += 1;\\n            }\\n            pRight += 1;\\n        }\\n        return pLeft == leftBound;\\n    }\\n}\\n```\n```\\nIf there are lots of incoming S, say S1 , S2 ...  you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\\n```\n```\\nclass Solution {\\n\\n    public boolean isSubsequence(String s, String t) {\\n\\n        // precomputation, build the hashmap out of the target string\\n        HashMap<Character, List<Integer>> letterIndicesTable = new HashMap<>();\\n        for (int i = 0; i < t.length(); ++i) {\\n            if (letterIndicesTable.containsKey(t.charAt(i)))\\n                letterIndicesTable.get(t.charAt(i)).add(i);\\n            else {\\n                ArrayList<Integer> indices = new ArrayList<Integer>();\\n                indices.add(i);\\n                letterIndicesTable.put(t.charAt(i), indices);\\n            }\\n        }\\n\\n        Integer currMatchIndex = -1;\\n        for (char letter : s.toCharArray()) {\\n            if (!letterIndicesTable.containsKey(letter))\\n                return false; // no match, early exist\\n\\n            boolean isMatched = false;\\n            // greedy match with linear search\\n            for (Integer matchIndex : letterIndicesTable.get(letter)) {\\n                if (currMatchIndex < matchIndex) {\\n                    currMatchIndex = matchIndex;\\n                    isMatched = true;\\n                    break;\\n                }\\n            }\\n\\n            if (!isMatched)\\n                return false;\\n        }\\n\\n        // consume all characters in the source string\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290853,
                "title": "c-one-pass-solution",
                "content": "**complexity**\\n- time; O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < t.Length; i++)\\n        {\\n            if(j < s.Length && s[j] == t[i])\\n                j++;\\n        }\\n            \\n        return j == s.Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < t.Length; i++)\\n        {\\n            if(j < s.Length && s[j] == t[i])\\n                j++;\\n        }\\n            \\n        return j == s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197645,
                "title": "python-dp-standard-solution",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        m = len(t)\\n        if n==0:\\n            return True\\n        if m==0:\\n            return False\\n        \\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if t[i-1] == s[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n                if dp[i][j] == len(s):\\n                    return True\\n        return False\\n            \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        m = len(t)\\n        if n==0:\\n            return True\\n        if m==0:\\n            return False\\n        \\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if t[i-1] == s[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n                if dp[i][j] == len(s):\\n                    return True\\n        return False\\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1077933,
                "title": "c-super-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.size() && t_i < t.size()) {\\n            \\n            if (s[s_i] == t[t_i])\\n                s_i++; \\n            \\n            t_i++;\\n        }\\n        \\n        return s_i == s.size();\\n    } \\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int s_i = 0, t_i = 0;\\n        \\n        while (s_i < s.size() && t_i < t.size()) {\\n            \\n            if (s[s_i] == t[t_i])\\n                s_i++; \\n            \\n            t_i++;\\n        }\\n        \\n        return s_i == s.size();\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979390,
                "title": "easy-java-subsequence-o-n-solution-explanation",
                "content": "class Solution {\\n    \\n    //O(N) time and O(1) space\\n    public boolean isSubsequence(String s1, String s2) {\\n        \\n        //using 2 pointers\\n        \\n        int i = 0;       // for traversing String 1\\n        int j = 0;       // for traversing String 2\\n        \\n        \\n        //traversing until s1 is not fully finded OR s2 ends\\n        while(i<s1.length()  && j<s2.length()){\\n            \\n            //s2 has the ith char then move i & j\\n            if(s1.charAt(i) == s2.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            //if s2 doesnt have ith char then only move j\\n            else\\n                j++;\\n        }\\n        \\n        if(i == s1.length())     //means s1\\'s all characters matched\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    //second method is to use Longest Common Subsequence (LCS)\\n    //find out the length of LCS(s1, s2)\\n    //if(lcsLength == s1.length()) return true else false\\n    \\n    \\n    // NOTE - Thanks for reading, feel free to ask your doubts below.\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    //O(N) time and O(1) space\\n    public boolean isSubsequence(String s1, String s2) {\\n        \\n        //using 2 pointers\\n        \\n        int i = 0;       // for traversing String 1\\n        int j = 0;       // for traversing String 2\\n        \\n        \\n        //traversing until s1 is not fully finded OR s2 ends\\n        while(i<s1.length()  && j<s2.length()){\\n            \\n            //s2 has the ith char then move i & j\\n            if(s1.charAt(i) == s2.charAt(j)){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 769405,
                "title": "elegant-python-solution-91-without-using-dp-simple-to-understand-o-n",
                "content": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i=0\\n        j=0\\n        while(j<len(t) and i<len(s)):\\n            if(s[i] == t[j]):\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        if(i==len(s)):\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i=0\\n        j=0\\n        while(j<len(t) and i<len(s)):\\n            if(s[i] == t[j]):\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        if(i==len(s)):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1724727,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1571666,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1658486,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1565519,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1753335,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1682783,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1804014,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1567968,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1569976,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1574251,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1724727,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1571666,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1658486,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1565519,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1753335,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1682783,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1804014,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1567968,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1569976,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1574251,
                "content": [
                    {
                        "username": "zhou-en",
                        "content": "This test case result seems to be incorrect.\\nThe original `t` is \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyycyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyydyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\\n\\nIf all the `y`s are removed, this is what is left: `\"leeeeeetcode\"` and this does not equal to `s`=\"leeeeetcode\". So the result for this case should be `false`.\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "is this an actual test case? I think it is, my code easily did it lol"
                    },
                    {
                        "username": "midud",
                        "content": "look count \"e\""
                    },
                    {
                        "username": "freezingfire15",
                        "content": "Even it took a long time for me to understand this, but I figured it out. Take the example below.\\n\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeeeeeeeetcodee - (10 e\\'s and extra e at end)\\n\\nOutput = true\\n\\nThis is because \\'s\\' can still be formed from \\'t\\' . It does not matter if it contains extra letters .\\n\\n It matters only when t contains less e\\'s (letters) than s.\\ns= leeeeetcode - (5 e\\'s)\\nt=leeeetcodee - (4 e\\'s and extra e at end)\\n\\nOutput = false \\n\\nThis is because s needs another \\'e\\' in t to form the sub sequence\\n"
                    },
                    {
                        "username": "voronokKita",
                        "content": "You're not looking for a substring, but a subsequence. So some of the characters in the target may be repeated more times than in the sub.\n(◕‿◕)"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "its not like you can remove only one type of letter,\\nyou can also remove an \\'e\\' from leeeeeetcode to make it leeeeetcode, which is also a subsequence. hence , this test case is correct"
                    },
                    {
                        "username": "mohammedwed",
                        "content": "I too am unable to validate case 17 ."
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "The hint is in the question itself, let me put it here, \\n\"A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\""
                    },
                    {
                        "username": "emeckx",
                        "content": "I have been bashing my head against the keyboard over this testcase, since a solution to the missing \"e\" before the \"t\" contradicts the testcase 9"
                    },
                    {
                        "username": "shashankr_19",
                        "content": "If there is an extra \\'e\\' that can be removed too along with all the Ys , I think this test case is correct."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Are you guys certain? I, too can\\'t validate test 17 -_-;:\\n"
                    },
                    {
                        "username": "Cheetahboy3000",
                        "content": "that\\'s what i got wrong too. There is one extra e in the t parameter"
                    },
                    {
                        "username": "joejoechu",
                        "content": "Can anyone give any hints on the follow up? How to answer this question?"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "can you explain what\\'s that"
                    },
                    {
                        "username": "vbarinov",
                        "content": "If you don't prefer to use DP approach. I've used cache outside of function:  `{ t: { tchar:  [list of tchar positions], ... }, ... }`\n\nThen just iterate over `s`, keep `lastIndex` with the index of last match and check if: \n1) character `schar` is in `cache[t]`\n2) you can find larger index than `lastIndex` in cache list (binary search would be more effective)"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "I think its dp[c][i] by nearest char \"c\" from index \"i\".\\nTime complexity $$O(s.length)$$ for each $$s_i$$.\\nBut maybe there is something more efficient."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Two pointer Approach =>  very easy"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "stack"
                    },
                    {
                        "username": "thep1ckaxe",
                        "content": "So here's one idea for the follow up:\nSince there are more than a billion string, time complexity is now not in any second but it just need to be as low as possible.\nIn that case, we need to optimize the runtime to check 1 string to a prepared specific string. In most solution, time complexity is O(N) with N is the maximum size of string t and s. And since all the time size of s must smaller than or equal  to string t, we should be able to get this to lower than size of string t.\nThe idea here is to use prefix sum and binary search:\nFirst, we need to prepare a 2D array size 26xN call T[x-'a'][i] = number of character x appear from start to i in string t.\nFor example I have string t=\"abdeabcd\" a part of my array should look something like this: \nx\\i :0 |    1   |    2   |    3   |    4   |    5   |    6   |    7   |\na   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |    2   |\nb   |    0   |    1   |    1   |    1   |    1   |    2   |    2   |    2   |\nc   |    0   |    0   |    0   |    0   |    0   |    0   |    1   |    1   |\nd   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |    2   |\ne   |    0   |    0   |    0   |    1   |    1   |    1   |    1   |    1   |\n\nNext, with every character in string S, let say j is the position that we last found character S[i-1], to find S[i], we need to get the first position in T[ S[i] ] that have value greater than T[ S[i] - 'a' ][j], if we don't found any return false.\nFor example: With string t above and string S=\"add\", let say we found character S[1] = 'd' and we need to find S[2] which is also d, in that case, we can find it in log2(N) by binary search the value T[d][2]+1, in this case, we can find that position at j=7.\n\nCode should look sth like [this](https://pastebin.com/7tz1RjFP)\nlet say: S is maximum size of string s, N is size of string t\nWith that, overall complexity of the follow up is:\nO( K*S*log2(N) + N*26 ) much better if we do the regular algorithm with time complexity : O(N*S*K)\nFeel free to ask if there're any unclear part, and also I would like to see if there are any solution with O(1) time complexity in checking if S is subsequence of T"
                    },
                    {
                        "username": "iv_leetcoder",
                        "content": "x\\\\i :0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\\na |  0 |  4 |  4 |  4 |  0 | -1 | -1 | -1 |\\nb |  1 |  0 |  5 |  5 |  5 |  0 | -1 | -1 |\\nc |  6 |  6 |  6 |  6 |  6 |  6 |  0 | -1 |\\nd |  2 |  2 |  0 |  7 |  7 |  7 |  7 |  0 |\\ne |  3 |  3 |  3 |  0 | -1 | -1 | -1 | -1 |\\n\\nT[d][i] == -1 means that no d left in the string t\\nT[d][i] ==  0 means that d is in position i in the string t\\nT[d][i] ==  some integer > 0 means that T[d][i] is equal to the next position of letter d\\nTo fill this table one has to iterate backwards the string t\\nSearch for the next char has O(1) complexity\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/is-subsequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer with Greedy\n\n  \n**Approach 2:** Two-Pointers\n\n  \n**Approach 3:** Greedy Match with Character Indices Hashmap\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I just learned that for loops are faster than while loops\\nEnjoy your new knowledge"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@kevzpeter](/kevzpeter) Lots of people on Leetcode have no programming background so they like these kinds of black and white one liner \"advices\" that are just completely wrong. "
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Why does this baseless comment have so many likes?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Yes because you can custom the time complexity in for loop that can\\'t be done using while loop."
                    },
                    {
                        "username": "lexmarch",
                        "content": "No, they are not.\\n\\nThe assembly generated for while/for loops should generally be the same.\\nThere might be some specific cases in certain programming languages where differences could arise, but I don\\'t believe this is one of those cases."
                    },
                    {
                        "username": "z_acc",
                        "content": "do you have a explanation for this or are you basing this off your codes measured performance here? its my understanding that your performance here is a function of code speed and server load here at least that\\'s my understanding."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Thats not the case. whats happening is the submission is returning random time and space. thats why one time it can show that your code is faster than 90%,and if you submit the same code at that same time again it can show it beats 45%."
                    },
                    {
                        "username": "Aust2000",
                        "content": "I made an algorithm recently using both while and for loop, and the one with while loop was faster."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Why so?"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "In any programming language? "
                    },
                    {
                        "username": "Ancouse",
                        "content": "i don't know why it is wrong.\nTest Cases: 17/18\nabc = leeeeeetcode     # \"e\"-> 6\ns     = leeeeetcode      # \"e\"-> 5\n\ni have one more \"e\"\n\n    class Solution(object):\n        def isSubsequence(self, s, t):\n            abc=\"\"\n            #method finds s in the t , and then it writes on the abc string.\n            for i in range(len(t)):\n                for j in range(len(s)):\n                    if s[j]== t[i]:\n                        abc += t[i]\n                        break\n            #if they are some , it will be true or if it has it ,it will be true \"aba\" -> \"baba\" like that.\n            if abc == s  or abc.find(s)>0 :\n                return True\n            else:\n                return False\n\n\n\n"
                    },
                    {
                        "username": "HelainZ",
                        "content": "The complexity of this is insane -_-\n\nTry :\n```\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for i in s :\n          if i not in t :\n            return False\n          t.replace(i,'', 1)\n        return True\n```"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "This is the easiest question, so don\\'t worry.\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A programmer should know the difference between a TIP and a Solution. One shouldn\\'t tag a Solution with the TIP tag. TIP is meant to point out seekers in right direction and let them think the further steps by themselves, not to spoon feed them."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "I too have done in the similar approach bro !"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "thank you."
                    },
                    {
                        "username": "chenwu",
                        "content": "Why the tag shows DP?? DP solution would TLE since it's going to check character by character.\\n\\nAfter looking at the discuss, I realize it's a very simple and straight problem... 7 lines of python...\\n\\ndef isSubsequence(s, t):\\n\\ti = 0\\n\\tj = 0\\n\\twhile j < len(t):\\n\\t\\tif i < len(s) and s[i] == t[j]:\\n\\t\\t\\ti += 1\\n\\t\\tj += 1\\n\\treturn i == len(s)"
                    },
                    {
                        "username": "ashul",
                        "content": "because of the followup question I guess. "
                    },
                    {
                        "username": "SahilSuman_0304",
                        "content": "Why are you using Binary Search for Follow-up Question?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/b3033ed0-4ff7-4cfd-a0c8-adac13428bd5_1598013457.2319317.png)\\n\\n![image](https://assets.leetcode.com/users/images/87f4b02e-c880-4f42-a119-968e39564ace_1598013461.0032265.png)\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "OMG! what\\'s your code run time complexity ? Infinity\\nnice explanation in the pic btw"
                    }
                ]
            },
            {
                "id": 1569258,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2068009,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2067847,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2067796,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2067736,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2067652,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 2053499,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 1899424,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 1865496,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 1802595,
                "content": [
                    {
                        "username": "spirit_room",
                        "content": "792. Number of Matching Subsequences"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "how TF I implement DP, what would be the overlapping cases??"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Check if a[i]=b[j] , If true the i++ , j++..\\n If not then only increase j(j++).\\nIf i== length of a, then return true.. Else return false;\\n\\nupvote if you like or you can see my solution "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@SaiTarun2502](/SaiTarun2502) love you just getting the idea how to do"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Atleast do not copy paste the comment.\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Oh yeah, easy on Friday, I see what you did there."
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Check if s[i]=t[j] , If true the i++ , j++.. If not then only increase j(j++).\\nIf i== length of s, then return true.. Else return false;"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A relax friday :p"
                    },
                    {
                        "username": "shabeebtk07",
                        "content": "S = \"leeeeetcode\"\nT = \"yyyyylyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyeyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy“ \nHow this expected True :( failing this testcase"
                    },
                    {
                        "username": "spatulatom",
                        "content": "same here, dont get it"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The problem itself as it is can be solved in multiple very simple ways, however curious leetcoder may ask why it has the DP tag...\\nTry to solve follow-up using DP approach, but DONT use any binary search, try to use pre-calculations using DP.\\nEssentially, you need to quickly get an answer: \"What is the closest index of the current character AFTER the index I matched last time?\""
                    },
                    {
                        "username": "serhattnc",
                        "content": "how  s=\"ab\" and t=\"baab\" is Subsequence when a is comming after b. "
                    },
                    {
                        "username": "FWard",
                        "content": "Take the second or third a and final b."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "My test case is failing even it is giving the right output.\\ns=\"acb\"\\nt=\"ahbgdc\"\\nOutput-true\\nExpected-false.\\n\\ndont know what\\'s wrong with the leetcode. does anyone facing same issue"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Don\\'t forget about the order. If you take a look at the t string carefully you will see that order is \"a b c\", and your substring is \"a c b\". "
                    }
                ]
            },
            {
                "id": 1791441,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 1716303,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 1573203,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 1573090,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 1572990,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2075337,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2075333,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2072822,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2071489,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2068771,
                "content": [
                    {
                        "username": "uahmad212",
                        "content": "I tried to exploded the String t into ArrayList and checked each element using contains. It fails. I am not able to figure out why. \n\n `  public boolean isSubsequence(String s, String t) {\n\n         ArrayList<String> strList = new ArrayList<String>(Arrays.asList(t.split(\"\")));\n         for(int i=0; i<s.length(); i++){\n             if(!(strList.contains(s.charAt(i))))\n             return false;\n         }\n         return true;\n    } `"
                    },
                    {
                        "username": "emptiness_me",
                        "content": "# why this approach not work for last testcase: yyyyyyyyyyyyyyyyyy......  :((\n        hlist = []\n        if s in t: return True\n        for i in range(len(s)):\n            if s[i] in t and t.find(s[i]) not in hlist:\n                hlist.append(t.find(s[i]))\n        if len(s) == len(hlist):\n            return hlist == sorted(hlist)\n"
                    },
                    {
                        "username": "ashishkumar2306",
                        "content": "I wanted to understand, why this problem is tagged as a Dynamic Programming problem? Or am I seeing this wrong!!"
                    },
                    {
                        "username": "calebthewood",
                        "content": "I believe the follow-up prompt is a DP problem. You could build up a set of valid/invalid substrings as you go, and check to see if a given substring has already be computed before running a full comparison."
                    },
                    {
                        "username": "syatam",
                        "content": "I am a java developer and learning kotlin. I am really confused, why I always see less performance for Kotlin code even though the same in Java has a better performance. \\n\\nI am not sure whom to ask this question. Hope, someone will answer me..."
                    },
                    {
                        "username": "kushagradrdixit",
                        "content": "it depends on server traffic"
                    },
                    {
                        "username": "zhangz91",
                        "content": "Is there something I\\'m missing?\\nWhy not use a hashset for all t\\'s subsequence, then check up on s will be constant time, so O(k) total? \\nI think this will optimal, I know if t is too big will take up time,  but still comparing to k 1 billion?\\nWhy not think this is just a simple follow up, if t is short like \"apple\", isn\\'t that hashset the best solution?"
                    },
                    {
                        "username": "juba2",
                        "content": "Hashset does not preserve order and that\\'s critical to determine if s is a subsequence of t. Storing all of t\\'s characters in some sort of data structure will also affect space complexity as you mentioned."
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    // public boolean solve(String s, String temp, String t){\\n    //     if(s.equals(temp))return true;\\n    //     if(t.length()==0)return false;\\n    //     boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n    //     boolean ex=solve(s, temp,t.substring(1));\\n    //     return in||ex;\\n    // }\\n    private boolean solve(String s, String t){\\n        int len1=s.length();\\n        int len2=t.length();\\n        int [][]arr=new int[len1+1][len2+1];\\n        arr[0][0]=0;\\n        int i=1;\\n        int j=1;\\n        while(i<=len1){\\n        char ch=s.charAt(i-1);\\n        while(j<=len2){\\n            if(ch==t.charAt(j-1)){\\n                arr[i][j]=arr[i-1][j-1]+1;\\n            }else{\\n                arr[i][j]=Math.max(arr[i-1][j],arr[i][j-1]);\\n            }\\n            j++;\\n        }\\n        j=1;\\n        i++;\\n        \\n        }\\n        return len1==arr[len1][len2];\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,t);\\n    }\\n}`"
                    },
                    {
                        "username": "Sonu_kumar123",
                        "content": " `class Solution {\\n    public boolean solve(String s, String temp, String t){\\n        if(s.equals(temp))return true;\\n        if(t.length()==0)return false;\\n        boolean in=solve(s, temp+t.charAt(0),t.substring(1));\\n        boolean ex=solve(s, temp,t.substring(1));\\n        return in||ex;\\n    }\\n    \\n    public boolean isSubsequence(String s, String t) {\\n    return solve(s,\"\",t);\\n    }\\n}.`"
                    },
                    {
                        "username": "louie33",
                        "content": "There are errors in test cases , just run my code 17/19 correct.\\n\\ntest case : s=\"\" , t=\"ahbgdc\"\\n\\nexpected: true\\n\\nthis is wrong, s is not subsequence of t in this case"
                    },
                    {
                        "username": "juanpablogeve08",
                        "content": "I\\'m just not getting it, basically my code checks for true outputs from the t parameter and then adds a 1 to the variable, if the total number is not equal or greater (meaning not every letter checks out) then it returns flase, why is it failing? \\n`var isSubsequence = function(s, t) {\\n    var z = 0;\\n    for(let a = 0;a < t.length + 1;a++){\\n        if(s.includes(t[a]) === true){\\n            z++\\n        } \\n    }\\n    if (z >= s.length){\\n            return true\\n        }else if (z < s.length){\\n            return false\\n        }\\n};`"
                    },
                    {
                        "username": "suleifa1",
                        "content": "С99 \n\n`bool isSubsequence(char *s, char *t) {\n\n    if ((int)*s == 0)\n        return 1;\n    while (*t) {\n        if (*s == *t) {\n            s++;\n            if ((int)*s == 0)\n                return 1;\n        }\n        t++;\n    }\n    return 0; \n}`"
                    }
                ]
            },
            {
                "id": 2068687,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068620,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068583,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068454,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068102,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068088,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068085,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2068073,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2067919,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2067887,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "HEY, I GAVE UP BUT STARTED AGAIN FROM TODAY\\'S PROBLEM HOPE IT WILL BOOST ME SOLVED IT.\\nYES, IT WAS EASY THOUGH."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "It is actually easy. "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Why is this problem\\'s acceptance rate so low"
                    },
                    {
                        "username": "den012",
                        "content": "finally a easy problem in 30 days"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint:- Use two-pointer to count to count \\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "Placing the solution to a problem in the appropriate section is the best skill you can have."
                    },
                    {
                        "username": "elaabouazza",
                        "content": "This problem is physically nauseating. On 6th possible solution. I will bite through steel."
                    },
                    {
                        "username": "MariooY2",
                        "content": "    let sum=0;\\n    let y=0;\\n    for(let x=0;x<t.length;x++){\\n\\n        if(s[y]==t[x]){\\n            sum++;\\n            y++;\\n        }\\n        else if(s[y+1]==t[x] && t[x+1]!=s[x]){\\n            sum--;\\n        }\\n    }\\n    return sum==s.length?1:0;\\n\\neasy and simple javascript code"
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow up question asks how would you change your solution if there are a series of strings `[s1, s2, s3, ... , sk]` and you want to check if `s1` is a subsequence of `t`, `s2` is a subsequence of `t`, `s3` is a subsequence of `t`, and so on.\n\n\nYou can give it a try here: [792. Number of Matching Subsequences\n](https://leetcode.com/problems/number-of-matching-subsequences/description/)\n\nP.S.: 2 pointers give TLE on that problem"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem can be easily solved with LCS algorithm by dynamic programming. https://leetcode.com/problems/is-subsequence/solutions/4075256/lcs-easiest-dynamic-programming-o-n-2/"
                    }
                ]
            },
            {
                "id": 2067724,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2067705,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2067700,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2067686,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2067665,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2067580,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2066807,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2056515,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2044964,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2023168,
                "content": [
                    {
                        "username": "SMajumder2003",
                        "content": "If there is no string that means s.length()==0 then it would return false or true"
                    },
                    {
                        "username": "psionl0",
                        "content": "True because we reached the end of s. Had s not been a subsequence of t then we would not reach the end of s."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Never expected an easy question on friday."
                    },
                    {
                        "username": "arthurhenrique02",
                        "content": "can I import any lib to do this problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "Does anyone understand what the \"follow up\" is trying to say?"
                    },
                    {
                        "username": "psionl0",
                        "content": "It depends on what \"there are lots of incoming s\" means. Do they arrive 1 at a time or do we have the entire array of strings at the same time?"
                    },
                    {
                        "username": "luanct",
                        "content": "the difference is when you only has 1 s tring, you just checking subsequence using 2 pointers, but since there\\'re a lot of s string, you need to preprocess t first to avoid duplicate calculation process"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "exactly similar to [LCS](https://leetcode.com/problems/longest-common-subsequence) . Aditya Verma OP \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@psionl0](/psionl0)  Ya true even i have solved using 2 pointers. in the recent days i have watched the dp videos of Aditya verma. seems similar to LCS, initially tried that one  then optimized to O(n). "
                    },
                    {
                        "username": "psionl0",
                        "content": "Why would you use LCS? That is O(m*n) time. You are not finding the LCS of s and t, you are just checking if s is a subsequence of t. Just using 2 pointers will get you O(n) time."
                    },
                    {
                        "username": "psionl0",
                        "content": "Darn! When I re-submitted my solution my run time was still 0 ms but my memory useage went up from 5.6 MB to 6.6 MB (bottom 5.18%). :("
                    },
                    {
                        "username": "anindyamanna",
                        "content": "How is this in easy? Maybe easy implementation. "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy because the constraints are small so no fancy tricks are needed. Just use two pointers: one for ``t`` and one for ``s``. As you iterate through ``t``, increment the ``s`` pointer if the characters match. If you made it all the way through ``s`` then ``s`` is a subsequence of ``t``."
                    },
                    {
                        "username": "Prikers",
                        "content": "Hum...\\nSubmit a solution. Beats 15% in runtime. \\uD83D\\uDE12\\nWait for 3 seconds. Resubmit the very same code. Beats 85%!!! \\uD83E\\uDD73"
                    },
                    {
                        "username": "user2419cy",
                        "content": "can someone explain to me how \"ab\" is not subsequence of \"baab\" \\n????????????????????????????"
                    },
                    {
                        "username": "Anshul29",
                        "content": "It is. Who says its not"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t know how this is DP but it is a classic 2 pointer problem "
                    }
                ]
            },
            {
                "id": 2013617,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1996626,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1958541,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1951654,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1947104,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1934556,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1928201,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1917682,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1908854,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1907337,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "classic DP problem"
                    },
                    {
                        "username": "overbound",
                        "content": "Clearly this author doesn't understand the definition of \"sequence\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "For those who need a method to reason through the problem: https://leetcode.com/problems/is-subsequence/submissions/987638243/"
                    },
                    {
                        "username": "FWard",
                        "content": "Hey guys, I am running into a problem with this testcase:\\ns=\"\" t=\"ahbgdc\"\\nOutputting false, should be true."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It looks like you are running out from an edge case.\\nTry to check related topics and search how to apply them here.\\nFor example, try two pointers approach."
                    },
                    {
                        "username": "nhd98z",
                        "content": "I just wonder why leetcode doesn\\'t create problem for the Follow up?"
                    },
                    {
                        "username": "malokokha2",
                        "content": "Is there something wrong in the 11 testcase ? \\ns = \"acb\"\\nt= \"ahbgdc\"\\n\\nExpected = false \\ncan anyone explain why the expected output is \"false\"?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@malokokha2](/malokokha2) YES"
                    },
                    {
                        "username": "malokokha2",
                        "content": "[@ashish_2298744](/ashish_2298744) should i be aware of sequence to ?\\n"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "We can\\'t generate \"acb\" from \"ahbgdc\", since we cannot disturb the sequence of their appearance in string t."
                    },
                    {
                        "username": "geekyshark",
                        "content": "for anyone stuck, use this hint\\n\\nfid  LCS(Longest Common Subsequence) of s and t, if length of LCS==length of s, return true, else return false. Happy Leetcoding :)"
                    },
                    {
                        "username": "TYCN_129",
                        "content": "Why does this question have a DP tag? Anyone?"
                    },
                    {
                        "username": "poddar_vatsal",
                        "content": "Using recursion(inclusion, exclusion) I am getting memory limit exceeded for case 11..\\nIdea is to store all subsequences in a reference vector....then check if str belongs in the vector or not...what must be the optimal solution?\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try two pointers approach.\\nOne pointer for one string."
                    },
                    {
                        "username": "mohammad_ali_73",
                        "content": "Easy and fast solution for the problem \\n//we will use two pointer approach here \\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n       // j is a pointer which is pointing in the string s  \\n       //j pointer starts with initial indix \\n        int j = 0;\\n\\n        //if the string is empty it is also the subsequence of the string so in this case ww will return true\\n        if(s==\"\")return true;\\n          \\n          //now the second pointer i itrating in t string (as t is main string )\\n          //we will compare the elements of \"t\" string to elements of \"s\" string \\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == s[j])j++; //if ement matches then increment the j pointer\\n\\n            //if we reach the last element of s string means we are done \\n            if(j == s.size()) return true; \\n\\n        }\\n        return false; //if not then this is not subsequence \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and fast rules for the Discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1901579,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1898490,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1889911,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1887002,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1869063,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1862885,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1860720,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1854640,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1845804,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1819188,
                "content": [
                    {
                        "username": "sharma_bhabani",
                        "content": "This code works locally in PyCharm. But when I submit the code in LC, Case 2 is failing. Not sure why \\n\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        mapDict = {}\\n        firstString = s\\n        secondString = t\\n        idx =0\\n        count =0\\n        for i in range(len(secondString)):\\n            if not secondString[i] in mapDict:\\n                mapDict[secondString[i]]=i\\n        for i in range(len(firstString)):\\n            if firstString[i] in mapDict and idx <= mapDict[firstString[i]]:\\n                idx =  mapDict[firstString[i]]\\n                count = count + 1\\n            else:\\n                return \\'False\\'\\n            if count == len(firstString):\\n                return \\'True\\'    "
                    },
                    {
                        "username": "luisfernandophsc",
                        "content": "My solution in Python3:\\n```\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(t)>=len(s):\\n            for x in s:\\n                if x in t:\\n                    t = t[t.index(x)+1:]\\n                else:\\n                    return False\\n        else:\\n            return False\\n                \\n        return True\\n```\\n\\nThe logic of the code is as follows:\\n\\n1 - The method iterates over each character \"x\" in the string \"s\".\\n\\n2 - For each character \"x\", it checks if it is present in the string \"t\" using the \"in\" operator.\\n\\n3 - If the character \"x\" is found in \"t\", it updates the string \"t\" by excluding the already tested character \"x\". This is done by finding the \\n     position of the first occurrence of \"x\" using the \"index\" method, and then taking a slice of the string \"t\" starting from that position plus \\n     one (t[t.index(x)+1:]). This effectively removes the character \"x\" from the remaining portion of \"t\".\\n\\n4 - If the character \"x\" is not present in \"t\", it means that \"s\" cannot be a subsequence of \"t\". In this case, the method returns False.\\n\\n5 - If all iterations are successfully completed, i.e., all characters of \"s\" have been found in \"t\" in the correct order while excluding the tested \\n     characters, the method returns True."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "goyalishika132",
                        "content": "Hey can someone help me this. I am getting Time Limit Exceed problem 11/18\\n\\n void check(int index,int n,string t, vector<string> &v,string st)\\n    {\\n        if(index>=n)\\n        {\\n            v.push_back(st);\\n            return;\\n        }\\n\\n        st+=t[index];\\n        check(index+1,n,t,v,st);\\n        st.pop_back();\\n        check(index+1,n,t,v,st);\\n    }\\n\\nbool isSubsequence(string s, string t) {\\n        vector<string> v;\\n        int n=t.size();\\n        string st=\"\";\\n        check(0,n,t,v,st);\\n        if(find(v.begin(),v.end(),s)==v.end())\\n            return false;\\n        else\\n            return true;    \\n    }\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Don\\'t use recursive appraoch for this prolem, use simple iterative approach\\n\\n1. check if s[i] == t[j] , if yes then increase both i and j,\\n2. if not, then increase only j++;\\n3. In the end, if ( i==size of s ), return true, else return false.\\n\\nSolution : https://leetcode.com/problems/is-subsequence/submissions/899560605/"
                    },
                    {
                        "username": "Vladikur",
                        "content": "Hello! Can you tell me why the expected result in Case1 is empty? Javascript.\\nhttps://leetcode.com/problems/is-subsequence/?envType=study-plan&id=level-1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Think of two pointers approach here.\nIt is a good start."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isSubsequence(String s, String t) {\\n        int counter = 0;\\n        int k = t.length()-1;\\n        int j = s.length()-1;\\n\\n        for(;k>=0;k--){\\n            if(j>=0 && t.charAt(k)==s.charAt(j)){\\n                j--;\\n                counter++;\\n            }\\n        }\\n\\n        if(counter==s.length()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast | c++| understandable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking letter of s string in t string in order wise\\n\\nApproach\\nfor loop\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n\\n    bool isSubsequence(string s, string t) {\\n        \\n        if( s.size()>t.size())\\n        { return false;}\\n\\n        if( s.size()==0)\\n        {\\n             return true ;\\n        }\\n       \\n       int j=0;\\n\\n       for( auto it: t)\\n       {\\n            if( j==s.size())\\n            {\\n                 return true;\\n            }\\n\\n            if( it==s[j] )\\n            { \\n                j++;\\n            }\\n       }\\n\\n       if( j==s.size())\\n       {\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast and understandable rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sk212",
                        "content": "With the follow up question, I've seen people say that it is a dynamic programming problem, but I don't understand why it should be. This is my solution to the original question:\n\n        s_count = 0\n        for i in range(len(t)):\n            if(s_count < len(s)):\n                if s[s_count] == t[i]:\n                    s_count += 1\n        if (s_count != len(s)):\n            return False\n        return True\n\nAnd I think the only change I would make to the above code for the follow-up would be to keep a count of how many chars in s we've seen and then use that count instead of len(s). Would that be incorrect and do I really need a DP to solve the follow-up?"
                    },
                    {
                        "username": "MichaelArnoldOwens",
                        "content": "in the case of `s = \"abc\"` and `t = \"\"`, the judge expects false, but can\\'t you just delete all the characters in `s` to get `\"\"` ?"
                    },
                    {
                        "username": "lamardeepak5",
                        "content": "\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        int i = 0, j = 0;\\n        while(i < m && j < n) {\\n            if(s[i] == t[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1811253,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1800230,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1786253,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1782613,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1776247,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1760358,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1753073,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1752740,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1750092,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1741390,
                "content": [
                    {
                        "username": "Swang2022",
                        "content": "The testcase 17/18 is broken i think because it expects false when you return true\\nand true when you return false\\nis anyone else getting this error?"
                    },
                    {
                        "username": "Sidchou",
                        "content": "why does my regex exceed time limit....\\nsaw some people can use regex for python, but i cant do it for c#?\\nthis is how i do it, maybe i cant use for loop\\n ```using System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsSubsequence(string s, string t) {\\n        string rgstr = @\"\";\\n        for(int i = 0; i < s.Length; i ++)\\n        {\\n            rgstr += s[i];\\n            if(i != s.Length-1)\\n            rgstr += @\".*\";\\n        }\\n\\n        Regex rx = new Regex(rgstr);\\n        \\n        return rx.IsMatch(t);\\n    }\\n}"
                    },
                    {
                        "username": "annealex",
                        "content": "Hi, when I run the debugger I see the right output but when I submit my answer, this one test case fails saying wrong answer. I used the same test case in the debugger which gives me the expected answer. Whats the issue?"
                    },
                    {
                        "username": "user1059cR",
                        "content": "Can some tell me what is wrong with my code?  The wrong boolean is returned and I am not sure why\\n\\nclass Solution(object):\\n    def isSubsequence(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"    \\n        self.pointerBased(s, t)\\n\\n\\n    def pointerBased(self, s, t): # What is\\n        pointer = 0 \\n\\n        for i in t: \\n            if pointer == len(s): \\n                break \\n            \\n            if s[pointer] == i: \\n                pointer +=1 \\n                print(i , pointer)\\n               \\n        print(pointer, len(s))\\n        \\n        return True if  pointer==len(s) else False\\n"
                    },
                    {
                        "username": "Saybhagya_08",
                        "content": "Tiilii liii"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/392_IS_SUBSEQUENCE.CPP"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Beat 97% run time and 91% space JS submission \\n\\nhttps://leetcode.com/problems/is-subsequence/solutions/3036989/js-beats-97-91-time-and-space-explanation-built-in-fn-indexof-slice-o-n-2-time/"
                    },
                    {
                        "username": "Legend_33",
                        "content": "\n\t\tfunc isSubsequence(_ s: String, _ t: String) -> Bool {\n    var sIndex = s.startIndex\n    var tIndex = t.startIndex\n    while sIndex < s.endIndex && tIndex < t.endIndex {\n        if s[sIndex] == t[tIndex] {\n            sIndex = s.index(after: sIndex)\n        }\n        tIndex = t.index(after: tIndex)\n    }\n    return sIndex == s.endIndex\n}\n\t\t\n\nswift solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "if string1 is empty return true but if string 2 i.e. t is empty return false"
                    },
                    {
                        "username": "salih_mutlu",
                        "content": "Why is this question DP, the solution does not build upon the solution of sub-probems. It is not even two pointers (ok, you use two pointers for s and t, but not in the real context of algorithm). It is just simple string char comparison."
                    }
                ]
            },
            {
                "id": 1736346,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1735060,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1731372,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724077,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1722620,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1722439,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1721557,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1721172,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710144,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709656,
                "content": [
                    {
                        "username": "gocreating",
                        "content": "Sure, DP is absolutely \"easy\" question"
                    },
                    {
                        "username": "Rheinhard",
                        "content": "\nIn str t, search for each character of str s sequentially. \n\nThe search `scope` is initially the entire str t.\nFor each character `ch` in str s, searching for the position of `ch` in `scope`\n①If succeed in finding the position, slice the `scope` and let the next `scope` start from this position, which ensures the sequence.\n②If fail to find it, return False.\n\n"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "can anyone please explain me , how its DP problem? I don\\'t get it !"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aryan1113",
                        "content": "How is \\'ab\\' a subsequence of \\'baab\\' ?\\n"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@aryan1113](/aryan1113) No.\\nThe 2nd character is \\'a\\' and the last is \\'b\\'. That is the subsequence.\\nindeces 1,3 are being matched."
                    },
                    {
                        "username": "aryan1113",
                        "content": "Acchaa, got it, \"baab\" has \"ab\" in the end"
                    },
                    {
                        "username": "user0329ov",
                        "content": "```\\nvar isSubsequence = function(s, t) {\\n    let j = 0;\\n    for(let i = 0; i < t.length & j < s.length; i++) {\\n        if(t[i] == s[j])  j++;\\n    }\\n    return j == s.length;\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Brandon-Wang",
                        "content": "So by looking at the description; is it possible that s is longer than t and for s to be a subsequence of t? No, correct?\\n"
                    },
                    {
                        "username": "WildChildx",
                        "content": "````\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n    if(t.size()==0 and s.size()>0)\\n        return false;\\n\\n      int j = 0,count=0;\\n      for(int i = 0;i<t.size();i++){\\n          if(t[i]==s[j]){\\n              j++;\\n              count++;\\n          }\\n      }\\n      if(count==s.size())\\n        return true;\\n      return false;\\n    }\\n};\\n\\n````"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "liyamQ",
                        "content": "Guys, what is the time complexity in this solution? \n\n `public class Solution {\n    public bool IsSubsequence(string s, string t) {\n            \nif (s.Length == 0) return true;\n\n            char[] s1 = s.ToCharArray();\n            char[] t1 = t.ToCharArray();\n            int storeJ = 0;\n            int counter = 0;\n            for(int i = 0; i<s.Length;i++)\n            {\n                for(int j = storeJ; j<t.Length;j++)\n                {\n                    if(s1[i]==t1[j])\n                    {\n                   counter++;\n                        storeJ = j+1;\n                    j = t.Length-1;\n                    }\n               }\n                if (counter == s.Length)\n                   return true;\n            }\n            return false;\n    }\n}`\n\nAs you can see, there's a for loop inside a for loop, which usually indicates of O(n^2), the thing is that the 2nd loop is basically running on the string t one time, which means it should be O(2n) which basically just a O(n)...? I'm not sure, thanks in advance for whoever reaches out!"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "class Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        n_e=0\\n        f=0\\n        for i in range(len(s)):\\n\\n            \\n            for j in range(n_e,len(t)):\\n                \\n                if s[i]==t[j]:\\n\\n                    f+=1\\n                    \\n                    n_e=j+1\\n                    break\\n        if f==len(s):\\n                return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1705980,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1697153,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1691222,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1688937,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1671433,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1671304,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1635432,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1629622,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1624903,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2067870,
                "content": [
                    {
                        "username": "AjayAjmera",
                        "content": "If you see the solution posted for 0ms time, It uses String.contains() method which has a time complexity of O(n) where n is the length of bigger string which contains the subsequence. It loops for k times where k is length of the s ( string which is present as subsequence). Hence, its time complexity will be O(n*k). I have used a 2-pointer way where i use one pointer on the s and one on t and i keep on comparing the character at those index, if matched increment both and if not then increment the pointer of t.  My code has time complexity of O(n) only which is less than O(n*k), so why is my code\\'s runtime more than the 0ms one??"
                    },
                    {
                        "username": "vivekpatel99586",
                        "content": "Easy solution without use of Collections\\n\\nclass Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        String newValue=\"\";\\n        int val=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            for(int j=val;j<t.length();j++){\\n                if(ch==t.charAt(j)){\\n                    newValue+=ch;\\n                    val=j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        if(newValue.equals(s)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy rules without use of posting solutions in discussion.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nfunction isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\')\\n\\n  for (const chr of t) {\\n    if (sChars[0] === chr) {\\n      sChars.shift();\\n    }\\n  }\\n\\n  return sChars.length === 0\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "itzme",
                        "content": "```javascript\\nThoughts on the following solution?\\n\\n function isSubsequence(s, t) {\\n  const sChars = s.split(\\'\\');  \\n  const charsMap = sChars.reduce(\\n    (map, key, idx) => {\\n      const val = map.get(key) || []\\n      val.push(idx)\\n      return map.set(key, val)\\n    }, new Map()\\n  )\\n   \\n  let matchIndex = 0;\\n  for(let i = 0; i < t.length; i++) {\\n      let tChar = t.charAt(i);\\n      let valArray = charsMap.get(tChar) || [];\\n       if (valArray[0] === matchIndex) {\\n        matchIndex++;        \\n        valArray.shift();\\n    }\\n  }\\n\\n  return matchIndex === s.length;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vmb004",
                        "content": " `        \\n        if len(s) == 0:                     #edge case for null\\n           return True\\n        \\n        indx = 0\\n        sarr = [0 for x in range(len(s))]   #create array size s \\n        for st in t:                        #iterate through t\\n            if st in s and st in s[indx]:\\n                sarr[indx] = 1\\n                indx  += 1\\n    \\n        for a in sarr:                      #search for non 1 values\\n            if a == 1:\\n                continue\\n            else:\\n                return False\\n        return True`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "_Abhishek_Sharma_",
                        "content": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n       if(s.length() > t.length())\n            return false;\n        \n        int i=0;\n        int j=0;\n        while(i<s.length() && j<t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        \n        if(i==s.length())\n            return true;\n        else\n            return false;\n         \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "HariKrishnaDuvvada",
                        "content": "temp = 0\\n        if len(s) == 0:\\n            return True\\n        else:\\n            for i in t:\\n                if s[temp] == i:\\n                    temp += 1\\n                    if temp == len(s):\\n                        break\\n            if temp == len(s):\\n                return True\\n            else:\\n                return False "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        const char* ps = s.c_str();\\n        const char* pt = t.c_str();\\n\\n        while(*ps != \\'\\\\0\\' && *pt != \\'\\\\0\\') {\\n            if(*ps == *pt) {\\n                ++ps;\\n            }\\n            ++pt;\\n        }\\n\\n        return *ps == \\'\\\\0\\';\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hakantongur",
                        "content": "      public boolean isSubsequence(String s, String t) {\\n          char[] chars1 = s.toCharArray();\\n          char[] chars2 = t.toCharArray();\\n          if(s.equals(\"\")){\\n              return true;\\n          }\\n          return helper(0, 0,chars1, chars2);\\n      }\\n\\n      private boolean helper(int indexS, int current, char[] chars1, char[] chars2){\\n        if(indexS == chars1.length){\\n            return true;\\n        }\\n        for(int i=current; i<chars2.length; i++){\\n            if(chars1[indexS] == chars2[i]){\\n                return helper(indexS+1, i+1, chars1, chars2);\\n            }\\n        }\\n\\n        return false;\\n      }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n         String ans =\"\";\\n        int j=-1;\\n        for(int i=0;i<s.length();i++){\\n            j++;\\n            for(;j<t.length();j++){\\n                if(s.charAt(i)==t.charAt(j)){\\n                    ans+=t.charAt(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if(s.contentEquals(ans)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]