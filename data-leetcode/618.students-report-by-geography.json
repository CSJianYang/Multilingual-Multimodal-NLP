[
    {
        "title": "Add Bold Tag in String",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1575945,
                "content": [
                    {
                        "username": "identical123",
                        "content": "just wondering . seems impossible to come up with a solution on the spot"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Such thing become into my mind when I read the description first time. Then you need to split the solution into steps/phase and it becomes clear.\\n\\n1. find positions of tags in string\\n2. merge all overlap positions\\n3. build the result according to positions from step #2"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Should be this task marked as 'Hard'? \nFrom my point of view it's combination of several 'Medium' level problems, but it's a lot of code to write for the full task. "
                    },
                    {
                        "username": "as9vd2",
                        "content": "Very involved and a lot of test cases for a medium. Not too bad though I don\\'t think."
                    }
                ]
            },
            {
                "id": 1751044,
                "content": [
                    {
                        "username": "identical123",
                        "content": "just wondering . seems impossible to come up with a solution on the spot"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Such thing become into my mind when I read the description first time. Then you need to split the solution into steps/phase and it becomes clear.\\n\\n1. find positions of tags in string\\n2. merge all overlap positions\\n3. build the result according to positions from step #2"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Should be this task marked as 'Hard'? \nFrom my point of view it's combination of several 'Medium' level problems, but it's a lot of code to write for the full task. "
                    },
                    {
                        "username": "as9vd2",
                        "content": "Very involved and a lot of test cases for a medium. Not too bad though I don\\'t think."
                    }
                ]
            },
            {
                "id": 1970113,
                "content": [
                    {
                        "username": "identical123",
                        "content": "just wondering . seems impossible to come up with a solution on the spot"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Such thing become into my mind when I read the description first time. Then you need to split the solution into steps/phase and it becomes clear.\\n\\n1. find positions of tags in string\\n2. merge all overlap positions\\n3. build the result according to positions from step #2"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "Should be this task marked as 'Hard'? \nFrom my point of view it's combination of several 'Medium' level problems, but it's a lot of code to write for the full task. "
                    },
                    {
                        "username": "as9vd2",
                        "content": "Very involved and a lot of test cases for a medium. Not too bad though I don\\'t think."
                    }
                ]
            }
        ]
    },
    {
        "title": "Merge Two Binary Trees",
        "question_content": "<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>\n\n<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>\n\n<p>Return <em>the merged tree</em>.</p>\n\n<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"width: 600px; height: 163px;\" />\n<pre>\n<strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>Output:</strong> [3,4,5,5,4,null,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [1], root2 = [1,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 104302,
                "title": "python-straightforward-with-explanation",
                "content": "Let's create a recursive solution.\\n* If both trees are empty then we return empty.\\n* Otherwise, we will return a tree.  The root value will be t1.val + t2.val, except these values are 0 if the tree is empty.\\n* The left child will be the merge of t1.left and t2.left, except these trees are empty if the parent is empty.\\n* The right child is similar.\\n\\n```\\ndef mergeTrees(self, t1, t2):\\n    if not t1 and not t2: return None\\n    ans = TreeNode((t1.val if t1 else 0) + (t2.val if t2 else 0))\\n    ans.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)\\n    ans.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef mergeTrees(self, t1, t2):\\n    if not t1 and not t2: return None\\n    ans = TreeNode((t1.val if t1 else 0) + (t2.val if t2 else 0))\\n    ans.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)\\n    ans.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 588123,
                "title": "100-00-fast-in-run-time-and-memory-recursive-iterative-bfs-dfs",
                "content": "**Using Recursion (DFS Similar) 1:** \\n**Time complexity** : **O(m)**. A total of m nodes need to be traversed. Here, m represents the minimum number of nodes from the two given trees.\\n**Space complexity** : **O(m)**. The depth of the recursion tree can go upto m in the case of a skewed tree. In **average case**, depth will be ****O(logm).\\n```\\nstatic int x = []() {\\nstd::ios::sync_with_stdio(false);\\ncin.tie(nullptr);\\nreturn 0; }();\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1) return t2;\\n        if(!t2) return t1;\\n        t1->val+=t2->val;\\n        if(t2->left) t1->left = mergeTrees(t1->left,t2->left);\\n        if(t2->right) t1->right = mergeTrees(t1->right,t2->right);\\n        return t1;\\n    }\\n};\\n```\\n\\n**Using Recursion (DFS Similar) 2:** \\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1) return t2;\\n        if(!t2) return t1;\\n        t1->val+=t2->val;\\n        t1->left = mergeTrees(t1->left,t2->left);\\n        t1->right = mergeTrees(t1->right,t2->right);\\n        return t1;\\n    }\\n};\\n```\\n\\n**Create New Tree 1:**\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2,TreeNode* &root){\\n        if(!t1 && !t2) return;\\n        else if(t1 && !t2){\\n            TreeNode* node(new TreeNode(t1->val));\\n            root=node;\\n            dfs(t1->left,t2,root->left);\\n            dfs(t1->right,t2,root->right);\\n        }else if(t2 && !t1){\\n            TreeNode* node(new TreeNode(t2->val));\\n            root=node;\\n            dfs(t1,t2->left,root->left);\\n            dfs(t1,t2->right,root->right);\\n        }else{\\n            TreeNode* node(new TreeNode(t1->val+t2->val));\\n            root=node;\\n            dfs(t1->left,t2->left,root->left);\\n            dfs(t1->right,t2->right,root->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        TreeNode* root(nullptr);\\n        dfs(t1,t2,root);\\n        return root;\\n    }\\n};\\n```\\n\\n**Create New Tree 2:**\\nIn the real world, sharing nodes between the old trees and the new tree can be a problem. If any of the old trees is deleted, it\\'s going to also destruct the shared nodes in the new tree. C++ does have some nice & clean solutions for this, like using shared_ptr for example. But as-is I\\'d say the \\'trick\\' of reusing nodes from the old trees does more harm than good and if I were the interviewer, unless the interviewee points these nuances out I\\'d be lead to believe that they don\\'t have a good grasp on memory management in C++. Especially since the \\'safe\\' solution is not that much more code:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        int val1 = t1? t1->val:0;\\n        int val2 = t2? t2->val:0;\\n        \\n        TreeNode* t = new TreeNode(val1+val2);\\n        t->left = mergeTrees(t1?t1->left:nullptr,t2?t2->left:nullptr);\\n        t->right = mergeTrees(t1?t1->right:nullptr,t2?t2->right:nullptr);\\n        return t;\\n    }\\n};\\n```\\n\\n------\\n**Iterative: Using Stack**\\n**Time complexity** : **O(n)**. We traverse over a total of n nodes. Here, nn refers to the smaller of the number of nodes in the two trees.\\n\\n**Space complexity** : **O(n)**. The depth of stack can grow upto n in case of a skewed tree.\\n```\\nclass Solution { // iterative: Stack\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1 || !t2) return t1? t1:t2;\\n\\t\\t\\t\\t\\n        stack<TreeNode*> s1,s2;\\n        s1.push(t1);\\n        s2.push(t2);\\n        \\n        while(!s1.empty()){\\n            TreeNode* c1(s1.top());\\n            TreeNode* c2(s2.top());\\n            s1.pop();\\n            s2.pop();\\n            \\n            c1->val+=c2->val;\\n            \\n            if(!c1->left && c2->left) c1->left = c2->left;\\n            else if(c1->left && c2->left) { s1.push(c1->left); s2.push(c2->left); }\\n            \\n            if(!c1->right && c2->right) c1->right = c2->right;\\n            else if(c1->right && c2->right) { s1.push(c1->right); s2.push(c2->right); }\\n        }\\n        return t1;\\n    }\\n};\\n```\\n\\n----\\n**Iterative: Using Queue**\\n\\n```\\nclass Solution { // iterative: Queue    \\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1 || !t2) return t1? t1:t2;\\n\\n        queue<TreeNode*> q1,q2;\\n        q1.push(t1);\\n        q2.push(t2);\\n        \\n        while(!q1.empty() && !q2.empty()){\\n            TreeNode* c1(q1.front());\\n            TreeNode* c2(q2.front());\\n            q1.pop();\\n            q2.pop();\\n            \\n            c1->val+=c2->val;\\n            \\n            if(!c1->left && c2->left) c1->left = c2->left;\\n            else if(c1->left && c2->left) { q1.push(c1->left); q2.push(c2->left); }\\n            \\n            if(!c1->right && c2->right) c1->right = c2->right;\\n            else if(c1->right && c2->right) { q1.push(c1->right); q2.push(c2->right); }\\n        }\\n        return t1;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nstatic int x = []() {\\nstd::ios::sync_with_stdio(false);\\ncin.tie(nullptr);\\nreturn 0; }();\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1) return t2;\\n        if(!t2) return t1;\\n        t1->val+=t2->val;\\n        if(t2->left) t1->left = mergeTrees(t1->left,t2->left);\\n        if(t2->right) t1->right = mergeTrees(t1->right,t2->right);\\n        return t1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1) return t2;\\n        if(!t2) return t1;\\n        t1->val+=t2->val;\\n        t1->left = mergeTrees(t1->left,t2->left);\\n        t1->right = mergeTrees(t1->right,t2->right);\\n        return t1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2,TreeNode* &root){\\n        if(!t1 && !t2) return;\\n        else if(t1 && !t2){\\n            TreeNode* node(new TreeNode(t1->val));\\n            root=node;\\n            dfs(t1->left,t2,root->left);\\n            dfs(t1->right,t2,root->right);\\n        }else if(t2 && !t1){\\n            TreeNode* node(new TreeNode(t2->val));\\n            root=node;\\n            dfs(t1,t2->left,root->left);\\n            dfs(t1,t2->right,root->right);\\n        }else{\\n            TreeNode* node(new TreeNode(t1->val+t2->val));\\n            root=node;\\n            dfs(t1->left,t2->left,root->left);\\n            dfs(t1->right,t2->right,root->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        TreeNode* root(nullptr);\\n        dfs(t1,t2,root);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        int val1 = t1? t1->val:0;\\n        int val2 = t2? t2->val:0;\\n        \\n        TreeNode* t = new TreeNode(val1+val2);\\n        t->left = mergeTrees(t1?t1->left:nullptr,t2?t2->left:nullptr);\\n        t->right = mergeTrees(t1?t1->right:nullptr,t2?t2->right:nullptr);\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution { // iterative: Stack\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1 || !t2) return t1? t1:t2;\\n\\t\\t\\t\\t\\n        stack<TreeNode*> s1,s2;\\n        s1.push(t1);\\n        s2.push(t2);\\n        \\n        while(!s1.empty()){\\n            TreeNode* c1(s1.top());\\n            TreeNode* c2(s2.top());\\n            s1.pop();\\n            s2.pop();\\n            \\n            c1->val+=c2->val;\\n            \\n            if(!c1->left && c2->left) c1->left = c2->left;\\n            else if(c1->left && c2->left) { s1.push(c1->left); s2.push(c2->left); }\\n            \\n            if(!c1->right && c2->right) c1->right = c2->right;\\n            else if(c1->right && c2->right) { s1.push(c1->right); s2.push(c2->right); }\\n        }\\n        return t1;\\n    }\\n};\\n```\n```\\nclass Solution { // iterative: Queue    \\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(!t1 && !t2) return nullptr;\\n        if(!t1 || !t2) return t1? t1:t2;\\n\\n        queue<TreeNode*> q1,q2;\\n        q1.push(t1);\\n        q2.push(t2);\\n        \\n        while(!q1.empty() && !q2.empty()){\\n            TreeNode* c1(q1.front());\\n            TreeNode* c2(q2.front());\\n            q1.pop();\\n            q2.pop();\\n            \\n            c1->val+=c2->val;\\n            \\n            if(!c1->left && c2->left) c1->left = c2->left;\\n            else if(c1->left && c2->left) { q1.push(c1->left); q2.push(c2->left); }\\n            \\n            if(!c1->right && c2->right) c1->right = c2->right;\\n            else if(c1->right && c2->right) { q1.push(c1->right); q2.push(c2->right); }\\n        }\\n        return t1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104301,
                "title": "short-recursive-solution-w-python-c",
                "content": "as the problem description says: Otherwise, the NOT null node will be used as the node of new tree. so here comes this solution.\\n\\npython solution\\n```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        if t1 and t2:\\n            root = TreeNode(t1.val + t2.val)\\n            root.left = self.mergeTrees(t1.left, t2.left)\\n            root.right = self.mergeTrees(t1.right, t2.right)\\n            return root\\n        else:\\n            return t1 or t2\\n```\\nc++ solution\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        if t1 and t2:\\n            root = TreeNode(t1.val + t2.val)\\n            root.left = self.mergeTrees(t1.left, t2.left)\\n            root.right = self.mergeTrees(t1.right, t2.right)\\n            return root\\n        else:\\n            return t1 or t2\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104308,
                "title": "java-c-clean-code-unique-node-shared-node-5-liner",
                "content": "**Java - Shared Node**\\n```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n\\n        TreeNode node = new TreeNode(t1.val + t2.val);\\n        node.left = mergeTrees(t1.left, t2.left);\\n        node.right = mergeTrees(t1.right, t2.right);\\n        return node;\\n    }\\n}\\n```\\n**Create new Nodes**\\nI like to create new nodes for newly formed tree in this type of problem, as you are literally creating nested graph otherwise.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 && !t2) return nullptr;\\n\\n        TreeNode* node = new TreeNode((t1 ? t1->val : 0) + (t2 ? t2->val : 0));\\n        node->left = mergeTrees((t1 ? t1->left : nullptr), (t2 ? t2->left : nullptr));\\n        node->right = mergeTrees((t1 ? t1->right : nullptr), (t2 ? t2->right : nullptr));\\n        return node;\\n    }\\n};\\n```\\n\\n**Share Nodes with the nonnull TreeNode**\\nAs @zqfan point out, this problem explicitly tell you to use the NOT null node, there is no need to create new nodes. And the code would also be simpler.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 || !t2) return t1 ? t1 : t2;\\n\\n        TreeNode* node = new TreeNode(t1->val + t2->val);\\n        node->left = mergeTrees(t1->left, t2->left);\\n        node->right = mergeTrees(t1->right, t2->right);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n\\n        TreeNode node = new TreeNode(t1.val + t2.val);\\n        node.left = mergeTrees(t1.left, t2.left);\\n        node.right = mergeTrees(t1.right, t2.right);\\n        return node;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 && !t2) return nullptr;\\n\\n        TreeNode* node = new TreeNode((t1 ? t1->val : 0) + (t2 ? t2->val : 0));\\n        node->left = mergeTrees((t1 ? t1->left : nullptr), (t2 ? t2->left : nullptr));\\n        node->right = mergeTrees((t1 ? t1->right : nullptr), (t2 ? t2->right : nullptr));\\n        return node;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 || !t2) return t1 ? t1 : t2;\\n\\n        TreeNode* node = new TreeNode(t1->val + t2->val);\\n        node->left = mergeTrees(t1->left, t2->left);\\n        node->right = mergeTrees(t1->right, t2->right);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104429,
                "title": "python-bfs-solution",
                "content": "```python\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not (t1 and t2):\\n            return t1 or t2\\n        queue1, queue2 = collections.deque([t1]), collections.deque([t2])\\n        while queue1 and queue2:\\n            node1, node2 = queue1.popleft(), queue2.popleft()\\n            if node1 and node2:\\n                node1.val = node1.val + node2.val\\n                if (not node1.left) and node2.left:\\n                    node1.left = TreeNode(0)\\n                if (not node1.right) and node2.right:\\n                    node1.right = TreeNode(0)\\n                queue1.append(node1.left)\\n                queue1.append(node1.right)\\n                queue2.append(node2.left)\\n                queue2.append(node2.right)\\n        return t1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not (t1 and t2):\\n            return t1 or t2\\n        queue1, queue2 = collections.deque([t1]), collections.deque([t2])\\n        while queue1 and queue2:\\n            node1, node2 = queue1.popleft(), queue2.popleft()\\n            if node1 and node2:\\n                node1.val = node1.val + node2.val\\n                if (not node1.left) and node2.left:\\n                    node1.left = TreeNode(0)\\n                if (not node1.right) and node2.right:\\n                    node1.right = TreeNode(0)\\n                queue1.append(node1.left)\\n                queue1.append(node1.right)\\n                queue2.append(node2.left)\\n                queue2.append(node2.right)\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104331,
                "title": "java-one-recursive-solution-and-two-iterative-solutions-dfs-and-bfs-with-explanations",
                "content": "Solution 1: Recursive Solution\\n```\\n// Method 1: Recursive Solution\\n// Time: O(n)\\n// Space: O(height)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n\\n  if (t2 != null) {\\n    t1.val += t2.val;\\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n  }\\n\\n  return t1;\\n}\\n```\\n\\nSolution 2: Iterative DFS\\n```\\n// Method 2: Iterative DFS\\n// Time: O(n)\\n// Space: O(height)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n  // Use stack to help DFS\\n  Deque<TreeNode[]> stack = new LinkedList<>();\\n  stack.offerLast(new TreeNode[] {t1, t2});\\n  while (!stack.isEmpty()) {\\n    TreeNode[] cur = stack.pollLast();\\n    // no need to merge t2 into t1\\n    if (cur[1] == null) {\\n      continue;\\n    }\\n    // merge t1 and t2\\n    cur[0].val += cur[1].val;\\n    // if node in t1 == null, use node in t2 instead\\n    // else put both nodes in stack to merge\\n    if (cur[0].left == null) {\\n      cur[0].left = cur[1].left;\\n    } else {\\n      stack.offerLast(new TreeNode[] {cur[0].left, cur[1].left});\\n    }\\n    if (cur[0].right == null) {\\n      cur[0].right = cur[1].right;\\n    } else {\\n      stack.offerLast(new TreeNode[] {cur[0].right, cur[1].right});\\n    }\\n  }\\n  return t1;\\n}\\n```\\n\\nSolution 3: Iterative BFS\\n```\\n// Method 3: Iterative BFS\\n// Time: O(n)\\n// Space: O(n)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n  // Use stack to help DFS\\n  Queue<TreeNode[]> queue = new LinkedList<>();\\n  queue.offer(new TreeNode[] {t1, t2});\\n  while (!queue.isEmpty()) {\\n    TreeNode[] cur = queue.poll();\\n    // no need to merge t2 into t1\\n    if (cur[1] == null) {\\n      continue;\\n    }\\n    // merge t1 and t2\\n    cur[0].val += cur[1].val;\\n    // if node in t1 == null, use node in t2 instead\\n    // else put both nodes in stack to merge\\n    if (cur[0].left == null) {\\n      cur[0].left = cur[1].left;\\n    } else {\\n      queue.offer(new TreeNode[] {cur[0].left, cur[1].left});\\n    }\\n    if (cur[0].right == null) {\\n      cur[0].right = cur[1].right;\\n    } else {\\n      queue.offer(new TreeNode[] {cur[0].right, cur[1].right});\\n    }\\n  }\\n  return t1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Method 1: Recursive Solution\\n// Time: O(n)\\n// Space: O(height)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n\\n  if (t2 != null) {\\n    t1.val += t2.val;\\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n  }\\n\\n  return t1;\\n}\\n```\n```\\n// Method 2: Iterative DFS\\n// Time: O(n)\\n// Space: O(height)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n  // Use stack to help DFS\\n  Deque<TreeNode[]> stack = new LinkedList<>();\\n  stack.offerLast(new TreeNode[] {t1, t2});\\n  while (!stack.isEmpty()) {\\n    TreeNode[] cur = stack.pollLast();\\n    // no need to merge t2 into t1\\n    if (cur[1] == null) {\\n      continue;\\n    }\\n    // merge t1 and t2\\n    cur[0].val += cur[1].val;\\n    // if node in t1 == null, use node in t2 instead\\n    // else put both nodes in stack to merge\\n    if (cur[0].left == null) {\\n      cur[0].left = cur[1].left;\\n    } else {\\n      stack.offerLast(new TreeNode[] {cur[0].left, cur[1].left});\\n    }\\n    if (cur[0].right == null) {\\n      cur[0].right = cur[1].right;\\n    } else {\\n      stack.offerLast(new TreeNode[] {cur[0].right, cur[1].right});\\n    }\\n  }\\n  return t1;\\n}\\n```\n```\\n// Method 3: Iterative BFS\\n// Time: O(n)\\n// Space: O(n)\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n  if (t1 == null) {\\n    return t2;\\n  }\\n  // Use stack to help DFS\\n  Queue<TreeNode[]> queue = new LinkedList<>();\\n  queue.offer(new TreeNode[] {t1, t2});\\n  while (!queue.isEmpty()) {\\n    TreeNode[] cur = queue.poll();\\n    // no need to merge t2 into t1\\n    if (cur[1] == null) {\\n      continue;\\n    }\\n    // merge t1 and t2\\n    cur[0].val += cur[1].val;\\n    // if node in t1 == null, use node in t2 instead\\n    // else put both nodes in stack to merge\\n    if (cur[0].left == null) {\\n      cur[0].left = cur[1].left;\\n    } else {\\n      queue.offer(new TreeNode[] {cur[0].left, cur[1].left});\\n    }\\n    if (cur[0].right == null) {\\n      cur[0].right = cur[1].right;\\n    } else {\\n      queue.offer(new TreeNode[] {cur[0].right, cur[1].right});\\n    }\\n  }\\n  return t1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386403,
                "title": "c-simple-solution-beats-100-on-memory-with-explanation",
                "content": "```\\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n\\n    if (t1 && t2) { // If both nodes exist, add their values then look at the next node. \\n        t1->val+=t2->val;\\n        t1->left = mergeTrees(t1->left,t2->left);  \\n        t1->right = mergeTrees(t1->right, t2->right);\\n    } else { // If one node doesn\\'t exist, link it back to the calling node.\\n\\t    return t1 ? t1 : t2;  \\n\\t}\\n    \\n    return t1; // Return the first tree, which is now altered. No need to create a new node, which bloats memory.\\n}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n\\n    if (t1 && t2) { // If both nodes exist, add their values then look at the next node. \\n        t1->val+=t2->val;\\n        t1->left = mergeTrees(t1->left,t2->left);  \\n        t1->right = mergeTrees(t1->right, t2->right);\\n    } else { // If one node doesn\\'t exist, link it back to the calling node.\\n\\t    return t1 ? t1 : t2;  \\n\\t}\\n    \\n    return t1; // Return the first tree, which is now altered. No need to create a new node, which bloats memory.\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 426243,
                "title": "python-recursive-solution-beats-100",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        elif not t2:\\n            return t1\\n        else:\\n            res = TreeNode(t1.val + t2.val)\\n            res.left = self.mergeTrees(t1.left, t2.left)\\n            res.right = self.mergeTrees(t1.right, t2.right)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        elif not t2:\\n            return t1\\n        else:\\n            res = TreeNode(t1.val + t2.val)\\n            res.left = self.mergeTrees(t1.left, t2.left)\\n            res.right = self.mergeTrees(t1.right, t2.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173640,
                "title": "python-simple-iterative-using-list-stack",
                "content": "Standard approach is using recursive. Here sharing a clean iterative solution using Python list inspired by the solution approach #2\\n```\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        \"\"\"\\n        if t1 is None:\\n            return t2\\n\\t\\t\\t\\t\\t\\t\\n        stack = []\\n        stack.append((t1,t2))\\n        while stack:\\n            t = stack.pop()\\n            if t[1] is None:\\n                continue\\n            t[0].val += t[1].val\\n            \\n            if t[0].left is None:\\n                t[0].left = t[1].left\\n            else:\\n                stack.append((t[0].left,t[1].left))\\n            \\n            if t[0].right is None:\\n                t[0].right = t[1].right\\n            else:\\n                stack.append((t[0].right,t[1].right))\\n        return t1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        \"\"\"\\n        if t1 is None:\\n            return t2\\n\\t\\t\\t\\t\\t\\t\\n        stack = []\\n        stack.append((t1,t2))\\n        while stack:\\n            t = stack.pop()\\n            if t[1] is None:\\n                continue\\n            t[0].val += t[1].val\\n            \\n            if t[0].left is None:\\n                t[0].left = t[1].left\\n            else:\\n                stack.append((t[0].left,t[1].left))\\n            \\n            if t[0].right is None:\\n                t[0].right = t[1].right\\n            else:\\n                stack.append((t[0].right,t[1].right))\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276921,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "* **Recursive approach.**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1 == NULL)\\n        {\\n            return root2;\\n        }\\n        if(root2 == NULL)\\n        {\\n            return root1;\\n        }\\n        \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1 == NULL)\\n        {\\n            return root2;\\n        }\\n        if(root2 == NULL)\\n        {\\n            return root1;\\n        }\\n        \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104298,
                "title": "c-o-n-space-iterative-solution-no-new-tree",
                "content": "```\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t2==NULL) return t1;\\n        if(t1==NULL) return t2;\\n        TreeNode* res=t1;\\n        stack<TreeNode*> s1, s2;\\n        s1.push(t1), s2.push(t2);\\n        while(!s1.empty()) {\\n            TreeNode* c1=s1.top();\\n            TreeNode* c2=s2.top();\\n            s1.pop(), s2.pop();\\n            c1->val+=c2->val;\\n            if(c1->right==NULL&&c2->right!=NULL) c1->right=c2->right;\\n            else if(c1->right!=NULL&&c2->right!=NULL) s1.push(c1->right), s2.push(c2->right);\\n            if(c1->left==NULL&&c2->left!=NULL) c1->left=c2->left;\\n            else if(c1->left!=NULL&&c2->left!=NULL) s1.push(c1->left), s2.push(c2->left);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t2==NULL) return t1;\\n        if(t1==NULL) return t2;\\n        TreeNode* res=t1;\\n        stack<TreeNode*> s1, s2;\\n        s1.push(t1), s2.push(t2);\\n        while(!s1.empty()) {\\n            TreeNode* c1=s1.top();\\n            TreeNode* c2=s2.top();\\n            s1.pop(), s2.pop();\\n            c1->val+=c2->val;\\n            if(c1->right==NULL&&c2->right!=NULL) c1->right=c2->right;\\n            else if(c1->right!=NULL&&c2->right!=NULL) s1.push(c1->right), s2.push(c2->right);\\n            if(c1->left==NULL&&c2->left!=NULL) c1->left=c2->left;\\n            else if(c1->left!=NULL&&c2->left!=NULL) s1.push(c1->left), s2.push(c2->left);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 372395,
                "title": "java-solution-100-runtime-and-memory",
                "content": "```\\nclass Solution {\\n    \\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        \\n        TreeNode new_node = new TreeNode(t1.val + t2.val);\\n        \\n        new_node.left = mergeTrees(t1.left, t2.left);\\n        new_node.right = mergeTrees(t1.right, t2.right);\\n        \\n        return new_node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        \\n        TreeNode new_node = new TreeNode(t1.val + t2.val);\\n        \\n        new_node.left = mergeTrees(t1.left, t2.left);\\n        new_node.right = mergeTrees(t1.right, t2.right);\\n        \\n        return new_node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137279,
                "title": "javascript-recursive-and-iterative-solutions",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n// Recursive Algorithm:\\n//\\n// 1. Traverse the tree in Preorder fashion\\n// 2. Check if both the tree nodes are NULL\\n//   1. If not, then update the value\\n// 3. Recur for left subtrees\\n// 4. Recur for right subtrees\\n// 5. Return root of updated Tree\\nconst mergeTrees = (t1, t2) => {\\n  if (!t1) {\\n    return t2;\\n  }\\n  if (!t2) {\\n    return t1;\\n  }\\n  t1.val += t2.val;\\n  t1.left = mergeTrees(t1.left, t2.left);\\n  t1.right = mergeTrees(t1.right, t2.right);\\n  return t1;\\n};\\n\\n// Iterative Algorithm:\\n//\\n// 1. Create a stack\\n// 2. Push the root nodes of both the trees onto the stack.\\n// 3. While the stack is not empty, perform following steps :\\n//   1. Pop a node pair from the top of the stack\\n//   2. For every node pair removed, add the values corresponding to the two nodes and update the value of the corresponding node in the first tree\\n//   3. If the left child of the first tree exists, push the left child(pair) of both the trees onto the stack.\\n//   4. If the left child of the first tree doesn\\u2019t exist, append the left child of the second tree to the current node of the first tree\\n//   5. Do same for right child pair as well.\\n//   6. If both the current nodes are NULL, continue with popping the next nodes from the stack.\\n// 4. Return root of updated Tree\\nconst mergeTrees2 = (t1, t2) => {\\n  if (t1 === null) {\\n    return t2;\\n  }\\n  const stack = [];\\n  stack.push([t1, t2]);\\n  while (stack.length !== 0) {\\n    const t = stack.pop();\\n    if (t[0] === null || t[1] === null) {\\n      continue;\\n    }\\n    t[0].val += t[1].val;\\n    if (t[0].left === null) {\\n      t[0].left = t[1].left;\\n    } else {\\n      stack.push([t[0].left, t[1].left]);\\n    }\\n    if (t[0].right === null) {\\n      t[0].right = t[1].right;\\n    } else {\\n      stack.push([t[0].right, t[1].right]);\\n    }\\n  }\\n  return t1;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n// Recursive Algorithm:\\n//\\n// 1. Traverse the tree in Preorder fashion\\n// 2. Check if both the tree nodes are NULL\\n//   1. If not, then update the value\\n// 3. Recur for left subtrees\\n// 4. Recur for right subtrees\\n// 5. Return root of updated Tree\\nconst mergeTrees = (t1, t2) => {\\n  if (!t1) {\\n    return t2;\\n  }\\n  if (!t2) {\\n    return t1;\\n  }\\n  t1.val += t2.val;\\n  t1.left = mergeTrees(t1.left, t2.left);\\n  t1.right = mergeTrees(t1.right, t2.right);\\n  return t1;\\n};\\n\\n// Iterative Algorithm:\\n//\\n// 1. Create a stack\\n// 2. Push the root nodes of both the trees onto the stack.\\n// 3. While the stack is not empty, perform following steps :\\n//   1. Pop a node pair from the top of the stack\\n//   2. For every node pair removed, add the values corresponding to the two nodes and update the value of the corresponding node in the first tree\\n//   3. If the left child of the first tree exists, push the left child(pair) of both the trees onto the stack.\\n//   4. If the left child of the first tree doesn\\u2019t exist, append the left child of the second tree to the current node of the first tree\\n//   5. Do same for right child pair as well.\\n//   6. If both the current nodes are NULL, continue with popping the next nodes from the stack.\\n// 4. Return root of updated Tree\\nconst mergeTrees2 = (t1, t2) => {\\n  if (t1 === null) {\\n    return t2;\\n  }\\n  const stack = [];\\n  stack.push([t1, t2]);\\n  while (stack.length !== 0) {\\n    const t = stack.pop();\\n    if (t[0] === null || t[1] === null) {\\n      continue;\\n    }\\n    t[0].val += t[1].val;\\n    if (t[0].left === null) {\\n      t[0].left = t[1].left;\\n    } else {\\n      stack.push([t[0].left, t[1].left]);\\n    }\\n    if (t[0].right === null) {\\n      t[0].right = t[1].right;\\n    } else {\\n      stack.push([t[0].right, t[1].right]);\\n    }\\n  }\\n  return t1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499177,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} t1\\n * @param {TreeNode} t2\\n * @return {TreeNode}\\n */\\nvar mergeTrees = function(t1, t2) {\\n    // goal is to merge t2 to t1\\n    \\n    // if one of the node missing, return the other\\n    if (t1 === null) {\\n        return t2;\\n    }\\n    if (t2 === null) {\\n        return t1;\\n    }\\n    // if both nodes exist, sum the values\\n    t1.val += t2.val;\\n    \\n    // do the same thing for left and right branch\\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n    \\n    // return the merged t1\\n    return t1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} t1\\n * @param {TreeNode} t2\\n * @return {TreeNode}\\n */\\nvar mergeTrees = function(t1, t2) {\\n    // goal is to merge t2 to t1\\n    \\n    // if one of the node missing, return the other\\n    if (t1 === null) {\\n        return t2;\\n    }\\n    if (t2 === null) {\\n        return t1;\\n    }\\n    // if both nodes exist, sum the values\\n    t1.val += t2.val;\\n    \\n    // do the same thing for left and right branch\\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n    \\n    // return the merged t1\\n    return t1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205328,
                "title": "java-5ms-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) {\\n            return null;\\n        } else if (t2 == null) {\\n            return t1;\\n        } else if (t1 == null) {\\n            return t2;\\n        } else {\\n            TreeNode t = new TreeNode(t1.val + t2.val);\\n            t.left = mergeTrees(t1.left, t2.left);\\n            t.right = mergeTrees(t1.right, t2.right);\\n            return t;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) {\\n            return null;\\n        } else if (t2 == null) {\\n            return t1;\\n        } else if (t1 == null) {\\n            return t2;\\n        } else {\\n            TreeNode t = new TreeNode(t1.val + t2.val);\\n            t.left = mergeTrees(t1.left, t2.left);\\n            t.right = mergeTrees(t1.right, t2.right);\\n            return t;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104389,
                "title": "concise-c-solution",
                "content": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2) {\\n    if (!t2)\\n        return t1;\\n    if (!t1)\\n        return t2;\\n    t1->val += t2->val;\\n    t1->left = mergeTrees(t1->left, t2->left);\\n    t1->right = mergeTrees(t1->right, t2->right);\\n    return t1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2) {\\n    if (!t2)\\n        return t1;\\n    if (!t1)\\n        return t2;\\n    t1->val += t2->val;\\n    t1->left = mergeTrees(t1->left, t2->left);\\n    t1->right = mergeTrees(t1->right, t2->right);\\n    return t1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104325,
                "title": "a-few-lines-of-javascript",
                "content": "Original:\\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) return null;\\n    const root = new TreeNode(((t1 || 0).val || 0) + ((t2 || 0).val || 0));\\n    root.left = mergeTrees(t1 && t1.left, t2 && t2.left);\\n    root.right = mergeTrees(t1 && t1.right, t2 && t2.right);\\n    return root;\\n};\\n```\\nvfanggg\\'s refactor:\\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 && t2) {\\n        const newNode = new TreeNode(t1.val + t2.val);\\n        newNode.left = mergeTrees(t1.left, t2.left);\\n        newNode.right = mergeTrees(t1.right, t2.right);\\n        return newNode;\\n    } \\n    return t1 || t2;\\n};\\n```\\nOriginal updated with option chaining:\\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) return null;\\n    const root = new TreeNode((t1?.val || 0) + (t2?.val || 0));\\n    root.left = mergeTrees(t1?.left, t2?.left);\\n    root.right = mergeTrees(t1?.right, t2?.right);\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) return null;\\n    const root = new TreeNode(((t1 || 0).val || 0) + ((t2 || 0).val || 0));\\n    root.left = mergeTrees(t1 && t1.left, t2 && t2.left);\\n    root.right = mergeTrees(t1 && t1.right, t2 && t2.right);\\n    return root;\\n};\\n```\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 && t2) {\\n        const newNode = new TreeNode(t1.val + t2.val);\\n        newNode.left = mergeTrees(t1.left, t2.left);\\n        newNode.right = mergeTrees(t1.right, t2.right);\\n        return newNode;\\n    } \\n    return t1 || t2;\\n};\\n```\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) return null;\\n    const root = new TreeNode((t1?.val || 0) + (t2?.val || 0));\\n    root.left = mergeTrees(t1?.left, t2?.left);\\n    root.right = mergeTrees(t1?.right, t2?.right);\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626668,
                "title": "python-simple-create-new-tree-by-joining-two-input-trees",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node1, node2):\\n            if node1 and node2:\\n                # If both node exists, combine their values to form a new super node\\n                root = TreeNode(node1.val + node2.val)\\n                # And add its children by joining the children from both nodes\\n                root.left = dfs(node1.left, node2.left)\\n                root.right = dfs(node1.right, node2.right)\\n                # Finally return this super node\\n                return root\\n            else:\\n                # Otherwise return either that exists or None if neither exists\\n                return node1 or node2\\n        \\n        # Start the search in the head or roots of both trees\\n        return dfs(root1, root2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node1, node2):\\n            if node1 and node2:\\n                # If both node exists, combine their values to form a new super node\\n                root = TreeNode(node1.val + node2.val)\\n                # And add its children by joining the children from both nodes\\n                root.left = dfs(node1.left, node2.left)\\n                root.right = dfs(node1.right, node2.right)\\n                # Finally return this super node\\n                return root\\n            else:\\n                # Otherwise return either that exists or None if neither exists\\n                return node1 or node2\\n        \\n        # Start the search in the head or roots of both trees\\n        return dfs(root1, root2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410057,
                "title": "java-easy-approach-with-explanation-dfs-postorder",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) \\n    {//Postorder Traversal   \\n        if(root1 == null)//when we see that the root1 is null there is a possibility that root2 is not null so we return that and maintaining the link and continue overlapping\\n           return root2;//telling that root1 is not present so sending root1\\n      \\n        if(root2 == null)//when we see that the root2 is null there is a possibility that root1 is not null so we return that and maintaining the link  \\n           return root1;//telling that root2 is not present so sending root1\\n   \\n        //LEFT - RIGHT\\n        TreeNode left= mergeTrees(root1.left, root2.left);//recursing down the left subtree and knowing about the left child \\n        TreeNode right= mergeTrees(root1.right, root2.right);//recursing down the right subtree and knowing about the right child \\n      \\n        //ROOT\\n        //creating the node by the total information received from left and right child \\n        TreeNode node= new TreeNode(root1.val+root2.val, left, right);\\n      \\n        return node;//returning the node in order to maintain the backward modified link at each instant//Telling to the parent that I am present  \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) \\n    {//Postorder Traversal   \\n        if(root1 == null)//when we see that the root1 is null there is a possibility that root2 is not null so we return that and maintaining the link and continue overlapping\\n           return root2;//telling that root1 is not present so sending root1\\n      \\n        if(root2 == null)//when we see that the root2 is null there is a possibility that root1 is not null so we return that and maintaining the link  \\n           return root1;//telling that root2 is not present so sending root1\\n   \\n        //LEFT - RIGHT\\n        TreeNode left= mergeTrees(root1.left, root2.left);//recursing down the left subtree and knowing about the left child \\n        TreeNode right= mergeTrees(root1.right, root2.right);//recursing down the right subtree and knowing about the right child \\n      \\n        //ROOT\\n        //creating the node by the total information received from left and right child \\n        TreeNode node= new TreeNode(root1.val+root2.val, left, right);\\n      \\n        return node;//returning the node in order to maintain the backward modified link at each instant//Telling to the parent that I am present  \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054426,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860133,
                "title": "easy-yet-simple-solution",
                "content": "Breakdown the problem into simple steps:-\\n1. Check if either of the trees are null\\n2. Change tree 1\\'s node values to tree 1\\'s node + tree2\\'s current node\\n3. Merge left and right of each trees\\n\\nThat\\'s it\\n\\n```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317995,
                "title": "easiest-solution-in-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null) return root2;\\n        if(root2==null) return root1;\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left,root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null) return root2;\\n        if(root2==null) return root1;\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left,root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966783,
                "title": "python-simple-recursion-beats-95",
                "content": "### \\u2705 Upvote if it helps ! \\uD83D\\uDE42\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I used a simple recursion with the *constructTree* function.\\n- **If one of the 2 nodes is not defined**, we can simply return the other node.\\n- **If the 2 nodes are not defined**, we can finish the recursion.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeTrees(self, root1, root2):\\n\\n        def constructTree(root1, root2):\\n            if not root1 and not root2:\\n                return None\\n            if not root2:\\n                return root1\\n            if not root1:\\n                return root2\\n            head = TreeNode(root1.val + root2.val)\\n            head.left = constructTree(root1.left, root2.left)\\n            head.right = constructTree(root1.right, root2.right)\\n        \\n            return head\\n        \\n        return constructTree(root1, root2)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeTrees(self, root1, root2):\\n\\n        def constructTree(root1, root2):\\n            if not root1 and not root2:\\n                return None\\n            if not root2:\\n                return root1\\n            if not root1:\\n                return root2\\n            head = TreeNode(root1.val + root2.val)\\n            head.left = constructTree(root1.left, root2.left)\\n            head.right = constructTree(root1.right, root2.right)\\n        \\n            return head\\n        \\n        return constructTree(root1, root2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300617,
                "title": "c-solution-recursive-creating-new-tree-with-void-helper-function",
                "content": "This is not the best solution to this problem. This is just an approach in which I am creating new tree with new helper function of type ``` void ``` .\\n\\nDo upvote this post if you liked the approach ! It really motivates the author to post more on leetcode \\uD83D\\uDE42 and comment section is open if you want to suggest some changes in my code.\\n\\n```\\n// This is the helper function\\nvoid createTree(TreeNode* &root  , TreeNode* root1 , TreeNode* root2 ){\\n        \\n        if(root1 == NULL && root2 == NULL)\\n            root = NULL ;\\n        \\n        else if(root1 == NULL && root2)\\n        {\\n            root = new TreeNode(root2->val);\\n            createTree(root->left,NULL,root2->left);\\n            createTree(root->right,NULL , root2->right);\\n        }\\n        \\n        else if(root1 && root2 == NULL)\\n        {\\n            root = new TreeNode(root1->val);\\n            createTree(root->left,root1->left,NULL);\\n            createTree(root->right,root1->right,NULL);\\n        }\\n        \\n        else \\n        {\\n            root = new TreeNode(root1->val + root2->val);\\n            createTree(root->left,root1->left,root2->left);\\n            createTree(root->right,root1->right,root2->right);\\n        }\\n        \\n    }\\n    \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        \\n        TreeNode* root ;\\n        \\n        createTree(root,root1,root2);\\n        \\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "``` void ```\n```\\n// This is the helper function\\nvoid createTree(TreeNode* &root  , TreeNode* root1 , TreeNode* root2 ){\\n        \\n        if(root1 == NULL && root2 == NULL)\\n            root = NULL ;\\n        \\n        else if(root1 == NULL && root2)\\n        {\\n            root = new TreeNode(root2->val);\\n            createTree(root->left,NULL,root2->left);\\n            createTree(root->right,NULL , root2->right);\\n        }\\n        \\n        else if(root1 && root2 == NULL)\\n        {\\n            root = new TreeNode(root1->val);\\n            createTree(root->left,root1->left,NULL);\\n            createTree(root->right,root1->right,NULL);\\n        }\\n        \\n        else \\n        {\\n            root = new TreeNode(root1->val + root2->val);\\n            createTree(root->left,root1->left,root2->left);\\n            createTree(root->right,root1->right,root2->right);\\n        }\\n        \\n    }\\n    \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        \\n        TreeNode* root ;\\n        \\n        createTree(root,root1,root2);\\n        \\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1097923,
                "title": "python-easiest-solution",
                "content": "**Platform**: leetcode.com\\n**617. Merge Two Binary Trees**\\n**Link**: https://leetcode.com/problems/merge-two-binary-trees/\\n**Difficulty**: Easy\\n**Author**: hritik5102\\n**Date**: 7/3/2021\\n**Post Discussion** : https://leetcode.com/problems/merge-two-binary-trees/discuss/1097923/Python-or-Easiest-solution\\n**Submission**: https://leetcode.com/submissions/detail/464670896/\\n**(Time, Space) Complexity** : O(n), O(n)\\n**Github** : https://github.com/hritik5102\\n**Social-handles** : https://linktr.ee/hritikdj\\n\\n**PLEASE UPVOTE \\uD83C\\uDFAF, if found helpful**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None and root2 is None:\\n            return None\\n        \\n        if root1 is None:\\n            res = root2\\n        elif root2 is None:\\n            res = root1\\n        else:\\n            res = TreeNode(root1.val + root2.val)\\n            res.left = self.mergeTrees(root1.left, root2.left)\\n            res.right = self.mergeTrees(root1.right, root2.right)\\n            \\n        return res\\n   ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None and root2 is None:\\n            return None\\n        \\n        if root1 is None:\\n            res = root2\\n        elif root2 is None:\\n            res = root1\\n        else:\\n            res = TreeNode(root1.val + root2.val)\\n            res.left = self.mergeTrees(root1.left, root2.left)\\n            res.right = self.mergeTrees(root1.right, root2.right)\\n            \\n        return res\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 360879,
                "title": "python3-recursively-and-iteratively",
                "content": "* Recursively\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 == None:\\n            return t2\\n        if t2 == None:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left,t2.left)\\n        t1.right = self.mergeTrees(t1.right,t2.right)\\n        return t1\\n```\\n* Iteratively\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 == None:\\n            return t2\\n        stack = []\\n        stack = [[t1,t2]]\\n        while stack:\\n            cur = stack.pop()\\n            if cur[0] == None or cur[1] == None:\\n                continue\\n            cur[0].val += cur[1].val\\n            if cur[0].left == None:\\n                cur[0].left = cur[1].left\\n            else:\\n                stack.append([cur[0].left,cur[1].left])\\n            if cur[0].right == None:\\n                cur[0].right = cur[1].right\\n            else:\\n                stack.append([cur[0].right,cur[1].right])\\n        return t1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 == None:\\n            return t2\\n        if t2 == None:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left,t2.left)\\n        t1.right = self.mergeTrees(t1.right,t2.right)\\n        return t1\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 == None:\\n            return t2\\n        stack = []\\n        stack = [[t1,t2]]\\n        while stack:\\n            cur = stack.pop()\\n            if cur[0] == None or cur[1] == None:\\n                continue\\n            cur[0].val += cur[1].val\\n            if cur[0].left == None:\\n                cur[0].left = cur[1].left\\n            else:\\n                stack.append([cur[0].left,cur[1].left])\\n            if cur[0].right == None:\\n                cur[0].right = cur[1].right\\n            else:\\n                stack.append([cur[0].right,cur[1].right])\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238458,
                "title": "very-simple-javascript-solution-recursive",
                "content": "Just a recursive way to traverse whole tree;\\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 === null || t2 === null) {\\n        return t1 || t2;\\n    } \\n    const root = new TreeNode(t1.val + t2.val);\\n    const left = mergeTrees(t1.left, t2.left);\\n    const right = mergeTrees(t1.right, t2.right);\\n    root.left = left;\\n    root.right = right;\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 === null || t2 === null) {\\n        return t1 || t2;\\n    } \\n    const root = new TreeNode(t1.val + t2.val);\\n    const left = mergeTrees(t1.left, t2.left);\\n    const right = mergeTrees(t1.right, t2.right);\\n    root.left = left;\\n    root.right = right;\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121170,
                "title": "python-iterative",
                "content": "I didn\\'t find any Python iterative solution. So, here you go. \\n\\n```\\n    def mergeTrees(self, t1, t2):\\n        dummy = TreeNode(0)\\n        stack = [(t1, t2, dummy, \\'l\\')]\\n        while stack:\\n            n1, n2, parent, lr = stack.pop()\\n            n = TreeNode((n1.val if n1 else 0 ) + (n2.val if n2 else 0 )) if n1 or n2 else None\\n            if lr == \\'l\\': \\n                parent.left = n \\n            else:\\n                parent.right = n\\n                \\n            if n1 or n2:\\n                stack.append((n1 and n1.left, n2 and n2.left, n, \\'l\\'))\\n                stack.append((n1 and n1.right, n2 and n2.right, n, \\'r\\'))\\n            \\n        return dummy.left\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def mergeTrees(self, t1, t2):\\n        dummy = TreeNode(0)\\n        stack = [(t1, t2, dummy, \\'l\\')]\\n        while stack:\\n            n1, n2, parent, lr = stack.pop()\\n            n = TreeNode((n1.val if n1 else 0 ) + (n2.val if n2 else 0 )) if n1 or n2 else None\\n            if lr == \\'l\\': \\n                parent.left = n \\n            else:\\n                parent.right = n\\n                \\n            if n1 or n2:\\n                stack.append((n1 and n1.left, n2 and n2.left, n, \\'l\\'))\\n                stack.append((n1 and n1.right, n2 and n2.right, n, \\'r\\'))\\n            \\n        return dummy.left\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2077828,
                "title": "python3-bfs-create-new-tree",
                "content": "As requested: create **a new** merged Tree via BFS (level order traversal):\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1: return root2\\n        if not root2: return root1\\n        \\n        new_root = TreeNode()\\n        queue = deque([(root1, root2, new_root)])\\n        \\n        while queue:\\n            n1, n2, n = queue.popleft()\\n            if n1: n.val = n1.val\\n            if n2: n.val += n2.val\\n\\n            if (n1 and n1.left) or (n2 and n2.left):\\n                n.left = TreeNode()\\n                queue.append((n1.left if n1 else None, n2.left if n2 else None, n.left))\\n            if (n1 and n1.right) or (n2 and n2.right):\\n                n.right = TreeNode()\\n                queue.append((n1.right if n1 else None, n2.right if n2 else None, n.right))\\n\\n        return new_root\\n```\\n\\nP.S. Maybe someone will be interested in 3 lines DFS?\\n```\\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif not root1: return root2\\n\\tif not root2: return root1\\n\\treturn TreeNode(root1.val + root2.val, self.mergeTrees(root1.left, root2.left), self.mergeTrees(root1.right, root2.right))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1: return root2\\n        if not root2: return root1\\n        \\n        new_root = TreeNode()\\n        queue = deque([(root1, root2, new_root)])\\n        \\n        while queue:\\n            n1, n2, n = queue.popleft()\\n            if n1: n.val = n1.val\\n            if n2: n.val += n2.val\\n\\n            if (n1 and n1.left) or (n2 and n2.left):\\n                n.left = TreeNode()\\n                queue.append((n1.left if n1 else None, n2.left if n2 else None, n.left))\\n            if (n1 and n1.right) or (n2 and n2.right):\\n                n.right = TreeNode()\\n                queue.append((n1.right if n1 else None, n2.right if n2 else None, n.right))\\n\\n        return new_root\\n```\n```\\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif not root1: return root2\\n\\tif not root2: return root1\\n\\treturn TreeNode(root1.val + root2.val, self.mergeTrees(root1.left, root2.left), self.mergeTrees(root1.right, root2.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853764,
                "title": "javascript-solution-617",
                "content": "```\\nlet mergeTrees = function(t1, t2) {\\n    if (!t1) {\\n        return t2;\\n    }\\n    if (!t2) {\\n        return t1;\\n    }\\n    \\n    t1.val += t2.val;\\n    \\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n    \\n    return t1;\\n    \\n};\\n```\\n**Runtime: 108 ms, faster than 85.34% of JavaScript online submissions for Merge Two Binary Trees.**\\n\\n**Memory Usage: 43.9 MB, less than 98.47% of JavaScript online submissions for Merge Two Binary Trees.**\\n\\n**Feedback Appreciated**\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet mergeTrees = function(t1, t2) {\\n    if (!t1) {\\n        return t2;\\n    }\\n    if (!t2) {\\n        return t1;\\n    }\\n    \\n    t1.val += t2.val;\\n    \\n    t1.left = mergeTrees(t1.left, t2.left);\\n    t1.right = mergeTrees(t1.right, t2.right);\\n    \\n    return t1;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795448,
                "title": "c-simplest-recursive-solution",
                "content": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2){\\n    if (!t1) return t2;\\n    if (!t2) return t1;\\n    t1->val += t2->val;\\n    t1->left = mergeTrees(t1->left, t2->left);\\n    t1->right = mergeTrees(t1->right, t2->right);\\n    return t1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2){\\n    if (!t1) return t2;\\n    if (!t2) return t1;\\n    t1->val += t2->val;\\n    t1->left = mergeTrees(t1->left, t2->left);\\n    t1->right = mergeTrees(t1->right, t2->right);\\n    return t1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702235,
                "title": "js-90-with-exlanation",
                "content": "![image](https://assets.leetcode.com/users/images/dd9ff164-e2ab-43d4-a964-ca931f9a3592_1665744619.6863892.png)\\n\\nTo solve this problem, we need to sum the values if both nodes, if one of them is not present, return the other (it does not matter if the other one also turns out to be null).\\nFirst of all, we need to consider edge cases. One or both nodes can be null. When one of the given trees is null, we can immediately return another tree (regardless of whether it is null or not).\\nTo transform one tree, we can merge another with it, when both trees are not null, we sum the values of the nodes. So, we first go through the left nodes, and then the right ones, and at the end we can return the already merged tree.\\n\\n![image](https://assets.leetcode.com/users/images/6250b614-8deb-4102-9a33-49c1641c7bda_1665745121.283226.png)\\n![image](https://assets.leetcode.com/users/images/d77f13e7-8bd9-43e9-9180-eeba58be1484_1665745182.5205383.png)\\n\\n```\\nvar mergeTrees = function (root1, root2) {\\n    if (!root1) return root2;\\n    else if (!root2) return root1;\\n    else {\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1\\n    }\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvar mergeTrees = function (root1, root2) {\\n    if (!root1) return root2;\\n    else if (!root2) return root1;\\n    else {\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559908,
                "title": "java-iterative-solution-w-stack",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) \\n    {\\n        Stack <TreeNode> s = new Stack <TreeNode>();\\n        s.push(t1);\\n        s.push(t2);\\n        if (t1 == null)\\n            return t2;\\n \\n        while(!s.isEmpty())\\n        {\\n            TreeNode two = s.pop();\\n            TreeNode one = s.pop();\\n            \\n            if (one != null && two != null)\\n            {\\n                one.val += two.val;\\n                if (one.left == null){\\n                    one.left = two.left;\\n                }\\n                else\\n                {\\n                    s.push(one.left);\\n                    s.push(two.left);\\n                }\\n                      \\n                if (one.right == null){\\n                    one.right = two.right;\\n                }\\n                else\\n                {\\n                    s.push(one.right);\\n                    s.push(two.right);\\n                }  \\n            }     \\n        }\\n        return t1;  \\n    }\\n}\\n```\\n\\nNot too many iterative solutions, its important to try coding it iteratively for interviews. \\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) \\n    {\\n        Stack <TreeNode> s = new Stack <TreeNode>();\\n        s.push(t1);\\n        s.push(t2);\\n        if (t1 == null)\\n            return t2;\\n \\n        while(!s.isEmpty())\\n        {\\n            TreeNode two = s.pop();\\n            TreeNode one = s.pop();\\n            \\n            if (one != null && two != null)\\n            {\\n                one.val += two.val;\\n                if (one.left == null){\\n                    one.left = two.left;\\n                }\\n                else\\n                {\\n                    s.push(one.left);\\n                    s.push(two.left);\\n                }\\n                      \\n                if (one.right == null){\\n                    one.right = two.right;\\n                }\\n                else\\n                {\\n                    s.push(one.right);\\n                    s.push(two.right);\\n                }  \\n            }     \\n        }\\n        return t1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159138,
                "title": "python-solution",
                "content": "recursive:\\n```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 == None and t2 == None:\\n            return None\\n        elif t1 == None:\\n            return t2\\n        elif t2 == None:\\n            return t1\\n        new_root = TreeNode(t1.val + t2.val)\\n        left = self.mergeTrees(t1.left, t2.left)\\n        right = self.mergeTrees(t1.right, t2.right)\\n        new_root.left = left\\n        new_root.right = right\\n        return new_root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 == None and t2 == None:\\n            return None\\n        elif t1 == None:\\n            return t2\\n        elif t2 == None:\\n            return t1\\n        new_root = TreeNode(t1.val + t2.val)\\n        left = self.mergeTrees(t1.left, t2.left)\\n        right = self.mergeTrees(t1.right, t2.right)\\n        new_root.left = left\\n        new_root.right = right\\n        return new_root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104460,
                "title": "simple-python-recursive",
                "content": "The idea is simple, when ```t1``` and ```t2``` are both ```None```, return ```None``` otherwise just turtle all the way down.\\n```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not t1 and not t2: return None\\n        if t1:\\n            v1, L1, R1 = t1.val, t1.left, t1.right\\n        else:\\n            v1, L1, R1 = 0, None, None\\n        if t2:\\n            v2, L2, R2 = t2.val, t2.left, t2.right\\n        else:\\n            v2, L2, R2 = 0, None, None\\n        node = TreeNode(v1+v2)\\n        node.left = self.mergeTrees(L1, L2)\\n        node.right = self.mergeTrees(R1, R2)\\n        return node\\n```",
                "solutionTags": [],
                "code": "```t1```\n```t2```\n```None```\n```None```\n```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not t1 and not t2: return None\\n        if t1:\\n            v1, L1, R1 = t1.val, t1.left, t1.right\\n        else:\\n            v1, L1, R1 = 0, None, None\\n        if t2:\\n            v2, L2, R2 = t2.val, t2.left, t2.right\\n        else:\\n            v2, L2, R2 = 0, None, None\\n        node = TreeNode(v1+v2)\\n        node.left = self.mergeTrees(L1, L2)\\n        node.right = self.mergeTrees(R1, R2)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342175,
                "title": "elegant-python-iterative-recursive-solutions",
                "content": "#### Iterative\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1: return root2\\n        if not root2: return root1\\n        queue = deque([(root1, root2)])\\n        while queue:\\n            current_root1, current_root2 = queue.pop()\\n            if current_root1.left and current_root2.left: queue.append((current_root1.left, current_root2.left))\\n            elif not current_root1.left: current_root1.left = current_root2.left\\n            if current_root1.right and current_root2.right: queue.append((current_root1.right, current_root2.right))\\n            elif not current_root1.right: current_root1.right = current_root2.right\\n            current_root1.val += current_root2.val\\n        return root1\\n```\\n#### Recursive\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1: return root2\\n        if not root2: return root1\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1: return root2\\n        if not root2: return root1\\n        queue = deque([(root1, root2)])\\n        while queue:\\n            current_root1, current_root2 = queue.pop()\\n            if current_root1.left and current_root2.left: queue.append((current_root1.left, current_root2.left))\\n            elif not current_root1.left: current_root1.left = current_root2.left\\n            if current_root1.right and current_root2.right: queue.append((current_root1.right, current_root2.right))\\n            elif not current_root1.right: current_root1.right = current_root2.right\\n            current_root1.val += current_root2.val\\n        return root1\\n```\n```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1: return root2\\n        if not root2: return root1\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830358,
                "title": "c-recursive-dfs-solution-explained-80-time-40-space",
                "content": "Core idea here: we merge the 2 trees in place, using `t1` as a base (unless it is empty, in which case we just return `t2`) and summing the values when both have a node present in the same position, recursively calling a `dfs` helper function to traverse the trees.\\n\\nWhen `t1` does not have nodes, but `t2` has, we just attach the matching node from `t2` and move on.\\n\\nOnce done, we return `t1`.\\n \\nMy initial code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2) {\\n        // we act only if both nodes are present, otherwise do nothing (ie: return)\\n        if (t1 && t2) {\\n            // if we have both and t1 was not taken by t2, we sum\\n            if (t1 != t2) t1->val += t2->val;\\n            // if t1 misses branches, we attach the ones from t2\\n            if (!t1->left) t1->left = t2->left;\\n            if (!t1->right) t1->right = t2->right;\\n            // recursively we go!\\n            dfs(t1->left, t2->left);\\n            dfs(t1->right, t2->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        dfs(t1, t2);\\n        return t1;\\n    }\\n};\\n```\\n\\nThen I was like: \"wait a moment - when I just attach `t2` to make up for missing parts of `t1`, there is no point in going down, so let\\'s put a conditional before the recursive calls\":\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2) {\\n        // we act only if both nodes are present, otherwise do nothing (ie: return)\\n        if (t1 && t2) {\\n            t1->val += t2->val;\\n            // if t1 misses branches, we attach the ones from t2\\n            if (!t1->left) t1->left = t2->left;\\n            if (!t1->right) t1->right = t2->right;\\n            // recursively we go!\\n            if (t1->left != t2->left) dfs(t1->left, t2->left);\\n            if (t1->right != t2->right) dfs(t1->right, t2->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        dfs(t1, t2);\\n        return t1;\\n    }\\n};\\n```\\n\\nFinally I was like \"Hey, but I do not need a helper function at all!\" and got this;\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        // mergin when both are present\\n        if (t1 && t2) {\\n            t1->val += t2->val;\\n            // recursively we go!\\n            t1->left = mergeTrees(t1->left, t2->left);\\n            t1->right = mergeTrees(t1->right, t2->right);\\n        }\\n        return t1;\\n    }\\n};\\n```\\n\\nPerformances are still very random (and overall comparable with the second version) and I have no clue how I might use less memory (maybe extra test cases were added later?), but it was a fun exercise nevertheless!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2) {\\n        // we act only if both nodes are present, otherwise do nothing (ie: return)\\n        if (t1 && t2) {\\n            // if we have both and t1 was not taken by t2, we sum\\n            if (t1 != t2) t1->val += t2->val;\\n            // if t1 misses branches, we attach the ones from t2\\n            if (!t1->left) t1->left = t2->left;\\n            if (!t1->right) t1->right = t2->right;\\n            // recursively we go!\\n            dfs(t1->left, t2->left);\\n            dfs(t1->right, t2->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        dfs(t1, t2);\\n        return t1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* t1, TreeNode* t2) {\\n        // we act only if both nodes are present, otherwise do nothing (ie: return)\\n        if (t1 && t2) {\\n            t1->val += t2->val;\\n            // if t1 misses branches, we attach the ones from t2\\n            if (!t1->left) t1->left = t2->left;\\n            if (!t1->right) t1->right = t2->right;\\n            // recursively we go!\\n            if (t1->left != t2->left) dfs(t1->left, t2->left);\\n            if (t1->right != t2->right) dfs(t1->right, t2->right);\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        dfs(t1, t2);\\n        return t1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        // edge case: empty t1\\n        if (!t1) return t2;\\n        // mergin when both are present\\n        if (t1 && t2) {\\n            t1->val += t2->val;\\n            // recursively we go!\\n            t1->left = mergeTrees(t1->left, t2->left);\\n            t1->right = mergeTrees(t1->right, t2->right);\\n        }\\n        return t1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124537,
                "title": "python-recursive-iterative-dfs-bfs-solutions",
                "content": "```\\n# Recursion pre-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        t = TreeNode(t1.val + t2.val)\\n        t.left = self.mergeTrees(t1.left, t2.left)\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        \\n        return t\\n\\n# Recursion in-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        tLeft = self.mergeTrees(t1.left, t2.left)\\n        t = TreeNode(t1.val + t2.val)\\n        t.left = tLeft\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        \\n        return t\\n\\n# Recursion post-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        tLeft = self.mergeTrees(t1.left, t2.left)\\n        tRight = self.mergeTrees(t1.right, t2.right)\\n        t = TreeNode(t1.val + t2.val)\\n        t.left, t.right = tLeft, tRight\\n        \\n        return t\\n\\n# Iterative pre-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        stack1 = [t1]\\n        stack2 = [t2]\\n        tRoot = TreeNode(t1.val + t2.val)\\n        stack = [tRoot]\\n        while len(stack) > 0:\\n            t1 = stack1.pop()\\n            t2 = stack2.pop()\\n            t = stack.pop()\\n            if t1.right is None and t2.right is None:\\n                pass\\n            elif t1.right is None:\\n                t.right = t2.right\\n            elif t2.right is None:\\n                t.right = t1.right\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                stack1.append(t1.right)\\n                stack2.append(t2.right)\\n                stack.append(t.right)\\n            if t1.left is None and t2.left is None:\\n                pass\\n            elif t1.left is None:\\n                t.left = t2.left\\n            elif t2.left is None:\\n                t.left = t1.left\\n            else:\\n                t.left = TreeNode(t1.left.val + t2.left.val)\\n                stack1.append(t1.left)\\n                stack2.append(t2.left)\\n                stack.append(t.left)\\n        \\n        return tRoot\\n\\n# Iterative in-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        stack1 = []\\n        stack2 = []\\n        stack = []\\n        tRoot = TreeNode(t1.val + t2.val)\\n        t = tRoot\\n        while len(stack1) > 0 or t1 is not None:\\n            while t1 is not None and t2 is not None:\\n                stack1.append(t1)\\n                stack2.append(t2)\\n                stack.append(t)\\n                # Note: need to delay going to left if one tree is null\\n                if t1.left is not None and t2.left is not None:\\n                    t.left = TreeNode(t1.left.val + t2.left.val)\\n                    t = t.left\\n                t1, t2 = t1.left, t2.left\\n            if t1 is not None:\\n                t.left = t1\\n            if t2 is not None:\\n                t.left = t2\\n            t1, t2, t = stack1.pop(), stack2.pop(), stack.pop()\\n            if t1.right is None and t2.right is None:\\n                t1 = t2 = None\\n            elif t1.right is None:\\n                t.right = t2.right\\n                t1 = t2 = None\\n            elif t2.right is None:\\n                t.right = t1.right\\n                t1 = t2 = None\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                t1, t2, t = t1.right, t2.right, t.right            \\n        \\n        return tRoot\\n\\n# BFS\\nfrom collections import deque\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        q1, q2, q = deque(), deque(), deque()\\n        tRoot = TreeNode(t1.val + t2.val)\\n        t = tRoot\\n        q1.append(t1)\\n        q2.append(t2)\\n        q.append(t)\\n        \\n        while len(q1) > 0:\\n            t1, t2, t = q1.popleft(), q2.popleft(), q.popleft()\\n            if t1.left is None and t2.left is None:\\n                pass\\n            elif t1.left is None:\\n                t.left = t2.left\\n            elif t2.left is None:\\n                t.left = t1.left\\n            else:\\n                t.left = TreeNode(t1.left.val + t2.left.val)\\n                q1.append(t1.left)\\n                q2.append(t2.left)\\n                q.append(t.left)\\n            if t1.right is None and t2.right is None:\\n                pass\\n            elif t1.right is None:\\n                t.right = t2.right\\n            elif t2.right is None:\\n                t.right = t1.right\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                q1.append(t1.right)\\n                q2.append(t2.right)\\n                q.append(t.right)\\n        \\n        return tRoot\\n```",
                "solutionTags": [],
                "code": "```\\n# Recursion pre-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        t = TreeNode(t1.val + t2.val)\\n        t.left = self.mergeTrees(t1.left, t2.left)\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        \\n        return t\\n\\n# Recursion in-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        tLeft = self.mergeTrees(t1.left, t2.left)\\n        t = TreeNode(t1.val + t2.val)\\n        t.left = tLeft\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        \\n        return t\\n\\n# Recursion post-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        tLeft = self.mergeTrees(t1.left, t2.left)\\n        tRight = self.mergeTrees(t1.right, t2.right)\\n        t = TreeNode(t1.val + t2.val)\\n        t.left, t.right = tLeft, tRight\\n        \\n        return t\\n\\n# Iterative pre-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        stack1 = [t1]\\n        stack2 = [t2]\\n        tRoot = TreeNode(t1.val + t2.val)\\n        stack = [tRoot]\\n        while len(stack) > 0:\\n            t1 = stack1.pop()\\n            t2 = stack2.pop()\\n            t = stack.pop()\\n            if t1.right is None and t2.right is None:\\n                pass\\n            elif t1.right is None:\\n                t.right = t2.right\\n            elif t2.right is None:\\n                t.right = t1.right\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                stack1.append(t1.right)\\n                stack2.append(t2.right)\\n                stack.append(t.right)\\n            if t1.left is None and t2.left is None:\\n                pass\\n            elif t1.left is None:\\n                t.left = t2.left\\n            elif t2.left is None:\\n                t.left = t1.left\\n            else:\\n                t.left = TreeNode(t1.left.val + t2.left.val)\\n                stack1.append(t1.left)\\n                stack2.append(t2.left)\\n                stack.append(t.left)\\n        \\n        return tRoot\\n\\n# Iterative in-order\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        stack1 = []\\n        stack2 = []\\n        stack = []\\n        tRoot = TreeNode(t1.val + t2.val)\\n        t = tRoot\\n        while len(stack1) > 0 or t1 is not None:\\n            while t1 is not None and t2 is not None:\\n                stack1.append(t1)\\n                stack2.append(t2)\\n                stack.append(t)\\n                # Note: need to delay going to left if one tree is null\\n                if t1.left is not None and t2.left is not None:\\n                    t.left = TreeNode(t1.left.val + t2.left.val)\\n                    t = t.left\\n                t1, t2 = t1.left, t2.left\\n            if t1 is not None:\\n                t.left = t1\\n            if t2 is not None:\\n                t.left = t2\\n            t1, t2, t = stack1.pop(), stack2.pop(), stack.pop()\\n            if t1.right is None and t2.right is None:\\n                t1 = t2 = None\\n            elif t1.right is None:\\n                t.right = t2.right\\n                t1 = t2 = None\\n            elif t2.right is None:\\n                t.right = t1.right\\n                t1 = t2 = None\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                t1, t2, t = t1.right, t2.right, t.right            \\n        \\n        return tRoot\\n\\n# BFS\\nfrom collections import deque\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None and t2 is None:\\n            return\\n        if t1 is None:\\n            return t2\\n        if t2 is None:\\n            return t1\\n        \\n        q1, q2, q = deque(), deque(), deque()\\n        tRoot = TreeNode(t1.val + t2.val)\\n        t = tRoot\\n        q1.append(t1)\\n        q2.append(t2)\\n        q.append(t)\\n        \\n        while len(q1) > 0:\\n            t1, t2, t = q1.popleft(), q2.popleft(), q.popleft()\\n            if t1.left is None and t2.left is None:\\n                pass\\n            elif t1.left is None:\\n                t.left = t2.left\\n            elif t2.left is None:\\n                t.left = t1.left\\n            else:\\n                t.left = TreeNode(t1.left.val + t2.left.val)\\n                q1.append(t1.left)\\n                q2.append(t2.left)\\n                q.append(t.left)\\n            if t1.right is None and t2.right is None:\\n                pass\\n            elif t1.right is None:\\n                t.right = t2.right\\n            elif t2.right is None:\\n                t.right = t1.right\\n            else:\\n                t.right = TreeNode(t1.right.val + t2.right.val)\\n                q1.append(t1.right)\\n                q2.append(t2.right)\\n                q.append(t.right)\\n        \\n        return tRoot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724430,
                "title": "python-3-120ms-no-extra-space-recursive-7-lines-easy-to-understand",
                "content": "***Adding all the values in Tree1 and returning Root1 of Tree1 :-***\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root1 and root2:\\n            root1.val  += root2.val\\n            root1.left = self.mergeTrees(root1.left, root2.left)\\n            root1.right = self.mergeTrees(root1.right, root2.right)\\n            return root1\\n        else:\\n            return root1 or root2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root1 and root2:\\n            root1.val  += root2.val\\n            root1.left = self.mergeTrees(root1.left, root2.left)\\n            root1.right = self.mergeTrees(root1.right, root2.right)\\n            return root1\\n        else:\\n            return root1 or root2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044363,
                "title": "python-recursive-runtime-beats-100",
                "content": "```\\ndef mergeTrees(self, t1, t2):\\n\\tif t1 and t2:\\n\\t\\tnode = TreeNode(t1.val + t2.val)\\n\\t\\tnode.left = self.mergeTrees(t1.left, t2.left)\\n\\t\\tnode.right = self.mergeTrees(t1.right, t2.right)\\n\\t\\treturn node\\n\\treturn t1 or t2\\n```",
                "solutionTags": [],
                "code": "```\\ndef mergeTrees(self, t1, t2):\\n\\tif t1 and t2:\\n\\t\\tnode = TreeNode(t1.val + t2.val)\\n\\t\\tnode.left = self.mergeTrees(t1.left, t2.left)\\n\\t\\tnode.right = self.mergeTrees(t1.right, t2.right)\\n\\t\\treturn node\\n\\treturn t1 or t2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 492357,
                "title": "golang-solution",
                "content": "```go\\nfunc mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {\\n    // if one of t1 and t2 is nil, return the other\\n    if t1 == nil {\\n        return t2\\n    }\\n    if t2 == nil {\\n        return t1\\n    }\\n    // merge t1 and t2\\n    root := &TreeNode{Val: t1.Val + t2.Val}\\n    // recursion\\n    root.Left = mergeTrees(t1.Left, t2.Left)\\n    root.Right = mergeTrees(t1.Right, t2.Right)\\n    return root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {\\n    // if one of t1 and t2 is nil, return the other\\n    if t1 == nil {\\n        return t2\\n    }\\n    if t2 == nil {\\n        return t1\\n    }\\n    // merge t1 and t2\\n    root := &TreeNode{Val: t1.Val + t2.Val}\\n    // recursion\\n    root.Left = mergeTrees(t1.Left, t2.Left)\\n    root.Right = mergeTrees(t1.Right, t2.Right)\\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923668,
                "title": "c-iterative-bfs-easy-to-read-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1 && !root2) return NULL;\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        q.push({root1, root2});\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            // (1) we add the value of the second tree\\'s node to the first node\\n            node.first->val+=node.second->val;\\n            \\n            //if both their leftnodes exist we push them back into the queue and repeat (1)\\n            if(node.first->left && node.second->left)\\n                q.push({node.first->left,node.second->left});\\n            //if only one node exists then we make both the nodes as the same one\\n            // like if the second tree\\'s left node exists then we make the first tree\\'s node left as well\\n            else if (node.second->left)\\n                node.first->left=node.second->left;\\n            \\n            //if both their rightnodes exist we push them back into the queue and repeat (1)\\n            if(node.first->right && node.second->right)\\n                q.push({node.first->right, node.second->right});\\n            //if only one node exists then we make both the nodes as the same one\\n            // like if the second tree\\'s right node exists then we make the first tree\\'s node right as well\\n            else if (node.second->right)\\n                node.first->right=node.second->right;\\n        }\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1 && !root2) return NULL;\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        q.push({root1, root2});\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            // (1) we add the value of the second tree\\'s node to the first node\\n            node.first->val+=node.second->val;\\n            \\n            //if both their leftnodes exist we push them back into the queue and repeat (1)\\n            if(node.first->left && node.second->left)\\n                q.push({node.first->left,node.second->left});\\n            //if only one node exists then we make both the nodes as the same one\\n            // like if the second tree\\'s left node exists then we make the first tree\\'s node left as well\\n            else if (node.second->left)\\n                node.first->left=node.second->left;\\n            \\n            //if both their rightnodes exist we push them back into the queue and repeat (1)\\n            if(node.first->right && node.second->right)\\n                q.push({node.first->right, node.second->right});\\n            //if only one node exists then we make both the nodes as the same one\\n            // like if the second tree\\'s right node exists then we make the first tree\\'s node right as well\\n            else if (node.second->right)\\n                node.first->right=node.second->right;\\n        }\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774743,
                "title": "c-efficient-dfs-short-easy-recursive-without-extra-space-with-comments",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        // If both nodes exist, add their values then look at the next node.\\n        if(root1!=NULL && root2!=NULL){\\n            root1->val=root1->val + root2->val;\\n            root1->left=mergeTrees(root1->left,root2->left);\\n            root1->right=mergeTrees(root1->right,root2->right);\\n        }else{//If one node doesn\\'t exist,NOT null node will be used.\\n            return root1? root1: root2;\\n        }\\n        //Return the first tree, which is now altered. No need to create a new node, which bloats memory.\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        // If both nodes exist, add their values then look at the next node.\\n        if(root1!=NULL && root2!=NULL){\\n            root1->val=root1->val + root2->val;\\n            root1->left=mergeTrees(root1->left,root2->left);\\n            root1->right=mergeTrees(root1->right,root2->right);\\n        }else{//If one node doesn\\'t exist,NOT null node will be used.\\n            return root1? root1: root2;\\n        }\\n        //Return the first tree, which is now altered. No need to create a new node, which bloats memory.\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990385,
                "title": "using-recursion-easy-in-python-beats-86-of-python-submission",
                "content": "```\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        result_node = TreeNode()\\n        if not t1: return t2\\n        if not t2: return t1\\n\\n        result_node.data = t1.data + t2.data\\n\\n        result_node.left = self.mergeTrees(t1.left, t2.left)\\n        result_node.right = self.mergeTrees(t1.right, t2.right)\\n        return result_node\\n\\t\\t\\n\\t``` \\nplease upvote once you get it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        result_node = TreeNode()\\n        if not t1: return t2\\n        if not t2: return t1\\n\\n        result_node.data = t1.data + t2.data\\n\\n        result_node.left = self.mergeTrees(t1.left, t2.left)\\n        result_node.right = self.mergeTrees(t1.right, t2.right)\\n        return result_node\\n\\t\\t\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 112395,
                "title": "bfs-solution-using-queue-explanation",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1 == null)\\n            return t2;\\n        if(t2 == null)\\n            return t1;\\n        \\n        Queue<TreeNode[] > queue = new LinkedList<>();  \\n        queue.add(new TreeNode[] {t1, t2});\\n        while(!queue.isEmpty()) {\\n            TreeNode[] nodes = queue.remove();\\n            // If right tree has a null value for a node, then we dont need to change anything in the left tree\\n            if(nodes[1] != null) {\\n                nodes[0].val += nodes[1].val; // Since the node exists in the right tree, lets add it to the left tree\\n                \\n                // If left node of 1st tree is null, then we just point to the left node of the 2nd tree\\n                if(nodes[0].left == null) {\\n                    nodes[0].left = nodes[1].left;\\n                } else {\\n                    queue.add(new TreeNode[] {nodes[0].left,nodes[1].left});\\n                }\\n                \\n                // If right node of 1st tree is null, then we just point to the right node of the 2nd tree\\n                if(nodes[0].right == null) {\\n                    nodes[0].right = nodes[1].right;\\n                } else {\\n                    queue.add(new TreeNode[] {nodes[0].right, nodes[1].right});\\n                }\\n            }\\n        }\\n        \\n        // Return t1, as we have been updating the nodes of t1 instead of creating a new tree\\n        return t1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1 == null)\\n            return t2;\\n        if(t2 == null)\\n            return t1;\\n        \\n        Queue<TreeNode[] > queue = new LinkedList<>();  \\n        queue.add(new TreeNode[] {t1, t2});\\n        while(!queue.isEmpty()) {\\n            TreeNode[] nodes = queue.remove();\\n            // If right tree has a null value for a node, then we dont need to change anything in the left tree\\n            if(nodes[1] != null) {\\n                nodes[0].val += nodes[1].val; // Since the node exists in the right tree, lets add it to the left tree\\n                \\n                // If left node of 1st tree is null, then we just point to the left node of the 2nd tree\\n                if(nodes[0].left == null) {\\n                    nodes[0].left = nodes[1].left;\\n                } else {\\n                    queue.add(new TreeNode[] {nodes[0].left,nodes[1].left});\\n                }\\n                \\n                // If right node of 1st tree is null, then we just point to the right node of the 2nd tree\\n                if(nodes[0].right == null) {\\n                    nodes[0].right = nodes[1].right;\\n                } else {\\n                    queue.add(new TreeNode[] {nodes[0].right, nodes[1].right});\\n                }\\n            }\\n        }\\n        \\n        // Return t1, as we have been updating the nodes of t1 instead of creating a new tree\\n        return t1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491056,
                "title": "java",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n\\n        if (root2 == null) {\\n            return root1;\\n        }\\n\\n        TreeNode resultNode = new TreeNode(root1.val + root2.val);\\n        resultNode.left = mergeTrees(root1.left, root2.left);\\n        resultNode.right = mergeTrees(root1.right, root2.right);\\n        return resultNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n\\n        if (root2 == null) {\\n            return root1;\\n        }\\n\\n        TreeNode resultNode = new TreeNode(root1.val + root2.val);\\n        resultNode.left = mergeTrees(root1.left, root2.left);\\n        resultNode.right = mergeTrees(root1.right, root2.right);\\n        return resultNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505705,
                "title": "java-only-4-line-code-recursive-solution",
                "content": "class Solution {\\n\\n    public TreeNode mergeTrees(TreeNode r1, TreeNode r2) {\\n        if (r1 == null && r2 == null) return null;\\n        else if (r1 == null) return r2;\\n        else if (r2 == null) return r1;             \\n        return new TreeNode(r1.val + r2.val, mergeTrees(r1.left, r2.left), mergeTrees(r1.right, r2.right));\\n    }\\n\\t\\n}\\n\\n**Please UpVote if you like the solution.**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    public TreeNode mergeTrees(TreeNode r1, TreeNode r2) {\\n        if (r1 == null && r2 == null) return null;\\n        else if (r1 == null) return r2;\\n        else if (r2 == null) return r1;             \\n        return new TreeNode(r1.val + r2.val, mergeTrees(r1.left, r2.left), mergeTrees(r1.right, r2.right));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 671367,
                "title": "java-recursion-and-iterative-dfs-and-bfs-with-new-nodes",
                "content": "I think it is better not to change the inputs.\\n1. recursion\\n```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null) {\\n            t1 = t2;\\n            t2 = null;\\n        }\\n        if(t1==null) return null;\\n        return new TreeNode(t1.val+(t2==null?0:t2.val), mergeTrees(t1.left,t2==null?null:t2.left), mergeTrees(t1.right,t2==null?null:t2.right));                \\n    }\\n```\\n2. Iterative dfs\\n```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null && t2==null) return null;\\n        Stack<TreeNode[]> stk = new Stack<>(); \\n        TreeNode r = new TreeNode();\\n        stk.push(new TreeNode[]{t1,t2,r}); \\n        while(!stk.empty()) {\\n            TreeNode[] t = stk.pop();\\n            if(t[0]==null) {\\n                t[0]=t[1];\\n                t[1]=null;\\n            }\\n            t[2].val = t[0].val+(t[1]==null?0:t[1].val);\\n            if(t[0].right!=null || t[1]!=null && t[1].right != null) \\n                stk.push(new TreeNode[]{t[0].right, t[1]==null?null:t[1].right, t[2].right = new TreeNode()});            \\n            if(t[0].left!=null || t[1]!=null && t[1].left != null) \\n                stk.push(new TreeNode[]{t[0].left, t[1]==null?null:t[1].left, t[2].left = new TreeNode()});            \\n        }\\n        return r;\\n    }\\n```\\n3. BFS\\n```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null && t2==null) return null;\\n        Queue<TreeNode[]> q = new LinkedList<>(); \\n        TreeNode r = new TreeNode();\\n        q.add(new TreeNode[]{t1,t2,r}); \\n        while(!q.isEmpty()) {\\n            TreeNode[] t = q.poll();\\n            if(t[0]==null) {\\n                t[0]=t[1];\\n                t[1]=null;\\n            }\\n            t[2].val = t[0].val+(t[1]==null?0:t[1].val);\\n            if(t[0].right!=null || t[1]!=null && t[1].right != null) \\n                q.add(new TreeNode[]{t[0].right, t[1]==null?null:t[1].right, t[2].right = new TreeNode()});            \\n            if(t[0].left!=null || t[1]!=null && t[1].left != null) \\n                q.add(new TreeNode[]{t[0].left, t[1]==null?null:t[1].left, t[2].left = new TreeNode()});   \\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null) {\\n            t1 = t2;\\n            t2 = null;\\n        }\\n        if(t1==null) return null;\\n        return new TreeNode(t1.val+(t2==null?0:t2.val), mergeTrees(t1.left,t2==null?null:t2.left), mergeTrees(t1.right,t2==null?null:t2.right));                \\n    }\\n```\n```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null && t2==null) return null;\\n        Stack<TreeNode[]> stk = new Stack<>(); \\n        TreeNode r = new TreeNode();\\n        stk.push(new TreeNode[]{t1,t2,r}); \\n        while(!stk.empty()) {\\n            TreeNode[] t = stk.pop();\\n            if(t[0]==null) {\\n                t[0]=t[1];\\n                t[1]=null;\\n            }\\n            t[2].val = t[0].val+(t[1]==null?0:t[1].val);\\n            if(t[0].right!=null || t[1]!=null && t[1].right != null) \\n                stk.push(new TreeNode[]{t[0].right, t[1]==null?null:t[1].right, t[2].right = new TreeNode()});            \\n            if(t[0].left!=null || t[1]!=null && t[1].left != null) \\n                stk.push(new TreeNode[]{t[0].left, t[1]==null?null:t[1].left, t[2].left = new TreeNode()});            \\n        }\\n        return r;\\n    }\\n```\n```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1==null && t2==null) return null;\\n        Queue<TreeNode[]> q = new LinkedList<>(); \\n        TreeNode r = new TreeNode();\\n        q.add(new TreeNode[]{t1,t2,r}); \\n        while(!q.isEmpty()) {\\n            TreeNode[] t = q.poll();\\n            if(t[0]==null) {\\n                t[0]=t[1];\\n                t[1]=null;\\n            }\\n            t[2].val = t[0].val+(t[1]==null?0:t[1].val);\\n            if(t[0].right!=null || t[1]!=null && t[1].right != null) \\n                q.add(new TreeNode[]{t[0].right, t[1]==null?null:t[1].right, t[2].right = new TreeNode()});            \\n            if(t[0].left!=null || t[1]!=null && t[1].left != null) \\n                q.add(new TreeNode[]{t[0].left, t[1]==null?null:t[1].left, t[2].left = new TreeNode()});   \\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469033,
                "title": "c-fast-easy-understandable",
                "content": "```\\nRuntime: 44 ms, faster than 27.70% of C++ online submissions for Merge Two Binary Trees.\\nMemory Usage: 13.4 MB, less than 100.00% of C++ online submissions for Merge Two Binary Trees.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        TreeNode* newRoot = t1;\\n\\n        if(t1 == NULL) return t2;\\n        if(t2 == NULL) return t1;\\n        \\n        newRoot->val += t2->val;\\n        \\n        newRoot->left = mergeTrees(t1->left, t2->left);\\n        newRoot->right = mergeTrees(t1->right, t2->right);\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 44 ms, faster than 27.70% of C++ online submissions for Merge Two Binary Trees.\\nMemory Usage: 13.4 MB, less than 100.00% of C++ online submissions for Merge Two Binary Trees.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        TreeNode* newRoot = t1;\\n\\n        if(t1 == NULL) return t2;\\n        if(t2 == NULL) return t1;\\n        \\n        newRoot->val += t2->val;\\n        \\n        newRoot->left = mergeTrees(t1->left, t2->left);\\n        newRoot->right = mergeTrees(t1->right, t2->right);\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348889,
                "title": "nice-and-short-c-solution",
                "content": "Really small recursive CPP solution below. Very intuitive application of recursion, you handle base cases, then you create the node and merge values from t1/t2 and later you do the same for left and right sub-tree recursively. Easy and beautiful.\\n\\n```\\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n\\t// Handle the base case\\n\\tif(t1 == nullptr) return t2;\\n\\tif(t2 == nullptr) return t1;\\n\\t// Create merged node and merge left and right as well\\n\\tTreeNode* t = new TreeNode(t1->val + t2->val);\\n\\tt->left     = mergeTrees(t1->left, t2->left);\\n\\tt->right    = mergeTrees(t1->right, t2->right);\\n\\t// All done\\n\\treturn t;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n\\t// Handle the base case\\n\\tif(t1 == nullptr) return t2;\\n\\tif(t2 == nullptr) return t1;\\n\\t// Create merged node and merge left and right as well\\n\\tTreeNode* t = new TreeNode(t1->val + t2->val);\\n\\tt->left     = mergeTrees(t1->left, t2->left);\\n\\tt->right    = mergeTrees(t1->right, t2->right);\\n\\t// All done\\n\\treturn t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104399,
                "title": "5-lines-elegant-solution",
                "content": "```\\n    public TreeNode MergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1 == null || t2 == null) return t1 == null ? t2:t1;\\n        t1.val += t2.val;\\n        t1.left = MergeTrees(t1.left, t2.left);\\n        t1.right = MergeTrees(t1.right, t2.right);\\n        return t1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public TreeNode MergeTrees(TreeNode t1, TreeNode t2) {\\n        if(t1 == null || t2 == null) return t1 == null ? t2:t1;\\n        t1.val += t2.val;\\n        t1.left = MergeTrees(t1.left, t2.left);\\n        t1.right = MergeTrees(t1.right, t2.right);\\n        return t1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 104369,
                "title": "simple-java-recursive-solution-o-n",
                "content": "\\n```\\npublic class Solution {\\n    public TreeNode merge(TreeNode t1, TreeNode t2) {\\n        if(t1 == null && t2 == null) {\\n            return null;\\n        }\\n        \\n        TreeNode newNode = new TreeNode(-1);\\n        if(t1 == null) {\\n            newNode.val = t2.val;\\n            newNode.left = merge(null, t2.left);\\n            newNode.right = merge(null, t2.right);\\n        }\\n        else if(t2 == null) {\\n            newNode.val = t1.val;\\n            newNode.left = merge(t1.left, null);\\n            newNode.right = merge(t1.right, null);\\n        }\\n        else {\\n            newNode.val = t1.val + t2.val;\\n            newNode.left = merge(t1.left, t2.left);\\n            newNode.right = merge(t1.right, t2.right);\\n        }\\n        \\n        return newNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode merge(TreeNode t1, TreeNode t2) {\\n        if(t1 == null && t2 == null) {\\n            return null;\\n        }\\n        \\n        TreeNode newNode = new TreeNode(-1);\\n        if(t1 == null) {\\n            newNode.val = t2.val;\\n            newNode.left = merge(null, t2.left);\\n            newNode.right = merge(null, t2.right);\\n        }\\n        else if(t2 == null) {\\n            newNode.val = t1.val;\\n            newNode.left = merge(t1.left, null);\\n            newNode.right = merge(t1.right, null);\\n        }\\n        else {\\n            newNode.val = t1.val + t2.val;\\n            newNode.left = merge(t1.left, t2.left);\\n            newNode.right = merge(t1.right, t2.right);\\n        }\\n        \\n        return newNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213072,
                "title": "java-easy-0ms-100-simple-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1==null && root2==null) return null;\\n        if (root1==null) return root2;\\n        if (root2==null) return root1;\\n        root1.val = root1.val+root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1==null && root2==null) return null;\\n        if (root1==null) return root2;\\n        if (root2==null) return root1;\\n        root1.val = root1.val+root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054830,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n         return merge(root1,root2);\\n    }\\n    public TreeNode merge(TreeNode t1,TreeNode t2){\\n        if(t1==null && t2==null){\\n            return null;\\n        }\\n        if(t1==null && t2!=null){\\n            return t2;\\n        }\\n        else if(t1!=null && t2==null){\\n            return t1;\\n        }\\n        TreeNode sum=new TreeNode(t1.val+t2.val);\\n        sum.left=merge(t1.left,t2.left);\\n        sum.right=merge(t1.right,t2.right);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n         return merge(root1,root2);\\n    }\\n    public TreeNode merge(TreeNode t1,TreeNode t2){\\n        if(t1==null && t2==null){\\n            return null;\\n        }\\n        if(t1==null && t2!=null){\\n            return t2;\\n        }\\n        else if(t1!=null && t2==null){\\n            return t1;\\n        }\\n        TreeNode sum=new TreeNode(t1.val+t2.val);\\n        sum.left=merge(t1.left,t2.left);\\n        sum.right=merge(t1.right,t2.right);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572845,
                "title": "c-recursive-solution",
                "content": "This solution uses a recursive approach. \\n\\nThe merging rules are: \\n1. If 2 nodes overlap - sum up their values, and place it in the new node. \\n2. If they do not, then the NON null node takes the place. \\n\\nAs per these rules: \\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        \\n        // If one of the nodes doesn\\'t exist - return the other one\\n        if(!root1){return root2;}\\n        \\n        if(!root2){return root1;}\\n    \\n      \\n        // Otherwise, add their values\\n        root1->val += root2->val;\\n        \\n        // Assign the value of the children as the result of the recursive call on the \\n        // children of the root\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        \\n        // return the root \\n        return root1;\\n    }\\n};\\n```\\nThe function returns the node which is present (in case one of them isn\\'t), or, in the case that both are present, it adds up their values. It is then called on the children recursively, which means it\\'s called on every node in the tree - always returning the root and slowly but surely populating the output array. \\n\\n*Time -- O(n)\\nSpace -- O(n)*\\n\\nUpvote if you found this helpful \\n\\nCheers",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        \\n        // If one of the nodes doesn\\'t exist - return the other one\\n        if(!root1){return root2;}\\n        \\n        if(!root2){return root1;}\\n    \\n      \\n        // Otherwise, add their values\\n        root1->val += root2->val;\\n        \\n        // Assign the value of the children as the result of the recursive call on the \\n        // children of the root\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        \\n        // return the root \\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218180,
                "title": "c-recursion-easy-explained-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n\\t//If any node is NULL then attach the other root node there, for eample if right of root1 is null then attach root2 right to root1 right\\n        if(!root2) return root1; \\n        if(!root1) return root2;\\n        \\n        root1->left = mergeTrees(root1->left, root2->left); //Merge left nodes\\n        root1->right = mergeTrees(root1->right, root2->right); //Merge right nodes\\n        \\n        root1 ->val = root1->val + root2->val; //Finally add both the values and return root1 because we have modified root1\\n        return root1;\\n    }\\n};\\n```\\n\\u200E\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n\\t//If any node is NULL then attach the other root node there, for eample if right of root1 is null then attach root2 right to root1 right\\n        if(!root2) return root1; \\n        if(!root1) return root2;\\n        \\n        root1->left = mergeTrees(root1->left, root2->left); //Merge left nodes\\n        root1->right = mergeTrees(root1->right, root2->right); //Merge right nodes\\n        \\n        root1 ->val = root1->val + root2->val; //Finally add both the values and return root1 because we have modified root1\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978746,
                "title": "easy-to-understand-code-for-beginners",
                "content": "class Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL and t2 ==NULL)\\n            return NULL;\\n        else if(t1==NULL and t2!=NULL)\\n            return t2;\\n        else if(t1!=NULL and t2==NULL)\\n            return t1;\\n        else \\n        {\\n            TreeNode *root = new TreeNode(t1->val+t2->val);\\n            root->left=mergeTrees(t1->left,t2->left);\\n            root->right=mergeTrees(t1->right,t2->right);\\n            return root;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL and t2 ==NULL)\\n            return NULL;\\n        else if(t1==NULL and t2!=NULL)\\n            return t2;\\n        else if(t1!=NULL and t2==NULL)\\n            return t1;\\n        else \\n        {\\n            TreeNode *root = new TreeNode(t1->val+t2->val);\\n            root->left=mergeTrees(t1->left,t2->left);\\n            root->right=mergeTrees(t1->right,t2->right);\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1631802,
                "title": "6-lines-easy-c",
                "content": "```\\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491883,
                "title": "99-41-in-runtime-and-92-01-in-memory",
                "content": "![image](https://assets.leetcode.com/users/images/e1e06a9d-9c33-43db-920c-a568d78c6248_1632851529.775284.png)\\n\\nclass Solution:\\n\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n      if root1 and root2:\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n      return root1 or root2\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/e1e06a9d-9c33-43db-920c-a568d78c6248_1632851529.775284.png)\\n\\nclass Solution:\\n\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n      if root1 and root2:\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n      return root1 or root2\\n",
                "codeTag": "Java"
            },
            {
                "id": 443033,
                "title": "617-merge-two-binary-trees-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Recursion**\\n| O(T): O(n) | O(S): O(h) | Rt: 64ms | \\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 and not t2: return \\n        elif t1 and t2: \\n            t1.val += t2.val\\n            t1.left = self.mergeTrees(t1.left, t2.left)\\n            t1.right = self.mergeTrees(t1.right, t2.right)\\n        elif not t1 and t2: \\n            t1 = t2\\n        return t1\\n```\\nAlternative: conciser version. | Rt: 76ms |\\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```\\n\\n\\n**II). Iteration**\\n| O(T): O(n) | O(S): O(n) | Rt: 76ms | \\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        s = [(t1, t2)]\\n        while s: \\n            n1, n2 = s.pop()\\n            #nothing to add on\\n            if not n2: continue\\n            n1.val += n2.val\\n            #base initialization, critical to check n2\\'s corresponding child\\n            if not n1.left and n2.left: n1.left = TreeNode(0)\\n            if not n1.right and n2.right: n1.right = TreeNode(0)\\n            #stack pairs, level by level add up\\n            s.append((n1.right, n2.right))\\n            s.append((n1.left, n2.left))\\n        return t1\\n```\\nComment: three things I learn from this solution: n2-oriented thinking pattern, the goal is to add n2 to n1. Therefore, we adjust n1 according to n2. When to start, When to stop, When we need initialization, all decided by n2. Second, complete the n1 to make edge case normal. Third, it is critical to make sure n1 is not empty in the first round and maintein this property in the process. \\nAlternative: | Rt: 72ms |\\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        s = [(t1, t2)]\\n        while s: \\n            n1, n2 = s.pop()\\n            #nothing to add on\\n            if not n2: continue\\n            n1.val += n2.val\\n            if not n1.right: n1.right = n2.right\\n            else: s.append((n1.right, n2.right))\\n            if not n1.left: n1.left = n2.left\\n            else: s.append((n1.left, n2.left))\\n        return t1\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 and not t2: return \\n        elif t1 and t2: \\n            t1.val += t2.val\\n            t1.left = self.mergeTrees(t1.left, t2.left)\\n            t1.right = self.mergeTrees(t1.right, t2.right)\\n        elif not t1 and t2: \\n            t1 = t2\\n        return t1\\n```\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        s = [(t1, t2)]\\n        while s: \\n            n1, n2 = s.pop()\\n            #nothing to add on\\n            if not n2: continue\\n            n1.val += n2.val\\n            #base initialization, critical to check n2\\'s corresponding child\\n            if not n1.left and n2.left: n1.left = TreeNode(0)\\n            if not n1.right and n2.right: n1.right = TreeNode(0)\\n            #stack pairs, level by level add up\\n            s.append((n1.right, n2.right))\\n            s.append((n1.left, n2.left))\\n        return t1\\n```\n```python\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2: return t1 or t2\\n        s = [(t1, t2)]\\n        while s: \\n            n1, n2 = s.pop()\\n            #nothing to add on\\n            if not n2: continue\\n            n1.val += n2.val\\n            if not n1.right: n1.right = n2.right\\n            else: s.append((n1.right, n2.right))\\n            if not n1.left: n1.left = n2.left\\n            else: s.append((n1.left, n2.left))\\n        return t1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 137646,
                "title": "java-iterative-dfs-approach",
                "content": "```\\nclass Solution {\\n    // idea is to use DFS iterative traverse to update t1 to be the merged tree\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        Stack<TreeNode[]> stack = new Stack();\\n        stack.push(new TreeNode[] {t1, t2}); // any node pair in stack much be both non-null     \\n        while (!stack.isEmpty()) {\\n            TreeNode[] t = stack.pop();\\n            t[0].val += t[1].val;\\n            // case 1: tree1 subtree null:                            put tree2 subtree to tree1, return\\n            // case 2: tree1 subtree not null, tree2 subtree null     do nothing, return\\n            // case 3: tree1 subtree not null, tree2 subtreenot null: put to stack\\n            /////// deal with left tree\\n            if (t[0].left == null) {\\n                t[0].left = t[1].left;\\n            } else if (t[1].left != null) {\\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\\n            }\\n            ////// deal with right tree\\n            if (t[0].right == null) {\\n                t[0].right = t[1].right;\\n            } else if (t[1].right != null) {\\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\\n            }\\n        }\\n        return t1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // idea is to use DFS iterative traverse to update t1 to be the merged tree\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        Stack<TreeNode[]> stack = new Stack();\\n        stack.push(new TreeNode[] {t1, t2}); // any node pair in stack much be both non-null     \\n        while (!stack.isEmpty()) {\\n            TreeNode[] t = stack.pop();\\n            t[0].val += t[1].val;\\n            // case 1: tree1 subtree null:                            put tree2 subtree to tree1, return\\n            // case 2: tree1 subtree not null, tree2 subtree null     do nothing, return\\n            // case 3: tree1 subtree not null, tree2 subtreenot null: put to stack\\n            /////// deal with left tree\\n            if (t[0].left == null) {\\n                t[0].left = t[1].left;\\n            } else if (t[1].left != null) {\\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\\n            }\\n            ////// deal with right tree\\n            if (t[0].right == null) {\\n                t[0].right = t[1].right;\\n            } else if (t[1].right != null) {\\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\\n            }\\n        }\\n        return t1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104326,
                "title": "simple-javascript-solution",
                "content": "```\\n/**\\n * @param {TreeNode} t1\\n * @param {TreeNode} t2\\n * @return {TreeNode}\\n */\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) {\\n        return null;\\n    }\\n    \\n    if (!t1 || !t2) {\\n        return t1 || t2;\\n    }\\n    \\n    var root = new TreeNode(t1.val + t2.val);\\n    \\n    root.left = mergeTrees(t1.left, t2.left);\\n    root.right = mergeTrees(t1.right, t2.right);\\n    \\n    return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} t1\\n * @param {TreeNode} t2\\n * @return {TreeNode}\\n */\\nvar mergeTrees = function(t1, t2) {\\n    if (!t1 && !t2) {\\n        return null;\\n    }\\n    \\n    if (!t1 || !t2) {\\n        return t1 || t2;\\n    }\\n    \\n    var root = new TreeNode(t1.val + t2.val);\\n    \\n    root.left = mergeTrees(t1.left, t2.left);\\n    root.right = mergeTrees(t1.right, t2.right);\\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104374,
                "title": "simple-and-clean-7-lines-in-go",
                "content": "```\\nfunc mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {\\n    if t1 == nil {\\n        return t2\\n    }\\n    if t2 == nil {\\n        return t1\\n    }\\n    \\n    return &TreeNode{t1.Val+t2.Val, mergeTrees(t1.Left, t2.Left), mergeTrees(t1.Right, t2.Right)}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {\\n    if t1 == nil {\\n        return t2\\n    }\\n    if t2 == nil {\\n        return t1\\n    }\\n    \\n    return &TreeNode{t1.Val+t2.Val, mergeTrees(t1.Left, t2.Left), mergeTrees(t1.Right, t2.Right)}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479171,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1 == NULL)\\n        {\\n            return root2;\\n        }\\n        if(root2 == NULL )\\n        {\\n            return root1;\\n        } \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1 == NULL)\\n        {\\n            return root2;\\n        }\\n        if(root2 == NULL )\\n        {\\n            return root1;\\n        } \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428329,
                "title": "0ms-short-and-simple-code",
                "content": "***UPVOTE PLZZ***\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1==NULL)\\n          return root2;\\n        if(root2==NULL)\\n          return root1;\\n\\n        root1->val+=root2->val;\\n        root1->left = mergeTrees(root1->left ,root2->left);\\n        root1->right = mergeTrees(root1->right ,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1==NULL)\\n          return root2;\\n        if(root2==NULL)\\n          return root1;\\n\\n        root1->val+=root2->val;\\n        root1->left = mergeTrees(root1->left ,root2->left);\\n        root1->right = mergeTrees(root1->right ,root2->right);\\n        \\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400517,
                "title": "java-merge-trees",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null && root2 == null) return null;\\n        TreeNode node = new TreeNode();\\n        if (root1 != null) node.val += root1.val;\\n        if (root2 != null) node.val += root2.val;\\n        node.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);\\n        node.right = mergeTrees(root1 != null ? root1.right : null,root2 != null ? root2.right : null);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null && root2 == null) return null;\\n        TreeNode node = new TreeNode();\\n        if (root1 != null) node.val += root1.val;\\n        if (root2 != null) node.val += root2.val;\\n        node.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);\\n        node.right = mergeTrees(root1 != null ? root1.right : null,root2 != null ? root2.right : null);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380987,
                "title": "easy-solution-5-line-code-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of Bst\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n       if(root1==null && root2==null) return null;\\n       if(root1==null) return root2;\\n       if(root2==null) return root1;\\n       root1.val+=root2.val;\\n       root1.left= mergeTrees(root1.left,root2.left);\\n       root1.right= mergeTrees(root1.right,root2.right);\\n       return root1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n       if(root1==null && root2==null) return null;\\n       if(root1==null) return root2;\\n       if(root2==null) return root1;\\n       root1.val+=root2.val;\\n       root1.left= mergeTrees(root1.left,root2.left);\\n       root1.right= mergeTrees(root1.right,root2.right);\\n       return root1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987855,
                "title": "c-dfs-pre-order-intuitive-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/a66244fe-56c1-44a5-8f4d-db3feb304e56_1672679698.3288825.png)\\n\\n**n==Number of Node which are common inn both the Trees\\nT->O(n) && S->O(Height of tree common in both)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid merge(TreeNode* curr1,TreeNode* curr2,TreeNode* prev1,char d){\\n\\t\\t//         Base Case\\n\\t\\t\\t\\tif(!curr1 && !curr2) return;\\n\\t\\t\\t\\telse if(curr1 && curr2) curr1->val+=curr2->val;\\n\\t\\t\\t\\telse if(curr2){\\n\\t\\t\\t\\t\\tif(d == \\'l\\') prev1->left = curr2;\\n\\t\\t\\t\\t\\telse prev1->right = curr2;\\n\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return;\\n\\t\\t\\t\\tmerge(curr1->left,curr2->left,curr1,\\'l\\');\\n\\t\\t\\t\\tmerge(curr1->right,curr2->right,curr1,\\'r\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n\\t\\t\\t\\tif(!root1) return root2;\\n\\t\\t\\t\\telse if(!root2) return root1;\\n\\t\\t\\t\\tmerge(root1,root2,NULL,\\'0\\');\\n\\t\\t\\t\\treturn root1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid merge(TreeNode* curr1,TreeNode* curr2,TreeNode* prev1,char d){\\n\\t\\t//         Base Case\\n\\t\\t\\t\\tif(!curr1 && !curr2) return;\\n\\t\\t\\t\\telse if(curr1 && curr2) curr1->val+=curr2->val;\\n\\t\\t\\t\\telse if(curr2){\\n\\t\\t\\t\\t\\tif(d == \\'l\\') prev1->left = curr2;\\n\\t\\t\\t\\t\\telse prev1->right = curr2;\\n\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1860049,
                "title": "4-approaches-recursion-iteration-bfs-and-dfs",
                "content": "[Leetcode](https://leetcode.com/) [617. Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees).\\n\\n***By Frank Luo***\\n\\nHere are **4** approaches to solve this problem in Java: **Recursion**, Iteration, BFS and DFS.\\n\\n# Recursion\\n\\n## Method 1: New Tree\\n\\nWe can create a new **Tree**, each $\\\\texttt{TreeNode}$ value is sum of two nodes.\\n\\n```java\\n    public static TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        if (root2 == null) {\\n            return root1;\\n        }\\n        TreeNode merged = new TreeNode(root1.val + root2.val);\\n        merged.left = mergeTrees(root1.left, root2.left);\\n        merged.right = mergeTrees(root1.right, root2.right);\\n        return merged;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(min(m, n))$\\n- **Space Complexity**: $O(min(m, n))$\\n\\n## Method 2\\n\\nTraverse both the given trees in a **PreOrder** style. \\n\\nAt every step, check if the current node exists for both the trees. If one of these children happens to be null, we return the child of the other tree to be added as a child subtree to the calling parent node in the first tree.\\n\\nWe can add the values in the current nodes of both the trees and update the value in the current node of the first tree to reflect this sum obtained. \\n\\nThen we call the $\\\\texttt{mergeTrees()}$ with the left children and then with the right children of the current nodes of the two trees. \\n\\nAt the end, the first tree will represent the required resultant merged binary tree.\\n\\n```java\\n    public static TreeNode mergeTrees_rec(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        if (root2 == null) {\\n            return root1;\\n        }\\n\\n        if (root1 != null) {\\n            root1.val += root2.val;\\n            root1.left = mergeTrees_rec(root1.left, root2.left);\\n            root1.right = mergeTrees_rec(root1.right, root2.right);\\n        }\\n\\n        return root1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(min(m, n))$\\n- **Space Complexity**: $O(min(m, n))$\\n\\n# Iteration\\n\\nWe can also traverse the two trees by make use of a **stack** to do so. \\n\\nEach entry in the **Stack** strores data in the form $[\\\\textit{node}_{tree1}, \\\\textit{node}_{tree2}]$. \\n\\n1. We push the root nodes of both the trees onto the stack. \\n2. At every step, we remove a node pair from the top of the stack. \\n3. For every node pair removed, we add the values corresponding to the two nodes and update the value of the corresponding node in the first tree.\\n4. If $root1.left != null && root2.left != null$, we push the left child(pair) of both the trees onto the stack. \\n5. If $root1.left == null$, we append the left child(subtree) of the second tree to the current node of the first tree. We do the same for the right child pair as well.\\n6. If, at any step, both the current nodes are null, we continue with popping the next nodes from the stack.\\n\\n```java\\n    public TreeNode mergeTrees_iter(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\n        Deque<TreeNode[]> stack = new ArrayDeque<>();\\n        stack.push(new TreeNode[]{root1, root2});\\n        while (!stack.isEmpty()) {\\n            TreeNode[] currNodes = stack.pop();\\n            if (currNodes[0] == null || currNodes[1] == null) {\\n                continue;\\n            }\\n\\n            currNodes[0].val += currNodes[1].val;\\n            if (currNodes[0].left == null) {\\n                currNodes[0].left = currNodes[1].left;\\n            } else {\\n                stack.push(new TreeNode[]{currNodes[0].left, currNodes[1].left});\\n            }\\n\\n            if (currNodes[0].right == null) {\\n                currNodes[0].right = currNodes[1].right;\\n            } else {\\n                stack.push(new TreeNode[]{currNodes[0].right, currNodes[1].right});\\n            }\\n        }\\n\\n        return root1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(min(m, n))$\\n- **Space Complexity**: $O(min(m, n))$\\n\\n\\n# BFS\\n\\nBFS is like the **Iteration** method, it create a new **Tree**.\\n\\n```java\\n    public static TreeNode mergeTrees_bfs(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\t\\t\\n        TreeNode merged = new TreeNode(root1.val + root2.val);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<TreeNode> queue1 = new LinkedList<>();\\n        Queue<TreeNode> queue2 = new LinkedList<>();\\n        queue.offer(merged);\\n        queue1.offer(root1);\\n        queue2.offer(root2);\\n        while (!queue1.isEmpty() && !queue2.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            TreeNode node1 = queue1.poll();\\n            TreeNode node2 = queue2.poll();\\n            if (node1.left != null || node2.left != null) {\\n                if (node1.left != null && node2.left != null) {\\n                    TreeNode leftNode = new TreeNode(node1.left.val + node2.left.val);\\n                    node.left = leftNode;\\n                    queue.offer(leftNode);\\n                    queue1.offer(node1.left);\\n                    queue2.offer(node2.left);\\n                } else if (node1.left != null) {\\n                    node.left = node1.left;\\n                } else if (node2.left != null) {\\n                    node.left = node2.left;\\n                }\\n            }\\n\\n            if (node1.right != null || node2.right != null) {\\n                if (node1.right != null && node2.right != null) {\\n                    TreeNode rightNode = new TreeNode(node1.right.val + node2.right.val);\\n                    node.right = rightNode;\\n                    queue.offer(rightNode);\\n                    queue1.offer(node1.right);\\n                    queue2.offer(node2.right);\\n                } else if (node1.right != null) {\\n                    node.right = node1.right;\\n                } else if (node2.right != null) {\\n                    node.right = node2.right;\\n                }\\n            }\\n        }\\n\\n        return merged;\\n    }\\n```\\n\\nThe BFS code is not neat, I have refactor it.\\n\\n```java\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\n        Queue<TreeNode[]> queue = new LinkedList<>();\\n        queue.offer(new TreeNode[]{root1, root2});\\n        while (!queue.isEmpty()) {\\n            TreeNode[] node = queue.poll();\\n            node[0].val += node[1].val;\\n\\n            if (node[0].left != null || node[1].left != null) {\\n                if (node[0].left != null && node[1].left != null) {\\n                    queue.offer(new TreeNode[]{node[0].left, node[1].left});\\n                } else if (node[0].left == null) {\\n                    node[0].left = node[1].left;\\n                }\\n            }\\n\\n            if (node[0].right != null || node[1].right != null) {\\n                if (node[0].right != null && node[1].right != null) {\\n                    queue.offer(new TreeNode[]{node[0].right, node[1].right});\\n                } else if (node[0].right == null) {\\n                    node[0].right = node[1].right;\\n                }\\n            }\\n        }\\n\\n        return root1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(min(m, n))$\\n- **Space Complexity**: $O(min(m, n))$\\n\\n# DFS\\n\\nDFS is the same as the recursion method, just a little bit difference.\\n\\n```java\\n    public static TreeNode mergeTrees_dfs(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        dfs(root1, root2);\\n        return root1;\\n    }\\n\\n    public static void dfs(TreeNode root1, TreeNode root2) {\\n        if (root1 != null && root2 != null) {\\n            if (root1 != root2) {\\n                root1.val += root2.val;\\n            }\\n\\n            if (root1.left == null) {\\n                root1.left = root2.left;\\n            }\\n            if (root1.right == null) {\\n                root1.right = root2.right;\\n            }\\n            dfs(root1.left, root2.left);\\n            dfs(root1.right, root2.right);\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(min(m, n))$\\n- **Space Complexity**: $O(min(m, n))$\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n    public static TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        if (root2 == null) {\\n            return root1;\\n        }\\n        TreeNode merged = new TreeNode(root1.val + root2.val);\\n        merged.left = mergeTrees(root1.left, root2.left);\\n        merged.right = mergeTrees(root1.right, root2.right);\\n        return merged;\\n    }\\n```\n```java\\n    public static TreeNode mergeTrees_rec(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        if (root2 == null) {\\n            return root1;\\n        }\\n\\n        if (root1 != null) {\\n            root1.val += root2.val;\\n            root1.left = mergeTrees_rec(root1.left, root2.left);\\n            root1.right = mergeTrees_rec(root1.right, root2.right);\\n        }\\n\\n        return root1;\\n    }\\n```\n```java\\n    public TreeNode mergeTrees_iter(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\n        Deque<TreeNode[]> stack = new ArrayDeque<>();\\n        stack.push(new TreeNode[]{root1, root2});\\n        while (!stack.isEmpty()) {\\n            TreeNode[] currNodes = stack.pop();\\n            if (currNodes[0] == null || currNodes[1] == null) {\\n                continue;\\n            }\\n\\n            currNodes[0].val += currNodes[1].val;\\n            if (currNodes[0].left == null) {\\n                currNodes[0].left = currNodes[1].left;\\n            } else {\\n                stack.push(new TreeNode[]{currNodes[0].left, currNodes[1].left});\\n            }\\n\\n            if (currNodes[0].right == null) {\\n                currNodes[0].right = currNodes[1].right;\\n            } else {\\n                stack.push(new TreeNode[]{currNodes[0].right, currNodes[1].right});\\n            }\\n        }\\n\\n        return root1;\\n    }\\n```\n```java\\n    public static TreeNode mergeTrees_bfs(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\t\\t\\n        TreeNode merged = new TreeNode(root1.val + root2.val);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<TreeNode> queue1 = new LinkedList<>();\\n        Queue<TreeNode> queue2 = new LinkedList<>();\\n        queue.offer(merged);\\n        queue1.offer(root1);\\n        queue2.offer(root2);\\n        while (!queue1.isEmpty() && !queue2.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            TreeNode node1 = queue1.poll();\\n            TreeNode node2 = queue2.poll();\\n            if (node1.left != null || node2.left != null) {\\n                if (node1.left != null && node2.left != null) {\\n                    TreeNode leftNode = new TreeNode(node1.left.val + node2.left.val);\\n                    node.left = leftNode;\\n                    queue.offer(leftNode);\\n                    queue1.offer(node1.left);\\n                    queue2.offer(node2.left);\\n                } else if (node1.left != null) {\\n                    node.left = node1.left;\\n                } else if (node2.left != null) {\\n                    node.left = node2.left;\\n                }\\n            }\\n\\n            if (node1.right != null || node2.right != null) {\\n                if (node1.right != null && node2.right != null) {\\n                    TreeNode rightNode = new TreeNode(node1.right.val + node2.right.val);\\n                    node.right = rightNode;\\n                    queue.offer(rightNode);\\n                    queue1.offer(node1.right);\\n                    queue2.offer(node2.right);\\n                } else if (node1.right != null) {\\n                    node.right = node1.right;\\n                } else if (node2.right != null) {\\n                    node.right = node2.right;\\n                }\\n            }\\n        }\\n\\n        return merged;\\n    }\\n```\n```java\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        } else if (root2 == null) {\\n            return root1;\\n        }\\n\\n        Queue<TreeNode[]> queue = new LinkedList<>();\\n        queue.offer(new TreeNode[]{root1, root2});\\n        while (!queue.isEmpty()) {\\n            TreeNode[] node = queue.poll();\\n            node[0].val += node[1].val;\\n\\n            if (node[0].left != null || node[1].left != null) {\\n                if (node[0].left != null && node[1].left != null) {\\n                    queue.offer(new TreeNode[]{node[0].left, node[1].left});\\n                } else if (node[0].left == null) {\\n                    node[0].left = node[1].left;\\n                }\\n            }\\n\\n            if (node[0].right != null || node[1].right != null) {\\n                if (node[0].right != null && node[1].right != null) {\\n                    queue.offer(new TreeNode[]{node[0].right, node[1].right});\\n                } else if (node[0].right == null) {\\n                    node[0].right = node[1].right;\\n                }\\n            }\\n        }\\n\\n        return root1;\\n    }\\n```\n```java\\n    public static TreeNode mergeTrees_dfs(TreeNode root1, TreeNode root2) {\\n        if (root1 == null) {\\n            return root2;\\n        }\\n        dfs(root1, root2);\\n        return root1;\\n    }\\n\\n    public static void dfs(TreeNode root1, TreeNode root2) {\\n        if (root1 != null && root2 != null) {\\n            if (root1 != root2) {\\n                root1.val += root2.val;\\n            }\\n\\n            if (root1.left == null) {\\n                root1.left = root2.left;\\n            }\\n            if (root1.right == null) {\\n                root1.right = root2.right;\\n            }\\n            dfs(root1.left, root2.left);\\n            dfs(root1.right, root2.right);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1771568,
                "title": "simple-c-4-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n   TreeNode* mergeTrees(TreeNode* node1,TreeNode* node2)\\n    {         \\n        if(node1==NULL)return node2;       \\n        else if(node2==NULL)return node1;\\n        else {TreeNode* node=new TreeNode(node1->val+node2->val,mergeTrees(node1->left,node2->left),mergeTrees(node1->right,node2->right));\\n            return node;\\n        }  \\n   }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n   TreeNode* mergeTrees(TreeNode* node1,TreeNode* node2)\\n    {         \\n        if(node1==NULL)return node2;       \\n        else if(node2==NULL)return node1;\\n        else {TreeNode* node=new TreeNode(node1->val+node2->val,mergeTrees(node1->left,node2->left),mergeTrees(node1->right,node2->right));\\n            return node;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1528229,
                "title": "c-bfs-single-queue-iterative",
                "content": "```\\nTreeNode* mergeTrees(TreeNode* r1, TreeNode* r2) {\\n        if(!r1 && !r2) return NULL;\\n        if(!r1) return r2;\\n        if(!r2) return r1;\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({r1,r2});\\n        while(!q.empty()){\\n            auto temp = q.front(); q.pop();\\n            temp.first->val+=temp.second->val;\\n            \\n            if(temp.first->left && temp.second->left)\\n                q.push({temp.first->left,temp.second->left});\\n            else if (temp.second->left)\\n                temp.first->left=temp.second->left;\\n            \\n            if(temp.first->right && temp.second->right)\\n                q.push({temp.first->right,temp.second->right});\\n            else if (temp.second->right)\\n                temp.first->right=temp.second->right;         \\n        }\\n        return r1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* mergeTrees(TreeNode* r1, TreeNode* r2) {\\n        if(!r1 && !r2) return NULL;\\n        if(!r1) return r2;\\n        if(!r2) return r1;\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({r1,r2});\\n        while(!q.empty()){\\n            auto temp = q.front(); q.pop();\\n            temp.first->val+=temp.second->val;\\n            \\n            if(temp.first->left && temp.second->left)\\n                q.push({temp.first->left,temp.second->left});\\n            else if (temp.second->left)\\n                temp.first->left=temp.second->left;\\n            \\n            if(temp.first->right && temp.second->right)\\n                q.push({temp.first->right,temp.second->right});\\n            else if (temp.second->right)\\n                temp.first->right=temp.second->right;         \\n        }\\n        return r1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1507689,
                "title": "c-very-short-and-easily-understandable-recursive-solution",
                "content": "**Approach: Transverse both the trees together\\nIf both trees are null, return NULL\\nelse create a new node, and add the values of not null nodes of the trees\\nrecursively call the function for creation of left and right subtrees by performing null sanity check on the passed nodes**\\n\\n*Time complexity :O(N), N = max(number of nodes in tree1, number of nodes in tree2)*\\n\\n```\\nTreeNode *mergeTrees(TreeNode *root1, TreeNode *root2)\\n    {\\n        if (root1 == NULL and root2 == NULL)\\n            return NULL;\\n        TreeNode *node = new TreeNode();\\n        if (root1)\\n            node->val += root1->val;\\n        if (root2)\\n            node->val += root2->val;\\n        node->left = mergeTrees(root1 ? root1->left : NULL, root2 ? root2->left : NULL);\\n        node->right = mergeTrees(root1 ? root1->right : NULL, root2 ? root2->right : NULL);\\n        return node;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode *mergeTrees(TreeNode *root1, TreeNode *root2)\\n    {\\n        if (root1 == NULL and root2 == NULL)\\n            return NULL;\\n        TreeNode *node = new TreeNode();\\n        if (root1)\\n            node->val += root1->val;\\n        if (root2)\\n            node->val += root2->val;\\n        node->left = mergeTrees(root1 ? root1->left : NULL, root2 ? root2->left : NULL);\\n        node->right = mergeTrees(root1 ? root1->right : NULL, root2 ? root2->right : NULL);\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491358,
                "title": "easy-to-understand-c-solution-recursion",
                "content": "**Explanation**\\nHere we are using recursion. First of all in base case we check if any of the root node exist or not, if not, we return NULL. then we make the root node and apply the conditions given in the question and then recursively call the function to solve the left and right subtree of the current node and then finally return the answer tree.\\n\\nPlease upvote the solution if you find it helpful and comment down if you have any questions!\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1,TreeNode* root2){\\n        //base case\\n        if(root1==NULL and root2==NULL)\\n            return NULL;\\n        \\n\\t\\t//making the root node\\n        TreeNode* ans=new TreeNode();\\n        \\n        if(root1 and !root2)\\n            ans->val=root1->val;\\n        else if(root2 and !root1)\\n            ans->val=root2->val;\\n        else\\n            ans->val=root1->val+root2->val;\\n        \\n        //recursive calls\\n\\t\\tans->left=mergeTrees(root1?root1->left:NULL,root2?root2->left:NULL);\\n        ans->right=mergeTrees(root1?root1->right:NULL,root2?root2->right:NULL);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1,TreeNode* root2){\\n        //base case\\n        if(root1==NULL and root2==NULL)\\n            return NULL;\\n        \\n\\t\\t//making the root node\\n        TreeNode* ans=new TreeNode();\\n        \\n        if(root1 and !root2)\\n            ans->val=root1->val;\\n        else if(root2 and !root1)\\n            ans->val=root2->val;\\n        else\\n            ans->val=root1->val+root2->val;\\n        \\n        //recursive calls\\n\\t\\tans->left=mergeTrees(root1?root1->left:NULL,root2?root2->left:NULL);\\n        ans->right=mergeTrees(root1?root1->right:NULL,root2?root2->right:NULL);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483705,
                "title": "python-bfs-without-modfying-the-original-trees",
                "content": "I couldn\\'t find a BFS solution which hasn\\'t modified the original Trees, so here it is:\\n```\\nfrom collections import deque\\n\\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif not root1 and not root2:\\n\\t\\treturn None\\n\\troot = TreeNode()\\n\\tqueue = deque()\\n\\tqueue.append((root1, root2, root))\\n\\twhile queue:\\n\\t\\tnode1, node2, node = queue.popleft()\\n\\t\\tnode.val = (node1.val if node1 else 0) + (node2.val if node2 else 0)\\n\\n\\t\\tif (node1 and node1.left) or (node2 and node2.left):\\n\\t\\t\\tnode.left = TreeNode()\\n\\t\\t\\tqueue.append((node1 and node1.left, node2 and node2.left, node.left))\\n\\t\\tif (node1 and node1.right) or (node2 and node2.right):\\n\\t\\t\\tnode.right = TreeNode()\\n\\t\\t\\tqueue.append((node1 and node1.right, node2 and node2.right, node.right))\\n\\n\\treturn root\\n```\\n\\nThe idea is to populate the queue with the nodes of both trees, and the node of the new tree.\\nWhen such a tuple gets popped, first the value gets assigned no the node of the new tree, and then we append to the queue depending on whether either of the trees has a child. There\\'s a lot of inline ifs and ands because node1 and node2 might be `None`.\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif not root1 and not root2:\\n\\t\\treturn None\\n\\troot = TreeNode()\\n\\tqueue = deque()\\n\\tqueue.append((root1, root2, root))\\n\\twhile queue:\\n\\t\\tnode1, node2, node = queue.popleft()\\n\\t\\tnode.val = (node1.val if node1 else 0) + (node2.val if node2 else 0)\\n\\n\\t\\tif (node1 and node1.left) or (node2 and node2.left):\\n\\t\\t\\tnode.left = TreeNode()\\n\\t\\t\\tqueue.append((node1 and node1.left, node2 and node2.left, node.left))\\n\\t\\tif (node1 and node1.right) or (node2 and node2.right):\\n\\t\\t\\tnode.right = TreeNode()\\n\\t\\t\\tqueue.append((node1 and node1.right, node2 and node2.right, node.right))\\n\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1080039,
                "title": "rust-recursive",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype Node = Rc<RefCell<TreeNode>>;\\n\\nimpl Solution {\\n    pub fn merge_trees(n1: Option<Node>, n2: Option<Node>) -> Option<Node> {\\n        fn recursive(n1: &Option<Node>, n2: &Option<Node>) -> Option<Node> {\\n            match (n1, n2) {\\n                (Some(n1), Some(n2)) => {\\n                    let (n1, n2) = (n1.borrow(),n2.borrow());\\n                    let mut root = TreeNode::new(n1.val + n2.val);\\n                    root.left = recursive(&n1.left, &n2.left);\\n                    root.right = recursive(&n1.right, &n2.right);\\n                    Some(Rc::new(RefCell::new(root)))\\n                }\\n                (None, Some(n2)) => Some(n2.clone()),\\n                (Some(n1), None) => Some(n1.clone()),\\n                (None, None) => None,\\n            }\\n        }\\n        recursive(&n1, &n2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype Node = Rc<RefCell<TreeNode>>;\\n\\nimpl Solution {\\n    pub fn merge_trees(n1: Option<Node>, n2: Option<Node>) -> Option<Node> {\\n        fn recursive(n1: &Option<Node>, n2: &Option<Node>) -> Option<Node> {\\n            match (n1, n2) {\\n                (Some(n1), Some(n2)) => {\\n                    let (n1, n2) = (n1.borrow(),n2.borrow());\\n                    let mut root = TreeNode::new(n1.val + n2.val);\\n                    root.left = recursive(&n1.left, &n2.left);\\n                    root.right = recursive(&n1.right, &n2.right);\\n                    Some(Rc::new(RefCell::new(root)))\\n                }\\n                (None, Some(n2)) => Some(n2.clone()),\\n                (Some(n1), None) => Some(n1.clone()),\\n                (None, None) => None,\\n            }\\n        }\\n        recursive(&n1, &n2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026601,
                "title": "java-simple-100-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t2 == null) return t1;\\n        if (t1 == null) return t2;\\n        t1.val = t1.val + t2.val;\\n        \\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        \\n        return t1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t2 == null) return t1;\\n        if (t1 == null) return t2;\\n        t1.val = t1.val + t2.val;\\n        \\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        \\n        return t1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889178,
                "title": "cpp-easiest-solution",
                "content": "**Upvote if helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL && t2==NULL)\\n            return NULL;\\n        \\n        if(t1==NULL && t2!=NULL)\\n            return t2;\\n        if(t1!=NULL && t2==NULL)\\n            return t1;\\n        \\n        TreeNode* temp = new TreeNode(t1->val+t2->val);\\n        temp->left=mergeTrees(t1->left,t2->left);\\n        temp->right= mergeTrees(t1->right,t2->right);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL && t2==NULL)\\n            return NULL;\\n        \\n        if(t1==NULL && t2!=NULL)\\n            return t2;\\n        if(t1!=NULL && t2==NULL)\\n            return t1;\\n        \\n        TreeNode* temp = new TreeNode(t1->val+t2->val);\\n        temp->left=mergeTrees(t1->left,t2->left);\\n        temp->right= mergeTrees(t1->right,t2->right);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772434,
                "title": "easy-understandable-c-solution-beats-91-time",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL) return t2;\\n        if(t2==NULL) return t1;\\n        \\n        t1->left=mergeTrees(t1->left,t2->left);\\n        t1->right=mergeTrees(t1->right,t2->right);\\n        t1->val=t1->val+t2->val;\\n        return t1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if(t1==NULL) return t2;\\n        if(t2==NULL) return t1;\\n        \\n        t1->left=mergeTrees(t1->left,t2->left);\\n        t1->right=mergeTrees(t1->right,t2->right);\\n        t1->val=t1->val+t2->val;\\n        return t1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699367,
                "title": "javascript-2-lines-solution",
                "content": "```\\nvar mergeTrees = function(t1, t2) {\\n    if(!t1 || !t2) return t1 || t2\\n    return new TreeNode(t1.val + t2.val, mergeTrees(t1.left, t2.left), mergeTrees(t1.right, t2.right))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeTrees = function(t1, t2) {\\n    if(!t1 || !t2) return t1 || t2\\n    return new TreeNode(t1.val + t2.val, mergeTrees(t1.left, t2.left), mergeTrees(t1.right, t2.right))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350138,
                "title": "python-beats-nearly-100",
                "content": "```\\n def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not t1: return t2\\n        if not t2: return t1\\n        root = TreeNode(t1.val + t2.val)\\n        root.val = t1.val + t2.val\\n        root.left = self.mergeTrees(t1.left, t2.left)\\n        root.right = self.mergeTrees(t1.right,t2.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not t1: return t2\\n        if not t2: return t1\\n        root = TreeNode(t1.val + t2.val)\\n        root.val = t1.val + t2.val\\n        root.left = self.mergeTrees(t1.left, t2.left)\\n        root.right = self.mergeTrees(t1.right,t2.right)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 219465,
                "title": "rust-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn merge_trees(t1: Option<Rc<RefCell<TreeNode>>>, t2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if t1.is_none() {\\n            return t2;\\n        }\\n        if t2.is_none() {\\n            return t1;\\n        }\\n        let _t1 = t1.unwrap();\\n        let _t2 = t2.unwrap();\\n        let mut res;\\n        res = TreeNode::new(_t1.borrow().val + _t2.borrow().val);\\n        res.left = Self::merge_trees(_t1.borrow().left.clone(), _t2.borrow().left.clone());\\n        res.right = Self::merge_trees(_t1.borrow().right.clone(), _t2.borrow().right.clone());\\n        \\n        return Some(Rc::new(RefCell::new(res)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn merge_trees(t1: Option<Rc<RefCell<TreeNode>>>, t2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if t1.is_none() {\\n            return t2;\\n        }\\n        if t2.is_none() {\\n            return t1;\\n        }\\n        let _t1 = t1.unwrap();\\n        let _t2 = t2.unwrap();\\n        let mut res;\\n        res = TreeNode::new(_t1.borrow().val + _t2.borrow().val);\\n        res.left = Self::merge_trees(_t1.borrow().left.clone(), _t2.borrow().left.clone());\\n        res.right = Self::merge_trees(_t1.borrow().right.clone(), _t2.borrow().right.clone());\\n        \\n        return Some(Rc::new(RefCell::new(res)));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218908,
                "title": "python-solution-with-recursively-and-iteratively",
                "content": "The description said :\\n> You need to merge them into a new binary tree\\n\\nSo I think some solutions that modifies the input tree node in place are wrong.\\n\\nrecursively approach:\\n```python\\ndef mergeTrees(self, t1, t2):\\n    if not t1:\\n        return t2\\n    if not t2:\\n        return t1\\n    t = TreeNode(t1.val+t2.val)\\n    t.left = self.mergeTrees(t1.left, t2.left)\\n    t.right = self.mergeTrees(t1.right, t2.right)\\n    return t\\n```\\n\\niteratively approach:\\n\\n```python\\ndef mergeTrees(self, t1, t2):\\n    if not t1 and not t2:\\n        return []\\n    t = TreeNode(0)\\n    stack = [(t, t1, t2)]\\n    while stack:\\n        n, n1, n2 = stack.pop()\\n        if n1 or n2:\\n            n.val = (n1.val if n1 else 0) + (n2.val if n2 else 0)\\n            if (n1 and n1.right) or (n2 and n2.right):\\n                n.right = TreeNode(None)\\n                stack.append((n.right, n1.right if n1 else None, n2.right if n2 else None))\\n            if (n1 and n1.left) or (n2 and n2.left):\\n                n.left = TreeNode(None)\\n                stack.append((n.left, n1.left if n1 else None, n2.left if n2 else None))\\n    return t\\n```\\n\\ndidn\\'t change the input tree node. And the result won\\'t change when t1 or t2 changed.",
                "solutionTags": [],
                "code": "```python\\ndef mergeTrees(self, t1, t2):\\n    if not t1:\\n        return t2\\n    if not t2:\\n        return t1\\n    t = TreeNode(t1.val+t2.val)\\n    t.left = self.mergeTrees(t1.left, t2.left)\\n    t.right = self.mergeTrees(t1.right, t2.right)\\n    return t\\n```\n```python\\ndef mergeTrees(self, t1, t2):\\n    if not t1 and not t2:\\n        return []\\n    t = TreeNode(0)\\n    stack = [(t, t1, t2)]\\n    while stack:\\n        n, n1, n2 = stack.pop()\\n        if n1 or n2:\\n            n.val = (n1.val if n1 else 0) + (n2.val if n2 else 0)\\n            if (n1 and n1.right) or (n2 and n2.right):\\n                n.right = TreeNode(None)\\n                stack.append((n.right, n1.right if n1 else None, n2.right if n2 else None))\\n            if (n1 and n1.left) or (n2 and n2.left):\\n                n.left = TreeNode(None)\\n                stack.append((n.left, n1.left if n1 else None, n2.left if n2 else None))\\n    return t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 104441,
                "title": "5-line-python",
                "content": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 or t2:\\n            root = TreeNode((t1 and t1.val or 0) + (t2 and t2.val or 0))\\n            root.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)\\n            root.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 or t2:\\n            root = TreeNode((t1 and t1.val or 0) + (t2 and t2.val or 0))\\n            root.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)\\n            root.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410972,
                "title": "solution",
                "content": "```C++ []\\nclass Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1 && root2) { root1->val += root2->val; root1->left = mergeTrees(root1->left, root2->left); root1->right = mergeTrees(root1->right, root2->right); } else if(root2) { return root2; } return root1; } };\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def gh(root1,root2):\\n            if root1 is None and root2 is None:\\n                return \\n            if root1 is None:\\n                return root2\\n            if root2 is None:\\n                return root1\\n            s=TreeNode(root1.val+root2.val)\\n            s.left=gh(root1.left,root2.left)\\n            s.right=gh(root1.right,root2.right)\\n            return s\\n        return gh(root1,root2)\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1==null && root2==null) return null;\\n        if (root1==null) return root2;\\n        if (root2==null) return root1;\\n        root1.val = root1.val+root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1 && root2) { root1->val += root2->val; root1->left = mergeTrees(root1->left, root2->left); root1->right = mergeTrees(root1->right, root2->right); } else if(root2) { return root2; } return root1; } };\\n```\n```Python3 []\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def gh(root1,root2):\\n            if root1 is None and root2 is None:\\n                return \\n            if root1 is None:\\n                return root2\\n            if root2 is None:\\n                return root1\\n            s=TreeNode(root1.val+root2.val)\\n            s.left=gh(root1.left,root2.left)\\n            s.right=gh(root1.right,root2.right)\\n            return s\\n        return gh(root1,root2)\\n```\n```Java []\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if (root1==null && root2==null) return null;\\n        if (root1==null) return root2;\\n        if (root2==null) return root1;\\n        root1.val = root1.val+root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370340,
                "title": "easiest-solution-you-can-find-java-beats-100",
                "content": "Like it if you Like it\\n# Approach\\n1. Iterate through both trees via same path\\n2. if path ahead of any tree is empty then concate the path of other non empty tree\\n3. create a node containing the sum of nodes of each tree (in case both node of tree are non empty)\\n4. combine the returned nodes to form the tree\\n \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N+M)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null)\\n        return root2;\\n\\n        if(root2==null)\\n        return root1;\\n\\n        int val1 = root1.val;\\n        int val2 = root2.val;\\n\\n        TreeNode node= new TreeNode(val1+val2);\\n\\n        node.left = mergeTrees(root1.left,root2.left);\\n        node.right = mergeTrees(root1.right,root2.right);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null)\\n        return root2;\\n\\n        if(root2==null)\\n        return root1;\\n\\n        int val1 = root1.val;\\n        int val2 = root2.val;\\n\\n        TreeNode node= new TreeNode(val1+val2);\\n\\n        node.left = mergeTrees(root1.left,root2.left);\\n        node.right = mergeTrees(root1.right,root2.right);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308472,
                "title": "617-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. If \"root1\" is None, return \"root2\".\\n2. If \"root2\" is None, return \"root1\".\\n3. Merge the nodes that are overlapped by adding their values together and storing the sum in the \"val\" attribute of \"root1\".\\n4. Recursively merge the left subtree of \"root1\" and the left subtree of \"root2\" by calling the \"mergeTrees\" function with the left child nodes of \"root1\" and \"root2\".\\n5. Recursively merge the right subtree of \"root1\" and the right subtree of \"root2\" by calling the \"mergeTrees\" function with the right child nodes of \"root1\" and \"root2\".\\n6. Return \"root1\", which represents the merged tree.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        # merge the nodes that are overlapped\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        # merge the nodes that are overlapped\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213062,
                "title": "python-easy-recursive-code-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root1 is None and root2 is None:\\n            return None\\n        if root1 is None: return root2\\n        if root2 is None: return root1\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root1 is None and root2 is None:\\n            return None\\n        if root1 is None: return root2\\n        if root2 is None: return root1\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124342,
                "title": "c-recursive-solution-creating-new-tree",
                "content": "```\\nclass Solution {\\npublic:    \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1 && !root2) return NULL;\\n        auto ans= new TreeNode((root1?root1->val:0) + (root2?root2->val:0));\\n        ans->left= mergeTrees(root1?root1->left:NULL , root2?root2->left:NULL);\\n        ans->right= mergeTrees(root1?root1->right:NULL , root2?root2->right:NULL);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!root1 && !root2) return NULL;\\n        auto ans= new TreeNode((root1?root1->val:0) + (root2?root2->val:0));\\n        ans->left= mergeTrees(root1?root1->left:NULL , root2?root2->left:NULL);\\n        ans->right= mergeTrees(root1?root1->right:NULL , root2?root2->right:NULL);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764528,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        \\n        if(t1 == null) {\\n            return t2;\\n        }\\n        if(t2 == null) {\\n            return t1;\\n        }\\n        t1.val += t2.val;\\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        return t1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        \\n        if(t1 == null) {\\n            return t2;\\n        }\\n        if(t2 == null) {\\n            return t1;\\n        }\\n        t1.val += t2.val;\\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        return t1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668232,
                "title": "c-easy-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1==NULL)\\n            return root2;\\n        if(root2==NULL)\\n            return root1;\\n        TreeNode *temp=new TreeNode(root1->val+root2->val);\\n       \\n      if(root1->left !=NULL || root2->left!=NULL)\\n      {\\n          temp->left=mergeTrees(root1->left,root2->left);\\n      }\\n         if(root1->right !=NULL || root2->right!=NULL)\\n      {\\n          temp->right=mergeTrees(root1->right,root2->right);\\n      }\\n      return temp;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1==NULL)\\n            return root2;\\n        if(root2==NULL)\\n            return root1;\\n        TreeNode *temp=new TreeNode(root1->val+root2->val);\\n       \\n      if(root1->left !=NULL || root2->left!=NULL)\\n      {\\n          temp->left=mergeTrees(root1->left,root2->left);\\n      }\\n         if(root1->right !=NULL || root2->right!=NULL)\\n      {\\n          temp->right=mergeTrees(root1->right,root2->right);\\n      }\\n      return temp;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423934,
                "title": "python-c-java-beginner-level-solution-5-line-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q617.  Merge Two Binary Trees***\\n\\nYou are given two binary trees root1 and root2.\\n\\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n\\n```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null)return root2;\\n        if(root2==null)return root1;\\n        root1.val=root1.val+root2.val;\\n        root1.left=mergeTrees(root1.left,root2.left);\\n        root1.right=mergeTrees(root1.right,root2.right);\\n        \\n        return root1;\\n    }\\n}\\n```\\n**Runtime:**  1ms\\n**Memory Usage:**  50.5 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n\\n```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        elif not t2:\\n            return t1\\n        else:\\n            res = TreeNode(t1.val + t2.val)\\n            res.left = self.mergeTrees(t1.left, t2.left)\\n            res.right = self.mergeTrees(t1.right, t2.right)\\n        return res\\n```\\n**Runtime:**  147ms\\n**Memory Usage:**  15.4 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 && root2)\\n        {\\n            TreeNode* root=new TreeNode(root1->val+root2->val);\\n            root->left=mergeTrees(root1->left,root2->left);\\n            root->right=mergeTrees(root1->right,root2->right);\\n            return root;\\n        }\\n        else\\n            return root1?root1:root2;\\n    }\\n};\\n```\\n**Runtime:**  64ms\\n**Memory Usage:**  34.7MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null)return root2;\\n        if(root2==null)return root1;\\n        root1.val=root1.val+root2.val;\\n        root1.left=mergeTrees(root1.left,root2.left);\\n        root1.right=mergeTrees(root1.right,root2.right);\\n        \\n        return root1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        elif not t2:\\n            return t1\\n        else:\\n            res = TreeNode(t1.val + t2.val)\\n            res.left = self.mergeTrees(t1.left, t2.left)\\n            res.right = self.mergeTrees(t1.right, t2.right)\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 && root2)\\n        {\\n            TreeNode* root=new TreeNode(root1->val+root2->val);\\n            root->left=mergeTrees(root1->left,root2->left);\\n            root->right=mergeTrees(root1->right,root2->right);\\n            return root;\\n        }\\n        else\\n            return root1?root1:root2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237709,
                "title": "java-simple-bfs-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null && root2 == null)\\n            return null;\\n        if(root1 == null || root2 == null)\\n            return root1 == null ? root2 : root1;\\n        \\n        LinkedList<TreeNode[]> que = new LinkedList<>();\\n//         {root1, root2}\\n        que.addLast(new TreeNode[]{root1, root2});\\n        while(que.size() != 0){\\n            int size = que.size();\\n            while(size-- != 0){\\n                TreeNode[] rm = que.removeFirst();\\n                TreeNode r1 = rm[0], r2 = rm[1];\\n\\t\\t\\t\\t\\n                if(r1 != null && r2 != null)\\n                    r1.val += r2.val;\\n\\t\\t\\t\\t\\t\\n                if(r1.left == null && r2.left != null)\\n                    r1.left = r2.left;\\n                else if(r1.left != null && r2.left != null){\\n                    que.addLast(new TreeNode[]{r1.left, r2.left});\\n                }\\n\\t\\t\\t\\t\\n                if(r1.right == null && r2.right != null)\\n                    r1.right = r2.right;\\n                else if(r1.right != null && r2.right != null)\\n                    que.addLast(new TreeNode[]{r1.right, r2.right});\\n            }\\n        }\\n        return root1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null && root2 == null)\\n            return null;\\n        if(root1 == null || root2 == null)\\n            return root1 == null ? root2 : root1;\\n        \\n        LinkedList<TreeNode[]> que = new LinkedList<>();\\n//         {root1, root2}",
                "codeTag": "Java"
            },
            {
                "id": 2089170,
                "title": "python3-using-dfs",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def dfs(root1,root2):\\n            if(root1 == None and root2 == None):\\n                return None\\n            if(root1 != None and root2 == None):\\n                return root1\\n            if(root1 == None and root2 != None):\\n                return root2\\n            \\n            root1.val = root1.val + root2.val\\n            \\n            left = dfs(root1.left, root2.left)\\n                \\n            right = dfs(root1.right, root2.right)\\n                \\n            root1.left = left\\n            root1.right = right\\n            return root1\\n        \\n        return dfs(root1,root2)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def dfs(root1,root2):\\n            if(root1 == None and root2 == None):\\n                return None\\n            if(root1 != None and root2 == None):\\n                return root1\\n            if(root1 == None and root2 != None):\\n                return root2\\n            \\n            root1.val = root1.val + root2.val\\n            \\n            left = dfs(root1.left, root2.left)\\n                \\n            right = dfs(root1.right, root2.right)\\n                \\n            root1.left = left\\n            root1.right = right\\n            return root1\\n        \\n        return dfs(root1,root2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934579,
                "title": "javascript-dfs-two-solutions",
                "content": "## Solution 1 (create new tree)\\n\\nIn this solution we create a new tree with the merged values as this is what the questions asks for.\\n\\n> You need to merge the two trees into a new binary tree\\n\\nThe `mergeTrees` function is used recursively to set the left and right values of the tree. If `root1` and `root2` are `null` then `null` is returned. Otherwise a new `TreeNode` is created with the combined values of the two nodes.\\n\\n```\\nvar mergeTrees = function(root1, root2) {\\n  if (!root1 && !root2) {\\n    return null;\\n  }\\n\\n  let val = 0;\\n  val += root1 ? root1.val : 0;\\n  val += root2 ? root2.val : 0;\\n\\n  let root = new TreeNode(val);\\n  root.left = mergeTrees(root1 ? root1.left : null, root2 ? root2.left : null);\\n  root.right = mergeTrees(root1 ? root1.right : null, root2 ? root2.right : null);\\n\\n  return root;\\n};\\n```\\n\\n## Solution 2 (in-place)\\n\\nWe can achieve the same result in-place (although not mentioned in the question).\\n\\n```\\nvar mergeTrees = function(root1, root2) {\\n  if (!root1 && !root2) {\\n    return null;\\n  }\\n  if (!root1) {\\n    return root2;\\n  }\\n  if (!root2) {\\n    return root1;\\n  }\\n\\n  root1.val += root2.val;\\n  root1.left = mergeTrees(root1.left, root2.left);\\n  root1.right = mergeTrees(root1.right, root2.right);\\n\\n  return root1;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar mergeTrees = function(root1, root2) {\\n  if (!root1 && !root2) {\\n    return null;\\n  }\\n\\n  let val = 0;\\n  val += root1 ? root1.val : 0;\\n  val += root2 ? root2.val : 0;\\n\\n  let root = new TreeNode(val);\\n  root.left = mergeTrees(root1 ? root1.left : null, root2 ? root2.left : null);\\n  root.right = mergeTrees(root1 ? root1.right : null, root2 ? root2.right : null);\\n\\n  return root;\\n};\\n```\n```\\nvar mergeTrees = function(root1, root2) {\\n  if (!root1 && !root2) {\\n    return null;\\n  }\\n  if (!root1) {\\n    return root2;\\n  }\\n  if (!root2) {\\n    return root1;\\n  }\\n\\n  root1.val += root2.val;\\n  root1.left = mergeTrees(root1.left, root2.left);\\n  root1.right = mergeTrees(root1.right, root2.right);\\n\\n  return root1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735514,
                "title": "c-easy-recursive-dfs-merge-two-binary-trees",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n\\t\\n        if(!root1 && !root2) {\\n            return root1;\\n        } else if(!root1) {\\n            return root2;\\n        } else if(!root2) {\\n            return root1;\\n        }\\n        \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n\\t\\n        if(!root1 && !root2) {\\n            return root1;\\n        } else if(!root1) {\\n            return root2;\\n        } else if(!root2) {\\n            return root1;\\n        }\\n        \\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734790,
                "title": "javascript-bfs-iterative",
                "content": "```\\nconst mergeTrees = function(root1, root2) {\\n    if (!root1) return root2\\n    if (!root2) return root1\\n    \\n    const res = root1\\n    \\n    const queue = []\\n    queue.push({v1:res, v2:root2}) \\n    \\n    while (queue.length) {\\n        const {v1, v2} = queue.shift()\\n        v1.val += v2.val\\n        \\n        if (v1.left && v2.left) queue.push({v1:v1.left, v2:v2.left})\\n        if (!v1.left && v2.left) v1.left = v2.left\\n        \\n        if (v1.right && v2.right) queue.push({v1:v1.right, v2:v2.right})\\n        if (!v1.right && v2.right) v1.right = v2.right  \\n        \\n    }\\n    \\n    return res\\n     \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nconst mergeTrees = function(root1, root2) {\\n    if (!root1) return root2\\n    if (!root2) return root1\\n    \\n    const res = root1\\n    \\n    const queue = []\\n    queue.push({v1:res, v2:root2}) \\n    \\n    while (queue.length) {\\n        const {v1, v2} = queue.shift()\\n        v1.val += v2.val\\n        \\n        if (v1.left && v2.left) queue.push({v1:v1.left, v2:v2.left})\\n        if (!v1.left && v2.left) v1.left = v2.left\\n        \\n        if (v1.right && v2.right) queue.push({v1:v1.right, v2:v2.right})\\n        if (!v1.right && v2.right) v1.right = v2.right  \\n        \\n    }\\n    \\n    return res\\n     \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610451,
                "title": "concise-python-using-recursion-90",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def merge(a, b):\\n            if a is None: return b\\n            if b is None: return a\\n            \\n            return TreeNode(a.val + b.val, merge(a.left, b.left), merge(a.right, b.right))\\n        \\n        return merge(root1, root2)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def merge(a, b):\\n            if a is None: return b\\n            if b is None: return a\\n            \\n            return TreeNode(a.val + b.val, merge(a.left, b.left), merge(a.right, b.right))\\n        \\n        return merge(root1, root2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607150,
                "title": "python-using-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1:\\n            return root2\\n        \\n        if not root2:\\n            return root1\\n        \\n        stack = [(root1, root2)]\\n        \\n        root1.val += root2.val\\n        while stack:\\n            l, r  = stack.pop()\\n            if l.left and r.left:\\n                l.left.val += r.left.val\\n                stack.append((l.left,r.left))\\n            elif not l.left and  r.left:\\n                l.left = r.left\\n                        \\n            if l.right and r.right:\\n                l.right.val += r.right.val\\n                stack.append((l.right,r.right))\\n            elif not l.right and  r.right:\\n                l.right = r.right\\n                \\n        return root1\\n                \\n\\n        ```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1:\\n            return root2\\n        \\n        if not root2:\\n            return root1\\n        \\n        stack = [(root1, root2)]\\n        \\n        root1.val += root2.val\\n        while stack:\\n            l, r  = stack.pop()\\n            if l.left and r.left:\\n                l.left.val += r.left.val\\n                stack.append((l.left,r.left))\\n            elif not l.left and  r.left:\\n                l.left = r.left\\n                        \\n            if l.right and r.right:\\n                l.right.val += r.right.val\\n                stack.append((l.right,r.right))\\n            elif not l.right and  r.right:\\n                l.right = r.right\\n                \\n        return root1\\n                \\n\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1212982,
                "title": "simple-c-solution-with-comment-28-ms-faster-than-93-85-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        // Return root2, if root1 is null\\n        if (root1 == nullptr){\\n            return root2;\\n        }\\n        // Return root1, if root2 is null\\n        if (root2 == nullptr){\\n            return root1;\\n        }\\n        // Now since, we know that neither root1 is null nor root2 is null, now you can add the values of root1 and root 2 and store in root1\\n        root1->val +=  root2->val;\\n        // Starting to build left subtree from bottom\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        // Starting to build right subtree from bottom\\n        root1->right = mergeTrees(root1-> right, root2->right);\\n        // Returned to update\\n        return root1;\\n    }\\n};\\n```\\n\\n**Please upvote this solution if this helps you understand better**\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        // Return root2, if root1 is null\\n        if (root1 == nullptr){\\n            return root2;\\n        }\\n        // Return root1, if root2 is null\\n        if (root2 == nullptr){\\n            return root1;\\n        }\\n        // Now since, we know that neither root1 is null nor root2 is null, now you can add the values of root1 and root 2 and store in root1\\n        root1->val +=  root2->val;\\n        // Starting to build left subtree from bottom\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        // Starting to build right subtree from bottom\\n        root1->right = mergeTrees(root1-> right, root2->right);\\n        // Returned to update\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204063,
                "title": "c-easy-and-short-recursion",
                "content": "```\\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(!root1)\\n            return root2;\\n        if(!root2)\\n            return root1;\\n        root1 -> val += root2 -> val;\\n        root1 -> left = mergeTrees(root1 -> left, root2 -> left);\\n        root1 -> right = mergeTrees(root1 -> right, root2 -> right);\\n        \\n        return root1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(!root1)\\n            return root2;\\n        if(!root2)\\n            return root1;\\n        root1 -> val += root2 -> val;\\n        root1 -> left = mergeTrees(root1 -> left, root2 -> left);\\n        root1 -> right = mergeTrees(root1 -> right, root2 -> right);\\n        \\n        return root1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979765,
                "title": "c-preorder-traversal-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode t1, TreeNode t2) {\\n\\n        if(t1 != null && t2 != null){\\n            t1.val += t2.val;\\n\\n            t1.left = MergeTrees(t1.left, t2.left);\\n            t1.right = MergeTrees(t1.right, t2.right);\\n\\n            return t1;\\n        }\\n        return t1 ?? t2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode t1, TreeNode t2) {\\n\\n        if(t1 != null && t2 != null){\\n            t1.val += t2.val;\\n\\n            t1.left = MergeTrees(t1.left, t2.left);\\n            t1.right = MergeTrees(t1.right, t2.right);\\n\\n            return t1;\\n        }\\n        return t1 ?? t2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474242,
                "title": "python-o-n-sol-by-dfs-tree-building-with-explanation",
                "content": "Python O( n ) sol. based on DFS tree-building\\n\\n```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        \\n        root_node = None\\n        \\n        if not t1:\\n\\t\\t\\t# t1 is empty, new tree is decided by t2\\n            return t2\\n        \\n        elif not t2:\\n\\t\\t\\t# t2 is empty, new tree is decided by t1\\n            return t1\\n        \\n        else:\\n            # both t1 and t2 exist, merge current node, and traverse on DFS again\\n            root_node =  TreeNode( t1.val + t2.val )\\n            root_node.left = self.mergeTrees( t1.left, t2.left )\\n            root_node.right = self.mergeTrees( t1.right, t2.right )\\n            \\n            return root_node\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        \\n        root_node = None\\n        \\n        if not t1:\\n\\t\\t\\t# t1 is empty, new tree is decided by t2\\n            return t2\\n        \\n        elif not t2:\\n\\t\\t\\t# t2 is empty, new tree is decided by t1\\n            return t1\\n        \\n        else:\\n            # both t1 and t2 exist, merge current node, and traverse on DFS again\\n            root_node =  TreeNode( t1.val + t2.val )\\n            root_node.left = self.mergeTrees( t1.left, t2.left )\\n            root_node.right = self.mergeTrees( t1.right, t2.right )\\n            \\n            return root_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464379,
                "title": "java-recursive-solution-straightforward",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        TreeNode root = new TreeNode(t1.val + t2.val);\\n        root.left = mergeTrees(t1.left, t2.left);\\n        root.right = mergeTrees(t1.right, t2.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        TreeNode root = new TreeNode(t1.val + t2.val);\\n        root.left = mergeTrees(t1.left, t2.left);\\n        root.right = mergeTrees(t1.right, t2.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416799,
                "title": "two-recursive-solutions-in-6-lines-explained",
                "content": "#### 1. Non-destructive\\nThis is the straight-forward recursive solution, where we build the merged tree from scratch.\\n```python\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 or t2:\\n            v1, l1, r1 = (t1.val, t1.left, t1.right) if t1 else (0, None, None)\\n            v2, l2, r2 = (t2.val, t2.left, t2.right) if t2 else (0, None, None)\\n            merged = TreeNode(v1 + v2)\\n            merged.left, merged.right = self.mergeTrees(l1, l2), self.mergeTrees(r1, r2)\\n            return merged\\n```\\n---\\n#### 2. Destructive but fast (beats 99.87% in one of the best runtimes)\\nBy reusing the existing nodes of `t1` and `t2`, we create fewer new nodes and therefore spend less time, but `t1` may be destroyed.\\n```python\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 and t2:\\n            t1.val += t2.val\\n            t1.left, t1.right = self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)\\n        elif t2:\\n            return t2\\n        return t1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 or t2:\\n            v1, l1, r1 = (t1.val, t1.left, t1.right) if t1 else (0, None, None)\\n            v2, l2, r2 = (t2.val, t2.left, t2.right) if t2 else (0, None, None)\\n            merged = TreeNode(v1 + v2)\\n            merged.left, merged.right = self.mergeTrees(l1, l2), self.mergeTrees(r1, r2)\\n            return merged\\n```\n```python\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if t1 and t2:\\n            t1.val += t2.val\\n            t1.left, t1.right = self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)\\n        elif t2:\\n            return t2\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365266,
                "title": "clean-python-recursive-iterative-preorder-traversal",
                "content": "Recursive is pretty straight-forward:\\n```py\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2:\\n            return t1 or t2\\n\\n        t2.val += t1.val\\n        t2.left = self.mergeTrees(t1.left, t2.left)\\n        t2.right = self.mergeTrees(t1.right, t2.right)\\n        return t2\\n```\\nIterative:\\n```py\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2:\\n            return t1 or t2\\n\\n        stack = [(t1, t2)]\\n        head = t2\\n\\n        while stack:\\n            t1, t2 = stack.pop()\\n            t2.val += t1.val\\n\\n            # process the left child\\n            if t1.left and t2.left:\\n                stack.append((t1.left, t2.left))\\n            elif t1.left:\\n                t2.left = t1.left\\n\\n            # process the right child\\n            if t1.right and t2.right:\\n                stack.append((t1.right, t2.right))\\n            elif t1.right:\\n                t2.right = t1.right\\n\\n        return head\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2:\\n            return t1 or t2\\n\\n        t2.val += t1.val\\n        t2.left = self.mergeTrees(t1.left, t2.left)\\n        t2.right = self.mergeTrees(t1.right, t2.right)\\n        return t2\\n```\n```py\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1 or not t2:\\n            return t1 or t2\\n\\n        stack = [(t1, t2)]\\n        head = t2\\n\\n        while stack:\\n            t1, t2 = stack.pop()\\n            t2.val += t1.val\\n\\n            # process the left child\\n            if t1.left and t2.left:\\n                stack.append((t1.left, t2.left))\\n            elif t1.left:\\n                t2.left = t1.left\\n\\n            # process the right child\\n            if t1.right and t2.right:\\n                stack.append((t1.right, t2.right))\\n            elif t1.right:\\n                t2.right = t1.right\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211442,
                "title": "kotlin",
                "content": "```\\n/**\\n * https://leetcode.com/problems/merge-two-binary-trees/\\n *\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int = 0) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n  fun mergeTrees(t1: TreeNode?, t2: TreeNode?): TreeNode? {\\n    if (t1 == null) return t2\\n    if (t2 == null) return t1\\n    return t1.apply {\\n      `val` += t2.`val`\\n      left = mergeTrees(left, t2.left)\\n      right = mergeTrees(right, t2.right)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * https://leetcode.com/problems/merge-two-binary-trees/\\n *\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int = 0) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n  fun mergeTrees(t1: TreeNode?, t2: TreeNode?): TreeNode? {\\n    if (t1 == null) return t2\\n    if (t2 == null) return t1\\n    return t1.apply {\\n      `val` += t2.`val`\\n      left = mergeTrees(left, t2.left)\\n      right = mergeTrees(right, t2.right)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163117,
                "title": "python-simple-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 == None:\\n            return t2\\n        if t2 == None:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 == None:\\n            return t2\\n        if t2 == None:\\n            return t1\\n        t1.val += t2.val\\n        t1.left = self.mergeTrees(t1.left, t2.left)\\n        t1.right = self.mergeTrees(t1.right, t2.right)\\n        return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104355,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Merge Two Binary Trees** https://leetcode.com/problems/merge-two-binary-trees/description/\\n\\n**Simple Recursive Solution**\\n* If t1 and t2 are not None, then create a new merged tree with root as t1.val+t2.val and merge the left and right sub-trees to create the left and right sub-tree for the root.\\n* If either t1 or t2 are None, then simply return the non-None subtree for the merge.\\n* Time complexity is O(min(n,m)) and Space complexity should be O(min(h1, h2)). This part requires careful thought !.\\n\\n```\\nclass Solution:\\n    def helper(self, t1, t2):\\n        if t1 is None or t2 is None:\\n            return t1 or t2\\n        else:\\n            x = TreeNode(t1.val+t2.val)\\n            x.left = self.helper(t1.left, t2.left)\\n            x.right = self.helper(t1.right, t2.right)\\n            return x\\n    \\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        return self.helper(t1, t2)\\n```\\n\\n**Iterative solution to merge**\\n* The key to write an iterative solution is to consider constructing the merged tree into t1 directly.\\n* Use a stack and push t1,t2 into the stack. Now iterate until stack is not empty.\\n* Pop the stack and add the value of t2 into t1. Now test if t1.left is None or t2.left is None. If either is None, attach the non None subtree to t1.left. If both are not None, push t1.left, t2.left on the stack. Repeat for t1.right and t2.right.\\n* Time complexity is O(min(n,m)) and Space Complexity is O(min(h1,h2)).\\n```\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None or t2 is None:\\n            return t1 or t2\\n        else:\\n            root = t1\\n            st = [(t1,t2)]\\n            while st:\\n                t1, t2 = st.pop()\\n                t1.val += t2.val\\n                if t1.left is None or t2.left is None:\\n                    t1.left = t1.left or t2.left\\n                else:\\n                    st.append((t1.left, t2.left))\\n                if t1.right is None or t2.right is None:\\n                    t1.right = t1.right or t2.right\\n                else:\\n                    st.append((t1.right, t2.right))\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def helper(self, t1, t2):\\n        if t1 is None or t2 is None:\\n            return t1 or t2\\n        else:\\n            x = TreeNode(t1.val+t2.val)\\n            x.left = self.helper(t1.left, t2.left)\\n            x.right = self.helper(t1.right, t2.right)\\n            return x\\n    \\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        return self.helper(t1, t2)\\n```\n```\\nclass Solution:\\n    def mergeTrees(self, t1, t2):\\n        \"\"\"\\n        :type t1: TreeNode\\n        :type t2: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if t1 is None or t2 is None:\\n            return t1 or t2\\n        else:\\n            root = t1\\n            st = [(t1,t2)]\\n            while st:\\n                t1, t2 = st.pop()\\n                t1.val += t2.val\\n                if t1.left is None or t2.left is None:\\n                    t1.left = t1.left or t2.left\\n                else:\\n                    st.append((t1.left, t2.left))\\n                if t1.right is None or t2.right is None:\\n                    t1.right = t1.right or t2.right\\n                else:\\n                    st.append((t1.right, t2.right))\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104407,
                "title": "runtime-beat-100-6-lines-java-recursive-solution",
                "content": "\\n\\tpublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n\\t\\tif (t1 == null) return t2;\\n\\t\\tif (t2 == null) return t1;\\n\\n\\t\\tTreeNode temp = new TreeNode(t1.val + t2.val);\\n\\t\\ttemp.left = mergeTrees(t1.left, t2.left);\\n\\t\\ttemp.right = mergeTrees(t1.right, t2.right);\\n\\n\\t\\treturn temp;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\tpublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n\\t\\tif (t1 == null) return t2;\\n\\t\\tif (t2 == null) return t1;\\n\\n\\t\\tTreeNode temp = new TreeNode(t1.val + t2.val);\\n\\t\\ttemp.left = mergeTrees(t1.left, t2.left);\\n\\t\\ttemp.right = mergeTrees(t1.right, t2.right);\\n\\n\\t\\treturn temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3788509,
                "title": "4-liner-c-inplace-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are merging root 2 into our root 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(logn)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == nullptr || root2 == nullptr) return root1?root1:root2;\\n        root1 -> val += root2 -> val;\\n        root1 -> left = mergeTrees(root1 -> left , root2 ->left);\\n        root1 -> right = mergeTrees(root1 -> right , root2 -> right);\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == nullptr || root2 == nullptr) return root1?root1:root2;\\n        root1 -> val += root2 -> val;\\n        root1 -> left = mergeTrees(root1 -> left , root2 ->left);\\n        root1 -> right = mergeTrees(root1 -> right , root2 -> right);\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280925,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL and root2 == NULL) return NULL;\\n        if(!root2) return root1;\\n        if(!root1) return root2;\\n        root1->val = root1->val + root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL and root2 == NULL) return NULL;\\n        if(!root2) return root1;\\n        if(!root1) return root2;\\n        root1->val = root1->val + root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253566,
                "title": "very-easy-solution-python-uwu",
                "content": "\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n\\n        return root1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n\\n        root1.val += root2.val\\n        root1.left = self.mergeTrees(root1.left, root2.left)\\n        root1.right = self.mergeTrees(root1.right, root2.right)\\n\\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169102,
                "title": "js-solution-recursion",
                "content": "# Intuition\\nCreate a new node with the sum of the values. Recursively call the main function with the left and right children, passing the result of each call as the left and right children of the new node.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of nodes of the larger tree\\n\\n- Space complexity:\\nO(h) where h is the height of the taller tree\\n\\n# Code\\n```\\nconst mergeTrees = (root1, root2) => {\\n    // base case: if one is null then return the other.\\n    if (!root1 || !root2) return root1 || root2\\n\\n    let node = new TreeNode(root1.val + root2.val)\\n    \\n    node.left = mergeTrees(root1.left, root2.left)\\n    node.right = mergeTrees(root1.right, root2.right)\\n\\n    return node\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mergeTrees = (root1, root2) => {\\n    // base case: if one is null then return the other.\\n    if (!root1 || !root2) return root1 || root2\\n\\n    let node = new TreeNode(root1.val + root2.val)\\n    \\n    node.left = mergeTrees(root1.left, root2.left)\\n    node.right = mergeTrees(root1.right, root2.right)\\n\\n    return node\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068880,
                "title": "merge-two-b3-best-python-o-n-time-memory-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root1, root2)]\\n        \\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        \\n        root1.val += root2.val\\n\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            \\n            if node2:\\n                if node2.right:\\n                    if not node1.right:\\n                        node1.right = node2.right\\n                    else:\\n                        node1.right.val += node2.right.val\\n                        queue.append((node1.right, node2.right))\\n                if node2.left:\\n                    if not node1.left:\\n                        node1.left = node2.left\\n                    else:\\n                        node1.left.val += node2.left.val\\n                        queue.append((node1.left, node2.left))\\n        return root1                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root1, root2)]\\n        \\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        \\n        root1.val += root2.val\\n\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            \\n            if node2:\\n                if node2.right:\\n                    if not node1.right:\\n                        node1.right = node2.right\\n                    else:\\n                        node1.right.val += node2.right.val\\n                        queue.append((node1.right, node2.right))\\n                if node2.left:\\n                    if not node1.left:\\n                        node1.left = node2.left\\n                    else:\\n                        node1.left.val += node2.left.val\\n                        queue.append((node1.left, node2.left))\\n        return root1                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060973,
                "title": "c-simple-readable-solution-time-o-n-space-o-1",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode root1, TreeNode root2)\\n    {\\n        if (root1 == null & root2 == null) return null;\\n        if (root1 == null) return root2;\\n        if (root2 == null) return root1;\\n\\n        var left = MergeTrees(root1.left, root2.left);\\n        var right = MergeTrees(root1.right, root2.right);\\n\\n        if (root1.left != left) root1.left = left;\\n        if (root1.right != right) root1.right = right;\\n\\n        root1.val += root2.val;\\n\\n        return root1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode root1, TreeNode root2)\\n    {\\n        if (root1 == null & root2 == null) return null;\\n        if (root1 == null) return root2;\\n        if (root2 == null) return root1;\\n\\n        var left = MergeTrees(root1.left, root2.left);\\n        var right = MergeTrees(root1.right, root2.right);\\n\\n        if (root1.left != left) root1.left = left;\\n        if (root1.right != right) root1.right = right;\\n\\n        root1.val += root2.val;\\n\\n        return root1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859743,
                "title": "easy-c-recursive-solution-with-explanation-for-begginers",
                "content": "\\n# Approach\\nFirst you need to check if both nodes is nulls, if they are - you can\\'t merge them (this branch is over for both trees) so you have to return null (this\\'ll stop recursion).\\n\\nIf any of nodes (left or right) is not empty - create new node and calculate sum (replace null node with 0), don\\'t forget to use brackets (root1?.val ?? 0) + (root2?.val ?? 0).\\n\\nThen need to calculate child nodes, method calls himself for left pair and right pair of nodes (some of them can be null - it\\'s okay, programm\\'ll go deepper just for one of branches). \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null && root2 == null){\\n            return null;\\n        }\\n        TreeNode result = new TreeNode((root1?.val ?? 0) + (root2?.val ?? 0));\\n        result.left = MergeTrees(root1?.left, root2?.left);\\n        result.right = MergeTrees(root1?.right, root2?.right);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode MergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null && root2 == null){\\n            return null;\\n        }\\n        TreeNode result = new TreeNode((root1?.val ?? 0) + (root2?.val ?? 0));\\n        result.left = MergeTrees(root1?.left, root2?.left);\\n        result.right = MergeTrees(root1?.right, root2?.right);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634265,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-h-h-is-tree-height",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        // if both are null, return null\\n        if(root1 == null && root2 == null) return null;\\n        \\n        // if root1 is null, then return root2\\n        if(root1 == null) return root2;\\n        \\n        // if root2 is null then return root1\\n        if(root2 == null) return root1;\\n        \\n        // if both are present, then create a new node with both value\\n        TreeNode root = new TreeNode(root1.val + root2.val);\\n        \\n        // call for left side, whatever gets add it to the left side of the root\\n        root.left = mergeTrees(root1.left, root2.left);\\n        \\n        // call for right side, whatever gets add it to the right side of the root\\n        root.right = mergeTrees(root1.right, root2.right);\\n        \\n        // return root\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        // if both are null, return null\\n        if(root1 == null && root2 == null) return null;\\n        \\n        // if root1 is null, then return root2\\n        if(root1 == null) return root2;\\n        \\n        // if root2 is null then return root1\\n        if(root2 == null) return root1;\\n        \\n        // if both are present, then create a new node with both value\\n        TreeNode root = new TreeNode(root1.val + root2.val);\\n        \\n        // call for left side, whatever gets add it to the left side of the root\\n        root.left = mergeTrees(root1.left, root2.left);\\n        \\n        // call for right side, whatever gets add it to the right side of the root\\n        root.right = mergeTrees(root1.right, root2.right);\\n        \\n        // return root\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230922,
                "title": "java-solution-steps-tc-and-sc-explained-code-is-kept-simple",
                "content": "```\\nclass Solution {\\n\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n\\t\\n        //we merge trees in first tree(root1)\\n        \\n        //whenever we find a null we return and connect the  other root\\n        if(root1 == null) {\\n            return root2;\\n        }\\n        \\n        if(root2 == null) {\\n            return root1;\\n        }\\n        \\n        //if both are not null then we add the values to first tree\\n        root1.val += root2.val;\\n        \\n        //recursive call to traverse the whole tree\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        \\n        return root1;\\n    }\\n}\\n\\n//Time Complexity: O(m) m is the minimum number of nodes in the smallest tree of two\\n//Space Complexity: O(m) depth of recursion tree can go upto m in case of skewed tree and in average case it will be O(logm)\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n\\t\\n        //we merge trees in first tree(root1)\\n        \\n        //whenever we find a null we return and connect the  other root\\n        if(root1 == null) {\\n            return root2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2225480,
                "title": "javascript-simple-solution",
                "content": "```\\nvar mergeTrees = function(root1, root2) {\\n    if (root1 === null) return root2;\\n    if (root2 === null) return root1;\\n    root1.val += root2.val;\\n    \\n    root1.left = mergeTrees(root1.left, root2.left);\\n    root1.right = mergeTrees(root1.right, root2.right);\\n    return root1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeTrees = function(root1, root2) {\\n    if (root1 === null) return root2;\\n    if (root2 === null) return root1;\\n    root1.val += root2.val;\\n    \\n    root1.left = mergeTrees(root1.left, root2.left);\\n    root1.right = mergeTrees(root1.right, root2.right);\\n    return root1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884388,
                "title": "c-recursive-solution-69-o-n",
                "content": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883652,
                "title": "rust-4ms-2-4-mb",
                "content": "Runtime: 4 ms, faster than 97.83% of Rust online submissions for Merge Two Binary Trees.\\nMemory Usage: 2.4 MB, less than 28.26% of Rust online submissions for Merge Two Binary Trees.\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\ntype Node = Option<Rc<RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn merge_trees(root1: Node, root2: Node) -> Node {\\n        \\n        match (root1, root2) {\\n            (Some(n1), Some(n2)) =>  {\\n                let (n1, n2) = (n1.borrow(), n2.borrow());\\n                let mut root = TreeNode::new(n1.val + n2.val);\\n                root.left =  Self::merge_trees(n1.left.clone(), n2.left.clone());\\n                root.right = Self::merge_trees(n1.right.clone(), n2.right.clone());\\n                Some(Rc::new(RefCell::new(root)))\\n            }\\n            (None, Some(n)) | (Some(n), None) => return Some(n),\\n            (None, None) => return None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\ntype Node = Option<Rc<RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn merge_trees(root1: Node, root2: Node) -> Node {\\n        \\n        match (root1, root2) {\\n            (Some(n1), Some(n2)) =>  {\\n                let (n1, n2) = (n1.borrow(), n2.borrow());\\n                let mut root = TreeNode::new(n1.val + n2.val);\\n                root.left =  Self::merge_trees(n1.left.clone(), n2.left.clone());\\n                root.right = Self::merge_trees(n1.right.clone(), n2.right.clone());\\n                Some(Rc::new(RefCell::new(root)))\\n            }\\n            (None, Some(n)) | (Some(n), None) => return Some(n),\\n            (None, None) => return None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845508,
                "title": "python-short-faster-than-99-76-ms",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1 or not root2: return root1 or root2\\n        root = TreeNode(root1.val + root2.val)\\n        root.left = self.mergeTrees(root1.left, root2.left)\\n        root.right = self.mergeTrees(root1.right, root2.right)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root1 or not root2: return root1 or root2\\n        root = TreeNode(root1.val + root2.val)\\n        root.left = self.mergeTrees(root1.left, root2.left)\\n        root.right = self.mergeTrees(root1.right, root2.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832557,
                "title": "c-easy-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n     TreeNode* helper(TreeNode* root1, TreeNode* root2) {\\n             if(!root1 && !root2) return NULL;\\n             if(root1 && !root2) return root1;\\n             if(!root1 && root2) return root2;\\n             TreeNode* result= new TreeNode(root1->val+root2->val);\\n             result->left=helper(root1->left, root2->left);\\n             result->right=helper(root1->right,root2->right);            \\n             return result;             \\n         }   \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {      \\n        return helper(root1,root2);      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     TreeNode* helper(TreeNode* root1, TreeNode* root2) {\\n             if(!root1 && !root2) return NULL;\\n             if(root1 && !root2) return root1;\\n             if(!root1 && root2) return root2;\\n             TreeNode* result= new TreeNode(root1->val+root2->val);\\n             result->left=helper(root1->left, root2->left);\\n             result->right=helper(root1->right,root2->right);            \\n             return result;             \\n         }   \\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {      \\n        return helper(root1,root2);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810192,
                "title": "java-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null) return root2;\\n        if(root2 == null) return root1;\\n        \\n        root2.val += root1.val;\\n        root2.left = mergeTrees(root1.left, root2.left);\\n        root2.right = mergeTrees(root1.right, root2.right);\\n\\n        return root2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1 == null) return root2;\\n        if(root2 == null) return root1;\\n        \\n        root2.val += root1.val;\\n        root2.left = mergeTrees(root1.left, root2.left);\\n        root2.right = mergeTrees(root1.right, root2.right);\\n\\n        return root2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795013,
                "title": "bfs-solution-o-n-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL) return root2;\\n        if(root2 == NULL) return root1;\\n        if(root1==NULL && root2 ==NULL) return NULL;\\n        \\n        queue<pair<TreeNode*,TreeNode*>>q;\\n        q.push({root1,root2});\\n        \\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            \\n            /* if the right subtree is not null or the root of the right sub-tree (either left or right isnt null)\\n               then we will process further */ \\n            \\n            if(temp.second!=NULL){\\n                temp.first->val += temp.second->val;\\n            \\n            \\n            /* if the left node of the first subtree is null we can just point the left node of second tree to the\\n               left node of the first subtree */ \\n            \\n            if(temp.first->left == NULL){\\n                temp.first->left = temp.second->left;\\n            }\\n            else{\\n                q.push({temp.first->left,temp.second->left});\\n            }\\n            \\n             /* if the right node of the first subtree is null we can just point the right node of second tree to the\\n               right node of the first subtree */ \\n            \\n            if(temp.first->right == NULL){\\n                temp.first->right = temp.second->right;\\n            }\\n            else{\\n                q.push({temp.first->right,temp.second->right});\\n            }\\n            }\\n        }\\n        return root1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL) return root2;\\n        if(root2 == NULL) return root1;\\n        if(root1==NULL && root2 ==NULL) return NULL;\\n        \\n        queue<pair<TreeNode*,TreeNode*>>q;\\n        q.push({root1,root2}",
                "codeTag": "Java"
            },
            {
                "id": 1751392,
                "title": "c-easy-o-n-7-line-code-solution",
                "content": "```\\n\\tTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!(root1 || root2)) return NULL;\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        if(root2) root1->val = root1->val + root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\tTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(!(root1 || root2)) return NULL;\\n        if(!root1) return root2;\\n        if(!root2) return root1;\\n        if(root2) root1->val = root1->val + root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1689471,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if(root1==None):\\n            return root2\\n        if(root2==None):\\n            return root1\\n        root1.val=root1.val+root2.val\\n        root1.left=self.mergeTrees(root1.left,root2.left)\\n        root1.right=self.mergeTrees(root1.right,root2.right)\\n        return root1",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if(root1==None):\\n            return root2\\n        if(root2==None):\\n            return root1\\n        root1.val=root1.val+root2.val\\n        root1.left=self.mergeTrees(root1.left,root2.left)\\n        root1.right=self.mergeTrees(root1.right,root2.right)\\n        return root1",
                "codeTag": "Java"
            },
            {
                "id": 1684909,
                "title": "short-fast-c-code-6-lines-recursive-dfs-99-86-faster",
                "content": "**Please Upvote if  You Like>> :)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL) return root2;\\n        if(root2 == NULL) return root1;\\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL) return root2;\\n        if(root2 == NULL) return root1;\\n        root1->val += root2->val;\\n        root1->left = mergeTrees(root1->left, root2->left);\\n        root1->right = mergeTrees(root1->right, root2->right);\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674491,
                "title": "very-short-recursive-implementation-in-ruby",
                "content": "```\\ndef merge_trees(root1, root2)\\n    return root2 if root1.nil?\\n    return root1 if root2.nil?\\n    TreeNode.new(root1.val + root2.val,\\n        merge_trees(root1.left, root2.left),\\n        merge_trees(root1.right, root2.right)\\n    )\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```\\ndef merge_trees(root1, root2)\\n    return root2 if root1.nil?\\n    return root1 if root2.nil?\\n    TreeNode.new(root1.val + root2.val,\\n        merge_trees(root1.left, root2.left),\\n        merge_trees(root1.right, root2.right)\\n    )\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1470493,
                "title": "c-recursive-3-coding-ways",
                "content": "\\n```\\n//In this we have created a new function and done standard recursive calls\\nclass Solution {\\npublic:\\n    TreeNode* util(TreeNode* root1,TreeNode *root2)\\n    {\\n        TreeNode *root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val);\\n            root->left=util(root1->left,root2->left);\\n            root->right=util(root1->right,root2->right);            \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val);\\n            root->left=util(NULL,root2->left);\\n            root->right=util(NULL,root2->right);            \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val);\\n            root->left=util(root1->left,NULL);\\n            root->right=util(root1->right,NULL);            \\n        }\\n        return root;\\n        \\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        TreeNode* root=util(root1,root2); \\n        return root;\\n    }\\n};\\n```\\n```\\n//In this we are utilising the given constructors for recursive calls\\nclass Solution {\\npublic:\\n    TreeNode* util(TreeNode* root1,TreeNode *root2)\\n    {\\n        TreeNode *root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val,util(root1->left,root2->left),util(root1->right,root2->right));      \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val,util(NULL,root2->left),util(NULL,root2->right)); \\n                        \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val,util(root1->left,NULL),util(root1->right,NULL)); \\n                       \\n        }\\n        return root;\\n        \\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        TreeNode* root=util(root1,root2); \\n        return root;\\n    }\\n};\\n```\\n```\\n//In this we are not creating a util function and are also utilising the given  constructors\\nclass Solution {\\npublic:\\n     TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) \\n     {\\n         TreeNode* root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val,mergeTrees(root1->left,root2->left),mergeTrees(root1->right,root2->right));      \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val,mergeTrees(NULL,root2->left),mergeTrees(NULL,root2->right)); \\n                        \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val,mergeTrees(root1->left,NULL),mergeTrees(root1->right,NULL)); \\n                       \\n        }\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\n//In this we have created a new function and done standard recursive calls\\nclass Solution {\\npublic:\\n    TreeNode* util(TreeNode* root1,TreeNode *root2)\\n    {\\n        TreeNode *root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val);\\n            root->left=util(root1->left,root2->left);\\n            root->right=util(root1->right,root2->right);            \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val);\\n            root->left=util(NULL,root2->left);\\n            root->right=util(NULL,root2->right);            \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val);\\n            root->left=util(root1->left,NULL);\\n            root->right=util(root1->right,NULL);            \\n        }\\n        return root;\\n        \\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        TreeNode* root=util(root1,root2); \\n        return root;\\n    }\\n};\\n```\n```\\n//In this we are utilising the given constructors for recursive calls\\nclass Solution {\\npublic:\\n    TreeNode* util(TreeNode* root1,TreeNode *root2)\\n    {\\n        TreeNode *root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val,util(root1->left,root2->left),util(root1->right,root2->right));      \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val,util(NULL,root2->left),util(NULL,root2->right)); \\n                        \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val,util(root1->left,NULL),util(root1->right,NULL)); \\n                       \\n        }\\n        return root;\\n        \\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        TreeNode* root=util(root1,root2); \\n        return root;\\n    }\\n};\\n```\n```\\n//In this we are not creating a util function and are also utilising the given  constructors\\nclass Solution {\\npublic:\\n     TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) \\n     {\\n         TreeNode* root;\\n        if(!root1&&!root2)return NULL;\\n        else if(root1&&root2)\\n        {\\n            root=new TreeNode(root1->val+root2->val,mergeTrees(root1->left,root2->left),mergeTrees(root1->right,root2->right));      \\n        }\\n        else if(!root1)\\n        {\\n            root=new TreeNode(root2->val,mergeTrees(NULL,root2->left),mergeTrees(NULL,root2->right)); \\n                        \\n        }\\n        else\\n        {\\n            root=new TreeNode(root1->val,mergeTrees(root1->left,NULL),mergeTrees(root1->right,NULL)); \\n                       \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450469,
                "title": "c-simple-dfs-solution-99-faster-than-other-c-solution",
                "content": "Simple DFS based solution.\\n* I merge **root2 into root1**, and at the end **return root1**.\\n* **DRY RUN WITH AN EXAMPLE FOR PROPER UNDERSTANDING**.\\n```\\nclass Solution {\\npublic:\\n    void merge(TreeNode* root1,TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL)\\n            return;\\n        if(root1 == NULL || root2 == NULL)\\n            return;\\n        \\n\\t\\t// Add the value of the current node of root2 into root1 (if both root1 & root2 are not NULL) \\n        root1->val += root2->val;\\n\\t\\t\\n\\t    merge(root1->left,root2->left);\\n\\t\\t\\n\\t\\t// In this case we just attach the extra part in root2 into root1, if any (left part)\\n        if(root1->left == NULL && root2->left != NULL){\\n            TreeNode* curr = root2->left;\\n            root1->left = curr;\\n        }\\n\\t\\t\\n        merge(root1->right,root2->right);\\n\\t\\t\\n\\t\\t// In this case we just attach the extra part in root2 into root1, if any (right part)\\n        if(root1->right == NULL && root2->right != NULL){\\n            TreeNode* curr = root2->right;\\n            root1->right = curr;\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL && root2 == NULL)\\n            return NULL;\\n        if(root1 == NULL)\\n            return root2;\\n        if(root2 == NULL)\\n            return root1;\\n        merge(root1,root2);\\n        return root1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(TreeNode* root1,TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL)\\n            return;\\n        if(root1 == NULL || root2 == NULL)\\n            return;\\n        \\n\\t\\t// Add the value of the current node of root2 into root1 (if both root1 & root2 are not NULL) \\n        root1->val += root2->val;\\n\\t\\t\\n\\t    merge(root1->left,root2->left);\\n\\t\\t\\n\\t\\t// In this case we just attach the extra part in root2 into root1, if any (left part)\\n        if(root1->left == NULL && root2->left != NULL){\\n            TreeNode* curr = root2->left;\\n            root1->left = curr;\\n        }\\n\\t\\t\\n        merge(root1->right,root2->right);\\n\\t\\t\\n\\t\\t// In this case we just attach the extra part in root2 into root1, if any (right part)\\n        if(root1->right == NULL && root2->right != NULL){\\n            TreeNode* curr = root2->right;\\n            root1->right = curr;\\n        }\\n    }\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n        if(root1 == NULL && root2 == NULL)\\n            return NULL;\\n        if(root1 == NULL)\\n            return root2;\\n        if(root2 == NULL)\\n            return root1;\\n        merge(root1,root2);\\n        return root1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429959,
                "title": "c-recursive-solution-time-complexity-o-n",
                "content": "class Solution {\\n    \\npublic:\\n    //Time complexity: O(n)\\n    //Space complexity: O(n)\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n      \\n        if(root1 ==NULL) return root2;\\n        if(root2 ==NULL) return root1;\\n        root1->val+= root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        return root1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n    //Time complexity: O(n)\\n    //Space complexity: O(n)\\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\\n      \\n        if(root1 ==NULL) return root2;\\n        if(root2 ==NULL) return root1;\\n        root1->val+= root2->val;\\n        root1->left = mergeTrees(root1->left,root2->left);\\n        root1->right = mergeTrees(root1->right,root2->right);\\n        return root1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1330085,
                "title": "c-0-n-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        \\n        if(!t1)\\n            return t2;\\n        if(!t2)\\n            return t1;\\n        \\n        t1->val+=t2->val;\\n        t1->left=mergeTrees(t1->left,t2->left);\\n        t1->right=mergeTrees(t1->right,t2->right);\\n        \\n        return t1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        \\n        if(!t1)\\n            return t2;\\n        if(!t2)\\n            return t1;\\n        \\n        t1->val+=t2->val;\\n        t1->left=mergeTrees(t1->left,t2->left);\\n        t1->right=mergeTrees(t1->right,t2->right);\\n        \\n        return t1;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1165187,
                "title": "python-87-percent-faster-easy-to-understand-it-should-be-atleast-medium",
                "content": "```\\ndef mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None or root2 is None:\\n            return root1 if root2 is None else root2\\n        root = self.helper(root1,root2)\\n        return root\\n    \\n    def helper(self,root1,root2):\\n        if root1 is None or root2 is None:\\n            return\\n        temp = root1.val+root2.val\\n        node = TreeNode(temp)\\n        node.left = self.helper(root1.left,root2.left)\\n        if root1.left is not None and root2.left is None:\\n            temp = root1.left\\n            root1.left = None\\n            node.left = temp\\n            \\n        elif root1.left is None and root2.left is not None:\\n            temp = root2.left\\n            root2.left = None\\n            node.left = temp\\n            \\n        node.right = self.helper(root1.right,root2.right)\\n        if root1.right is not None and root2.right is None:\\n            temp = root1.right\\n            root1.right = None\\n            node.right = temp\\n        elif root1.right is None and root2.right is not None:\\n            temp = root2.right\\n            root2.right = None\\n            node.right = temp\\n            \\n        return node\\n```\\nThe code looks intimidating but trust me I was intimidated by the level given to the problem. It should be atleast medium. \\nThe logic is do dfs simultaneously on both the trees. The momemt you find a none return and then just attach the subtree of current node which is not none to our resultant tree. \\nDo let me know if you face any difficulty. \\n**Thanks**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None or root2 is None:\\n            return root1 if root2 is None else root2\\n        root = self.helper(root1,root2)\\n        return root\\n    \\n    def helper(self,root1,root2):\\n        if root1 is None or root2 is None:\\n            return\\n        temp = root1.val+root2.val\\n        node = TreeNode(temp)\\n        node.left = self.helper(root1.left,root2.left)\\n        if root1.left is not None and root2.left is None:\\n            temp = root1.left\\n            root1.left = None\\n            node.left = temp\\n            \\n        elif root1.left is None and root2.left is not None:\\n            temp = root2.left\\n            root2.left = None\\n            node.left = temp\\n            \\n        node.right = self.helper(root1.right,root2.right)\\n        if root1.right is not None and root2.right is None:\\n            temp = root1.right\\n            root1.right = None\\n            node.right = temp\\n        elif root1.right is None and root2.right is not None:\\n            temp = root2.right\\n            root2.right = None\\n            node.right = temp\\n            \\n        return node\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1108949,
                "title": "no-auxiliary-space-easy-to-understand-beats-99-solutions",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None or root2 is None:\\n            return root1 or root2\\n        self.mergeTreesHelper(None, root1, root2)\\n        return root1\\n    def mergeTreesHelper(self, parent, nodeOne, nodeTwo,):\\n        if nodeOne and nodeTwo:\\n            nodeOne.val += nodeTwo.val\\n            nodeOne.left = self.mergeTreesHelper(nodeOne, nodeOne.left, nodeTwo.left)\\n            nodeOne.right = self.mergeTreesHelper(nodeOne, nodeOne.right, nodeTwo.right)\\n            return nodeOne\\n        return nodeOne or nodeTwo\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if root1 is None or root2 is None:\\n            return root1 or root2\\n        self.mergeTreesHelper(None, root1, root2)\\n        return root1\\n    def mergeTreesHelper(self, parent, nodeOne, nodeTwo,):\\n        if nodeOne and nodeTwo:\\n            nodeOne.val += nodeTwo.val\\n            nodeOne.left = self.mergeTreesHelper(nodeOne, nodeOne.left, nodeTwo.left)\\n            nodeOne.right = self.mergeTreesHelper(nodeOne, nodeOne.right, nodeTwo.right)\\n            return nodeOne\\n        return nodeOne or nodeTwo\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1064426,
                "title": "python-iterative",
                "content": "```\\n    from collections import deque\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        stack = deque()\\n        stack.append((root1, root2))\\n        while stack:\\n            first, second = stack.pop()\\n            if first and second:\\n                first.val += second.val\\n                if first.left and second.left:\\n                    stack.append((first.left, second.left))\\n                elif not first.left:\\n                    first.left = second.left\\n                if first.right and second.right:\\n                    stack.append((first.right, second.right))\\n                elif not first.right:\\n                    first.right = second.right\\n        return root1\\n```",
                "solutionTags": [],
                "code": "```\\n    from collections import deque\\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\\n        if not root1:\\n            return root2\\n        if not root2:\\n            return root1\\n        stack = deque()\\n        stack.append((root1, root2))\\n        while stack:\\n            first, second = stack.pop()\\n            if first and second:\\n                first.val += second.val\\n                if first.left and second.left:\\n                    stack.append((first.left, second.left))\\n                elif not first.left:\\n                    first.left = second.left\\n                if first.right and second.right:\\n                    stack.append((first.right, second.right))\\n                elif not first.right:\\n                    first.right = second.right\\n        return root1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972904,
                "title": "c-48ms-87-breadth-traversal-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n      if(!t1 && !t2) return NULL;\\n      if(!t1) return t2;\\n      if(!t2) return t1;                                  //we will consider tree t1 as tree for answer\\n      \\n      queue <TreeNode*> q1,q2;\\n      q1.push(t1);\\n      q2.push(t2);\\n      while(!q1.empty()){\\n        TreeNode *tmp1 = q1.front(),  *tmp2 = q2.front();    \\n        q1.pop();q2.pop();\\n        tmp1->val += tmp2->val;                             //add for node val tree t1 node val from tree t2\\n        \\n        if(tmp1->left && tmp2->left){q1.push(tmp1->left);q2.push(tmp2->left);}                              // if we have nodes in the same place in trees put in our traversal\\n        else if(tmp2->left){tmp1->left = tmp2->left;}                        // if we have node only t1 tree we will ignore it , else we create left subtree of tree t1 is equal left subtree of tree t2  \\n                                             \\n        if(tmp1->right && tmp2->right){q1.push(tmp1->right);q2.push(tmp2->right);}                                                //for right branch consideration is similary\\n        else if(tmp2->right){tmp1->right = tmp2->right;}\\n      }\\n      return t1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n      if(!t1 && !t2) return NULL;\\n      if(!t1) return t2;\\n      if(!t2) return t1;                                  //we will consider tree t1 as tree for answer\\n      \\n      queue <TreeNode*> q1,q2;\\n      q1.push(t1);\\n      q2.push(t2);\\n      while(!q1.empty()){\\n        TreeNode *tmp1 = q1.front(),  *tmp2 = q2.front();    \\n        q1.pop();q2.pop();\\n        tmp1->val += tmp2->val;                             //add for node val tree t1 node val from tree t2\\n        \\n        if(tmp1->left && tmp2->left){q1.push(tmp1->left);q2.push(tmp2->left);}                              // if we have nodes in the same place in trees put in our traversal\\n        else if(tmp2->left){tmp1->left = tmp2->left;}                        // if we have node only t1 tree we will ignore it , else we create left subtree of tree t1 is equal left subtree of tree t2  \\n                                             \\n        if(tmp1->right && tmp2->right){q1.push(tmp1->right);q2.push(tmp2->right);}                                                //for right branch consideration is similary\\n        else if(tmp2->right){tmp1->right = tmp2->right;}\\n      }\\n      return t1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938214,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nUse DFS to traverse both trees simultaneously\\nFor overlapping nodes, add value to first tree (so we don\\'t use extra space)\\nFor not-overlapping nodes, take one of the NOT-NULL nodes and append it to first tree\\nRecursively perform this for every node of both trees\\n*/\\nvar mergeTrees = function(root1, root2) {\\n    return dfs(root1, root2);\\n    // T.C: O(min(M, N))\\n    // S.C: O(min(H1, H2))\\n};\\n\\nconst dfs = (root1, root2) => {\\n    if (!root1 && !root2) {\\n        return null;\\n    }\\n    if (!root1 || !root2) {\\n        return root1 || root2;\\n    }\\n    root1.val += root2.val;\\n    root1.left = dfs(root1.left, root2.left);\\n    root1.right = dfs(root1.right, root2.right);\\n    return root1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nUse DFS to traverse both trees simultaneously\\nFor overlapping nodes, add value to first tree (so we don\\'t use extra space)\\nFor not-overlapping nodes, take one of the NOT-NULL nodes and append it to first tree\\nRecursively perform this for every node of both trees\\n*/\\nvar mergeTrees = function(root1, root2) {\\n    return dfs(root1, root2);\\n    // T.C: O(min(M, N))\\n    // S.C: O(min(H1, H2))\\n};\\n\\nconst dfs = (root1, root2) => {\\n    if (!root1 && !root2) {\\n        return null;\\n    }\\n    if (!root1 || !root2) {\\n        return root1 || root2;\\n    }\\n    root1.val += root2.val;\\n    root1.left = dfs(root1.left, root2.left);\\n    root1.right = dfs(root1.right, root2.right);\\n    return root1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925154,
                "title": "javascript-dfs",
                "content": "```\\nvar mergeTrees = function(root1, root2) {\\n  return dfs(root1, root2)\\n};\\n\\nfunction dfs(r,t){\\n  if(!r && !t) return null\\n  if(!r) return t\\n  if(!t) return r\\n  r.val += t ? t.val : 0\\n  r.left = dfs(r.left, t.left)\\n  r.right = dfs(r.right, t.right)  \\n  return r\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar mergeTrees = function(root1, root2) {\\n  return dfs(root1, root2)\\n};\\n\\nfunction dfs(r,t){\\n  if(!r && !t) return null\\n  if(!r) return t\\n  if(!t) return r\\n  r.val += t ? t.val : 0\\n  r.left = dfs(r.left, t.left)\\n  r.right = dfs(r.right, t.right)  \\n  return r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 828075,
                "title": "python-concise-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        if not t1 or not t2:\\n            return t1 or t2\\n        node = TreeNode(t1.val + t2.val)\\n        node.left = self.mergeTrees(t1.left, t2.left)\\n        node.right = self.mergeTrees(t1.right, t2.right)\\n        return node\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mergeTrees(self, t1, t2):\\n        if not t1 or not t2:\\n            return t1 or t2\\n        node = TreeNode(t1.val + t2.val)\\n        node.left = self.mergeTrees(t1.left, t2.left)\\n        node.right = self.mergeTrees(t1.right, t2.right)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759130,
                "title": "java-iterative-solution-without-modifying-input-trees",
                "content": "This question becomes much harder if you\\'re not allowed to modify the input and have to solve it iteratively.\\nThis is my take: a level-order traversal on triplets of tree nodes [leftTree, rightTree, resTree] \\n```\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) {\\n            return null;\\n        }\\n        Deque<TreeNode[]> queue = new ArrayDeque<>();\\n        TreeNode res = new TreeNode();\\n        queue.push(new TreeNode[] {t1, t2, res});\\n        TreeNode[] curNodes;\\n        while (! queue.isEmpty()) {\\n            curNodes = queue.pop();\\n            if (curNodes[0] == null && curNodes[1] == null) {\\n                continue;\\n            }\\n            TreeNode[] nextLeft = new TreeNode[3];\\n            TreeNode[] nextRight = new TreeNode[3];\\n            if (curNodes[0] != null) {\\n                curNodes[2].val += curNodes[0].val;\\n                if (curNodes[0].left != null) {\\n                    curNodes[2].left = new TreeNode();\\n                }\\n                if (curNodes[0].right != null) {\\n                    curNodes[2].right = new TreeNode();\\n                }\\n                nextLeft[0] = curNodes[0].left;\\n                nextRight[0] = curNodes[0].right;\\n            }\\n            if (curNodes[1] != null) {\\n                curNodes[2].val += curNodes[1].val;\\n                if (curNodes[1].left != null && curNodes[2].left  == null) {\\n                    curNodes[2].left = new TreeNode();\\n                }\\n                if (curNodes[1].right != null && curNodes[2].right == null) {\\n                    curNodes[2].right = new TreeNode();\\n                }\\n                nextLeft[1] = curNodes[1].left;\\n                nextRight[1] = curNodes[1].right;\\n            }\\n            nextLeft[2] = curNodes[2].left;\\n            nextRight[2] = curNodes[2].right;\\n\\n            queue.push(nextLeft);\\n            queue.push(nextRight);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "This question becomes much harder if you\\'re not allowed to modify the input and have to solve it iteratively.\\nThis is my take: a level-order traversal on triplets of tree nodes [leftTree, rightTree, resTree] \\n```\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) {\\n            return null;\\n        }\\n        Deque<TreeNode[]> queue = new ArrayDeque<>();\\n        TreeNode res = new TreeNode();\\n        queue.push(new TreeNode[] {t1, t2, res});\\n        TreeNode[] curNodes;\\n        while (! queue.isEmpty()) {\\n            curNodes = queue.pop();\\n            if (curNodes[0] == null && curNodes[1] == null) {\\n                continue;\\n            }\\n            TreeNode[] nextLeft = new TreeNode[3];\\n            TreeNode[] nextRight = new TreeNode[3];\\n            if (curNodes[0] != null) {\\n                curNodes[2].val += curNodes[0].val;\\n                if (curNodes[0].left != null) {\\n                    curNodes[2].left = new TreeNode();\\n                }\\n                if (curNodes[0].right != null) {\\n                    curNodes[2].right = new TreeNode();\\n                }\\n                nextLeft[0] = curNodes[0].left;\\n                nextRight[0] = curNodes[0].right;\\n            }\\n            if (curNodes[1] != null) {\\n                curNodes[2].val += curNodes[1].val;\\n                if (curNodes[1].left != null && curNodes[2].left  == null) {\\n                    curNodes[2].left = new TreeNode();\\n                }\\n                if (curNodes[1].right != null && curNodes[2].right == null) {\\n                    curNodes[2].right = new TreeNode();\\n                }\\n                nextLeft[1] = curNodes[1].left;\\n                nextRight[1] = curNodes[1].right;\\n            }\\n            nextLeft[2] = curNodes[2].left;\\n            nextRight[2] = curNodes[2].right;\\n\\n            queue.push(nextLeft);\\n            queue.push(nextRight);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 718351,
                "title": "java-simple-dfs",
                "content": "```\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        t1.val += t2.val;\\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        return t1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        t1.val += t2.val;\\n        t1.left = mergeTrees(t1.left, t2.left);\\n        t1.right = mergeTrees(t1.right, t2.right);\\n        return t1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711437,
                "title": "5-lines-is-all-you-need-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 and !t2) return NULL;\\n        \\n        TreeNode *root = new TreeNode((t1 ? t1->val : 0) + (t2 ? t2->val : 0));\\n        \\n        root->left = mergeTrees(t1 ? t1->left : NULL, t2 ? t2->left : NULL);\\n        root->right = mergeTrees(t1 ? t1->right : NULL, t2 ? t2->right : NULL);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if (!t1 and !t2) return NULL;\\n        \\n        TreeNode *root = new TreeNode((t1 ? t1->val : 0) + (t2 ? t2->val : 0));\\n        \\n        root->left = mergeTrees(t1 ? t1->left : NULL, t2 ? t2->left : NULL);\\n        root->right = mergeTrees(t1 ? t1->right : NULL, t2 ? t2->right : NULL);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631415,
                "title": "java-recursive-3-lines-but-readable",
                "content": "```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        return new TreeNode(t1.val + t2.val, mergeTrees(t1.left, t2.left), mergeTrees(t1.right, t2.right));       \\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        return new TreeNode(t1.val + t2.val, mergeTrees(t1.left, t2.left), mergeTrees(t1.right, t2.right));       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 534504,
                "title": "python-very-simple-80-ms-faster-than-98-19",
                "content": "**Intuition:**\\nWork your way down the input trees recursively:\\nStart from the top of both trees.\\nIf both trees are not None:\\n- Create a third tree with the root\\'s value being the sum of the root values of the input trees\\n- The left and right subtrees of the new tree will be calculated recursively\\n- Return the newly created third tree\\n \\nIf there is only one of the input trees (the other one is None), then return it\\nElse return none\\n\\n**Code:**\\n```\\ndef mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n\\tif t1 and t2:\\n\\t\\tt3 = TreeNode(t1.val + t2.val) \\n\\t\\tt3.left = self.mergeTrees(t1.left, t2.left)\\n\\t\\tt3.right = self.mergeTrees(t1.right, t2.right)\\n\\t\\treturn t3\\n\\telif t1:\\n\\t\\treturn t1\\n\\telif t2:\\n\\t\\treturn t2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n\\tif t1 and t2:\\n\\t\\tt3 = TreeNode(t1.val + t2.val) \\n\\t\\tt3.left = self.mergeTrees(t1.left, t2.left)\\n\\t\\tt3.right = self.mergeTrees(t1.right, t2.right)\\n\\t\\treturn t3\\n\\telif t1:\\n\\t\\treturn t1\\n\\telif t2:\\n\\t\\treturn t2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528621,
                "title": "much-simpler-solution-than-the-existing-ones-with-most-votes",
                "content": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        TreeNode node = new TreeNode(t1.val + t2.val);\\n        node.left = mergeTrees(t1.left, t2.left);\\n        node.right = mergeTrees(t1.right, t2.right);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (t1 == null && t2 == null) return null;\\n        if (t1 == null) return t2;\\n        if (t2 == null) return t1;\\n        TreeNode node = new TreeNode(t1.val + t2.val);\\n        node.left = mergeTrees(t1.left, t2.left);\\n        node.right = mergeTrees(t1.right, t2.right);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518939,
                "title": "python-iterative-construction-of-the-3rd-tree-without-changing-two-original",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n\\n        # new node val\\n        def nodeSum(node1, node2):\\n            if not node1:\\n                return node2.val\\n            if not node2:\\n                return node1.val\\n            return node1.val+node2.val\\n\\n        root = TreeNode(t1.val + t2.val)\\n        queue = [[root, t1, t2]]\\n\\n        while queue:\\n            t = queue.pop()\\n            if t[1] or t[2]:\\n                # left child\\n                n1 = t[1].left if t[1] else None\\n                n2 = t[2].left if t[2] else None\\n                if n1 or n2:\\n                    t[0].left = TreeNode(nodeSum(n1, n2))\\n                    queue.append([t[0].left, n1, n2])\\n            \\n                # right child\\n                n1 = t[1].right if t[1] else None\\n                n2 = t[2].right if t[2] else None\\n                if n1 or n2:\\n                    t[0].right = TreeNode(nodeSum(n1, n2))\\n                    queue.append([t[0].right, n1, n2])\\n                \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n\\n        # new node val\\n        def nodeSum(node1, node2):\\n            if not node1:\\n                return node2.val\\n            if not node2:\\n                return node1.val\\n            return node1.val+node2.val\\n\\n        root = TreeNode(t1.val + t2.val)\\n        queue = [[root, t1, t2]]\\n\\n        while queue:\\n            t = queue.pop()\\n            if t[1] or t[2]:\\n                # left child\\n                n1 = t[1].left if t[1] else None\\n                n2 = t[2].left if t[2] else None\\n                if n1 or n2:\\n                    t[0].left = TreeNode(nodeSum(n1, n2))\\n                    queue.append([t[0].left, n1, n2])\\n            \\n                # right child\\n                n1 = t[1].right if t[1] else None\\n                n2 = t[2].right if t[2] else None\\n                if n1 or n2:\\n                    t[0].right = TreeNode(nodeSum(n1, n2))\\n                    queue.append([t[0].right, n1, n2])\\n                \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468208,
                "title": "clean-pythonic-solution",
                "content": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n        t = TreeNode(t1.val + t2.val)\\n        t.left = self.mergeTrees(t1.left, t2.left)\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\\n        if not t1:\\n            return t2\\n        if not t2:\\n            return t1\\n        t = TreeNode(t1.val + t2.val)\\n        t.left = self.mergeTrees(t1.left, t2.left)\\n        t.right = self.mergeTrees(t1.right, t2.right)\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436821,
                "title": "bfs-souliution",
                "content": "```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (null == t1) {\\n            return t2;\\n        }\\n        if (null == t2) {\\n            return t1;\\n        }\\n        \\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        \\n        q1.add(t1);\\n        q2.add(t2);\\n        \\n        while (!q1.isEmpty()) {\\n            TreeNode node1 = q1.poll();\\n            TreeNode node2 = q2.poll();\\n            \\n            if (node1 == null || node2 == null) {\\n               continue;\\n            }\\n            \\n            if (null != node2) {\\n                node1.val += node2.val; \\n            }\\n\\n            if (null == node1.left && null != node2) {\\n                node1.left = node2.left;\\n            } else {\\n                q1.add(node1.left);\\n                if (null != node2) {\\n                    q2.offer(node2.left);\\n                }\\n            }\\n\\n            if (null == node1.right && null != node2) {\\n                node1.right = node2.right;\\n            } else {\\n                q1.add(node1.right);\\n                if (null != node2) {\\n                    q2.offer(node2.right);\\n                }\\n            }\\n        }\\n        \\n        return t1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\\n        if (null == t1) {\\n            return t2;\\n        }\\n        if (null == t2) {\\n            return t1;\\n        }\\n        \\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        \\n        q1.add(t1);\\n        q2.add(t2);\\n        \\n        while (!q1.isEmpty()) {\\n            TreeNode node1 = q1.poll();\\n            TreeNode node2 = q2.poll();\\n            \\n            if (node1 == null || node2 == null) {\\n               continue;\\n            }\\n            \\n            if (null != node2) {\\n                node1.val += node2.val; \\n            }\\n\\n            if (null == node1.left && null != node2) {\\n                node1.left = node2.left;\\n            } else {\\n                q1.add(node1.left);\\n                if (null != node2) {\\n                    q2.offer(node2.left);\\n                }\\n            }\\n\\n            if (null == node1.right && null != node2) {\\n                node1.right = node2.right;\\n            } else {\\n                q1.add(node1.right);\\n                if (null != node2) {\\n                    q2.offer(node2.right);\\n                }\\n            }\\n        }\\n        \\n        return t1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405718,
                "title": "preorder-recursive-solution-in-python-and-javascript",
                "content": "```\\ndef mergeTrees(self, t1, t2):\\n\\tif t1 is None: return t2\\n\\tif t2 is None: return t1\\n\\tt1.val += t2.val\\n\\tt1.left, t1.right = self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)\\n\\treturn t1\\n```\\n\\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 == null) return t2;\\n    if (t2 == null) return t1;\\n    t1.val += t2.val;\\n    t1.left = mergeTrees(t1.left, t2.left), t1.right = mergeTrees(t1.right, t2.right);\\n    return t1;  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndef mergeTrees(self, t1, t2):\\n\\tif t1 is None: return t2\\n\\tif t2 is None: return t1\\n\\tt1.val += t2.val\\n\\tt1.left, t1.right = self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)\\n\\treturn t1\\n```\n```\\nvar mergeTrees = function(t1, t2) {\\n    if (t1 == null) return t2;\\n    if (t2 == null) return t1;\\n    t1.val += t2.val;\\n    t1.left = mergeTrees(t1.left, t2.left), t1.right = mergeTrees(t1.right, t2.right);\\n    return t1;  \\n};\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1722414,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1575783,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1569855,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1572412,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1572156,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1857907,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 2070301,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 2045185,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1999983,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1914781,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1722414,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1575783,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1569855,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1572412,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1572156,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1857907,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 2070301,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 2045185,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1999983,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            },
            {
                "id": 1914781,
                "content": [
                    {
                        "username": "user1141B",
                        "content": "The problem says: \"You need to merge the two trees into a new binary tree.\"\\nand the result is the same tree (t1) and not a new one. it\\'s misleading "
                    },
                    {
                        "username": "WebDev-Akhil",
                        "content": "![image](https://assets.leetcode.com/users/images/2a0e8da4-3823-4350-99d9-5ce683bd02a1_1632487203.2924182.png)\\n\\n"
                    },
                    {
                        "username": "sachin2000",
                        "content": "your approach is valid only for full binary tree."
                    },
                    {
                        "username": "99ansh",
                        "content": "![image](https://assets.leetcode.com/users/99ansh/image_1588275639.png)\\n\\nHow to resolve this issue in python ?\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "I mean, merging the tree in a new tree. Anyone?"
                    },
                    {
                        "username": "barris",
                        "content": "Why doesn\\'t this problem include the attributes of a TreeNode so we know how to access it??"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are two iterative approaches: one modifies the data in existing tree, second  - doesn't. \nFor the second approach see if you can use dummy objects to avoid if/else npe conditions as much as possible."
                    },
                    {
                        "username": "ecdrid",
                        "content": "Here\\'s a simple iterative solution -:\\n\\n```python3\\n        def iterative_solution():\\n            WHITE, GRAY = 0, 1\\n            stack = [(WHITE, root1, root2)]\\n\\n            while stack:\\n                color, node_first, node_second = stack.pop()\\n                if not node_first or not node_second:\\n                    continue\\n                if color == WHITE:\\n                    node_first.val += node_second.val\\n                    if not node_first.left:\\n                        node_first.left = node_second.left\\n                    else:\\n                        stack.append((WHITE, node_first.left, node_second.left))\\n                    \\n                    # stack.append((GRAY, node_first, node_second))\\n\\n                    if not node_first.right:\\n                        node_first.right = node_second.right\\n                    else:\\n                        stack.append((WHITE, node_first.right, node_second.right))\\n                else:\\n                    pass\\n            return root1\\n        \\n        if not root1: return root2\\n        return iterative_solution()      \\n```"
                    },
                    {
                        "username": "cs_can",
                        "content": "this according to me is good level easy problem even if it  was tagged medium too still it was ok. I don't know why but when one of the node is null and the other node is not null then instead of going ahead and copying the subtree of not null node if u just return the not null node without creating new node it still runs . So the problem could have been clearer if it wanted to create complete new Tree or not. "
                    },
                    {
                        "username": "ca3l007",
                        "content": "For the js version at least, you need to return null on the test case where !root1 && !root2. Feel like that should be made more clear... Failed several times trying to guess the desired return because the expected return shows as []."
                    },
                    {
                        "username": "noobengineer",
                        "content": "I have a problem.\\nMy method is wrong, I merge root2 tree to root1 tree.\\nHowever, I don\\'t know where is wrong for the method.\\n ```\\nvoid recursive(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if(root1 == NULL && root2 == NULL)\\n    {\\n        return;\\n    }\\n    if(root1 != NULL && root2 != NULL)\\n    {\\n        root1->val = root1->val + root2->val;\\n    }else if(root1 == NULL && root2 != NULL)\\n    {\\n        root1 = root2;\\n        return;\\n    }else if(root2 == NULL && root1 != NULL)\\n    {\\n        return;\\n    }\\n    recursive(root1->left,root2->left);\\n    recursive(root1->right,root2->right);\\n}\\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    //if(root1 == NULL) return root2;\\n    //else if(root2 == NULL) return root1;\\n    recursive(root1,root2);\\n    return root1;\\n}\\n```\\n\\nI see my result, and the root1 cannot combine with the root2.\\nBut I don\\'t know the what is forbidden in C.\\n```\\nelse if(root1 == NULL && root2 != NULL) {\\n        root1 = root2;\\n        return;\\n}\\n```\\nThe above code is the wrong part I think.\\n\\nI will be grateful for any help you can provide."
                    }
                ]
            }
        ]
    },
    {
        "title": "Students Report By Geography",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566350,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1570817,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1567511,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1575120,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1573717,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1734027,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1725489,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            },
            {
                "id": 1658116,
                "content": [
                    {
                        "username": "anupriya123456",
                        "content": "# Write your MySQL query statement below\\nselect min(America) as America, min(Asia) as Asia, min(Europe) as Europe from \\n(select\\ncase when continent= \"America\" then name else null end as \"America\",\\ncase when continent = \"Asia\" then name else null end as \"Asia\",\\ncase when continent = \"Europe\" then name end as \"Europe\",\\nrow_number() over (partition by continent order by name) as rnk                                    \\nfrom student\\n) t1\\ngroup by rnk"
                    },
                    {
                        "username": "AshleySnowbro",
                        "content": "# Write your MySQL query statement below\\nWITH ranked AS(\\nSELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS ranking \\nFROM Student)\\n\\nSELECT DISTINCT (SELECT name FROM ranked a WHERE a.ranking = r.ranking AND continent = \"America\") AS \"America\", (SELECT name FROM ranked b WHERE b.ranking = r.ranking  AND continent = \"Asia\") AS \"Asia\", (SELECT name FROM ranked c WHERE c.ranking = r.ranking  AND continent = \"Europe\") AS \"Europe\"\\nFROM ranked r"
                    },
                    {
                        "username": "paragsaxena",
                        "content": "![image](https://assets.leetcode.com/users/images/705fbdfe-26a8-41bf-a85b-fdf951eb3a76_1594384495.8498034.png)\\n"
                    },
                    {
                        "username": "saini_sandeep33",
                        "content": "with main as\\n(\\nselect row_number() over(partition by continent order by name) rn,name,continent\\nfrom student\\n)\\nselect  max(case when continent = \\'America\\'  then name else null end) as America,\\n        max(case when continent = \\'Asia\\'  then name else null end) as Asia,\\n        max(case when continent = \\'Europe\\'  then name else null end)  as Europe\\nfrom main\\ngroup by rn\\norder by 1,2,3"
                    },
                    {
                        "username": "terron23",
                        "content": "\\n\\nSelect America, Asia, Europe  from (\\nSelect name as America, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'America\\') as a\\nleft join \\n(Select name as Asia, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Asia\\') b\\non b.rank = a.rank\\nleft join\\n(Select name as Europe, row_number() over(partition by continent order by name) as rank\\nfrom student\\nwhere continent = \\'Europe\\') c\\non c.rank = a.rank \\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY SOLUTION USING WINDOWING FUNCTION(SQL SERVER)\\nwith cte as\\n(select *, ROW_NUMBER() over (partition by continent order by name)rn from student)\\n\\n(select min(case when continent = \\'America\\' then name end)America, \\nmin(case when continent = \\'Asia\\' then name end)Asia, \\nmin(case when continent = \\'Europe\\' then name end)Europe from cte\\ngroup by rn)"
                    },
                    {
                        "username": "rank3082",
                        "content": " `WITH american AS(\\n      SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS America\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'America\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\nasian AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Asia\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Asia\\'\\n    ORDER BY\\n        name ASC\\n),\\n\\neuropean AS(\\n    SELECT\\n        (ROW_NUMBER() OVER(ORDER BY name ASC)) AS rowNumber,\\n        name AS Europe\\n    FROM Student\\n    WHERE 1=1\\n        AND continent = \\'Europe\\'\\n    ORDER BY\\n        name ASC\\n)\\n\\n\\nSELECT \\n    american.America,\\n    asian.Asia,\\n    european.Europe\\nFROM american\\n\\nLEFT JOIN asian\\nON 1=1\\n    AND american.rowNumber = asian.rowNumber\\n\\nLEFT JOIN european\\nON 1=1\\n    AND american.rowNumber = european.rowNumber\\n`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith t_america as \\n(\\n    select\\n        (@cnt := @cnt + 1) as id, name as America\\n    from \\n        Student s, (select @cnt:= 0) r\\n    where\\n        continent = \\'America\\'\\n    order by name\\n),\\nt_asia as \\n(\\n    select\\n        (@cnt2 := @cnt2 + 1) as id, name as Asia\\n    from \\n        Student s, (select @cnt2:= 0) r\\n    where\\n        continent = \\'Asia\\'\\n    order by name\\n),\\nt_europe as \\n(\\n    select\\n        (@cnt3 := @cnt3 + 1) as id, name as Europe\\n    from \\n        Student s, (select @cnt3:= 0) r\\n    where\\n        continent = \\'Europe\\'\\n    order by name\\n)\\n\\nselect\\n    America, Asia, Europe\\nfrom\\n    t_america m\\nleft join\\n    t_asia s on m.id = s.id\\nleft join\\n    t_europe u on m.id = u.id\\n\\n```"
                    }
                ]
            }
        ]
    }
]