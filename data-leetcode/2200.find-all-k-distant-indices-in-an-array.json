[
    {
        "title": "Find All K-Distant Indices in an Array",
        "question_content": "You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.\nReturn a list of all k-distant indices sorted in increasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [3,4,9,1,3,9,5], key = 9, k = 1\nOutput: [1,2,3,4,5,6]\nExplanation: Here, nums[2] == key and nums[5] == key.\n- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.\n- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.\n- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.\n- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.\n- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.\n- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.\n- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.\nThus, we return [1,2,3,4,5,6] which is sorted in increasing order. \n\nExample 2:\n\nInput: nums = [2,2,2,2,2], key = 2, k = 2\nOutput: [0,1,2,3,4]\nExplanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. \nHence, we return [0,1,2,3,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 1000\n\tkey is an integer from the array nums.\n\t1 <= k <= nums.length",
        "solutions": [
            {
                "id": 1844332,
                "title": "one-pass",
                "content": "We can use two pointers to swipe the array once (`i`) and collect all k-distant indices (`j`).\\n\\n**C++**\\n```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        if (nums[i] == key)\\n            for (j = max(j, i - k); j <= i + k && j < nums.size(); ++j)\\n                res.push_back(j);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        if (nums[i] == key)\\n            for (j = max(j, i - k); j <= i + k && j < nums.size(); ++j)\\n                res.push_back(j);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845912,
                "title": "o-n-solution-detailed-pictures-easy-to-understand-explaination-c",
                "content": "# Breaking down and understanding the problem\\nThe problem says to return indexes such that |i - j| <= k and nums[j] = key. What does it mean ?\\n\\nSee once we find the key at a particular index. We need to print those indexes which satisfy the condtion \\n|i - j| <= k. Right ? . Now that we understand it, let\\'s look at a visual\\n\\n\\n![image](https://assets.leetcode.com/users/images/48d5ea71-9b81-4e67-b4a9-dd6c8e6f26e9_1647172473.148794.png)\\n\\nFrom here we see that whenever the key is found. We can only move **AT MOST** k indexes to the left and **AT MOST** k indexes to the right. If we move any further along in any direction the |i - j| <= k condition breaks.\\n\\n\\n**So which basically means that the actual problem is whenever we find the key. we have to move k indexes to the left and k indexes to the right and that gives the answer.**\\n\\nNow comes a few scenarios to keep in mind.\\n\\n1. What if we find key on extreme left. We can\\'t move to left of index 0, it gives us out of bounds.\\n     \\n     ![image](https://assets.leetcode.com/users/images/6b485aa7-eb11-4aa9-b9bb-43bec2a3db8e_1647173394.7046137.png)\\n\\n    In order to avoid this we can move to **max(0, i-k)** positions. So that we never fall below 0.\\n\\n2. What if we find key on extreme right. We can\\'t move beyond array limit.\\n\\n     ![image](https://assets.leetcode.com/users/images/09b4f2e3-9783-4257-9d13-c860e06f0204_1647173786.0431998.png)\\n\\n    In order to avoid this we can move to **min(n-1, i+k)** positions. So that we don\\'t go beyond limit of array.\\n\\n3. Avoiding overlapping in intervals\\n\\n![image](https://assets.leetcode.com/users/images/0358be07-6a88-49ad-b584-08459d4dfec5_1647174378.3456926.png)\\n\\nHere what we can do is, we check the last entry of index that we stored. We compare it with the start of the new interval. We take the max of last index entry + 1 & current start.  In above example last entry for first 3 will be 4 **(See the end of red line)**. Starting index for 3 will be 2 **(See the start of orange line)**. So comparing \\nmax(lastEntry of index + 1, startIndex) = max(5, 2) = 5. So we avoid overlapping interval and start from 5.\\n\\n\\n```\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) // if we find the key\\n            {\\n                int start = max(0, i-k);   // initialize the start\\n                int end = min(n-1, i+k);   // intialize the end\\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n  \\nAs we are able to avoid overlapping intervals. The time complexity is O(n).\\n\\nUpvote if it was able to help you. Cheers !!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) // if we find the key\\n            {\\n                int start = max(0, i-k);   // initialize the start\\n                int end = min(n-1, i+k);   // intialize the end\\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844247,
                "title": "brute-force-o-1-extra-space-without-sorting",
                "content": "- Keep on finding the corresponding index **j** w.r.t **i** , having **abs(j-i)<=k** and **nums[j]==target**.\\n- In this way index i will automatically be in **sorted order** as we are pushing it on the way.\\n- We will use a `break statement` the moment we will get a `j` satisfying all the constraint w.r.t `i`.\\n- We don\\'t need any `extra data structure `or any `sorting algorithm` because we will automatically get a sorted answer.\\n# C++   \\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=0;j<size(nums);j++){\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k and nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n**Time** - O(N^2)\\n**Space** - O(1) -> apart from the space of the answer that is a vector that we must return\\n**Pls tell any better approach , if you have**\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "- Keep on finding the corresponding index **j** w.r.t **i** , having **abs(j-i)<=k** and **nums[j]==target**.\\n- In this way index i will automatically be in **sorted order** as we are pushing it on the way.\\n- We will use a `break statement` the moment we will get a `j` satisfying all the constraint w.r.t `i`.\\n- We don\\'t need any `extra data structure `or any `sorting algorithm` because we will automatically get a sorted answer.\\n# C++   \\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=0;j<size(nums);j++){\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k and nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n**Time** - O(N^2)\\n**Space** - O(1) -> apart from the space of the answer that is a vector that we must return\\n**Pls tell any better approach , if you have**\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1844454,
                "title": "java-o-n-time-space-easy-4-ms-no-sorting",
                "content": "Problem : We have to find all the indices which are at <= k distance from the keys in an array. \\n\\nIdea : If we find all the indices of the keys in a given array in increasing order, then we can iterate k elements on the right and left sides of that key index to add them to answer in increasing order. For the next key index we can start iterating from the maximum(last key index + k , current key index - k) so that we will not process the already iterated array index. \\n\\nOnce we process all the indices with keys, we have a answer list in increasing order and we return it without the need of sorting.\\n\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> idx = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        int last = 0;\\n        for(int ind : idx){\\n            int i = Math.max(last,ind-k);\\n            for(; i <= ind+k && i < nums.length; i++){\\n                ans.add(i);\\n            }\\n            last = i;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> idx = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        int last = 0;\\n        for(int ind : idx){\\n            int i = Math.max(last,ind-k);\\n            for(; i <= ind+k && i < nums.length; i++){\\n                ans.add(i);\\n            }\\n            last = i;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171271,
                "title": "python-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ind_j = []\\n        for ind, elem in enumerate(nums):\\n            if elem == key:\\n                ind_j.append(ind)\\n        res = []\\n        for i in range(len(nums)):\\n            for j in ind_j:\\n                if abs(i - j) <= k:\\n                    res.append(i)\\n                    break\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ind_j = []\\n        for ind, elem in enumerate(nums):\\n            if elem == key:\\n                ind_j.append(ind)\\n        res = []\\n        for i in range(len(nums)):\\n            for j in ind_j:\\n                if abs(i - j) <= k:\\n                    res.append(i)\\n                    break\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845499,
                "title": "c-two-pointers-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pointers\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size();\\n        vector<int> ans, idx;\\n        for (int i = 0; i < N; ++i){\\n            if (A[i] == key) idx.push_back(i); // `idx` is a list of indices whose corresponding value is `key`.\\n        }\\n        for (int i = 0, j = 0; i < N && j < idx.size(); ++i) {\\n            if (i < idx[j] - k) continue; // If `i` is not yet in range of the next `key` element at `idx[j]`, skip.\\n            while (j < idx.size() && i > idx[j] + k) ++j; // While `i > idx[j] + k`, keep incrementing `j` to bring `idx[j]` in range of `i`.\\n            if (j < idx.size() && i <= idx[j] + k && i >= idx[j] - k) ans.push_back(i); // add `i` to the answer if `idx[j] - k <= i <= idx[j] + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Two Pointers\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size(), j = 0;\\n        vector<int> ans;\\n        for (int i = 0, j = 0; i < N; ++i) {\\n            while (j < N && (A[j] != key || j < i - k)) ++j; // Find the first index `j` that `A[j] == key` and `j >= i - k`.\\n            if (j == N) break;\\n            if (i <= j + k && i >= j - k) ans.push_back(i); // add `i` to answer if `j - k <= i <= j + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size();\\n        vector<int> ans, idx;\\n        for (int i = 0; i < N; ++i){\\n            if (A[i] == key) idx.push_back(i); // `idx` is a list of indices whose corresponding value is `key`.\\n        }\\n        for (int i = 0, j = 0; i < N && j < idx.size(); ++i) {\\n            if (i < idx[j] - k) continue; // If `i` is not yet in range of the next `key` element at `idx[j]`, skip.\\n            while (j < idx.size() && i > idx[j] + k) ++j; // While `i > idx[j] + k`, keep incrementing `j` to bring `idx[j]` in range of `i`.\\n            if (j < idx.size() && i <= idx[j] + k && i >= idx[j] - k) ans.push_back(i); // add `i` to the answer if `idx[j] - k <= i <= idx[j] + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size(), j = 0;\\n        vector<int> ans;\\n        for (int i = 0, j = 0; i < N; ++i) {\\n            while (j < N && (A[j] != key || j < i - k)) ++j; // Find the first index `j` that `A[j] == key` and `j >= i - k`.\\n            if (j == N) break;\\n            if (i <= j + k && i >= j - k) ans.push_back(i); // add `i` to answer if `j - k <= i <= j + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845354,
                "title": "c-o-n-using-queue",
                "content": "**Time Complexity:- O(n)\\nSpace Complexity:- O(number of keys)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == key) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            if(q.empty()) break;\\n            int idx = q.front();\\n            \\n            if(abs(idx - i) <= k) {\\n                ans.push_back(i);\\n            }\\n            else {\\n                if(i > idx) {\\n\\t\\t\\t\\t\\t// if not able to cover current index then surely can\\'t cover indices after it\\n                    q.pop();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lets again try for current index\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == key) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            if(q.empty()) break;\\n            int idx = q.front();\\n            \\n            if(abs(idx - i) <= k) {\\n                ans.push_back(i);\\n            }\\n            else {\\n                if(i > idx) {\\n\\t\\t\\t\\t\\t// if not able to cover current index then surely can\\'t cover indices after it\\n                    q.pop();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lets again try for current index\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844098,
                "title": "o-n-simple-python-code-explained",
                "content": "The idea here is :\\n- Store all the indices of elements in a queue whose value is equal to key\\n- for every index in nums, there are 2 options:\\n    - check with the near index backside whose value = key and difference<=k\\n    - check with the near index in front whose value = k and difference<=k\\n\\nCode:\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        lis=deque([])\\n        prev_popped=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==key):\\n                lis.append(i)\\n        ans=[]\\n        for i in range(len(nums)):\\n            if(len(lis)>0 and lis[0]<i):\\n                prev_popped = lis.popleft()\\n            if(prev_popped!=-1 and (i-prev_popped) <=k):\\n                ans.append(i)\\n            elif(len(lis)>0 and (lis[0]-i)<=k):\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        lis=deque([])\\n        prev_popped=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==key):\\n                lis.append(i)\\n        ans=[]\\n        for i in range(len(nums)):\\n            if(len(lis)>0 and lis[0]<i):\\n                prev_popped = lis.popleft()\\n            if(prev_popped!=-1 and (i-prev_popped) <=k):\\n                ans.append(i)\\n            elif(len(lis)>0 and (lis[0]-i)<=k):\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501802,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int len = nums.length - 1;\\n        List<Integer> ans = new ArrayList<>();\\n\\n        int[] arr = new int[len+1];\\n        int dist1 = 0, dist2 = 0;\\n\\n        for (int i = 0; i <= len; i++) {\\n            if (nums[i] == key) dist1 = k + 1;\\n            if (dist1 > 0){\\n                arr[i]++;\\n                dist1--;\\n            }\\n\\n            if (nums[len-i] == key) dist2 = k+1;\\n            if (dist2 > 0){\\n                arr[len-i]++;\\n                dist2--;\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++)\\n            if (arr[i] > 0)\\n                ans.add(i);\\n\\t\\t\\t\\t\\n\\t\\treturn ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845916,
                "title": "java-most-efficient-solution-easy-understanding",
                "content": "public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List <Integer> id = new ArrayList <> ();\\n        for(int i=0; i<nums.length; ++i){\\n            if(nums[i] == key){\\n                id.add(i);\\n            }\\n        }\\n        \\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        for(int i=0; i<nums.length; ++i){\\n            for(int j=0; j<id.size(); ++j){\\n            \\n                if(Math.abs(i - id.get(j)) <= k){\\n                    \\n                    res.add(i);\\n                    break;\\n                    \\n                }\\n               \\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List <Integer> id = new ArrayList <> ();\\n        for(int i=0; i<nums.length; ++i){\\n            if(nums[i] == key){\\n                id.add(i);\\n            }\\n        }\\n        \\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        for(int i=0; i<nums.length; ++i){\\n            for(int j=0; j<id.size(); ++j){\\n            \\n                if(Math.abs(i - id.get(j)) <= k){\\n                    \\n                    res.add(i);\\n                    break;\\n                    \\n                }\\n               \\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844532,
                "title": "easy-understanding-python-binary-search",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \"\"\"\\n        find all that == key into a list, idx\\n        \\n        traverse in nums, using i: (using binary search)\\n            if abs(i - idx) <= k: res.append(i)\\n        \"\"\"\\n        keys = [i for (i, e) in enumerate(nums) if e == key]    \\n        res = set(keys)\\n        \\n        for i in range(len(nums)):\\n            idx = bisect.bisect_left(keys, i)\\n            \\n            # to keys[idx] and keys[idx - 1] are all <= k\\n            if 0 <= idx < len(keys) and abs(i - keys[idx]) <= k:\\n                res.add(i)\\n            if 0 < idx <= len(keys) and abs(i - keys[idx - 1]) <= k:\\n                res.add(i)\\n                \\n        \\n        return sorted(list(res))\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \"\"\"\\n        find all that == key into a list, idx\\n        \\n        traverse in nums, using i: (using binary search)\\n            if abs(i - idx) <= k: res.append(i)\\n        \"\"\"\\n        keys = [i for (i, e) in enumerate(nums) if e == key]    \\n        res = set(keys)\\n        \\n        for i in range(len(nums)):\\n            idx = bisect.bisect_left(keys, i)\\n            \\n            # to keys[idx] and keys[idx - 1] are all <= k\\n            if 0 <= idx < len(keys) and abs(i - keys[idx]) <= k:\\n                res.add(i)\\n            if 0 < idx <= len(keys) and abs(i - keys[idx - 1]) <= k:\\n                res.add(i)\\n                \\n        \\n        return sorted(list(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844183,
                "title": "c-easy-set-to-vector",
                "content": "- Create a Set of integers and store the indices.\\n- Set automatically arranges the elements in it in increasing order.\\n```cpp\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int N = nums.size();\\n        set<int> S;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] != key) continue;\\n            \\n            for(int j = 0; j < N; j++) {\\n                if(abs(i - j) <= k && nums[i] == key) {\\n                    S.insert(j);\\n                }\\n            }\\n        }\\n\\t\\t// No need to create a new vector\\n        return vector<int> (S.begin(), S.end());\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int N = nums.size();\\n        set<int> S;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] != key) continue;\\n            \\n            for(int j = 0; j < N; j++) {\\n                if(abs(i - j) <= k && nums[i] == key) {\\n                    S.insert(j);\\n                }\\n            }\\n        }\\n\\t\\t// No need to create a new vector\\n        return vector<int> (S.begin(), S.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468580,
                "title": "yet-another-fast-o-n-python-solution",
                "content": "**The logic**:\\n1. Initialize the left unseen border in `left = 0`.\\n2. We iterate along the array `nums`. \\n3. When we meet a value equal to `key` we add the surrounding indexes `(i - k, i + k)`. We keep in value of the most right added value in `last` not to add it anymore. Thus, every element could be seen by the algorithm maximum of two times.\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        ans = []\\n        \\n        left = 0\\n        \\n        for i, v in enumerate(nums):\\n            # meet new key - include nums in the border [i-k:i+k]\\n            if v == key:\\n                for j in range(max(left, i - k), min(len(nums), i + k + 1)):\\n                    ans.append(j)\\n                left = min(len(nums), i + k + 1)\\n                # if all right part is included?\\n                if left == len(nums):\\n                    break\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        ans = []\\n        \\n        left = 0\\n        \\n        for i, v in enumerate(nums):\\n            # meet new key - include nums in the border [i-k:i+k]\\n            if v == key:\\n                for j in range(max(left, i - k), min(len(nums), i + k + 1)):\\n                    ans.append(j)\\n                left = min(len(nums), i + k + 1)\\n                # if all right part is included?\\n                if left == len(nums):\\n                    break\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849214,
                "title": "linear-sweep-of-trimmed-window-to-each-key-location",
                "content": "# Algorithm\\n* Scan array for values of `key`. For each found at location `i`:\\n   * Output locations from `i - k` to `i + k`.\\n\\nDuring the scan, the highest output location is tracked and used to trim the above window of output locations if they overlap what has been output already.\\n# C++ Code\\n\\n```C++\\n    static vector<int> findKDistantIndices(const vector<int>& nums, const int key, const int k)\\n    {\\n        int next_unmarked = 0, end = nums.size();\\n        \\n        vector<int> res;\\n        for(int i = 0; i < end; ++i)\\n        {\\n            if(nums[i] == key){\\n                int j = max(next_unmarked, i - k);\\n                for(; j < min(end, i + k + 1); ++j)\\n                {\\n                    res.push_back(j);\\n                }\\n                next_unmarked = j;\\n            }\\n        } \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\n    static vector<int> findKDistantIndices(const vector<int>& nums, const int key, const int k)\\n    {\\n        int next_unmarked = 0, end = nums.size();\\n        \\n        vector<int> res;\\n        for(int i = 0; i < end; ++i)\\n        {\\n            if(nums[i] == key){\\n                int j = max(next_unmarked, i - k);\\n                for(; j < min(end, i + k + 1); ++j)\\n                {\\n                    res.push_back(j);\\n                }\\n                next_unmarked = j;\\n            }\\n        } \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844619,
                "title": "o-n-two-pass-solution-in-python",
                "content": "for each index `i`, we check for two possible key indexes - `keys[left]` and `keys[left + 1]`. If either of them is less than or equal to k, then add to `res`.\\n\\nIn order to handle the edges, I added negative and positive infinity to both sides.\\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keys = [-math.inf] + [idx for idx, num in enumerate(nums) if num == key] + [math.inf]\\n        N = len(nums)\\n        res = []\\n        left = 0\\n        \\n        for i in range(N):\\n            if i - keys[left] <= k or keys[left + 1] - i <= k:\\n                res.append(i)\\n            if keys[left + 1] == i:\\n                left += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keys = [-math.inf] + [idx for idx, num in enumerate(nums) if num == key] + [math.inf]\\n        N = len(nums)\\n        res = []\\n        left = 0\\n        \\n        for i in range(N):\\n            if i - keys[left] <= k or keys[left + 1] - i <= k:\\n                res.append(i)\\n            if keys[left + 1] == i:\\n                left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844437,
                "title": "easy-to-understand-elegant-python-code",
                "content": "Linear Scan , add to a set and sort it in very end\\n\\n```\\ndef findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n\\tres = set()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tfor j, _ in enumerate(nums):\\n\\t\\t\\tif abs(i - j) <= k and num == key:\\n\\t\\t\\t\\tres.add(j)\\n\\treturn sorted(list(res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n\\tres = set()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tfor j, _ in enumerate(nums):\\n\\t\\t\\tif abs(i - j) <= k and num == key:\\n\\t\\t\\t\\tres.add(j)\\n\\treturn sorted(list(res))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844330,
                "title": "2200-c-o-n-solution",
                "content": "* Approach:\\n* \\tCreate 2 vectors 1 for storing ans, another for storing nums[i] == key.\\n* \\tUsing loop storing all indices which value is equal to key.\\n* \\tUsing another loop find indices following given condition\\n* \\t\\t-> |i-j| <= k and nums[j] == keys then storing i in ans vector.\\n* \\t\\t-> i>j and |i-j| > k then move next index that vaue is equal to key.\\n* \\t\\tTime Complexity = O(N)\\n* \\t\\tSpace Complexity = O(2N)\\n* \\t\\t**\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans, equal;\\n        \\n\\t\\t//traversing through nums and put nums[i]==key into the vector\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==key)\\n                equal.push_back(i);\\n        }\\n        \\n        if(!equal.size()) return ans;\\n\\t\\t//j for traversing through vector of indices which value is equal to key\\n        int j=0;\\n        \\n\\t\\t//\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i > equal[j] && abs(i-equal[j]) > k && j<equal.size()-1)\\n            {\\n                j++;\\n            }\\n            \\n            if(abs(i-equal[j]) <= k)\\n                ans.push_back(i);   \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans, equal;\\n        \\n\\t\\t//traversing through nums and put nums[i]==key into the vector\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==key)\\n                equal.push_back(i);\\n        }\\n        \\n        if(!equal.size()) return ans;\\n\\t\\t//j for traversing through vector of indices which value is equal to key\\n        int j=0;\\n        \\n\\t\\t//\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i > equal[j] && abs(i-equal[j]) > k && j<equal.size()-1)\\n            {\\n                j++;\\n            }\\n            \\n            if(abs(i-equal[j]) <= k)\\n                ans.push_back(i);   \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844238,
                "title": "java-clean-code-linear",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        //flagging those who should be in result\\n        boolean flag[] = new boolean[1001];\\n        \\n\\t\\t//O(N * K)\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            //if we found the key\\n            if (nums[i] == key) {\\n                \\n                //flag range  of (i - k, i + k)\\n                int j = i - k > 0 ? i - k : 0;\\n                for (; j <= i + k  && j < nums.length; j++) {\\n                    flag[j] =true;\\n                }\\n            }\\n        }\\n        \\n        //pack up\\n        //add flagged nums in list\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i = 0; i < 1001; i++) {\\n            if (flag[i]) {\\n                list.add(i);\\n        \\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nTC : O(N * K)\\nSC : O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        //flagging those who should be in result\\n        boolean flag[] = new boolean[1001];\\n        \\n\\t\\t//O(N * K)\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            //if we found the key\\n            if (nums[i] == key) {\\n                \\n                //flag range  of (i - k, i + k)\\n                int j = i - k > 0 ? i - k : 0;\\n                for (; j <= i + k  && j < nums.length; j++) {\\n                    flag[j] =true;\\n                }\\n            }\\n        }\\n        \\n        //pack up\\n        //add flagged nums in list\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i = 0; i < 1001; i++) {\\n            if (flag[i]) {\\n                list.add(i);\\n        \\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844170,
                "title": "java-code-hashset",
                "content": "\\n```\\n    //contest ANS ::::: 1\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int from = 0, till = 0;//just initialising you could do anything with it;\\n                from = Math.max((i - k), 0);\\n                till = Math.min((i + k), nums.length - 1);\\n                for (int j = from; j <= till; j++) set.add(j);\\n            }\\n        }\\n        for (int i : set) list.add(i);\\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //contest ANS ::::: 1\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int from = 0, till = 0;//just initialising you could do anything with it;\\n                from = Math.max((i - k), 0);\\n                till = Math.min((i + k), nums.length - 1);\\n                for (int j = from; j <= till; j++) set.add(j);\\n            }\\n        }\\n        for (int i : set) list.add(i);\\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844159,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    \\n    let ind = [];\\n    let ans = [];\\n    \\n    nums.forEach((val, i) => {\\n       if (val == key) {\\n           ind.push(i);\\n       } \\n    });\\n    \\n    let temp = new Set();\\n    for (let i = 0; i < ind.length; i++) {\\n        let mn = Math.max(ind[i]-k, 0);\\n        let mx = Math.min(Math.abs(ind[i]+k), nums.length-1);\\n    \\n        for (let j = mn; j <= mx; j++) {\\n            temp.add(j);\\n        } \\n    }\\n    \\n    return [...temp];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    \\n    let ind = [];\\n    let ans = [];\\n    \\n    nums.forEach((val, i) => {\\n       if (val == key) {\\n           ind.push(i);\\n       } \\n    });\\n    \\n    let temp = new Set();\\n    for (let i = 0; i < ind.length; i++) {\\n        let mn = Math.max(ind[i]-k, 0);\\n        let mx = Math.min(Math.abs(ind[i]+k), nums.length-1);\\n    \\n        for (let j = mn; j <= mx; j++) {\\n            temp.add(j);\\n        } \\n    }\\n    \\n    return [...temp];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844133,
                "title": "easy-o-n-solution-using-vector",
                "content": "\\n\\n     int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n     int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;",
                "codeTag": "Unknown"
            },
            {
                "id": 1844096,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> result=new ArrayList<>();\\n              \\n        List<Integer> keyIndex=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key)\\n           {   \\n               keyIndex.add(i);                                  // Get All keys index present in nums\\n           }\\n        }\\n              \\n        for(int i=0;i<nums.length;i++){\\n           for(int j:keyIndex){\\n               if(Math.abs(i-j)<=k){      \\n                    result.add(i);\\n                    break;\\n               }      \\n           }    \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> result=new ArrayList<>();\\n              \\n        List<Integer> keyIndex=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key)\\n           {   \\n               keyIndex.add(i);                                  // Get All keys index present in nums\\n           }\\n        }\\n              \\n        for(int i=0;i<nums.length;i++){\\n           for(int j:keyIndex){\\n               if(Math.abs(i-j)<=k){      \\n                    result.add(i);\\n                    break;\\n               }      \\n           }    \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954362,
                "title": "simple-cpp",
                "content": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n           vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        for(int j=0;j<nums.size();j++){\\n            //if found atleast one index , break and save\\n            if(abs(i-j)<=k and nums[j]==key){\\n                ans.push_back(i);\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n           vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        for(int j=0;j<nums.size();j++){\\n            //if found atleast one index , break and save\\n            if(abs(i-j)<=k and nums[j]==key){\\n                ans.push_back(i);\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876576,
                "title": "java-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList();\\n        int lastIncluded=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n            int from=Math.max(i-k , lastIncluded+1);\\n            int to=Math.min(i+k , nums.length-1);\\n             for(int j=from;j<=to;j++){\\n                     result.add(j);\\n             }\\n            \\n            lastIncluded=to;\\n            }\\n        }\\n      return result;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList();\\n        int lastIncluded=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n            int from=Math.max(i-k , lastIncluded+1);\\n            int to=Math.min(i+k , nums.length-1);\\n             for(int j=from;j<=to;j++){\\n                     result.add(j);\\n             }\\n            \\n            lastIncluded=to;\\n            }\\n        }\\n      return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850967,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849656,
                "title": "simple-javascript-solution-time-o-n-2-space-o-n",
                "content": "```javascript\\nfunction findKDistantIndices (nums, key, k) {\\n  const result = new Set() \\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (nums[j] === key && Math.abs(i - j) <= k) {\\n          result.add(i)\\n      }\\n    }\\n  }\\n  return Array.from(result)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\nfunction findKDistantIndices (nums, key, k) {\\n  const result = new Set() \\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (nums[j] === key && Math.abs(i - j) <= k) {\\n          result.add(i)\\n      }\\n    }\\n  }\\n  return Array.from(result)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847962,
                "title": "python-solution-with-explanation",
                "content": "Here in this code I have implemented its brute force concept for better understanding .\\nHere in this we first store all indexes where value is equal to key in list l , then we iterate over the entire nums list for every index value and at the same time iterate over every value in list l to check for every possible scenarios , so that we don\\'t miss any hidden cases . For better understanding remove \"#\"\\nin the code and run it once .\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l=[]\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n        \\n        if len(l)==0:\\n            return []\\n        \\n        lst=[]\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    #print(nums[i:j+1],nums[j:i+1],i,j)\\n                    if i<j and key in nums[i:j+1]:\\n                        lst.append(i)\\n                        break\\n                    if i>=j and key in nums[j:i+1]:\\n                        lst.append(i)\\n                        break\\n        return lst\\n```\\nIf u understood the code then plz....UPVOTE....Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l=[]\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n        \\n        if len(l)==0:\\n            return []\\n        \\n        lst=[]\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    #print(nums[i:j+1],nums[j:i+1],i,j)\\n                    if i<j and key in nums[i:j+1]:\\n                        lst.append(i)\\n                        break\\n                    if i>=j and key in nums[j:i+1]:\\n                        lst.append(i)\\n                        break\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845733,
                "title": "c-brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(abs(i - j) <= k && nums[j] == key) {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(abs(i - j) <= k && nums[j] == key) {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845615,
                "title": "c-easy-using-set-beginners-friendly",
                "content": "// Please Upvote if it helps\\u2B06\\uFE0F\\n\\n**Approach**\\n* Created a Set \\n* Iterate over the array\\n* If founded key , then check the condiiotn abs(i-j) for all other indices\\n* Store all indices in a vector\\n* Sort the vector before returning it\\n\\n**TC : O(N square)**\\n**SC: O(N)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k)\\n    {\\n        set<int> st;        // for storing the k distant indices (in set there is no duplicacy)\\n        \\n        // iterating over the given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // if element is our key \\n            if(nums[i] == key)\\n            {\\n                // just check for the all other indices that they satisfies the condition or not\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(abs(i-j) <= k)\\n                    {\\n                        st.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // created a vector for storing the ans\\n        vector<int> ans;\\n        for(int i : st)\\n        {\\n            ans.push_back(i);\\n        }\\n        \\n        // sort the vector in increasing order before returning it\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**TC : O(N square)**\\n**SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans;\\n        \\n        // make one pointer to point some index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // make another pointer that will find the index that will satisfy the given conditions\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                // if both the conditions are satisfied\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k && nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```\\n\\n// Please Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k)\\n    {\\n        set<int> st;        // for storing the k distant indices (in set there is no duplicacy)\\n        \\n        // iterating over the given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // if element is our key \\n            if(nums[i] == key)\\n            {\\n                // just check for the all other indices that they satisfies the condition or not\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(abs(i-j) <= k)\\n                    {\\n                        st.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // created a vector for storing the ans\\n        vector<int> ans;\\n        for(int i : st)\\n        {\\n            ans.push_back(i);\\n        }\\n        \\n        // sort the vector in increasing order before returning it\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans;\\n        \\n        // make one pointer to point some index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // make another pointer that will find the index that will satisfy the given conditions\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                // if both the conditions are satisfied\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k && nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845200,
                "title": "java-detail-explanation-merge-intervals-variation-o-n-time-o-n-space-3ms-solution",
                "content": "We can think of this solution as variation of [Merge Interval](https://leetcode.com/problems/merge-intervals/) question where instead of just merging intervals, we also need to list all values between intervals.\\n\\nNow, the question is how to get intervals. As given in the question, we need to list out all indexes that satisfy  `|i - j| <= k`. Which means that all indexes are accessible that are `k` distance away on left and right side of `nums[key]`.\\n\\n**Approach**\\nPass 1: **Intervals**:\\tWe don\\'t need to create intervals but we can simply store count of where each intervals start and end. Just go throgh array and for each `nums[i] == key` \\n* increase count `Math.max(0, i-k)` in the start array to mark as start of intervals\\n* decrese count at `Math.min(nums.length-1, i+k)` in the end array marking as end of interval.\\n \\nPass 2:  Go through each start and end intervlas arrays. If your current index is in atleast one of the interval, add in the result. \\n\\n**Example**\\nnums =` [6,3,4,9,3,9,5]`, key = 9, k = 2\\n\\nWe have nums[i] == key for i=3 and i=5. So, we will increase the count for i-2 and decrese the count at i+2;\\nFor i=3  :     start = `[0, 1, 0, 0, 0, 0, 0]`;  end = `[0, 0, 0, 0, 0, -1, 0]`\\nAfter i=5;  start = `[0, 1, 0, 1, 0, 0, 0]`; end = `[0, 0, 0, 0, 0, -1, -1]`\\n\\nWhen you are at i=0, your count = 0, don\\'t add in the result.\\nFor i=1 and i=2, count = 1, add in result.\\nFor i=3 and i=4, count = 2, add in result.  //It\\'s overlap of intervals\\nFor i=5, count = 1, add in result\\nfor i=6, count = 1, add in result. Since the intervals are inclusive, always remove from `end` at the end.\\n\\nfinal output: `[1, 2, 3, 4, 5, 6]`\\n\\n**Solution**:\\n\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> result = new ArrayList<>();      \\n\\t   int[] start = new int[nums.length];\\n        int[] end = new int[nums.length];\\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != key)\\n                continue;\\n            int min = Math.max(0, i-k);  //Prevent negative index\\n            int max = Math.min(nums.length-1, i+k);  //Prevent overflow \\n            start[min]++;\\n            end[max]--;\\n        }       \\n\\t\\t// Variable to keep track of index inside at least one interval. \\n\\t\\t// If positive, we are in, if 0, we are out.\\n        int reachable = 0;  \\n        for(int i=0; i<nums.length; i++) {\\n            reachable += start[i];\\n            if(reachable > 0)\\n                result.add(i);\\n            reachable += end[i];\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> result = new ArrayList<>();      \\n\\t   int[] start = new int[nums.length];\\n        int[] end = new int[nums.length];\\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != key)\\n                continue;\\n            int min = Math.max(0, i-k);  //Prevent negative index\\n            int max = Math.min(nums.length-1, i+k);  //Prevent overflow \\n            start[min]++;\\n            end[max]--;\\n        }       \\n\\t\\t// Variable to keep track of index inside at least one interval. \\n\\t\\t// If positive, we are in, if 0, we are out.\\n        int reachable = 0;  \\n        for(int i=0; i<nums.length; i++) {\\n            reachable += start[i];\\n            if(reachable > 0)\\n                result.add(i);\\n            reachable += end[i];\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844196,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> s;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[i] == key)\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(abs(i-j) <= k){\\n                    s.insert(j);\\n                }\\n            }\\n        }\\n        for(auto x : s){\\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> s;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[i] == key)\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(abs(i-j) <= k){\\n                    s.insert(j);\\n                }\\n            }\\n        }\\n        for(auto x : s){\\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844127,
                "title": "c-use-set-to-store-distinct-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        set<int> temp;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==key){\\n                for(int j=0; j<n; j++){\\n                    if(abs(i-j)<=k)\\n                        temp.insert(j);\\n                }\\n            }   \\n        }\\n        \\n        vector<int> ans;\\n        for(auto &it: temp)\\n            ans.push_back(it);\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if u like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        set<int> temp;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==key){\\n                for(int j=0; j<n; j++){\\n                    if(abs(i-j)<=k)\\n                        temp.insert(j);\\n                }\\n            }   \\n        }\\n        \\n        vector<int> ans;\\n        for(auto &it: temp)\\n            ans.push_back(it);\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690014,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }\\n            }\\n            if(index != -1) {\\n                al.add(index);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }\\n            }\\n            if(index != -1) {\\n                al.add(index);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359787,
                "title": "find-all-k-distant-indices-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> indices_of_key;\\n        vector<int> ans;\\n        int i, j;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                indices_of_key.push_back(i);\\n            }\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<indices_of_key.size() ; j++)\\n            {\\n                if(abs(i-indices_of_key[j])<=k)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> indices_of_key;\\n        vector<int> ans;\\n        int i, j;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                indices_of_key.push_back(i);\\n            }\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<indices_of_key.size() ; j++)\\n            {\\n                if(abs(i-indices_of_key[j])<=k)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167337,
                "title": "easy-solution-without-redundant-iterations",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const keyIndicies = nums.reduce((acc, num, i) => num === key ? [...acc, i] : acc, []);\\n    const res = [];\\n\\n    let lastIndex = 0;\\n    for (const index of keyIndicies) {\\n        const startIndex = Math.max(lastIndex, index - k);\\n        lastIndex = Math.min(index + k, nums.length - 1) + 1;\\n\\n        for (let i = startIndex; i < lastIndex; i++) {\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const keyIndicies = nums.reduce((acc, num, i) => num === key ? [...acc, i] : acc, []);\\n    const res = [];\\n\\n    let lastIndex = 0;\\n    for (const index of keyIndicies) {\\n        const startIndex = Math.max(lastIndex, index - k);\\n        lastIndex = Math.min(index + k, nums.length - 1) + 1;\\n\\n        for (let i = startIndex; i < lastIndex; i++) {\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062399,
                "title": "easy-c-solution-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key)\\n                 a=i;\\n            }\\n            if(a!=-1) \\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key)\\n                 a=i;\\n            }\\n            if(a!=-1) \\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846856,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-simplest-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key) a=i;\\n            }\\n            if(a!=-1) ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key) a=i;\\n            }\\n            if(a!=-1) ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838117,
                "title": "java-using-linkedhashset",
                "content": "1. I use LinkedHashSet to keep the order of indices (which is required by the description of the problem) and keep the indices unique.\\n2. I look for a number in the array equal to key. When I find it I add indices from i - k to i + k.\\n3. end = Math.min(i + k, nums.length - 1) - means that if i + k is more than nums.length - 1, then end is equal to nums.length - 1, else end = i + k;\\n4. j = Math.max(i - k, 0) - here the logic is the same: if i - k is less than 0, then j = 0, else j = i - k;\\n5. And in the end I convert set to ArrayList.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> set = new LinkedHashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int end = Math.min(i + k, nums.length - 1);\\n                for (int j = Math.max(i - k, 0); j <= end; j++) {\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> set = new LinkedHashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int end = Math.min(i + k, nums.length - 1);\\n                for (int j = Math.max(i - k, 0); j <= end; j++) {\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541334,
                "title": "golang-o-n",
                "content": "```go\\nfunc findKDistantIndices(nums []int, key int, k int) []int {\\n    var res []int\\n    resMap := make(map[int]struct{})\\n\\n    for i, v := range nums {\\n        if v == key {         \\n            for j := i - k; j <= i + k; j++ {\\n                if j < 0 || j >= len(nums) {\\n                    continue\\n                }\\n\\n                if _, ok := resMap[j]; !ok {\\n                    resMap[j] = struct{}{}\\n                    res = append(res, j)   \\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findKDistantIndices(nums []int, key int, k int) []int {\\n    var res []int\\n    resMap := make(map[int]struct{})\\n\\n    for i, v := range nums {\\n        if v == key {         \\n            for j := i - k; j <= i + k; j++ {\\n                if j < 0 || j >= len(nums) {\\n                    continue\\n                }\\n\\n                if _, ok := resMap[j]; !ok {\\n                    resMap[j] = struct{}{}\\n                    res = append(res, j)   \\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363675,
                "title": "python-simple-solution-tc-o-n",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        s = [0]*len(nums)\\n        \\n        x = -inf\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                x = i\\n            if i-x<=k:\\n                s[i] = 1\\n                \\n        x = inf\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i] == key:\\n                x = i\\n            if x-i<=k:\\n                s[i] = 1\\n        \\n        return [i for i in range(len(s)) if s[i]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        s = [0]*len(nums)\\n        \\n        x = -inf\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                x = i\\n            if i-x<=k:\\n                s[i] = 1\\n                \\n        x = inf\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i] == key:\\n                x = i\\n            if x-i<=k:\\n                s[i] = 1\\n        \\n        return [i for i in range(len(s)) if s[i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353287,
                "title": "java-simple-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] arr1, int key, int k) {\\n        List<Integer> l1= new ArrayList<Integer>();\\n        List<Integer> index =new ArrayList<Integer>();\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                index.add(i);\\n            }\\n        }\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            for(int j=0;j<index.size();j++)\\n            {\\n                int val=index.get(j);\\n                int res=Math.abs(i-val);    \\n                if(res<=k)\\n                {\\n                    l1.add(i);\\n                    break;\\n                }\\n            }            \\n        }\\n        return l1;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findKDistantIndices(int[] arr1, int key, int k) {\\n        List<Integer> l1= new ArrayList<Integer>();\\n        List<Integer> index =new ArrayList<Integer>();\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                index.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328738,
                "title": "simple-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int>v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j= 0; j<nums.size(); j++)\\n            {\\n                if(abs(i-j) <= k && nums[j] == key)\\n                {\\n                    v.push_back(i);\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int>v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j= 0; j<nums.size(); j++)\\n            {\\n                if(abs(i-j) <= k && nums[j] == key)\\n                {\\n                    v.push_back(i);\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2253007,
                "title": "python-easy-solution-without-using-external-function-fast-and-single-pass",
                "content": "Time :0(n) | Space : 0(n)\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        res_idx = set()\\n        n = len(nums)\\n        for idx in range(n):\\n            if key==nums[idx]:\\n                sp = idx - k if idx - k > 0 else 0\\n                ep = idx + k if idx + k < n else n-1\\n                for val in range(sp,ep+1):\\n                    res_idx.add(val)\\n                \\n        return list(res_idx)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Time :0(n) | Space : 0(n)\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        res_idx = set()\\n        n = len(nums)\\n        for idx in range(n):\\n            if key==nums[idx]:\\n                sp = idx - k if idx - k > 0 else 0\\n                ep = idx + k if idx + k < n else n-1\\n                for val in range(sp,ep+1):\\n                    res_idx.add(val)\\n                \\n        return list(res_idx)",
                "codeTag": "Java"
            },
            {
                "id": 1946245,
                "title": "simple-c-two-pointers-o-n-with-explanation",
                "content": "1. Start with **both l and h = 0**.\\n2. Keep incrementing h till **key is found**.\\n3. Once key is found, keep **incrementing l** till it covers all indices **within k distance on both sides of h**.\\n4. Once **|h - l| becomes larger than k**, increment **h** and keep **l** the same.\\n5. Repeat\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int l = 0, h = 0, n = nums.size();\\n        vector<int> res;\\n        while(h < n){\\n            if(nums[h] == key){ // If element is found\\n                if(abs(h - l) <= k && l < n){ // Check if it\\'s in k distance and l is in bound of array\\n                    res.push_back(l);\\n                    l++; \\n                }\\n                else{                                           \\n                    l>h ? h++ : l++;  // If l has exceded h, increment h (find key again if it exists, no need to reset l because \\n\\t\\t\\t\\t\\t                  //all indices that were in k distance of previous key have been added)\\n                }\\n            }\\n            else{ \\n                h++; // keep incrementing h till key is found\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int l = 0, h = 0, n = nums.size();\\n        vector<int> res;\\n        while(h < n){\\n            if(nums[h] == key){ // If element is found\\n                if(abs(h - l) <= k && l < n){ // Check if it\\'s in k distance and l is in bound of array\\n                    res.push_back(l);\\n                    l++; \\n                }\\n                else{                                           \\n                    l>h ? h++ : l++;  // If l has exceded h, increment h (find key again if it exists, no need to reset l because \\n\\t\\t\\t\\t\\t                  //all indices that were in k distance of previous key have been added)\\n                }\\n            }\\n            else{ \\n                h++; // keep incrementing h till key is found\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935772,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    static ArrayList<Integer> res;\\n    static int[] index;\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        res = new ArrayList<Integer>();\\n        index = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==key&&fun(i,k,nums.length-1))\\n                break;\\n        }\\n        int i=0;\\n        for(int x:index)\\n        {\\n            if(x>0)\\n            res.add(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    static boolean fun(int i,int k,int length)\\n    {\\n        int start = Math.max(0,i-k);\\n        int end = Math.min(length,i+k);\\n        for(int j=start;j<=end;j++)\\n            index[j]++;\\n    \\n        if(end==length)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/31f89a49-269a-4258-8545-501abea00c05_1649669250.2263286.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static ArrayList<Integer> res;\\n    static int[] index;\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        res = new ArrayList<Integer>();\\n        index = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==key&&fun(i,k,nums.length-1))\\n                break;\\n        }\\n        int i=0;\\n        for(int x:index)\\n        {\\n            if(x>0)\\n            res.add(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    static boolean fun(int i,int k,int length)\\n    {\\n        int start = Math.max(0,i-k);\\n        int end = Math.min(length,i+k);\\n        for(int j=start;j<=end;j++)\\n            index[j]++;\\n    \\n        if(end==length)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935075,
                "title": "one-pass-o-n-time-o-1-extra-space",
                "content": "Once you use find a key and add all elgible indexes, you need not process the indices already added. You can store the prev key index, and whenever you find a key at index i, you can start adding indixes from Math.max(prevKeyIndex+k+1, i-k).\\nThis way you process each index only once.\\n\\n```\\n public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> res = new ArrayList();\\n        int prevKeyIndex = -1;\\n        for (int i = 0; i < nums.length;i++) {\\n            if (nums[i] == key) {\\n                int start = i-k;\\n                int end = i+k;\\n                if (prevKeyIndex != -1) {\\n                    start = Math.max(prevKeyIndex+k+1, start);\\n                }\\n                for (int j=start; j <=end;j++) {\\n                    if (j >= 0 && j < nums.length)\\n                        res.add(j);\\n                }\\n                prevKeyIndex = i;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> res = new ArrayList();\\n        int prevKeyIndex = -1;\\n        for (int i = 0; i < nums.length;i++) {\\n            if (nums[i] == key) {\\n                int start = i-k;\\n                int end = i+k;\\n                if (prevKeyIndex != -1) {\\n                    start = Math.max(prevKeyIndex+k+1, start);\\n                }\\n                for (int j=start; j <=end;j++) {\\n                    if (j >= 0 && j < nums.length)\\n                        res.add(j);\\n                }\\n                prevKeyIndex = i;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895259,
                "title": "find-all-k-distance-indices-in-an-array",
                "content": "\\'\\'\\'**we use ans variable for cheacking there is no dublicates indices push in vector \\nits a brute force its  take more than 100ms but work on all test cases .**\\nvector <int v;\\n        int ans=-1;\\n        int i=0,j=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=nums.size()-1;j>=0;j--){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    if(i!=ans){\\n                    v.push_back(i);\\n                        ans=i;\\n                    }\\n                    else\\n                        continue;\\n                }\\n            }\\n        }\\n     return v;\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'**we use ans variable for cheacking there is no dublicates indices push in vector \\nits a brute force its  take more than 100ms but work on all test cases .**\\nvector <int v;\\n        int ans=-1;\\n        int i=0,j=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=nums.size()-1;j>=0;j--){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    if(i!=ans){\\n                    v.push_back(i);\\n                        ans=i;\\n                    }\\n                    else\\n                        continue;\\n                }\\n            }\\n        }\\n     return v;\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1886150,
                "title": "python-3-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = []\\n        high = -1\\n        n = len(nums)\\n\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                for j in range(max(high + 1, i - k), min(n, i + k + 1)):\\n                    res.append(j)\\n                high = i + k\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = []\\n        high = -1\\n        n = len(nums)\\n\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                for j in range(max(high + 1, i - k), min(n, i + k + 1)):\\n                    res.append(j)\\n                high = i + k\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1876262,
                "title": "c-two-pointers-easy-to-understand-single-pass-o-n-time",
                "content": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n\\tvector<int> ans;\\n\\n\\t// Let i = index tracker and j = (last k-index added to `ans`) + 1\\n\\tfor(int i = 0, j = 0; i < nums.size(); ++i)\\n\\t\\tif(nums[i] == key) {\\n\\t\\t\\tj = max(j, i - k); // find the next k-index to add\\n\\t\\t\\twhile(j < nums.size() && j <= i + k) // add k-index\\'s till i + k\\n\\t\\t\\t\\tans.push_back(j++);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n\\tvector<int> ans;\\n\\n\\t// Let i = index tracker and j = (last k-index added to `ans`) + 1\\n\\tfor(int i = 0, j = 0; i < nums.size(); ++i)\\n\\t\\tif(nums[i] == key) {\\n\\t\\t\\tj = max(j, i - k); // find the next k-index to add\\n\\t\\t\\twhile(j < nums.size() && j <= i + k) // add k-index\\'s till i + k\\n\\t\\t\\t\\tans.push_back(j++);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1853807,
                "title": "java-2ms-without-sorting",
                "content": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> indices = new ArrayList<>();\\n        int i=0;\\n        for(int j=0; j<nums.length; j++) {\\n            if(nums[j] == key) {\\n                if(indices.size() == 0) {\\n                    i=0;\\n                } else {\\n                    i=indices.get(indices.size()-1)+1;\\n                }\\n                i=Math.max(j-k,i);\\n                int end = Math.min(j+k,nums.length-1);\\n                    \\n                for(; i<=end; i++) {\\n                    indices.add(i);                        \\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> indices = new ArrayList<>();\\n        int i=0;\\n        for(int j=0; j<nums.length; j++) {\\n            if(nums[j] == key) {\\n                if(indices.size() == 0) {\\n                    i=0;\\n                } else {\\n                    i=indices.get(indices.size()-1)+1;\\n                }\\n                i=Math.max(j-k,i);\\n                int end = Math.min(j+k,nums.length-1);\\n                    \\n                for(; i<=end; i++) {\\n                    indices.add(i);                        \\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850392,
                "title": "python-o-n-solution-find-index-range-around-key",
                "content": "Similar to the concept of absolute value, find the index within the distance of *k* from the index of given key:\\n\\n![image](https://assets.leetcode.com/users/images/6d556ea7-9891-4472-b334-e2bd7d0f0435_1647397141.1234796.png)\\nSuppose the red line is a list. The *k*-distance index of key1 is within the range of (j-k, j+k+1). \\n\\n```\\nkc = [i for i in range(len(nums)) if nums[i] == key]\\nans = []\\nfor j in kc:\\n\\tans += list(range(max(j-k, 0), min(j+k+1, len(nums))))\\n\\nreturn list(set(ans))\\n```",
                "solutionTags": [],
                "code": "```\\nkc = [i for i in range(len(nums)) if nums[i] == key]\\nans = []\\nfor j in kc:\\n\\tans += list(range(max(j-k, 0), min(j+k+1, len(nums))))\\n\\nreturn list(set(ans))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846739,
                "title": "python3-scan",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = []\\n        ii = 0\\n        for i, x in enumerate(nums): \\n            if x == key: \\n                lo, hi = max(ii, i-k), min(i+k+1, len(nums))\\n                ans.extend(list(range(lo, hi)))\\n                ii = hi\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = []\\n        ii = 0\\n        for i, x in enumerate(nums): \\n            if x == key: \\n                lo, hi = max(ii, i-k), min(i+k+1, len(nums))\\n                ans.extend(list(range(lo, hi)))\\n                ii = hi\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846065,
                "title": "java-two-loops-o-n",
                "content": "- iterate over the array \\n- when the key is found at nums[i], loop j from i-k to i+k to add to answer (remember j=i+k as jMax)\\n- when you find the next key, don\\'t loop from i-k, but from jMax i.e. max(i-k, jMax), to avoid adding same indices again\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tList<Integer> ans= new ArrayList<>();\\n\\tfor(int n= nums.length, i=0, j, jMax= 0; i<n && jMax<n; i++)\\n\\t\\tif(nums[i]==key)\\n\\t\\t\\tfor(j= Math.max(jMax, i-k), jMax= Math.min(n, i+k+1); j<jMax; j++)\\n\\t\\t\\t\\tans.add(j);\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "- iterate over the array \\n- when the key is found at nums[i], loop j from i-k to i+k to add to answer (remember j=i+k as jMax)\\n- when you find the next key, don\\'t loop from i-k, but from jMax i.e. max(i-k, jMax), to avoid adding same indices again\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tList<Integer> ans= new ArrayList<>();\\n\\tfor(int n= nums.length, i=0, j, jMax= 0; i<n && jMax<n; i++)\\n\\t\\tif(nums[i]==key)\\n\\t\\t\\tfor(j= Math.max(jMax, i-k), jMax= Math.min(n, i+k+1); j<jMax; j++)\\n\\t\\t\\t\\tans.add(j);\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1845257,
                "title": "find-all-k-distance-indices-in-an-array-80-faster-solution",
                "content": "class Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t    l = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n  \\n        ans = set()\\n        if len(nums) == len(l):\\n            for i in range(len(nums)):\\n                ans.add(i)\\n\\t\\t\\t\\t\\n        else:       \\n            if max(l)+k+1 <= len(nums):\\n                t = max(l)+k+1\\n            else:\\n                t = len(nums)\\n\\t\\t\\t\\t\\n            for i in l:\\n                for  j in range(t):\\n                    if(abs(j-i)<=k):\\n                        ans.add(i)\\n                        ans.add(j)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "class Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t    l = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n  \\n        ans = set()\\n        if len(nums) == len(l):\\n            for i in range(len(nums)):\\n                ans.add(i)\\n\\t\\t\\t\\t\\n        else:       \\n            if max(l)+k+1 <= len(nums):\\n                t = max(l)+k+1\\n            else:\\n                t = len(nums)\\n\\t\\t\\t\\t\\n            for i in l:\\n                for  j in range(t):\\n                    if(abs(j-i)<=k):\\n                        ans.add(i)\\n                        ans.add(j)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1845210,
                "title": "find-all-k-distance-easy-understandable",
                "content": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=max(0,i-k);\\n            for(j; j<n&&j<=i+k;j++)\\n            {\\n                if(nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=max(0,i-k);\\n            for(j; j<n&&j<=i+k;j++)\\n            {\\n                if(nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844914,
                "title": "simple-python-time-o-n-space-o-number-of-keys-without-sorting",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n       \\n\\t    l = len(nums)\\n        index = [i for i in range(l) if nums[i] == key]\\n        res =[]\\n        pointer = 0\\n        x = len(index)\\n        \\n        for i in range(l):\\n            \\n            if i == k+index[pointer] and  pointer+1 < x:\\n                \\n                if abs(i-index[pointer]) <= k:\\n                    res.append(i)\\n                \\n                pointer += 1\\n            \\n            elif i == index[pointer]:\\n                res.append(i)\\n            \\n            elif abs(i-index[pointer]) <= k:\\n                res.append(i)\\n\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n       \\n\\t    l = len(nums)\\n        index = [i for i in range(l) if nums[i] == key]\\n        res =[]\\n        pointer = 0\\n        x = len(index)\\n        \\n        for i in range(l):\\n            \\n            if i == k+index[pointer] and  pointer+1 < x:\\n                \\n                if abs(i-index[pointer]) <= k:\\n                    res.append(i)\\n                \\n                pointer += 1\\n            \\n            elif i == index[pointer]:\\n                res.append(i)\\n            \\n            elif abs(i-index[pointer]) <= k:\\n                res.append(i)\\n\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844788,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>ans;\\n        unordered_set<int>res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(abs(i-j)<=k && nums[i]==key){\\n                    res.insert(j);\\n                }\\n            }\\n        }\\n        for(int x:res)ans.push_back(x);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>ans;\\n        unordered_set<int>res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(abs(i-j)<=k && nums[i]==key){\\n                    res.insert(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1844665,
                "title": "brute-force-using-extra-space",
                "content": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> index;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==key){\\n                index.push_back(i);\\n            }\\n        }\\n        if(index.size()==0){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<index.size();j++){\\n                if(abs(index[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> index;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==key){\\n                index.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1844621,
                "title": "javascript-simple-solution-o-n",
                "content": "```\\nvar findKDistantIndices = function(nums, key, k) {\\n    const res = [];\\n    let j = 0;\\n    let i = 0;\\n    while(i < nums.length) {\\n        if(Math.abs(i-j) <= k && nums[j] === key ) {\\n            res.push(i);\\n            i++;\\n        }\\n        if(j - i > k) {\\n            i++;\\n        }\\n        if(nums[j] !== key || i - j > k){\\n            j++;\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findKDistantIndices = function(nums, key, k) {\\n    const res = [];\\n    let j = 0;\\n    let i = 0;\\n    while(i < nums.length) {\\n        if(Math.abs(i-j) <= k && nums[j] === key ) {\\n            res.push(i);\\n            i++;\\n        }\\n        if(j - i > k) {\\n            i++;\\n        }\\n        if(nums[j] !== key || i - j > k){\\n            j++;\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844620,
                "title": "java-solution-without-sorting",
                "content": "```\\n List<Integer> al = new ArrayList<>();\\n        List<Integer> idx = new ArrayList<>();\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            for(int j = 0; j<idx.size() ; j++){\\n                if(Math.abs(i - idx.get(j)) <= k){\\n                    if(!al.contains(i)) al.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return al;\\n```",
                "solutionTags": [],
                "code": "```\\n List<Integer> al = new ArrayList<>();\\n        List<Integer> idx = new ArrayList<>();\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            for(int j = 0; j<idx.size() ; j++){\\n                if(Math.abs(i - idx.get(j)) <= k){\\n                    if(!al.contains(i)) al.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return al;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844457,
                "title": "c-2200-find-all-k-distant-indices-in-an-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans; \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) \\n            if (nums[i] == key) \\n                for (ii = max(ii, i-k); ii <= i+k && ii < nums.size(); ++ii) \\n                    ans.push_back(ii); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans; \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) \\n            if (nums[i] == key) \\n                for (ii = max(ii, i-k); ii <= i+k && ii < nums.size(); ++ii) \\n                    ans.push_back(ii); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844451,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                \\n                for j in range(len(nums)):\\n                    if abs(i-j)<=k and j not in res:\\n                        res.append(j)\\n                if len(res)==len(nums):\\n                    return res\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                \\n                for j in range(len(nums)):\\n                    if abs(i-j)<=k and j not in res:\\n                        res.append(j)\\n                if len(res)==len(nums):\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844400,
                "title": "python-5-lines",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = set()\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))\\n        return sorted(list(res))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = set()\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))\\n        return sorted(list(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844373,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int startIndex = 0;\\n        List<Integer> kDistantIndices = new ArrayList<>();\\n        for(int idx = 0; idx < nums.length; idx += 1) {\\n            if(nums[idx] == key) {\\n                for(int rangeIdx = Math.max(idx - k, startIndex); rangeIdx <= Math.min(nums.length - 1, idx + k); rangeIdx += 1) {\\n                    kDistantIndices.add(rangeIdx);\\n                }\\n                startIndex = idx + k + 1;\\n            }\\n        }\\n        return kDistantIndices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int startIndex = 0;\\n        List<Integer> kDistantIndices = new ArrayList<>();\\n        for(int idx = 0; idx < nums.length; idx += 1) {\\n            if(nums[idx] == key) {\\n                for(int rangeIdx = Math.max(idx - k, startIndex); rangeIdx <= Math.min(nums.length - 1, idx + k); rangeIdx += 1) {\\n                    kDistantIndices.add(rangeIdx);\\n                }\\n                startIndex = idx + k + 1;\\n            }\\n        }\\n        return kDistantIndices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844346,
                "title": "python-simple-brute-force",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n = len(nums)\\n        res = set()\\n        for i in range(n):\\n            if nums[i] == key:\\n                for j in range(i-k,i+k+1):\\n                    if j >=0 and j <= n-1:\\n                        res.add(j)\\n        return res    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n = len(nums)\\n        res = set()\\n        for i in range(n):\\n            if nums[i] == key:\\n                for j in range(i-k,i+k+1):\\n                    if j >=0 and j <= n-1:\\n                        res.add(j)\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844310,
                "title": "c-brute-force-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> key_index;\\n        vector<int> ans;\\n        for(int j = 0; j < nums.size(); j++){\\n            if (nums[j] == key)\\n                key_index.push_back(j);\\n        }\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j : key_index){\\n                if (abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> key_index;\\n        vector<int> ans;\\n        for(int j = 0; j < nums.size(); j++){\\n            if (nums[j] == key)\\n                key_index.push_back(j);\\n        }\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j : key_index){\\n                if (abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844232,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        bool f=false;\\n        vector <int> ans;\\n        for(int i=0;i<n;i++){\\n \\n            for(int l=0;l<k+1;l++)\\n            {\\n                if((i+l)<n && nums[i+l]==key){\\n                    f=true;\\n                    break;\\n                }\\n                if((i-l)>=0 && nums[i-l]==key )\\n                {\\n                    f=true;\\n                    break;\\n                }\\n            } \\n            if(f==true)\\n                ans.push_back(i);\\n            \\n            f=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        bool f=false;\\n        vector <int> ans;\\n        for(int i=0;i<n;i++){\\n \\n            for(int l=0;l<k+1;l++)\\n            {\\n                if((i+l)<n && nums[i+l]==key){\\n                    f=true;\\n                    break;\\n                }\\n                if((i-l)>=0 && nums[i-l]==key )\\n                {\\n                    f=true;\\n                    break;\\n                }\\n            } \\n            if(f==true)\\n                ans.push_back(i);\\n            \\n            f=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844167,
                "title": "c-easiest-solution-ever-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> index,res;\\n        int n=nums.size();\\n        \\n\\t\\t//storing index of all [j] in vector\\n        for(int i=0;i<n;i++)\\n            if(key==nums[i])\\n                index.push_back(i);\\n      \\n\\t  //comparing each possible solution\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            \\n            for(auto j:index){\\n                if(abs(i-j) <= k){ //if condition true\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> index,res;\\n        int n=nums.size();\\n        \\n\\t\\t//storing index of all [j] in vector\\n        for(int i=0;i<n;i++)\\n            if(key==nums[i])\\n                index.push_back(i);\\n      \\n\\t  //comparing each possible solution\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            \\n            for(auto j:index){\\n                if(abs(i-j) <= k){ //if condition true\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844155,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> ans=new ArrayList<Integer>();\\n    List<Integer> list=new ArrayList<Integer>();\\n    int n = nums.length;\\n        for(int i = 0 ; i < n ;i++){\\n            if(nums[i] == key)\\n            list.add(i);  \\n        }\\n            for(int i = 0 ; i < n ; i++){\\n                for(Integer j : list){\\n                    if(Math.abs(i-j) <= k){\\n                        ans.add(i);\\n                        break;\\n                }\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> ans=new ArrayList<Integer>();\\n    List<Integer> list=new ArrayList<Integer>();\\n    int n = nums.length;\\n        for(int i = 0 ; i < n ;i++){\\n            if(nums[i] == key)\\n            list.add(i);  \\n        }\\n            for(int i = 0 ; i < n ; i++){\\n                for(Integer j : list){\\n                    if(Math.abs(i-j) <= k){\\n                        ans.add(i);\\n                        break;\\n                }\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844137,
                "title": "clean-python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n, ans = len(nums), []\\n        keys_index = [i for i in range(n) if nums[i] == key] # Holds the indices of all elements equal to key.\\n        m = len(keys_index)\\n        for i in range(n):\\n            for j in range(m):\\n                if abs(i - keys_index[j]) <= k: # If the conditions are met then add ith index to the answer array.\\n                    ans.append(i)\\n                    break\\n        return sorted(ans) # Return sorted ans according to problem\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n, ans = len(nums), []\\n        keys_index = [i for i in range(n) if nums[i] == key] # Holds the indices of all elements equal to key.\\n        m = len(keys_index)\\n        for i in range(n):\\n            for j in range(m):\\n                if abs(i - keys_index[j]) <= k: # If the conditions are met then add ith index to the answer array.\\n                    ans.append(i)\\n                    break\\n        return sorted(ans) # Return sorted ans according to problem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844125,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> inx;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key)  inx.push_back(i);\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<inx.size(); j++){\\n                if(abs(i-inx[j]) <= k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> inx;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key)  inx.push_back(i);\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<inx.size(); j++){\\n                if(abs(i-inx[j]) <= k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074276,
                "title": "simple-and-fast-solution-o-n",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans, n, left = [], len(nums), 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                right = min(i+k+1, n)\\n                ans.extend(range(max(i-k, left), right))\\n                left = right\\n        return ans      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans, n, left = [], len(nums), 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                right = min(i+k+1, n)\\n                ans.extend(range(max(i-k, left), right))\\n                left = right\\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067871,
                "title": "simple-short-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> ans{};\\n\\n        int high{-1}, n = nums.size();\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(nums[i] == key){\\n\\n                for(int j = max(high + 1, i - k); j <= i + k && j < n; j++){\\n                    ans.push_back(j);\\n                }\\n\\n                high = i + k;\\n                if(high >= n) break;\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> ans{};\\n\\n        int high{-1}, n = nums.size();\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(nums[i] == key){\\n\\n                for(int j = max(high + 1, i - k); j <= i + k && j < n; j++){\\n                    ans.push_back(j);\\n                }\\n\\n                high = i + k;\\n                if(high >= n) break;\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058097,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> result;\\n        int idx = 0;\\n        while (idx < nums.size())\\n        {\\n            if (nums[idx] == key)\\n            {\\n                int l = std::max<int>(0, idx - k);\\n                if (result.size() > 0)\\n                {\\n                    l = std::max<int>(l, result[result.size() - 1] + 1);\\n                }\\n                int r = std::min<int>(nums.size() - 1, idx + k);\\n                for (int i = l; i <= r; i++)\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> result;\\n        int idx = 0;\\n        while (idx < nums.size())\\n        {\\n            if (nums[idx] == key)\\n            {\\n                int l = std::max<int>(0, idx - k);\\n                if (result.size() > 0)\\n                {\\n                    l = std::max<int>(l, result[result.size() - 1] + 1);\\n                }\\n                int r = std::min<int>(nums.size() - 1, idx + k);\\n                for (int i = l; i <= r; i++)\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010541,
                "title": "easy-fast-solution-beats-96-84",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987437,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Reach the ith element having the nums[i] == key, then insert i-k to i+k indexes into the set.\\n- Here, we have used set as there are chances of indexes begin repeated.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> st;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j=i-k >= 0 ? i-k : 0; j<=i+k && j < nums.size(); j++)\\n                    st.insert(j);\\n            }\\n        }\\n\\n        return vector<int>(st.begin(), st.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> st;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j=i-k >= 0 ? i-k : 0; j<=i+k && j < nums.size(); j++)\\n                    st.insert(j);\\n            }\\n        }\\n\\n        return vector<int>(st.begin(), st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983218,
                "title": "priority-queue-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        priority_queue<int, vector<int> , greater<int> > pq;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] == key){\\n                pq.push(i);\\n                \\n            }\\n        }\\n        \\n        for(int i =0 ;i<nums.size();i++){\\n            int diff = i - pq.top();\\n            if(abs(diff) <= k){\\n                ans.push_back(i);\\n            }\\n            else{\\n                if(diff > 0 && diff > k){\\n                    pq.pop();\\n                    if(abs(i - pq.top()) <=k ) ans.push_back(i);\\n                }\\n            }\\n            \\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        priority_queue<int, vector<int> , greater<int> > pq;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] == key){\\n                pq.push(i);\\n                \\n            }\\n        }\\n        \\n        for(int i =0 ;i<nums.size();i++){\\n            int diff = i - pq.top();\\n            if(abs(diff) <= k){\\n                ans.push_back(i);\\n            }\\n            else{\\n                if(diff > 0 && diff > k){\\n                    pq.pop();\\n                    if(abs(i - pq.top()) <=k ) ans.push_back(i);\\n                }\\n            }\\n            \\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970928,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findKDistantIndices(\\n  nums: number[], \\n  key: number, \\n  k: number\\n): number[] {\\n  const list = [];\\n\\n  for (let i = 0, j = 0; i < nums.length; i++) {\\n    if (nums[i] == key) {\\n      for (j = Math.max(j, i - k); j <= i + k && j < nums.length; j++) {\\n        list.push(j);\\n      }\\n    }\\n  }\\n\\n  return list;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findKDistantIndices(\\n  nums: number[], \\n  key: number, \\n  k: number\\n): number[] {\\n  const list = [];\\n\\n  for (let i = 0, j = 0; i < nums.length; i++) {\\n    if (nums[i] == key) {\\n      for (j = Math.max(j, i - k); j <= i + k && j < nums.length; j++) {\\n        list.push(j);\\n      }\\n    }\\n  }\\n\\n  return list;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962371,
                "title": "c-simplified",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) maybe\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959909,
                "title": "find-all-k-distant-indices-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        System.out.println(nums.length);\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        int j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            while(j<nums.length&&(nums[j]!=key||i-j>k))\\n            {\\n                ++j;\\n            }\\n            if(j==nums.length)\\n            break;\\n            if(Math.abs(i-j)<=k)\\n            ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        System.out.println(nums.length);\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        int j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            while(j<nums.length&&(nums[j]!=key||i-j>k))\\n            {\\n                ++j;\\n            }\\n            if(j==nums.length)\\n            break;\\n            if(Math.abs(i-j)<=k)\\n            ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959189,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    if(list.contains(i)){\\n\\n                    }\\n                    else{\\n                        list.add(i);\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    if(list.contains(i)){\\n\\n                    }\\n                    else{\\n                        list.add(i);\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955587,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indices = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                indices.append(i)\\n        \\n        res = set()\\n\\n        for i in indices:\\n            for j in range(len(nums)):\\n                if abs(i-j) <= k:\\n                    res.add(j)\\n        \\n        res = list(res)\\n        res.sort()\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indices = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                indices.append(i)\\n        \\n        res = set()\\n\\n        for i in indices:\\n            for j in range(len(nums)):\\n                if abs(i-j) <= k:\\n                    res.add(j)\\n        \\n        res = list(res)\\n        res.sort()\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947054,
                "title": "simple-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947049,
                "title": "using-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919173,
                "title": "simple-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        ArrayList<Integer> idxsofkeys = new ArrayList<>();\\n        for(int i=0 ;i <n;i++){\\n            if(nums[i]==key) idxsofkeys.add(i);\\n        }\\n        int m = idxsofkeys.size();\\n        ArrayList<Integer> res = new ArrayList<>();boolean condtnmet;\\n        for(int i=0;i<n;i++){\\n            condtnmet = false;\\n            for(int j=0;j<m&&!condtnmet;j++){\\n                if(Math.abs(i-idxsofkeys.get(j))<=k){\\n                    res.add(i);condtnmet=true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        ArrayList<Integer> idxsofkeys = new ArrayList<>();\\n        for(int i=0 ;i <n;i++){\\n            if(nums[i]==key) idxsofkeys.add(i);\\n        }\\n        int m = idxsofkeys.size();\\n        ArrayList<Integer> res = new ArrayList<>();boolean condtnmet;\\n        for(int i=0;i<n;i++){\\n            condtnmet = false;\\n            for(int j=0;j<m&&!condtnmet;j++){\\n                if(Math.abs(i-idxsofkeys.get(j))<=k){\\n                    res.add(i);condtnmet=true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908221,
                "title": "easy-approach-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n        int n=a.size();\\n        // v is used to store indices of keys\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==key)v.push_back(i);\\n        }\\n        // if key is not present\\n        if(v.size()==0)return v;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int tmp=INT_MAX;\\n            for(auto j:v){\\n                // get the minimum distance from all key\\n                tmp=min(tmp,abs(i-j));\\n            }\\n            if(tmp!=INT_MAX && tmp<=k)ans.push_back(i);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n        int n=a.size();\\n        // v is used to store indices of keys\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==key)v.push_back(i);\\n        }\\n        // if key is not present\\n        if(v.size()==0)return v;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int tmp=INT_MAX;\\n            for(auto j:v){\\n                // get the minimum distance from all key\\n                tmp=min(tmp,abs(i-j));\\n            }\\n            if(tmp!=INT_MAX && tmp<=k)ans.push_back(i);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902422,
                "title": "simple-java-solution-time-o-n-space-o-n-for-the-o-p-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) \\n    {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (nums == null || nums.length == 0)\\n            return result;\\n\\n        int n = nums.length;\\n        int nextStartIndex = 0;\\n        int currentStartIndex = 0;\\n        int currentEndIndex = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                currentStartIndex = i - k < 0 ? 0 : i - k;\\n                currentEndIndex = i + k >= n ? n - 1 : i + k;\\n                currentStartIndex = currentStartIndex < nextStartIndex ? nextStartIndex : currentStartIndex;\\n\\n                for(int j = currentStartIndex; j <= currentEndIndex; j++)\\n                {\\n                    result.add(j);\\n                }\\n\\n                nextStartIndex = currentEndIndex + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) \\n    {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (nums == null || nums.length == 0)\\n            return result;\\n\\n        int n = nums.length;\\n        int nextStartIndex = 0;\\n        int currentStartIndex = 0;\\n        int currentEndIndex = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                currentStartIndex = i - k < 0 ? 0 : i - k;\\n                currentEndIndex = i + k >= n ? n - 1 : i + k;\\n                currentStartIndex = currentStartIndex < nextStartIndex ? nextStartIndex : currentStartIndex;\\n\\n                for(int j = currentStartIndex; j <= currentEndIndex; j++)\\n                {\\n                    result.add(j);\\n                }\\n\\n                nextStartIndex = currentEndIndex + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880184,
                "title": "python-single-pass-with-set-no-sort-5-line",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        ans, n = set(), len(nums)\\n        for i in range(n):\\n            if nums[i]==key:\\n                ans.update( range(max(0,i-k),min(n,i+k+1)) )\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        ans, n = set(), len(nums)\\n        for i in range(n):\\n            if nums[i]==key:\\n                ans.update( range(max(0,i-k),min(n,i+k+1)) )\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862551,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer>al=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n            if(Math.abs(i-j)<=k && nums[j]==key){\\n                al.add(i);\\n                break;\\n            }\\n        }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer>al=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n            if(Math.abs(i-j)<=k && nums[j]==key){\\n                al.add(i);\\n                break;\\n            }\\n        }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851790,
                "title": "java-easy-solution",
                "content": "class Solution {\\n   public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    \\t\\n    \\tList<Integer> ind=new ArrayList<>();\\n    \\tList<Integer> ans=new ArrayList<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\tif(nums[i]==key)\\n    \\t\\t\\tind.add(i);\\n    \\t}\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\t\\n    \\t\\tboolean p=false;\\n    \\t\\tfor(int j:ind) {\\n    \\t\\t\\tif(Math.abs(i-j)<=k) {\\n    \\t\\t\\t\\tp=true;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(p) ans.add(i);\\n    \\t}\\n    \\treturn ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    \\t\\n    \\tList<Integer> ind=new ArrayList<>();\\n    \\tList<Integer> ans=new ArrayList<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\tif(nums[i]==key)\\n    \\t\\t\\tind.add(i);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3824822,
                "title": "beat-100-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const indices = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) {\\n            indices.push(i);\\n        }\\n    }\\n\\n    const results = [];\\n\\n    // iterate nums\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let indice of indices) {\\n            if (Math.abs(i - indice) <= k) {\\n                results.push(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const indices = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) {\\n            indices.push(i);\\n        }\\n    }\\n\\n    const results = [];\\n\\n    // iterate nums\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let indice of indices) {\\n            if (Math.abs(i - indice) <= k) {\\n                results.push(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803254,
                "title": "one-pass-go-golang-solution",
                "content": "```\\nfunc findKDistantIndices(nums []int, key, k int) []int {\\n        res := make([]int, 0)\\n\\n        for i := 0; i < len(nums); i++ {\\n                if num := nums[i]; num == key {\\n                        startIdx := i - k\\n                        endIdx := i + k\\n\\n                        if startIdx < 0 {                                                       startIdx = 0\\n                        }\\n\\n                        if len(res) > 0 && res[len(res)-1] >= startIdx {\\n                                startIdx = res[len(res)-1] + 1\\n                        }\\n\\n                        if endIdx > len(nums)-1 {\\n                                endIdx = len(nums) - 1\\n                        }\\n\\n                        for j := startIdx; j <= endIdx; j++ {\\n                                res = append(res, j)\\n                        }\\n                }\\n        }\\n\\n        return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findKDistantIndices(nums []int, key, k int) []int {\\n        res := make([]int, 0)\\n\\n        for i := 0; i < len(nums); i++ {\\n                if num := nums[i]; num == key {\\n                        startIdx := i - k\\n                        endIdx := i + k\\n\\n                        if startIdx < 0 {                                                       startIdx = 0\\n                        }\\n\\n                        if len(res) > 0 && res[len(res)-1] >= startIdx {\\n                                startIdx = res[len(res)-1] + 1\\n                        }\\n\\n                        if endIdx > len(nums)-1 {\\n                                endIdx = len(nums) - 1\\n                        }\\n\\n                        for j := startIdx; j <= endIdx; j++ {\\n                                res = append(res, j)\\n                        }\\n                }\\n        }\\n\\n        return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797325,
                "title": "short-and-simple-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let see=[];\\n    for(var i=0;i<nums.length;i++){\\n        if(nums[i]==key){see.push(i)}\\n    }\\n    let ans=[];\\n    for(var i=0;i<nums.length;i++){\\n        for(var j=0;j<see.length;j++){\\n            dif=see[j]-i;\\n            if(dif<0) dif=0-dif;\\n            if(dif<=k){ans.push(i); break;}\\n        }\\n    } return ans;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let see=[];\\n    for(var i=0;i<nums.length;i++){\\n        if(nums[i]==key){see.push(i)}\\n    }\\n    let ans=[];\\n    for(var i=0;i<nums.length;i++){\\n        for(var j=0;j<see.length;j++){\\n            dif=see[j]-i;\\n            if(dif<0) dif=0-dif;\\n            if(dif<=k){ans.push(i); break;}\\n        }\\n    } return ans;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754311,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> output = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        output.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return output.stream().sorted().collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> output = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        output.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return output.stream().sorted().collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741402,
                "title": "python-easy-to-understand-beats-99-63",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\\n        # Create list of k_distant indices.\\n        k_distant = []\\n        \\n        # Set last checked index.\\n        last_checked = 0\\n\\n        for i, num in enumerate(nums):\\n            # All indices around the key element would be appropriate for k_distant.\\n            if num == key:\\n                # Go through indices around key element.\\n                # Also adjust left border according to the last_checked and\\n                # make sure, that right border are in the list.\\n                for j in range(max(last_checked, i-k), min(i+k+1, len(nums))):\\n                    k_distant.append(j)\\n\\n                # Update last_checked.\\n                last_checked = i+k+1\\n                \\n                # last_checked >= len(nums) means that all elements were already checked.\\n                if last_checked >= len(nums):\\n                    break\\n\\n        return k_distant\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\\n        # Create list of k_distant indices.\\n        k_distant = []\\n        \\n        # Set last checked index.\\n        last_checked = 0\\n\\n        for i, num in enumerate(nums):\\n            # All indices around the key element would be appropriate for k_distant.\\n            if num == key:\\n                # Go through indices around key element.\\n                # Also adjust left border according to the last_checked and\\n                # make sure, that right border are in the list.\\n                for j in range(max(last_checked, i-k), min(i+k+1, len(nums))):\\n                    k_distant.append(j)\\n\\n                # Update last_checked.\\n                last_checked = i+k+1\\n                \\n                # last_checked >= len(nums) means that all elements were already checked.\\n                if last_checked >= len(nums):\\n                    break\\n\\n        return k_distant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740612,
                "title": "beats-96-63-time-complexity-of-2ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n//         ArrayList<Integer> list = new ArrayList<>();\\n//         List<Integer> pos=position(key,nums);\\n//         for(int i=0;i<nums.length;i++){\\n//             for(int j=0;j<pos.size();j++){\\n//                 int diff= (int)Math.abs(i-pos.get(j));\\n//                 if(diff<=k){\\n//                     list.add(i);\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return list;\\n//     }\\n//     public List<Integer> position(int key,int nums[]){\\n//         ArrayList<Integer> pos = new ArrayList<>();\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]==key){\\n//                 pos.add(i);\\n//             }\\n//         }\\n//         return pos;\\n//     }\\n// }\\nclass Solution {\\n     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n         ArrayList<Integer> list = new ArrayList<>();\\n         int pos=position(0,key,nums);\\n         for(int i=0; i<nums.length;i++)\\n         {\\n             if(i>=pos-k && i<=pos+k){\\n                 list.add(i);\\n                 if(nums[i]==key){\\n                     pos=i;\\n                 }\\n             }\\n             else{\\n                 pos=position(i,key,nums);\\n                 if(pos==-1){\\n                     break;\\n                 }\\n                 else if(i>=pos-k && i<=pos+k){\\n                    list.add(i);\\n                 }\\n             }\\n         }\\n         return list;\\n     }\\n     public static int position(int p,int key,int nums[]){\\n         for(int i=p;i<nums.length;i++){\\n             if(nums[i]==key){\\n                return i;\\n             }\\n         }\\n         return -1;\\n    }\\n }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n//         ArrayList<Integer> list = new ArrayList<>();\\n//         List<Integer> pos=position(key,nums);\\n//         for(int i=0;i<nums.length;i++){\\n//             for(int j=0;j<pos.size();j++){\\n//                 int diff= (int)Math.abs(i-pos.get(j));\\n//                 if(diff<=k){\\n//                     list.add(i);\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return list;\\n//     }\\n//     public List<Integer> position(int key,int nums[]){\\n//         ArrayList<Integer> pos = new ArrayList<>();\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]==key){\\n//                 pos.add(i);\\n//             }\\n//         }\\n//         return pos;\\n//     }\\n// }\\nclass Solution {\\n     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n         ArrayList<Integer> list = new ArrayList<>();\\n         int pos=position(0,key,nums);\\n         for(int i=0; i<nums.length;i++)\\n         {\\n             if(i>=pos-k && i<=pos+k){\\n                 list.add(i);\\n                 if(nums[i]==key){\\n                     pos=i;\\n                 }\\n             }\\n             else{\\n                 pos=position(i,key,nums);\\n                 if(pos==-1){\\n                     break;\\n                 }\\n                 else if(i>=pos-k && i<=pos+k){\\n                    list.add(i);\\n                 }\\n             }\\n         }\\n         return list;\\n     }\\n     public static int position(int p,int key,int nums[]){\\n         for(int i=p;i<nums.length;i++){\\n             if(nums[i]==key){\\n                return i;\\n             }\\n         }\\n         return -1;\\n    }\\n }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724129,
                "title": "java-simple-explained",
                "content": "**Idea:** Collect the k distant elements\\' indices from any nums[i] = key. To avoid overlap, keep a common pointer (j) to resume from where you left for previous key\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tvar j = 0;\\n\\tvar n = nums.length;\\n\\tvar indices = new ArrayList<Integer>();\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] == key)\\n\\t\\t\\tfor (j = Math.max(j, i - k); j <= Math.min(i + k, n - 1); j++)\\n\\t\\t\\t\\tindices.add(j);\\n\\n\\treturn indices;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tvar j = 0;\\n\\tvar n = nums.length;\\n\\tvar indices = new ArrayList<Integer>();\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] == key)\\n\\t\\t\\tfor (j = Math.max(j, i - k); j <= Math.min(i + k, n - 1); j++)\\n\\t\\t\\t\\tindices.add(j);\\n\\n\\treturn indices;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723977,
                "title": "easiest-sol-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> li = new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=0;j<nums.length;j++){\\n               if(nums[j]==key && Math.abs(i-j)<=k){\\n                   li.add(i);\\n                   break;\\n               }\\n           }\\n       }\\n       return li; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> li = new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=0;j<nums.length;j++){\\n               if(nums[j]==key && Math.abs(i-j)<=k){\\n                   li.add(i);\\n                   break;\\n               }\\n           }\\n       }\\n       return li; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696067,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let arr = [];\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key) arr.push(i);  \\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let flag = false;\\n        for (let j = 0; j < arr.length; j++){\\n            if (Math.abs(i - arr[j]) <= k && !flag){\\n                result.push(i);\\n                flag = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let arr = [];\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key) arr.push(i);  \\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let flag = false;\\n        for (let j = 0; j < arr.length; j++){\\n            if (Math.abs(i - arr[j]) <= k && !flag){\\n                result.push(i);\\n                flag = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678643,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        //unordered_set<int> s;\\n\\n        for (int i=0 ; i<nums.size() ; i++){\\n            // if (i>k)\\n            //     s.erase(nums[i-k-1]);\\n            \\n            // if (s.count(key)>0 || nums[i]==key)\\n            //     ans.push_back(i);\\n            \\n            // s.insert(nums[i]);\\n            if (nums[i] == key){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            auto start = nums.begin() + max(i-k , 0);\\n            auto end = nums.begin() + min(i+k+1 , n);\\n            int occurrences = count(start , end , key);\\n            if (occurrences>0)\\n                ans.push_back(i);\\n        }\\n\\n        sort(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        //unordered_set<int> s;\\n\\n        for (int i=0 ; i<nums.size() ; i++){\\n            // if (i>k)\\n            //     s.erase(nums[i-k-1]);\\n            \\n            // if (s.count(key)>0 || nums[i]==key)\\n            //     ans.push_back(i);\\n            \\n            // s.insert(nums[i]);\\n            if (nums[i] == key){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            auto start = nums.begin() + max(i-k , 0);\\n            auto end = nums.begin() + min(i+k+1 , n);\\n            int occurrences = count(start , end , key);\\n            if (occurrences>0)\\n                ans.push_back(i);\\n        }\\n\\n        sort(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671952,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;   \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) \\n            {\\n                int start = max(0, i-k);   \\n                int end = min(n-1, i+k);  \\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;   \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) \\n            {\\n                int start = max(0, i-k);   \\n                int end = min(n-1, i+k);  \\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655242,
                "title": "python-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keyLis=[]\\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                keyLis.append(i)\\n        for i in range(len(nums)):\\n            for j in keyLis:\\n                if abs(i-j)<=k:\\n                    res.append(i)\\n                    break\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keyLis=[]\\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                keyLis.append(i)\\n        for i in range(len(nums)):\\n            for j in keyLis:\\n                if abs(i-j)<=k:\\n                    res.append(i)\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648630,
                "title": "java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we use at our advantage the fact that \"k\" defines how many indices are \"close\" to a key occurrence, namely all indices inside num[j] +/- k are what is considered as a k-distant index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find the occurrences of num[x] = key, and around them find the k-distant indices. The formula is simple: all indices between num[x] - k < num[x] < num[x] + k, where num[x] == key, should be part of the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n). \\n\\nWe iterate over the array to get the occurrences of key, and then we iterate over the occurrences and their k-distant indices. We use an optimization which saves us from visiting repeated indices. At worst case we visit the whole array 2 times, which is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as we create a new array for the result.\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        var coincidences = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) coincidences.add(i);\\n        }\\n\\n        int lastIdx = -1;\\n\\n        var result = new ArrayList<Integer>();\\n        for (Integer coincidence: coincidences) {\\n            for (int j = Math.max(0, Math.max(lastIdx, coincidence-k)); j <= Math.min(coincidence + k, nums.length-1); j++) {\\n                result.add(j);\\n                lastIdx = j+1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        var coincidences = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) coincidences.add(i);\\n        }\\n\\n        int lastIdx = -1;\\n\\n        var result = new ArrayList<Integer>();\\n        for (Integer coincidence: coincidences) {\\n            for (int j = Math.max(0, Math.max(lastIdx, coincidence-k)); j <= Math.min(coincidence + k, nums.length-1); j++) {\\n                result.add(j);\\n                lastIdx = j+1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619623,
                "title": "java-noob-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =0; i<nums.length; i++){\\n            if(nums[i]==key){\\n                for(int j =list.size(); j<nums.length; j++){\\n                    if(Math.abs(i-j)<=k){\\n                        if(!list.contains(j))\\n                         list.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =0; i<nums.length; i++){\\n            if(nums[i]==key){\\n                for(int j =list.size(); j<nums.length; j++){\\n                    if(Math.abs(i-j)<=k){\\n                        if(!list.contains(j))\\n                         list.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602808,
                "title": "easy-to-understand-explaination",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: look for all indices whose value == key\\nStep 2: While traversing find the key to processing element and check the condition. \\n\\n# Complexity\\n- Time complexity: O(nlog) as we are checking for each and every element in the treeset\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n) as TreeSet used hold all the indices whose value matched with key. In worst case all element in array is equal to key.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        TreeSet<Integer> keyIdx = new TreeSet<>();\\n        // Let find all the index where key == nums[index];\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key)\\n                keyIdx.add(i); // log(n) to add an element\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        // Lets traverse for each element to find it distance from nearest key index\\n        for(int i = 0; i < nums.length; i++){\\n            \\n            // check the left side of the index\\n            Integer lowerIdx = keyIdx.floor(i); //log(n) to search the nearest element\\n\\n            if(lowerIdx != null){\\n                if(i-lowerIdx <= k){\\n                    ans.add(i);\\n                    continue; // now check the next element.\\n                }\\n            } \\n\\n// if left side index key not found or is greater than K then check on it right side\\n            Integer higherIdx = keyIdx.ceiling(i); //log(n) to search the nearest element\\n            if(higherIdx != null){\\n                if(higherIdx-i <= k){\\n                    ans.add(i);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        TreeSet<Integer> keyIdx = new TreeSet<>();\\n        // Let find all the index where key == nums[index];\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key)\\n                keyIdx.add(i); // log(n) to add an element\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        // Lets traverse for each element to find it distance from nearest key index\\n        for(int i = 0; i < nums.length; i++){\\n            \\n            // check the left side of the index\\n            Integer lowerIdx = keyIdx.floor(i); //log(n) to search the nearest element\\n\\n            if(lowerIdx != null){\\n                if(i-lowerIdx <= k){\\n                    ans.add(i);\\n                    continue; // now check the next element.\\n                }\\n            } \\n\\n// if left side index key not found or is greater than K then check on it right side\\n            Integer higherIdx = keyIdx.ceiling(i); //log(n) to search the nearest element\\n            if(higherIdx != null){\\n                if(higherIdx-i <= k){\\n                    ans.add(i);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578123,
                "title": "easy-logic-and-13ms-solutions-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int len = nums.size();\\n        vector<int>vals;\\n        vector<int>ans;\\n        for(int i =0 ; i<len; i++){  // stores all the index of the keys.\\n            if(nums[i]==key){\\n                vals.push_back(i);\\n            }\\n        }\\n\\n        //for travelling and checking each index with the keys index if (i - vals[i]) < = k\\n        //  if ture -> push the i index in array and break\\n\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==key){  /*this if checks , if the value at ith is same as key \\n                                then simply push the index in ans array*/\\n                ans.push_back(i);\\n                continue;\\n            } \\n            else{\\n                for(int j=0 ; j<vals.size(); j++){\\n                    if(abs(i-vals[j])<=k){\\n                        cout<<abs(i-vals[j])<<endl;\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //noted we are traversing i from 0 to n so ans is already sorted!!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int len = nums.size();\\n        vector<int>vals;\\n        vector<int>ans;\\n        for(int i =0 ; i<len; i++){  // stores all the index of the keys.\\n            if(nums[i]==key){\\n                vals.push_back(i);\\n            }\\n        }\\n\\n        //for travelling and checking each index with the keys index if (i - vals[i]) < = k\\n        //  if ture -> push the i index in array and break\\n\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==key){  /*this if checks , if the value at ith is same as key \\n                                then simply push the index in ans array*/\\n                ans.push_back(i);\\n                continue;\\n            } \\n            else{\\n                for(int j=0 ; j<vals.size(); j++){\\n                    if(abs(i-vals[j])<=k){\\n                        cout<<abs(i-vals[j])<<endl;\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //noted we are traversing i from 0 to n so ans is already sorted!!\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3575807,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] == key){\\n                    if(abs(i-j)<=k) {\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] == key){\\n                    if(abs(i-j)<=k) {\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572879,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n            List<Integer> res = new ArrayList<>() , holder = new ArrayList<>();\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == key)\\n                holder.add(i);\\n        }\\n        for (int i=0;i<nums.length;i++){\\n            for (int n : holder){\\n                if (Math.abs(i-n) <=k){\\n                    res.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n            List<Integer> res = new ArrayList<>() , holder = new ArrayList<>();\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == key)\\n                holder.add(i);\\n        }\\n        for (int i=0;i<nums.length;i++){\\n            for (int n : holder){\\n                if (Math.abs(i-n) <=k){\\n                    res.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518043,
                "title": "this-is-not-effective-solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int> ans;\\n       unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j = 0; j < nums.size(); j++){\\n                    if(mp[j] == 0 && abs(i - j) <= k){\\n                        ans.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int> ans;\\n       unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j = 0; j < nums.size(); j++){\\n                    if(mp[j] == 0 && abs(i - j) <= k){\\n                        ans.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498162,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let res = []; // [2, 5]\\\\\\n    let curRes = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key){\\n            res.push(i);\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let isAdded = false;\\n        for (let j = 0; j < res.length; j++){\\n            if (Math.abs(i - res[j]) <= k && !isAdded){\\n                curRes.push(i);\\n                isAdded = true;\\n            }\\n        }\\n    }\\n    return curRes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let res = []; // [2, 5]\\\\\\n    let curRes = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key){\\n            res.push(i);\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let isAdded = false;\\n        for (let j = 0; j < res.length; j++){\\n            if (Math.abs(i - res[j]) <= k && !isAdded){\\n                curRes.push(i);\\n                isAdded = true;\\n            }\\n        }\\n    }\\n    return curRes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481917,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> keyset = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] == key) {\\n                keyset.add(i);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            for (int ke : keyset) {\\n\\n                if (Math.abs(ke - i) <= k) {\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> keyset = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] == key) {\\n                keyset.add(i);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            for (int ke : keyset) {\\n\\n                if (Math.abs(ke - i) <= k) {\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480840,
                "title": "java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                int rang1 = i-k;\\n                int rang2 = i+k;\\n                if(rang1<0){\\n                    rang1=0;\\n                }\\n                if(rang2>nums.length-1){\\n                    rang2 = nums.length-1;\\n                }\\n                for(int j=rang1;j<=rang2;j++){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        for(int ke:set){\\n            ans.add(ke);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                int rang1 = i-k;\\n                int rang2 = i+k;\\n                if(rang1<0){\\n                    rang1=0;\\n                }\\n                if(rang2>nums.length-1){\\n                    rang2 = nums.length-1;\\n                }\\n                for(int j=rang1;j<=rang2;j++){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        for(int ke:set){\\n            ans.add(ke);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466328,
                "title": "find-all-k-distant-indices-js-easy-to-understand-70-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/e3f31571-69e3-4270-ba5d-ba668476a473_1682776087.9805954.png)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    result = []                                 // store result\\n    arr_keys = []                               // store all nums keys indexes\\n    \\n    for (let i = 0; i < nums.length; i++) {     // get all keys indexes in nums\\n        if (nums[i] == key) arr_keys.push(i)\\n    }    \\n\\n    for (x of arr_keys) {                       // fill with \\'0\\' all nums[keys] on left && right for k value\\n        fix(x)\\n    }    \\n\\n    for (let i = 0; i < nums.length; i++) {     // all indexes with \\'0\\' in nums add to result array\\n        if (nums[i] == 0) result.push(i)\\n    }\\n\\n    return result                               // return result as answer\\n\\n    function fix(x) {                           // fill nums with \\'0\\' on left && right from nums[x] with k size\\n        left = Math.max(0, x - k)\\n        right = Math.min(nums.length - 1, x + k)\\n        \\n        for (let i = left; i <= right; i++) {\\n            nums[i] = 0\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    result = []                                 // store result\\n    arr_keys = []                               // store all nums keys indexes\\n    \\n    for (let i = 0; i < nums.length; i++) {     // get all keys indexes in nums\\n        if (nums[i] == key) arr_keys.push(i)\\n    }    \\n\\n    for (x of arr_keys) {                       // fill with \\'0\\' all nums[keys] on left && right for k value\\n        fix(x)\\n    }    \\n\\n    for (let i = 0; i < nums.length; i++) {     // all indexes with \\'0\\' in nums add to result array\\n        if (nums[i] == 0) result.push(i)\\n    }\\n\\n    return result                               // return result as answer\\n\\n    function fix(x) {                           // fill nums with \\'0\\' on left && right from nums[x] with k size\\n        left = Math.max(0, x - k)\\n        right = Math.min(nums.length - 1, x + k)\\n        \\n        for (let i = left; i <= right; i++) {\\n            nums[i] = 0\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464974,
                "title": "find-all-k-distant-indices-in-an-array-using-c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n     \\n        vector<int>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            int a =-1;\\n            for(int j=0; j<n; j++) // for matching the key\\n            {\\n              if(abs(i-j)<=k && nums[j]==key) //conditions \\n              {\\n                  a =i;\\n              }\\n            }\\n            if(a!=-1)\\n            {\\n                ans.push_back(a);\\n            } \\n        }\\n        return ans;  \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n     \\n        vector<int>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            int a =-1;\\n            for(int j=0; j<n; j++) // for matching the key\\n            {\\n              if(abs(i-j)<=k && nums[j]==key) //conditions \\n              {\\n                  a =i;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3458389,
                "title": "solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty array called: output\\n2. Create a for loop that goes throught every index in nums\\n3. Create an other for loop that goes throught every index in nums.\\n4. Check conditions: \\n    - Absolute (i-j) <= k  (  i is index in first for loop, j is index in secend for loop)\\n    - nums[j] == key\\n5. If conditions are true: append index i in to output array (then break out of the second for loop \\n6. Return output\\n# Complexity\\n- Time complexity:\\n    On2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- On\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\\n        var output : [Int] = []\\n        for i in 0...nums.count-1 {\\n            for j in 0...nums.count-1 {\\n                if abs(i-j) <= k && nums[j] == key {\\n                    output.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\\n        var output : [Int] = []\\n        for i in 0...nums.count-1 {\\n            for j in 0...nums.count-1 {\\n                if abs(i-j) <= k && nums[j] == key {\\n                    output.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446477,
                "title": "java-simple-solution-bruteforce-treeset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> kDistantIndicies = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        kDistantIndicies.add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(kDistantIndicies);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> kDistantIndicies = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        kDistantIndicies.add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(kDistantIndicies);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441524,
                "title": "100-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const result = []\\n    let keys = []\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) keys.push(i)\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (isKDistantIndex(i)) result.push(i)\\n    }\\n\\n\\n    return result\\n\\n    function isKDistantIndex(index) {\\n        for (const el of keys) {\\n            if (Math.abs(index - el) <= k) return true\\n        }\\n\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const result = []\\n    let keys = []\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) keys.push(i)\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (isKDistantIndex(i)) result.push(i)\\n    }\\n\\n\\n    return result\\n\\n    function isKDistantIndex(index) {\\n        for (const el of keys) {\\n            if (Math.abs(index - el) <= k) return true\\n        }\\n\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432752,
                "title": "83-submission",
                "content": "# Intuition\\nfor finding key we either use traverse whole array but it will give not optimize as key will be smaller or equal than array size so storing key and checking min key index to current index will optimize\\n\\n# Approach\\nfirst store key as will check only directly those index which have key ,then check one by one element as soon we found index-key index is less than k store it into ans array otherwise check for next key index till either index-key index is less than k or not found\\n\\n# Complexity\\n- Time complexity:\\no(n*no.of key)\\n\\n- Space complexity:\\no(no of key + no of valid index)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++) if(nums[i]==key) a.push_back(i);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<a.size();j++){\\n                if(abs(a[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++) if(nums[i]==key) a.push_back(i);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<a.size();j++){\\n                if(abs(a[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428316,
                "title": "java-treeset-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo store indexes of keys in TreeSet. \\nThen in cycle getting closest key indexes from TreeSet and compare. \\n\\n# Approach\\nTreeSet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m))\\nwhere n - elements in array\\nwhere m - freequency of key in array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key){\\n                set.add(i);\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            Integer higerIndex = set.ceiling(i);\\n            Integer lowerIndex = set.floor(i);\\n            higerIndex = higerIndex == null ? Integer.MAX_VALUE : higerIndex;\\n            lowerIndex = lowerIndex == null ? Integer.MAX_VALUE : lowerIndex;\\n            \\n            if(Math.abs(higerIndex - i) <= k || Math.abs(lowerIndex - i) <= k){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key){\\n                set.add(i);\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            Integer higerIndex = set.ceiling(i);\\n            Integer lowerIndex = set.floor(i);\\n            higerIndex = higerIndex == null ? Integer.MAX_VALUE : higerIndex;\\n            lowerIndex = lowerIndex == null ? Integer.MAX_VALUE : lowerIndex;\\n            \\n            if(Math.abs(higerIndex - i) <= k || Math.abs(lowerIndex - i) <= k){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418662,
                "title": "find-all-k-distant-indices-in-an-array-easiest-with-c-in-0ms-runtime",
                "content": "![image.png](https://assets.leetcode.com/users/images/716c88ed-0345-48ec-b791-fe02b37d4843_1681542492.5761387.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>index;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == key)\\n                index.push_back(i);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(auto j:index){\\n                if(abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>index;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == key)\\n                index.push_back(i);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(auto j:index){\\n                if(abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402046,
                "title": "rust-4ms-fast-enough",
                "content": "```\\nimpl Solution {\\n    pub fn find_k_distant_indices(nums: Vec<i32>, key: i32, k: i32) -> Vec<i32> {\\n        let indexes: Vec<_> = nums\\n            .iter()\\n            .enumerate()\\n            .filter(|&(_, x)| x == &key)\\n            .map(|(i, _)| i as i32)\\n            .collect();\\n\\n        let mut res = vec![];\\n\\n        for i in 0..nums.len() as i32 {\\n            if indexes.contains(&i) {\\n                res.push(i);\\n                continue;\\n            }\\n            for j in &indexes {\\n                if (i - j).abs() <= k {\\n                    res.push(i)\\n                }\\n            }\\n        }\\n        res.dedup();\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_k_distant_indices(nums: Vec<i32>, key: i32, k: i32) -> Vec<i32> {\\n        let indexes: Vec<_> = nums\\n            .iter()\\n            .enumerate()\\n            .filter(|&(_, x)| x == &key)\\n            .map(|(i, _)| i as i32)\\n            .collect();\\n\\n        let mut res = vec![];\\n\\n        for i in 0..nums.len() as i32 {\\n            if indexes.contains(&i) {\\n                res.push(i);\\n                continue;\\n            }\\n            for j in &indexes {\\n                if (i - j).abs() <= k {\\n                    res.push(i)\\n                }\\n            }\\n        }\\n        res.dedup();\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364029,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        List<Integer> keyIndices = new ArrayList<>();\\n        List<Integer> result = new ArrayList<>();\\n\\n        for (int i = 0; i<n; i++)\\n        {\\n            if (nums[i] == key)\\n                keyIndices.add(i);\\n        }\\n        if (keyIndices.isEmpty())\\n            return result;\\n        \\n        int index = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n            while (index < keyIndices.size())\\n            {\\n                if (Math.abs(i-keyIndices.get(index)) <=k)\\n                {\\n                    result.add(i);\\n                    break;\\n                }\\n                else if (i > keyIndices.get(index))\\n                    index++;\\n                else\\n                    break;\\n            }\\n            \\n            if (index >= keyIndices.size())\\n                return result;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        List<Integer> keyIndices = new ArrayList<>();\\n        List<Integer> result = new ArrayList<>();\\n\\n        for (int i = 0; i<n; i++)\\n        {\\n            if (nums[i] == key)\\n                keyIndices.add(i);\\n        }\\n        if (keyIndices.isEmpty())\\n            return result;\\n        \\n        int index = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n            while (index < keyIndices.size())\\n            {\\n                if (Math.abs(i-keyIndices.get(index)) <=k)\\n                {\\n                    result.add(i);\\n                    break;\\n                }\\n                else if (i > keyIndices.get(index))\\n                    index++;\\n                else\\n                    break;\\n            }\\n            \\n            if (index >= keyIndices.size())\\n                return result;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355084,
                "title": "swift-solution-with-explanations",
                "content": "# Approach\\n1. Create an empty array called ans\\n2. Create a for loop that goes through every index in nums\\n3. Create another for loop that goes through every index in nums\\n4. If the current number in nums is equal to the key and the absolute difference between the current index of the first for loop and the current index of the second for loop is less than or equal to k\\n5. Append the current index of the first for loop to ans\\n6. Break out of the second for loop\\n7. Return ans\\n\\n- Note that this code is not the most efficient way to solve the problem, but it gets the job done.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] \\n    {\\n        var ans = [Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            for j in 0..<nums.count\\n            {\\n                if nums[j] == key && abs(i - j) <= k\\n                {\\n                    ans.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution \\n{\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] \\n    {\\n        var ans = [Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            for j in 0..<nums.count\\n            {\\n                if nums[j] == key && abs(i - j) <= k\\n                {\\n                    ans.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354640,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums.length; j++){\\n                if(nums[j] == key && Math.abs(i - j) <=k){\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums.length; j++){\\n                if(nums[j] == key && Math.abs(i - j) <=k){\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336890,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $key\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function findKDistantIndices($nums, $key, $k) {\\n        $res = [];\\n\\n        for($i = 0; $i < count($nums); $i++){\\n            for($j = 0; $j < count($nums); $j++){\\n                    if(abs($i - $j) <= $k && $nums[$j] == $key){\\n                        array_push($res, $i);\\n                        break;\\n                    }\\n            }\\n        }\\n        sort($res);\\n        return $res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $key\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function findKDistantIndices($nums, $key, $k) {\\n        $res = [];\\n\\n        for($i = 0; $i < count($nums); $i++){\\n            for($j = 0; $j < count($nums); $j++){\\n                    if(abs($i - $j) <= $k && $nums[$j] == $key){\\n                        array_push($res, $i);\\n                        break;\\n                    }\\n            }\\n        }\\n        sort($res);\\n        return $res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305931,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indicies = []\\n\\n        for i in range(len(nums)):\\n            if key in nums[max(0, i-k):min(len(nums), i+k+1)]:\\n                indicies.append(i)\\n        \\n        return indicies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indicies = []\\n\\n        for i in range(len(nums)):\\n            if key in nums[max(0, i-k):min(len(nums), i+k+1)]:\\n                indicies.append(i)\\n        \\n        return indicies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290769,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        int len = nums.length;\\n        List<Integer> l = new ArrayList<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < len; j++) {\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    l.add(i);\\n                }\\n            }\\n        }\\n\\n        return l.stream().collect(Collectors.toSet()).stream().sorted().toList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        int len = nums.length;\\n        List<Integer> l = new ArrayList<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < len; j++) {\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    l.add(i);\\n                }\\n            }\\n        }\\n\\n        return l.stream().collect(Collectors.toSet()).stream().sorted().toList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285375,
                "title": "python-very-nice-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        idxkeys = [idx for idx, i in enumerate(nums) if i == key]\\n        ll = []\\n        for idx, i in enumerate(nums):\\n            for ky in idxkeys:\\n                if abs(idx - ky) <= k:\\n                    ll.append(idx)\\n                    break\\n        return ll\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        idxkeys = [idx for idx, i in enumerate(nums) if i == key]\\n        ll = []\\n        for idx, i in enumerate(nums):\\n            for ky in idxkeys:\\n                if abs(idx - ky) <= k:\\n                    ll.append(idx)\\n                    break\\n        return ll\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269249,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        arr = []\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                arr.append(i)\\n        for i in range(len(nums)):\\n            for j in arr:\\n                if abs(i-j) <= k:\\n                    ans.append(i)\\n                    break\\n        return ans\\n\\n\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        arr = []\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                arr.append(i)\\n        for i in range(len(nums)):\\n            for j in arr:\\n                if abs(i-j) <= k:\\n                    ans.append(i)\\n                    break\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265171,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> idx = new ArrayList<>();\\n    List<Integer> ans = new ArrayList<>();\\n    for(int i = 0 ; i < nums.length; i++){\\n        if(nums[i] == key){\\n            idx.add(i);\\n        }\\n    }\\n    int last = 0;\\n    for(int ind : idx){\\n        int i = Math.max(last,ind-k);\\n        for(; i <= ind+k && i < nums.length; i++){\\n            ans.add(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let idx = [];\\n    let ans = [];\\n    for (let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] === key){\\n            idx.push(i);\\n        }\\n    }\\n    let last = 0;\\n    for (let ind of idx) {\\n        let i = Math.max(last, ind - k);\\n        for(; i <= ind + k && i < nums.length; i++){\\n            ans.push(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> idx = new ArrayList<>();\\n    List<Integer> ans = new ArrayList<>();\\n    for(int i = 0 ; i < nums.length; i++){\\n        if(nums[i] == key){\\n            idx.add(i);\\n        }\\n    }\\n    int last = 0;\\n    for(int ind : idx){\\n        int i = Math.max(last,ind-k);\\n        for(; i <= ind+k && i < nums.length; i++){\\n            ans.add(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let idx = [];\\n    let ans = [];\\n    for (let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] === key){\\n            idx.push(i);\\n        }\\n    }\\n    let last = 0;\\n    for (let ind of idx) {\\n        let i = Math.max(last, ind - k);\\n        for(; i <= ind + k && i < nums.length; i++){\\n            ans.push(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3240226,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indexes = []\\n        res = []\\n        for i,j in enumerate(nums):\\n            if j == key:\\n                indexes.append(i)\\n        for t in range(len(nums)):\\n            for yy in indexes:\\n                if abs(yy-t) <= k:\\n                    res.append(t)\\n                    break\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indexes = []\\n        res = []\\n        for i,j in enumerate(nums):\\n            if j == key:\\n                indexes.append(i)\\n        for t in range(len(nums)):\\n            for yy in indexes:\\n                if abs(yy-t) <= k:\\n                    res.append(t)\\n                    break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236106,
                "title": "sliding-window-approach-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the indices of elements that are k distances away from the given key in a given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a sliding window approach to find the indices. We can keep a window of size nk+1 (where nk is 2k+1), and slide this window through the array. For each position i, we check if the element i-k-1 is the key, then decrement the count of keys. If the element i+k is the key, then we increment the count of keys. If the count of keys is greater than zero, we add the index i to our result.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$ for sorting the result vector after finding the indices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the result vector and the count of keys.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.size();\\n        vector<int> res;\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.push_back(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.add(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.add(i);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.size();\\n        vector<int> res;\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.push_back(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.add(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.add(i);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233981,
                "title": "c-hashset-solution-o-n-2-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate through the array to identify all the index where nums[index] == key - store the info in HashSet.\\n2. Iterate through the array to check if the condition of |j - i| <= k.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) - this solution provides clear view on solving the problem, but it unfortunately expensive one of O(n^2).  An optimized solution of O(n) is available - posted by others for other languages.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) {\\n\\n        var set = new HashSet<int>();\\n        var result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == key) set.Add(i);\\n        }\\n\\n        for (int j = 0; j < nums.Length; j++)\\n        {\\n            foreach (var index in set)\\n            {\\n                if (Math.Abs(j - index) <= k)  \\n                { result.Add(j); break; } \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) {\\n\\n        var set = new HashSet<int>();\\n        var result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == key) set.Add(i);\\n        }\\n\\n        for (int j = 0; j < nums.Length; j++)\\n        {\\n            foreach (var index in set)\\n            {\\n                if (Math.Abs(j - index) <= k)  \\n                { result.Add(j); break; } \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215175,
                "title": "find-all-k-distant-indices-in-an-array",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l = []\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                l.append(i)\\n        # print(l)\\n        p = []\\n        # count = 0\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    p.append(i)\\n                    break\\n                    \\n                    # count+=1\\n        # print(count)\\n        p.sort()\\n        return (p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l = []\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                l.append(i)\\n        # print(l)\\n        p = []\\n        # count = 0\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    p.append(i)\\n                    break\\n                    \\n                    # count+=1\\n        # print(count)\\n        p.sort()\\n        return (p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214537,
                "title": "simple-solution-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n       Set<Integer> set = new HashSet<>();\\n\\n       for (int i = 0; i < nums.length; i++) {\\n           for (int j = 0; j < nums.length; j++) {\\n               if (nums[j] == key && Math.abs(i - j) <= k)\\n                set.add(i);\\n           }\\n       } \\n        List<Integer> list = new ArrayList<Integer>(set);\\n        \\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n       Set<Integer> set = new HashSet<>();\\n\\n       for (int i = 0; i < nums.length; i++) {\\n           for (int j = 0; j < nums.length; j++) {\\n               if (nums[j] == key && Math.abs(i - j) <= k)\\n                set.add(i);\\n           }\\n       } \\n        List<Integer> list = new ArrayList<Integer>(set);\\n        \\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214136,
                "title": "scala-oneliner",
                "content": "```\\nobject Solution {\\n  def findKDistantIndices(nums: Array[Int], key: Int, k: Int): List[Int] =\\n    nums.iterator.zipWithIndex.filter(_._1 == key).map(_._2).to(Set)\\n      .flatMap{i:Int => (0.max(i-k) to (i+k).min(nums.size-1))}.toList.sorted\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def findKDistantIndices(nums: Array[Int], key: Int, k: Int): List[Int] =\\n    nums.iterator.zipWithIndex.filter(_._1 == key).map(_._2).to(Set)\\n      .flatMap{i:Int => (0.max(i-k) to (i+k).min(nums.size-1))}.toList.sorted\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203643,
                "title": "python-clean-and-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, A: list[int], key: int, k: int) -> list[int]:\\n        it = (idx for idx, a in enumerate(A) if a == key)  # creating generator from indices of \"key\"\\n\\n        i, n = 0, len(A)\\n        output = []\\n\\n        while i < n and (idx := next(it, n)) < n:\\n            i, j = max(i, idx - k), min(idx + k, n - 1)\\n\\n            output.extend(range(i, j + 1))  # + 1 to include index j in output\\n\\n            i = j + 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, A: list[int], key: int, k: int) -> list[int]:\\n        it = (idx for idx, a in enumerate(A) if a == key)  # creating generator from indices of \"key\"\\n\\n        i, n = 0, len(A)\\n        output = []\\n\\n        while i < n and (idx := next(it, n)) < n:\\n            i, j = max(i, idx - k), min(idx + k, n - 1)\\n\\n            output.extend(range(i, j + 1))  # + 1 to include index j in output\\n\\n            i = j + 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192161,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(abs(i-j)<=k and nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(abs(i-j)<=k and nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158281,
                "title": "java-o-n-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        for(int i = 0;i<nums.length ; i++){\\n            if(nums[i] == key)\\n                list1.add(i);\\n        }\\n        int last = 0;\\n        for(int i = 0;i<list1.size();i++){\\n            int j = Math.max(list1.get(i) - k,last);\\n            for(;j<=list1.get(i)+k;j++){\\n                if(j < nums.length)\\n                    list2.add(j);\\n            }\\n            last = j;\\n        }\\n        return list2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        for(int i = 0;i<nums.length ; i++){\\n            if(nums[i] == key)\\n                list1.add(i);\\n        }\\n        int last = 0;\\n        for(int i = 0;i<list1.size();i++){\\n            int j = Math.max(list1.get(i) - k,last);\\n            for(;j<=list1.get(i)+k;j++){\\n                if(j < nums.length)\\n                    list2.add(j);\\n            }\\n            last = j;\\n        }\\n        return list2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148789,
                "title": "pyhton-o-n-time-space-easy-fast-no-sorting",
                "content": "![image.png](https://assets.leetcode.com/users/images/091831b2-4009-4f1e-8aa3-0ed5d91f737d_1675653039.5216413.png)\\n\\n# Intuition\\nAdd all the indexes around the key to the result.\\n\\n# Approach\\nFor every num that equal to key, we prepare the index range that meets the requirements, and also use min and max function to avoid index out of range and interval overlap.\\n\\nCheers!\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        prev = 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                result += range(max(prev, i-k), min(i+k, len(nums)-1)+1)\\n                prev = min(i+k, len(nums)-1)+1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        prev = 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                result += range(max(prev, i-k), min(i+k, len(nums)-1)+1)\\n                prev = min(i+k, len(nums)-1)+1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146919,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int>v;\\n       for(int i=0; i<nums.size();i++){\\n           for(int j=0; j<nums.size(); j++){\\n               if(abs(i-j)<=k && nums[j]==key){\\n                  v.push_back(i);\\n                  break;\\n               }   \\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int>v;\\n       for(int i=0; i<nums.size();i++){\\n           for(int j=0; j<nums.size(); j++){\\n               if(abs(i-j)<=k && nums[j]==key){\\n                  v.push_back(i);\\n                  break;\\n               }   \\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108577,
                "title": "easy-c-brute-force-god-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid check(vector<int>& ans,vector<int>& nums,int i,int k){\\n    for(int j=0;j<nums.size();j++){\\n        if(abs(j-i)<=k){\\n            ans.push_back(j);\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key){\\n                check(ans,nums,i,k);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid check(vector<int>& ans,vector<int>& nums,int i,int k){\\n    for(int j=0;j<nums.size();j++){\\n        if(abs(j-i)<=k){\\n            ans.push_back(j);\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key){\\n                check(ans,nums,i,k);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101670,
                "title": "python3-simple-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/e73f61a5-ff5b-4464-a6f0-f686a6e13bea_1674736602.7959375.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums, key, k):\\n        res, l = [], len(nums)\\n        if l == 1 or len(set(nums)) == 1 and key in nums:\\n            return [i for i in range(l)]\\n        else:\\n            for idx, ele in enumerate(nums):\\n                if key == ele:\\n                    start = idx - k if idx - k > 0 else 0\\n                    end = idx + k + 1 if idx + k < l else l\\n                    for i in range(start, end):\\n                        res.append(i)\\n        return set(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums, key, k):\\n        res, l = [], len(nums)\\n        if l == 1 or len(set(nums)) == 1 and key in nums:\\n            return [i for i in range(l)]\\n        else:\\n            for idx, ele in enumerate(nums):\\n                if key == ele:\\n                    start = idx - k if idx - k > 0 else 0\\n                    end = idx + k + 1 if idx + k < l else l\\n                    for i in range(start, end):\\n                        res.append(i)\\n        return set(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085405,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n      int n=a.size();\\n      int p=0;\\n      map<int,int>mp;\\n      vector<int>v;\\n      vector<int>e;\\n      \\n        for(int j=0;j<n;j++)\\n      {\\n          \\n          { for(int i=0;i<n;i++)\\n          {  if(a[j]==key && abs(i-j)<=k)\\n              \\n              v.push_back(i);\\n          }\\n              \\n          }\\n         \\n      }\\n      for(int h=0;h<v.size();h++)\\n      { mp[v[h]]++;}\\n      for(auto h:mp)\\n      {\\n          e.push_back(h.first);\\n      }\\n      return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n      int n=a.size();\\n      int p=0;\\n      map<int,int>mp;\\n      vector<int>v;\\n      vector<int>e;\\n      \\n        for(int j=0;j<n;j++)\\n      {\\n          \\n          { for(int i=0;i<n;i++)\\n          {  if(a[j]==key && abs(i-j)<=k)\\n              \\n              v.push_back(i);\\n          }\\n              \\n          }\\n         \\n      }\\n      for(int h=0;h<v.size();h++)\\n      { mp[v[h]]++;}\\n      for(auto h:mp)\\n      {\\n          e.push_back(h.first);\\n      }\\n      return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060360,
                "title": "python3-beats-98-72-constant-space-key-ranges-approach",
                "content": "# Intuition\\nFind all the `key` positions. Each key covers a `2k`-range of indices that needs to be added. Only problem that may arise is if the range either spills out of the array length, or if it overlaps with another range. To account for this, we can keep track of the most recently added index.\\n\\n# Approach\\nFind the keys and generate the ranges they produce. At the start we\\'ve `covered` 0 indices. For each range, adjust the range by keeping left greater than or equal to what has already been covered.\\n\\n# Complexity\\n- $$n=len(nums)$$\\n\\n- Time complexity:  $$O(n)$$ as in any case we are only seeing each number in `nums` once because `covered` adjusts our pointer past seen numbers.\\n\\n- Space complexity:  $$O(1)$$ extra space as we iterate over a generator.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res: List[int] = []\\n\\n        keyRanges = ((pos - k, pos + k) for pos, num in enumerate(nums) if num == key)\\n        covered = 0\\n        for keyLeft, keyRight in keyRanges:\\n            keyLeft, keyRight = max(keyLeft, covered), min(keyRight + 1, len(nums))\\n            for i in range(keyLeft, keyRight):\\n                res.append(i)\\n                covered = keyRight\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res: List[int] = []\\n\\n        keyRanges = ((pos - k, pos + k) for pos, num in enumerate(nums) if num == key)\\n        covered = 0\\n        for keyLeft, keyRight in keyRanges:\\n            keyLeft, keyRight = max(keyLeft, covered), min(keyRight + 1, len(nums))\\n            for i in range(keyLeft, keyRight):\\n                res.append(i)\\n                covered = keyRight\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057385,
                "title": "c-fast-o-n-solution-135ms-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) \\n    {\\n        var r = new List<int>(nums.Length);\\n\\n        var i = Array.IndexOf(nums, key);\\n\\n        if(i < 0) return r;\\n\\n        r.Add(Math.Max(0, i-k)); // Initial index. The rest distant indexes for \\'i\\' will be filled in the loop.\\n\\n        for(var len1 = nums.Length-1; i <= len1; i++)\\n        {\\n            if(nums[i] != key) continue;\\n\\n            var (from, to) = (Math.Max(r[^1] + 1, i-k), Math.Min(i+k, len1));\\n\\n            while(from <= to) r.Add(from++);\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) \\n    {\\n        var r = new List<int>(nums.Length);\\n\\n        var i = Array.IndexOf(nums, key);\\n\\n        if(i < 0) return r;\\n\\n        r.Add(Math.Max(0, i-k)); // Initial index. The rest distant indexes for \\'i\\' will be filled in the loop.\\n\\n        for(var len1 = nums.Length-1; i <= len1; i++)\\n        {\\n            if(nums[i] != key) continue;\\n\\n            var (from, to) = (Math.Max(r[^1] + 1, i-k), Math.Min(i+k, len1));\\n\\n            while(from <= to) r.Add(from++);\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047606,
                "title": "easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        li=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                li.append(i)\\n        s=0\\n        li1=[]\\n        for i in range(len(nums)):\\n            for j in li:\\n                if abs(i-j)<=k:\\n                    li1.append(s)\\n                    break\\n            s+=1\\n        return li1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        li=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                li.append(i)\\n        s=0\\n        li1=[]\\n        for i in range(len(nums)):\\n            for j in li:\\n                if abs(i-j)<=k:\\n                    li1.append(s)\\n                    break\\n            s+=1\\n        return li1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043926,
                "title": "simple-java-solution-with-explanation-one-pass",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (j = Math.max(i - k, j); j <= Math.min(nums.length - 1, i + k); j++) {\\n                    result.add(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (j = Math.max(i - k, j); j <= Math.min(nums.length - 1, i + k); j++) {\\n                    result.add(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038809,
                "title": "java-search-iterator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRequires the position of all the indexes at which we have key.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet all the positions at which we have key. Now iterator over all nums and with iteator over the foundIndexes check for i<=it.next();. If found add it to list.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> response = new ArrayList<>();\\n        List<Integer> foundIndexes = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] == key)\\n                foundIndexes.add(i);\\n        for (int i = 0; i < nums.length; i++) {\\n            Iterator<Integer> it = foundIndexes.iterator();\\n            while (it.hasNext()) {\\n                if (Math.abs(i - it.next()) <= k) {\\n                    response.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return response;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> response = new ArrayList<>();\\n        List<Integer> foundIndexes = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] == key)\\n                foundIndexes.add(i);\\n        for (int i = 0; i < nums.length; i++) {\\n            Iterator<Integer> it = foundIndexes.iterator();\\n            while (it.hasNext()) {\\n                if (Math.abs(i - it.next()) <= k) {\\n                    response.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return response;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037906,
                "title": "python3-using-set",
                "content": "# Intuition\\nEssentially, the question is just asking to find value \\'key\\' in the array and then record the indices \\'k\\' spaces around it. If done in linear fashion, it will naturally yield a sorted result.\\n\\n# Approach\\n1. Initialize result set as I do not want duplicate indices added\\n2. For every number in array, check if value is equal to \\'key\\'\\n    1. if value is equal, then add all indices from (i - k) to (i + k) inclusively to the set\\n    2. if such values run out of the array, then make sure to check for the correct limit\\n3. Finally, return set as a list\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = set()\\n        for i, val in enumerate(nums):\\n            if val == key:\\n                low = i - k if i - k >= 0 else 0\\n                high = i + k + 1 if i + k + 1 < len(nums) else len(nums)\\n                res.update(range(low, high))\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = set()\\n        for i, val in enumerate(nums):\\n            if val == key:\\n                low = i - k if i - k >= 0 else 0\\n                high = i + k + 1 if i + k + 1 < len(nums) else len(nums)\\n                res.update(range(low, high))\\n        return list(res)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]