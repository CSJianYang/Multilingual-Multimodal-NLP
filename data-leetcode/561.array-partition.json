[
    {
        "title": "Array Partition",
        "question_content": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\n&nbsp;\nExample 1:\n\nInput: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\nExample 2:\n\nInput: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104\n\tnums.length == 2 * n\n\t-104 <= nums[i] <= 104",
        "solutions": [
            {
                "id": 102170,
                "title": "java-solution-sorting-and-rough-proof-of-algorithm",
                "content": "The algorithm is first sort the input array and then the sum of 1st, 3rd, 5th..., is the answer. \\n```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\nLet me try to prove the algorithm...\\n1. Assume in each pair ```i```, ```bi >= ai```. \\n2. Denote ```Sm = min(a1, b1) + min(a2, b2) + ... + min(an, bn)```. The biggest ```Sm``` is the answer of this problem. Given ```1```, ```Sm = a1 + a2 + ... + an```.\\n3. Denote ```Sa = a1 + b1 + a2 + b2 + ... + an + bn```. ```Sa``` is constant for a given input.\\n4. Denote ```di = |ai - bi|```. Given ```1```, ```di = bi - ai```. Denote ```Sd = d1 + d2 + ... + dn```.\\n5. So ```Sa = a1 + a1 + d1 + a2 + a2 + d2 + ... + an + an + dn = 2Sm + Sd``` => ```Sm = (Sa - Sd) / 2```. To get the max ```Sm```, given ```Sa``` is constant, we need to make ```Sd``` as small as possible.\\n6. So this problem becomes finding pairs in an array that makes sum of ```di``` (distance between ```ai``` and ```bi```) as small as possible. Apparently, sum of these distances of adjacent elements is the smallest. If that's not intuitive enough, see attached picture. Case 1 has the smallest ```Sd```.\\n![0_1492961937328_leetcode561.jpg](/uploads/files/1492961944408-leetcode561.jpg)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```i```\n```bi >= ai```\n```Sm = min(a1, b1) + min(a2, b2) + ... + min(an, bn)```\n```Sm```\n```1```\n```Sm = a1 + a2 + ... + an```\n```Sa = a1 + b1 + a2 + b2 + ... + an + bn```\n```Sa```\n```di = |ai - bi|```\n```1```\n```di = bi - ai```\n```Sd = d1 + d2 + ... + dn```\n```Sa = a1 + a1 + d1 + a2 + a2 + d2 + ... + an + an + dn = 2Sm + Sd```\n```Sm = (Sa - Sd) / 2```\n```Sm```\n```Sa```\n```Sd```\n```di```\n```ai```\n```bi```\n```Sd```",
                "codeTag": "Java"
            },
            {
                "id": 102180,
                "title": "java-o-n-beats-100",
                "content": "inspired by [c++ code O(n),beats 100%](https://discuss.leetcode.com/topic/87483/c-code-o-n-beats-100)\\n```\\npublic class Solution {\\n\\n\\tpublic int arrayPairSum(int[] nums) {\\n\\t\\tint[] exist = new int[20001];\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\texist[nums[i] + 10000]++;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tboolean odd = true;\\n\\t\\tfor (int i = 0; i < exist.length; i++) {\\n\\t\\t\\twhile (exist[i] > 0) {\\n\\t\\t\\t\\tif (odd) {\\n\\t\\t\\t\\t\\tsum += i - 10000;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\todd = !odd;\\n\\t\\t\\t\\texist[i]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n\\tpublic int arrayPairSum(int[] nums) {\\n\\t\\tint[] exist = new int[20001];\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\texist[nums[i] + 10000]++;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tboolean odd = true;\\n\\t\\tfor (int i = 0; i < exist.length; i++) {\\n\\t\\t\\twhile (exist[i] > 0) {\\n\\t\\t\\t\\tif (odd) {\\n\\t\\t\\t\\t\\tsum += i - 10000;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\todd = !odd;\\n\\t\\t\\t\\texist[i]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102161,
                "title": "python-1-line-sorting-is-accepted",
                "content": "```\\nclass Solution(object):\\n\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum(sorted(nums)[::2])",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum(sorted(nums)[::2])",
                "codeTag": "Java"
            },
            {
                "id": 102179,
                "title": "python-simple-with-explanation",
                "content": "Consider the smallest element ```x```.  It should be paired with the next smallest element, because ```min(x, anything) = x```, and having bigger elements only helps you have a larger score.  Thus, we should pair adjacent elements together in the sorted array.\\n\\n```\\ndef arrayPairSum(self, A):\\n    return sum(sorted(A)[::2])\\n```",
                "solutionTags": [],
                "code": "```x```\n```min(x, anything) = x```\n```\\ndef arrayPairSum(self, A):\\n    return sum(sorted(A)[::2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 390198,
                "title": "algorithm-and-solution-in-python3",
                "content": "The question states that we have to find the maximum sum obtained by taking minimum from **n** pairs. A pair can be formed from the elements of the list.\\n\\nHow to solve this:\\n- **Sort** the list\\n- **make a pair** starting from index 0\\n- take **minimum** from each pair\\n- **add** all the minimum obtained from the pairs\\n\\n**Logic and Working of the problem**:\\nSuppose we have a list of **6** elements say ```[2,1,4,5,7,9]```\\nFirst task is to pair them and thus we will have 3 pairs:\\n```\\n1.  [1,2], [4,5], [7,9] Sum of their min : 1 + 4 + 7 = 12\\n2.  [1,2], [4,7], [5,9] Sum of thier min : 1 + 4 + 5 = 10\\n3.  [1,2], [4,9], [5,7] Sum of their min : 1 + 4 + 5 = 10\\n4.  [1,4], [2,5], [7,9] Sum of their min : 1 + 2 + 7 = 10\\n5.  [1,4], [2,7], [5,9] Sum of their min : 1 + 2 + 7 = 10\\n6.  [1,5], [2,4], [7,9] Sum of their min : 1 + 2 + 7 = 10\\n7.  [1,4], [2,9], [5,7] Sum of their min : 1 + 2 + 5 = 8\\n8.  [1,7], [2,4], [5,9] Sum of their min : 1 + 2 + 5 = 8\\n9.  [1,9], [2,4], [5,7] Sum of their min : 1 + 2 + 5 = 8\\n10. [1,5], [2,7], [4,9] Sum of their min : 1 + 2 + 4 = 7\\n11. [1,7], [2,5], [4,9] Sum of their min : 1 + 2 + 4 = 7\\n12. [1,7], [2,9], [4,5] Sum of their min : 1 + 2 + 4 = 7\\n13. [1,5], [2,9], [4,7] Sum of their min : 1 + 2 + 4 = 7\\n14. [1,9], [2,5], [4,7] Sum of their min : 1 + 2 + 4 = 7\\n15. [1,9], [2,7], [4,5] Sum of their min : 1 + 2 + 4 = 7\\n```\\n\\nFrom the above pair and their sum we can conclude that the maximum sum is obtained from the pair which are obtained after sorting. Hence the answer to the above problem will be **12** which is obtained from the pairs ```[1,2], [4,5], [7,9]```\\n\\nOne solution can be\\n\\n```py\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        sum_ = 0\\n        for i in range(0,len(nums),2):\\n            sum_ += nums[i]\\n        return sum_\\n\\n# Time : 356 ms\\n# Memory : 16.7 M\\n        \\n```\\n\\nAnother solution can be:\\n```py\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n        \\n# Time : 332 ms\\n# Memory : 16.5 M\\n```\\n\\nPlease upvote this post if you like the solution, and I will keep on posting well commented solutions.\\n\\nCurrently I am using private repository for the solutions of Leetcode, but very soon I will make the repo public, so if you want to connect with me\\nGItHub : https://github.com/ramanaditya\\nLinkedIn : https://www.linkedin.com/in/ramanaditya/\\nTwitter : https://twitter.com/_adityaraman\\nWebsite : https://ramanaditya.github.io/",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```[2,1,4,5,7,9]```\n```\\n1.  [1,2], [4,5], [7,9] Sum of their min : 1 + 4 + 7 = 12\\n2.  [1,2], [4,7], [5,9] Sum of thier min : 1 + 4 + 5 = 10\\n3.  [1,2], [4,9], [5,7] Sum of their min : 1 + 4 + 5 = 10\\n4.  [1,4], [2,5], [7,9] Sum of their min : 1 + 2 + 7 = 10\\n5.  [1,4], [2,7], [5,9] Sum of their min : 1 + 2 + 7 = 10\\n6.  [1,5], [2,4], [7,9] Sum of their min : 1 + 2 + 7 = 10\\n7.  [1,4], [2,9], [5,7] Sum of their min : 1 + 2 + 5 = 8\\n8.  [1,7], [2,4], [5,9] Sum of their min : 1 + 2 + 5 = 8\\n9.  [1,9], [2,4], [5,7] Sum of their min : 1 + 2 + 5 = 8\\n10. [1,5], [2,7], [4,9] Sum of their min : 1 + 2 + 4 = 7\\n11. [1,7], [2,5], [4,9] Sum of their min : 1 + 2 + 4 = 7\\n12. [1,7], [2,9], [4,5] Sum of their min : 1 + 2 + 4 = 7\\n13. [1,5], [2,9], [4,7] Sum of their min : 1 + 2 + 4 = 7\\n14. [1,9], [2,5], [4,7] Sum of their min : 1 + 2 + 4 = 7\\n15. [1,9], [2,7], [4,5] Sum of their min : 1 + 2 + 4 = 7\\n```\n```[1,2], [4,5], [7,9]```\n```py\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        sum_ = 0\\n        for i in range(0,len(nums),2):\\n            sum_ += nums[i]\\n        return sum_\\n\\n# Time : 356 ms\\n# Memory : 16.7 M\\n        \\n```\n```py\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n        \\n# Time : 332 ms\\n# Memory : 16.5 M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102160,
                "title": "c-code-o-n-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        vector<int> hashtable(20001,0);\\n        for(size_t i=0;i<nums.size();i++)\\n        {\\n            hashtable[nums[i]+10000]++;\\n        }\\n        int ret=0;\\n        int flag=0;\\n        for(size_t i=0;i<20001;){\\n            if((hashtable[i]>0)&&(flag==0)){\\n                ret=ret+i-10000;\\n                flag=1;\\n                hashtable[i]--;\\n            }else if((hashtable[i]>0)&&(flag==1)){\\n                hashtable[i]--;\\n                flag=0;\\n            }else i++;\\n        }\\n        return ret;\\n    }\\n};\\n```\\nwith the range of numbers,it is easy to using vector,and if we don't know the range of numbers,maybe using STL multiset,but using multiset is O(nlogn).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        vector<int> hashtable(20001,0);\\n        for(size_t i=0;i<nums.size();i++)\\n        {\\n            hashtable[nums[i]+10000]++;\\n        }\\n        int ret=0;\\n        int flag=0;\\n        for(size_t i=0;i<20001;){\\n            if((hashtable[i]>0)&&(flag==0)){\\n                ret=ret+i-10000;\\n                flag=1;\\n                hashtable[i]--;\\n            }else if((hashtable[i]>0)&&(flag==1)){\\n                hashtable[i]--;\\n                flag=0;\\n            }else i++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102208,
                "title": "java-c-clean-code-1-sentence-explanation",
                "content": "In short, the sum of all number is fixed, to maximize the sum of smaller group, you want to minimize the diff of the sum of 2 groups.\\nAnd the best way to do that is to pair the numbers that are next to each other in sorted order.\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i += 2) {\\n            sum += nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i += 2) {\\n            sum += nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061085,
                "title": "o-nlogn-c-java-beats-99",
                "content": "**Implementation**\\n\\n**1st Approach in C++**\\nTime Complexity = O(NLogN), Space Complexity = O(1)\\n\\n```\\nint arrayPairSum(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int result = 0;\\n    for(int itr = 0; itr < nums.size(); itr += 2){\\n        result += nums[itr];\\n    }\\n    return result;\\n}\\n```\\n\\n\\n**2nd Approach in Java**\\nTime Complexity = O(NLogN), Space Complexity = O(1)\\n\\n```\\npublic int arrayPairSum(int[] nums) {\\n    Arrays.sort(nums);\\n    int result = 0;\\n    for(int itr = 0; itr < nums.length; itr += 2){\\n        result += nums[itr];\\n    }\\n    return result;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint arrayPairSum(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int result = 0;\\n    for(int itr = 0; itr < nums.size(); itr += 2){\\n        result += nums[itr];\\n    }\\n    return result;\\n}\\n```\n```\\npublic int arrayPairSum(int[] nums) {\\n    Arrays.sort(nums);\\n    int result = 0;\\n    for(int itr = 0; itr < nums.length; itr += 2){\\n        result += nums[itr];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102201,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with detailed discussion** https://discuss.leetcode.com/topic/91279/python-solution-with-detailed-explanation\\n\\n**Array Partition I** https://leetcode.com/problems/array-partition-i/#/description\\n\\n**Editorial** https://leetcode.com/articles/array-partitioning-i/\\n\\n**Bruteforce**\\n* Find all permutations and then imagine each adjacent pair being pairs.\\n\\n**Sorting based solution**\\n1. For an optimized solution, begin with an example arr = [4,3,1,2]\\n2. Sort this array. arr = [1,2,3,4]\\n3. Now note that 1 needs to be a paired with a larger number. What is the number we would like to sacrifice? Clearly the smallest possible.\\n4. This gives the insight: sort and pair adjacent numbers.\\n5. Sorting takes Nlg(N) and space lg(N).\\n\\n```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        s_so_far = 0\\n        for i in range(0, len(nums)-1, 2):\\n            s_so_far += nums[i]\\n        return s_so_far\\n```\\n\\n**Hashing based solution**\\n1. We use the same idea to pair adjacent elements, but instead use a counting sort approach.\\n2. Range of numbers is -10k to 10k. This means 20001 elements.\\n3. Build the frequency map for the input.\\n4. Now iterate this map. When frequency is even, the contribution is the implied number times freq//2. When odd, it is (implied number) times (freq//2 + 1).\\n5. Implied number: (idx-10000)\\n6. The time and space complexity is order K where K is the range of the numbers.\\n\\n```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = [0]*20001\\n        for x in nums:\\n            res[x+10000] += 1\\n        s_so_far, adjust = 0, False\\n        for idx, freq in enumerate(res):\\n            if freq:\\n                freq = freq-1 if adjust else freq\\n                if freq&1:\\n                    s_so_far += ((freq//2) + 1)*(idx-10000)\\n                    adjust = True\\n                else:\\n                    s_so_far += ((freq//2))*(idx-10000)\\n                    adjust = False\\n        return s_so_far\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        s_so_far = 0\\n        for i in range(0, len(nums)-1, 2):\\n            s_so_far += nums[i]\\n        return s_so_far\\n```\n```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = [0]*20001\\n        for x in nums:\\n            res[x+10000] += 1\\n        s_so_far, adjust = 0, False\\n        for idx, freq in enumerate(res):\\n            if freq:\\n                freq = freq-1 if adjust else freq\\n                if freq&1:\\n                    s_so_far += ((freq//2) + 1)*(idx-10000)\\n                    adjust = True\\n                else:\\n                    s_so_far += ((freq//2))*(idx-10000)\\n                    adjust = False\\n        return s_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102220,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar arrayPairSum = function(nums) {\\n    // sort and sum up the minimum of the pairs\\n    return nums\\n        .sort((a, b) => a - b)\\n        .reduce((sum, cur, i) => (i % 2 === 0) ? sum += cur : sum, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n    // sort and sum up the minimum of the pairs\\n    return nums\\n        .sort((a, b) => a - b)\\n        .reduce((sum, cur, i) => (i % 2 === 0) ? sum += cur : sum, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379603,
                "title": "c-o-n-in-depth-explanation",
                "content": "Algorithm:\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int* buckets = new int[20001] {0};\\n        \\n        for(auto n : nums) {\\n            ++buckets[n + 10000];\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0, used = 0; used < nums.size();) {\\n            if(buckets[i] == 0) {\\n                ++i;\\n            } else {\\n                if(used % 2 == 0)\\n                    sum += (i - 10000);\\n                \\n                --buckets[i];\\n                ++used;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nFirst, we know this question is a greedy problem because it is asking us to maximize something with respect to a list of elements and conditions. Greedy problems follow this format:\\n\\n* Given a list of conditions and a list of elements that may or may not satisfy the conditions, \"do something\" when an element satisfies a condition. Continue for all conditions, and finally, return \"something\"\\n\\n[Assign Cookies](https://leetcode.com/problems/assign-cookies/)  is good examples of greedy problems.\\n\\nUsually, the simple intuition is to sort the conditions and elements and perform the following:\\n1.  Check if the current element satisfies the condition\\n2.  If the element does not satisfy, you can assume the elements before this one also do not satisfy and can go to the next element\\n3.  If the element satisfies the condition, \"do something\" and move on to the next condition (if you cannot re-use elements, also move on to the next element)\\n\\nThis simple intuition can lead us to a simple solution where we sort the elements and add the first element, then the element 2 steps after that, and so on. Formally, you can think of our \"list of conditions\" as being an array of:\\n\\n```i % 2 == 0```\\n\\n, where i is the current array index.\\n\\nIn this problem\\'s case, when an element satisfies the condition, we just add to the sum. This is fine, but runtime here is O(n log n) because we are sorting the array. Because we need to access n/2 elements to compute the sum, best runtime is O(n). So the question is can we do this without sorting. Yes and no. We do not need to sort the elements with respect to each other (which is O(n log n), for each element we do something w.r.t elements we have seen already). \\n\\nKey point to identify here is that the array is \"technically\" **already sorted.** If you have elements from [1, n], then all you really need to know is the frequency of each value from [1, n]. If you have array like [8,2,5,9,1], and you know your elements are -10,000 < element < 10,000, then you just need to iterate once to collect the frequency, and you technically have a sorted array, just iterate from -10,000 to 10,000 and skip elements with frequency of 0. This is something like bucket sort.\\n\\nSo, we have now collected frequency of elements and have technically sorted array. How do we access each element to check the condition? \\n1. Access element in our bucket\\n2. Check if element is in the bucket (frequency > 0)\\n\\t3. If not, move to the next **bucket index**\\n\\t4. If element is in bucket, perform a check\\n\\t\\t5. Remember that the goal is to take elements when i % 2 == 0. i in this case is our array index.\\n\\t\\t6. If check is satisfied, add the current number to the sum\\n\\t\\t7. After that, reduce the frequency of current element\\n\\t\\t8. Move to the next **array index**\\n\\nNote we access elements in the bucket using bucket index, but we use the array index to determine if we take the current element or not. We only move to the next bucket if the current one is empty, otherwise we move to the next array index. So if we have something like [...., 7, 7, 7, 7,...], our frequency for buckets[7] == 4, and we will stay on that bucket until frequency == 0;\\n\\n",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int* buckets = new int[20001] {0};\\n        \\n        for(auto n : nums) {\\n            ++buckets[n + 10000];\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0, used = 0; used < nums.size();) {\\n            if(buckets[i] == 0) {\\n                ++i;\\n            } else {\\n                if(used % 2 == 0)\\n                    sum += (i - 10000);\\n                \\n                --buckets[i];\\n                ++used;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```i % 2 == 0```",
                "codeTag": "Java"
            },
            {
                "id": 656631,
                "title": "java-95-77-faster-with-96-43-space-complexity",
                "content": "First of all we have to sort array and after that we have to make pair of 2-2 elements from array and sum up all minimum of that pairs.\\n\\nEx. \\n<pre>\\n<b> nums =                     [4,50,30,20,10,45] \\n After sort:                [4,10,20,30,45,50]\\n Pairs will be:             [ (4,10), (20,30), (45,50) ]\\n Min of each pair will be =    4,      20,      45\\n \\n sum = 4+20+45 = 69\\n so simply we can iterate i and increment every time by 2 so that we can add all min in pairs.\\t\\t\\t\\n</b>\\n</pre>\\n\\nSolution:\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n            \\n        int sum = 0;\\n        Arrays.sort(nums);\\n            \\n        for(int i=0; i<nums.length; i=i+2) \\n            sum += nums[i];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n            \\n        int sum = 0;\\n        Arrays.sort(nums);\\n            \\n        for(int i=0; i<nums.length; i=i+2) \\n            sum += nums[i];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442802,
                "title": "easy-java-for-beginners-fast-o-log-n-space-complexity-explained",
                "content": "# Approach\\n- Quicksorting the array.\\n- create the returning integer named max = 0.\\n- take min of each two consecutive integers and add it to max.\\n- return max.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<nums.length;i = i+2){\\n            max = max + Math.min(nums[i],nums[i+1]);\\n        }\\n        return max;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4fef81d1-720c-4907-9bc0-4e8124c0a931_1682140717.2338047.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<nums.length;i = i+2){\\n            max = max + Math.min(nums[i],nums[i+1]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215534,
                "title": "java-solution-well-explained-logic",
                "content": "# Special thanks\\nSpecial thanks to geo1923 (https://leetcode.com/geo1923/) for his/her kind help with improving space complexity from O(n) to O(1). I really appreciate it.\\n\\n# Intuition\\nIf you pay attention to the hints you can notice that in the sorted array we do not need to find minimum for two numbers when we iterate over the array with +2 step. \\n\\nThis happens because the first one is already the minimum value which we are looking for. \\n\\nLet\\'s see this example: [1,4,3,2] -> [1,2,3,4] -> [1,2] and [3,4]. The minimum values of these pairs are 1 and 3. We will use this idea in our approach.\\n\\n# Approach\\n1. Let\\'s sort our array.\\n2. Initialize a variable for result counting.\\n3. Loop over initial array (nums) with +2 step and increment the variable. As was mentioned earlier, we do not need to find minimum because our i is already a minimum (we take the left value in each pair [i, i + 1].\\n4. Return the result.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\text{ }log \\\\text{ } n)$$ (due to sorting)\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i+=2) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n![4x5hdv.jpeg](https://assets.leetcode.com/users/images/83c083e7-9757-474b-a3fe-e6d87144b3d1_1677435546.8329794.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i+=2) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733194,
                "title": "java-o-n-solution-with-explanation-using-count-sort",
                "content": "```\\n// Runtime: 4 ms, faster than 99.96% of Java online submissions\\n\\nclass Solution {\\n    public int arrayPairSum(int[] nums) \\n    {\\n        //Doing using count sort\\n        //The range of nums[i] is -10^4 <= nums[i] <= 10^4\\n        //So the count array will be of size 10^4+10^4+1  +1 for zero\\n        int count[] = new int[20001];\\n        \\n        //now lets fill the count array\\n        //count array will contain the number of occurrences of the number that is equal to its index-10000\\n        //for example the number -10000 will be stored in index -10000+10000 i.e. 0\\n        //and number 10000 will be stored in index 10000+10000 i.e. 20000\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            count[nums[i]+10000]++;\\n        }\\n        \\n        //Now have filled the count array \\n        \\n        //as we know the index of the array are : 0 , 1 , 2 , 3 ......20001\\n        //already in ascending order \\n        //Lets take an example ;\\n        // nums = [6,2,6,5,1,2] will be stored like:\\n        // .. 10000 10001 10002 10003 10004 10005 10006  10007 ....\\n        //   ..  0    1    2       0    0     1     2      0 ..\\n        //we can get numbers in ascending order from here , as we can see \\n        //now we want min number to be added in sum\\n        //so lets take a variable min which will be true in starting , and then false and alternatively will change as we will encounter an element \\n        boolean min=true;\\n        int sum=0;\\n        for(int i=0;i<count.length;i++)\\n        {\\n            while(count[i]>0)\\n            {\\n               if(min) \\n                   {\\n\\t\\t\\t\\t   sum=sum+i-10000;\\n\\t\\t\\t\\t   }\\n                count[i]--;\\n                min=!min;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 99.96% of Java online submissions\\n\\nclass Solution {\\n    public int arrayPairSum(int[] nums) \\n    {\\n        //Doing using count sort\\n        //The range of nums[i] is -10^4 <= nums[i] <= 10^4\\n        //So the count array will be of size 10^4+10^4+1  +1 for zero\\n        int count[] = new int[20001];\\n        \\n        //now lets fill the count array\\n        //count array will contain the number of occurrences of the number that is equal to its index-10000\\n        //for example the number -10000 will be stored in index -10000+10000 i.e. 0\\n        //and number 10000 will be stored in index 10000+10000 i.e. 20000\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            count[nums[i]+10000]++;\\n        }\\n        \\n        //Now have filled the count array \\n        \\n        //as we know the index of the array are : 0 , 1 , 2 , 3 ......20001\\n        //already in ascending order \\n        //Lets take an example ;\\n        // nums = [6,2,6,5,1,2] will be stored like:\\n        // .. 10000 10001 10002 10003 10004 10005 10006  10007 ....\\n        //   ..  0    1    2       0    0     1     2      0 ..\\n        //we can get numbers in ascending order from here , as we can see \\n        //now we want min number to be added in sum\\n        //so lets take a variable min which will be true in starting , and then false and alternatively will change as we will encounter an element \\n        boolean min=true;\\n        int sum=0;\\n        for(int i=0;i<count.length;i++)\\n        {\\n            while(count[i]>0)\\n            {\\n               if(min) \\n                   {\\n\\t\\t\\t\\t   sum=sum+i-10000;\\n\\t\\t\\t\\t   }\\n                count[i]--;\\n                min=!min;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348928,
                "title": "this-question-sucks",
                "content": "**Hard to understand, ridiculously easy to solve**. It should be the opposite.\\n\\nMy short Python 3 solution (w/ list comprehension)\\n```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\treturn sum([nums[i] for i in range(0,len(nums),2)])\\n```\\n\\nA more readable solution for actual interviews:\\n```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tsum_of_min = 0\\n\\tfor i in range(0, len(nums), 2): #// every other index, e.g. 0,2,4\\n\\t\\tsum_of_min += nums[i]\\n\\treturn sum_of_min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\treturn sum([nums[i] for i in range(0,len(nums),2)])\\n```\n```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tsum_of_min = 0\\n\\tfor i in range(0, len(nums), 2): #// every other index, e.g. 0,2,4\\n\\t\\tsum_of_min += nums[i]\\n\\treturn sum_of_min\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102169,
                "title": "share-my-java-solution-beat-90",
                "content": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n         int[] hash=new int[20001];\\n         for(int ele:nums){\\n             hash[ele+10000]++;\\n         }\\n         int sum=0;\\n         int p=0;\\n         for(int i=0;i<20001;i++){\\n             if(hash[i]==0) continue;\\n             while(hash[i]!=0){\\n                 if(p%2==0){\\n                     sum+=(i-10000);\\n                 }\\n                 p++;\\n                 hash[i]--;\\n             }\\n         }\\n         return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n         int[] hash=new int[20001];\\n         for(int ele:nums){\\n             hash[ele+10000]++;\\n         }\\n         int sum=0;\\n         int p=0;\\n         for(int i=0;i<20001;i++){\\n             if(hash[i]==0) continue;\\n             while(hash[i]!=0){\\n                 if(p%2==0){\\n                     sum+=(i-10000);\\n                 }\\n                 p++;\\n                 hash[i]--;\\n             }\\n         }\\n         return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583876,
                "title": "c-easy-understanding-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxsum = 0;\\n        for(int i = 0 ; i<nums.size(); i= i +2){\\n            maxsum = maxsum+nums[i];\\n        }\\n        return maxsum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxsum = 0;\\n        for(int i = 0 ; i<nums.size(); i= i +2){\\n            maxsum = maxsum+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 102196,
                "title": "c-simple-solution",
                "content": "```\\nint arrayPairSum(int* nums, int numsSize) {\\n    int i, bucket[20001]={0};\\n    int Flag=1,reg=0,count=0;\\n    for(i=0;i<numsSize;i++)\\n        bucket[nums[i]+10000]++;\\n    for(i=0;i<20001&&count<numsSize/2;)   // Use count variable can reduce iteration times\\n    {\\n        if(bucket[i]>0)\\n        {\\n            if(Flag)\\n            {\\n                Flag=0;\\n                reg+=i-10000;\\n                bucket[i]--;\\n                count++;\\n            }\\n            else\\n            {\\n                Flag=1;\\n                bucket[i]--;\\n            }\\n                \\n        }\\n        else i++;\\n    }\\n    return reg;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint arrayPairSum(int* nums, int numsSize) {\\n    int i, bucket[20001]={0};\\n    int Flag=1,reg=0,count=0;\\n    for(i=0;i<numsSize;i++)\\n        bucket[nums[i]+10000]++;\\n    for(i=0;i<20001&&count<numsSize/2;)   // Use count variable can reduce iteration times\\n    {\\n        if(bucket[i]>0)\\n        {\\n            if(Flag)\\n            {\\n                Flag=0;\\n                reg+=i-10000;\\n                bucket[i]--;\\n                count++;\\n            }\\n            else\\n            {\\n                Flag=1;\\n                bucket[i]--;\\n            }\\n                \\n        }\\n        else i++;\\n    }\\n    return reg;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2382493,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int n = nums.length, answer = 0;\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < n; i += 2)\\n            answer += nums[i];\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int n = nums.length, answer = 0;\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < n; i += 2)\\n            answer += nums[i];\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992916,
                "title": "two-simple-javascript-solution-without-math-min-function",
                "content": "\\nFound these solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n\\n**Solution 1:**\\n```\\nvar arrayPairSum = nums => {\\n    nums.sort((a, b) => a - b);\\n    let sum = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2 === 0) sum += nums[i]\\n    }\\n\\n    return sum\\n};\\n```\\n\\n**Solution 2:**\\n```\\nvar arrayPairSum = nums => {\\n    nums.sort((a, b) => a - b);\\n    let sum = 0;\\n\\n    for (let i = 0; i < nums.length; i += 2) {\\n        sum += nums[i]\\n    }\\n\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayPairSum = nums => {\\n    nums.sort((a, b) => a - b);\\n    let sum = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2 === 0) sum += nums[i]\\n    }\\n\\n    return sum\\n};\\n```\n```\\nvar arrayPairSum = nums => {\\n    nums.sort((a, b) => a - b);\\n    let sum = 0;\\n\\n    for (let i = 0; i < nums.length; i += 2) {\\n        sum += nums[i]\\n    }\\n\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671385,
                "title": "easy-python-faster-than-95-81-two-lines",
                "content": "We need to find max sum from an array using min().\\nTo solve this problem we sort the array, so that we can take max value from every min() pair.\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return(sum(nums[::2]))\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return(sum(nums[::2]))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 138465,
                "title": "o-n-javascript-solution-99-5",
                "content": "Been learning interview questions in JavaScript so maybe there are built in functions that I didn\\'t use\\n```\\nvar arrayPairSum = function(nums) {\\n    let hash = [];\\n    for(let i=0; i<20001;++i){\\n        hash[i]=0;\\n    }\\n    let sum = 0;\\n    let min= Number.MAX_VALUE;\\n    let max= Number.MIN_VALUE;\\n    for(let i=0; i<nums.length;++i){\\n        let cur=nums[i]+10000;\\n        ++hash[cur];\\n        min=Math.min(min,cur);\\n        max=Math.max(max,cur);\\n    }\\n    let evenOdd=0;\\n    for(let i=min; i<=max;++i){\\n        let curAmount=hash[i];\\n           for(let j=0; j<curAmount;++j){\\n                if(evenOdd==0){\\n                    sum+=i-10000;\\n                }  \\n               evenOdd^=1;\\n           } \\n    }\\n    return sum; \\n    };\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n    let hash = [];\\n    for(let i=0; i<20001;++i){\\n        hash[i]=0;\\n    }\\n    let sum = 0;\\n    let min= Number.MAX_VALUE;\\n    let max= Number.MIN_VALUE;\\n    for(let i=0; i<nums.length;++i){\\n        let cur=nums[i]+10000;\\n        ++hash[cur];\\n        min=Math.min(min,cur);\\n        max=Math.max(max,cur);\\n    }\\n    let evenOdd=0;\\n    for(let i=min; i<=max;++i){\\n        let curAmount=hash[i];\\n           for(let j=0; j<curAmount;++j){\\n                if(evenOdd==0){\\n                    sum+=i-10000;\\n                }  \\n               evenOdd^=1;\\n           } \\n    }\\n    return sum; \\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208067,
                "title": "four-c-solutions",
                "content": "*Solution 1:*\\n\\n* Using sort.\\n* Runtime beats 28.24% (80ms).\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i+=2)   sum += nums[i];\\n        return sum;\\n    }\\n};\\n```\\n*Solution 2:*\\n* Ref: https://leetcode.com/problems/array-partition-i/discuss/102160/c-code-onbeats-100\\n* Using hashmap to replace sort, more time friendly.\\n* Runtime beats 60.38% (60ms).\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n\\t\\t\\n        for(int i = 0, flag = 0; i < 20001;){\\n            if(map[i] > 0 && flag == 0){\\n                sum += i - 10000;\\n                flag = 1;\\n                map[i]--;\\n            }\\n            else if(map[i] > 0 && flag == 1){\\n                flag = 0;\\n                map[i]--;\\n            }else i++;    \\n        }\\n\\t\\t\\n        return sum;\\n    }\\n};\\n```\\n*Solution 3:*\\n* Ref: https://leetcode.com/problems/array-partition-i/discuss/137734/Try-to-understand-the-code-at-99-of-Runtime-Distribution.\\n* Using while to replace if for map[i] >= 2.\\n* Using bool type flag which is more convenient to inverse.\\n* Runtime beats 91.65% (48ms).\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n        \\n        bool flag = true;\\n        for(int i = 0; i < 20001;){\\n            while(map[i] > 0){\\n                map[i]--;\\n                if(flag){\\n                    sum += i - 10000;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n*Solution 4:*\\n* Ref: https://leetcode.com/problems/array-partition-i/discuss/149237/Easy-understanding-Java-solution-beats-98\\n* Using nums.size() to control iteration times instead of 20000, which can be end earlier.\\n* Runtime beats 96.68% (40ms).\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n        \\n        bool flag = true;\\n        for(int i = 0, ct = 0; ct < n; i++){\\n           while(map[i]-- > 0){\\n               if(flag){\\n                   sum += i - 10000;\\n               }\\n               flag = !flag;\\n               ct++;\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i+=2)   sum += nums[i];\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n\\t\\t\\n        for(int i = 0, flag = 0; i < 20001;){\\n            if(map[i] > 0 && flag == 0){\\n                sum += i - 10000;\\n                flag = 1;\\n                map[i]--;\\n            }\\n            else if(map[i] > 0 && flag == 1){\\n                flag = 0;\\n                map[i]--;\\n            }else i++;    \\n        }\\n\\t\\t\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n        \\n        bool flag = true;\\n        for(int i = 0; i < 20001;){\\n            while(map[i] > 0){\\n                map[i]--;\\n                if(flag){\\n                    sum += i - 10000;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0, n = nums.size();\\n        vector<int> map(20001, 0);\\n        \\n        for(int i = 0; i < n; i++) map[nums[i]+10000]++;\\n        \\n        bool flag = true;\\n        for(int i = 0, ct = 0; ct < n; i++){\\n           while(map[i]-- > 0){\\n               if(flag){\\n                   sum += i - 10000;\\n               }\\n               flag = !flag;\\n               ct++;\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147120,
                "title": "javascript-simple-solution",
                "content": "```\\nvar arrayPairSum = function(nums) {\\n  nums.sort((x, y) => x - y);\\n  let res = 0;\\n  for(let i = 0; i < nums.length; i += 2){\\n    res += nums[i];\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n  nums.sort((x, y) => x - y);\\n  let res = 0;\\n  for(let i = 0; i < nums.length; i += 2){\\n    res += nums[i];\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858212,
                "title": "simple-and-detailed-solution-python",
                "content": "**Explanation:**\\nIn this question we can apply greedy approach.\\nLet us take an example for better understanding:\\nnums=[4,2,3,5,1,6]\\nNow, think about how can we maximise our sum as per given rule. So, we can simply maximise it by making a pair of numbers which have minimum difference between them as compare to other elements in the array. Like in our example the pair is looks like [ (1,2) , (3,4) , (5,6) ]. For this kind of pair we can easily find our answer by adding first element of each pair.\\n\\nNow, think about how we can make this kind of pair.\\nActually, here we not need to make a pair (to avoid use of space). Here, we can simply sort the nums array in increasing order. And then simply add the element which is at even place (because of zero indexing) and we get our answer. ( [ (1,2) , (3,4) , (5,6) ] by observing the pattern one can also get the hint.)\\n\\n**Now, move on to coding part:**\\n\\n```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(len(nums)):\\n            if i&1==0:\\n                ans+=nums[i]\\n        return ans\\n```\\n\\n**Tips:** Use bitwise operator to find even place as bitwise operation is fast.",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(len(nums)):\\n            if i&1==0:\\n                ans+=nums[i]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1489750,
                "title": "c-code-with-explanation",
                "content": "This question seems a non-intuitive question but if you can find the pattern in the question then the code is just a piece of cake.\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());  // sorting the array in O(n logn) time\\n\\t\\tint result = 0;\\n\\t\\tfor(int itr = 0; itr < nums.size(); itr += 2){  //increment iterator each time by 2, further explanation is down below\\n\\t\\t\\tresult += nums[itr]; // store the sum \\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```\\n***Continuation of the explanation:***\\nWe iterate through the array 2 elements at  time. For example if the array in the question is \\n```  \\n\\t/*\\n\\tnums = [6,2,6,5,1,2]\\n\\tand after sorting array becomes [1,2,2,5,6,6]\\n\\tnow think of the pairs in the array [ (1,2) , (2,5) , (6,6) ]\\n\\tout of which the minimum will always be the first element of the pair \\n\\tand that is the reason we are iterating 2 elements at the time summing \\n\\tup the minimum of each pair and having the maximum sum;\\n\\t*/ \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());  // sorting the array in O(n logn) time\\n\\t\\tint result = 0;\\n\\t\\tfor(int itr = 0; itr < nums.size(); itr += 2){  //increment iterator each time by 2, further explanation is down below\\n\\t\\t\\tresult += nums[itr]; // store the sum \\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```\n```  \\n\\t/*\\n\\tnums = [6,2,6,5,1,2]\\n\\tand after sorting array becomes [1,2,2,5,6,6]\\n\\tnow think of the pairs in the array [ (1,2) , (2,5) , (6,6) ]\\n\\tout of which the minimum will always be the first element of the pair \\n\\tand that is the reason we are iterating 2 elements at the time summing \\n\\tup the minimum of each pair and having the maximum sum;\\n\\t*/ \\n```",
                "codeTag": "Java"
            },
            {
                "id": 449816,
                "title": "java-o-n-solution-5ms",
                "content": "```\\nint[] arr = new int[20001];\\n        for (int num: nums)\\n            arr[num + 10000]++; //count the number of times each number appears\\n        int tag = 1, sum = 0;\\n        for (int i = -10000; i < 10001; i++) { // from left to right, add up every other one\\n            sum += (arr[i + 10000] + tag) / 2 * i; // tag for helping judge odd or even times the last number appears, 1 for even, 0 for odd\\n            tag = (arr[i + 10000] + tag) & 1; \\n        }\\n        return sum;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint[] arr = new int[20001];\\n        for (int num: nums)\\n            arr[num + 10000]++; //count the number of times each number appears\\n        int tag = 1, sum = 0;\\n        for (int i = -10000; i < 10001; i++) { // from left to right, add up every other one\\n            sum += (arr[i + 10000] + tag) / 2 * i; // tag for helping judge odd or even times the last number appears, 1 for even, 0 for odd\\n            tag = (arr[i + 10000] + tag) & 1; \\n        }\\n        return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426985,
                "title": "python3-easy-solution-99-98-faster-two-lines",
                "content": "class Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        return sum(nums[0:len(nums):2])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        return sum(nums[0:len(nums):2])\\n",
                "codeTag": "Java"
            },
            {
                "id": 376134,
                "title": "python-1-line-faster-than-98",
                "content": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732307,
                "title": "simple-and-easy-solution-c-time-complexity-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n= nums.size(), ans=0;\\n        for(int i=0; i<n; i+=2){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n= nums.size(), ans=0;\\n        for(int i=0; i<n; i+=2){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298796,
                "title": "561-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the input array of integers.\\n2. Traverse the sorted array by taking every second element and adding them to get the sum.\\n3. Return the sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the array\\n        return sum(nums[::2]) # return the sum of every other element in the sorted array\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the array\\n        return sum(nums[::2]) # return the sum of every other element in the sorted array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029188,
                "title": "javascript-nlogn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNope\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var sum = 0\\n    for(var i = 0; i<nums.length; i+= 2){\\n        sum += nums[i]\\n    }\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var sum = 0\\n    for(var i = 0; i<nums.length; i+= 2){\\n        sum += nums[i]\\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850851,
                "title": "c-best-logic-solution-explained-explanation-with-another-example",
                "content": "**Other Input Example:**\\n\\nHere, **n** means size of the vector(given input). And we have make n/2 pairs.\\n\\n- Input = [5,11,9,1], n=4\\n- Then we have to group them into n/2 pairs. \\n- The Possible pairs are: (1,9), (1,11), (1,5), (9,11), (11,5), (5,9).\\n- Now we want to find the maximum sum of any n/2 pairs. And, sum from one pair need to taken as min of those numbers.\\n\\nPossible output sums are shown below:\\n\\nmin(1,9) = 1, min(5,11) = 5     So, sum = 6(1+5)\\nmin(1,11) = 1, min(9,5) = 5     So, sum = 6(1+5)\\nmin(1,5) = 1,  min(11,9) = 9    So, sum = 10(1+9)   // Output\\n\\nNow, we have to return the maximum sum of any n/2 pairs.\\nThus, output = 10 would give us the maximum sum of min of n/2 pairs.\\n\\nHope, it helps.    Happy Coding  :)\\n\\n**Given Basic Test-case Example:**\\n\\nInput = [1,2,3,4],  n =4\\nThen we have to group them into n/2 pairs. possible pairs are: (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) . \\nPossible output sums are shown below:\\n( min(1,4) = 1 + min(2,3) = 2 ) = 3\\n( min(1,3) = 1 + min(2,4) = 2 ) = 3\\n( min(1,2) = 1 + min(3,4) = 3 ) = 4 // Output\\n\\nThus, output = 4 would give us the maximum sum of min pairs.\\n\\n**Solution:**\\n```\\nclass Solution\\n{\\npublic:\\n    int arrayPairSum(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0, count = 0;\\n        for (int i = nums.size() - 1; i >= 0; i -= 2)\\n            if (count != nums.size() / 2)\\n            {\\n                sum += min(nums[i], nums[i - 1]);\\n                count++;\\n            }\\n        return sum;\\n    }\\n};\\n```\\n**Optimized Solution**\\n```\\nclass Solution\\n{\\npublic:\\n    int arrayPairSum(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for (int i = nums.size() - 1; i >= 0; i -= 2)\\n            sum += nums[i - 1];\\n        return sum;\\n    }\\n};\\n```\\n\\n**Note:**  Pls update/inform if anything looks wrong or doesn\\'t make sense.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int arrayPairSum(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0, count = 0;\\n        for (int i = nums.size() - 1; i >= 0; i -= 2)\\n            if (count != nums.size() / 2)\\n            {\\n                sum += min(nums[i], nums[i - 1]);\\n                count++;\\n            }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int arrayPairSum(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for (int i = nums.size() - 1; i >= 0; i -= 2)\\n            sum += nums[i - 1];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734403,
                "title": "c-solution-qsort",
                "content": "```\\ncmp(void* a, void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint arrayPairSum(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int count = 0;\\n    for(int i; i<numsSize;i+=2)\\n        count+=nums[i];\\n    return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ncmp(void* a, void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint arrayPairSum(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int count = 0;\\n    for(int i; i<numsSize;i+=2)\\n        count+=nums[i];\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 429063,
                "title": "python-solution-faster-than-99",
                "content": "```\\narr = sorted(nums)\\nreturn sum(arr[0::2])\\n```",
                "solutionTags": [],
                "code": "```\\narr = sorted(nums)\\nreturn sum(arr[0::2])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253279,
                "title": "javascript-solution",
                "content": "```\\nlet arrayPairSum = function(nums) {\\n\\treturn nums\\n\\t\\t.sort((a, b) => a - b)\\n\\t\\t.filter((x, index) => index % 2 === 0)\\n\\t\\t.reduce((a, b) => a + b);\\n};\\n```\\n\\n\\u041D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E, \\u0437\\u0430\\u0447\\u0435\\u043C \\u0432 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u0438 \\u0441\\u043A\\u0430\\u0437\\u0430\\u043D\\u043E \\u0440\\u0430\\u0437\\u0431\\u0438\\u0432\\u0430\\u0442\\u044C \\u043D\\u0430 \\u043F\\u0430\\u0440\\u044B \\u0438 \\u043D\\u0430\\u0445\\u043E\\u0434\\u0438\\u0442\\u044C \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0438\\u0437 \\u043D\\u0438\\u0445 - \\u0435\\u0441\\u0442\\u044C \\u0431\\u043E\\u043B\\u0435\\u0435 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E\\u0435 \\u0438 \\u0431\\u044B\\u0441\\u0442\\u0440\\u043E\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet arrayPairSum = function(nums) {\\n\\treturn nums\\n\\t\\t.sort((a, b) => a - b)\\n\\t\\t.filter((x, index) => index % 2 === 0)\\n\\t\\t.reduce((a, b) => a + b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246648,
                "title": "rust-3-lines",
                "content": "```\\nimpl Solution {\\n    pub fn array_pair_sum(nums: Vec<i32>) -> i32 {\\n        let mut nums_v = nums;\\n        nums_v.sort_unstable();\\n        nums_v.iter().step_by(2).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_pair_sum(nums: Vec<i32>) -> i32 {\\n        let mut nums_v = nums;\\n        nums_v.sort_unstable();\\n        nums_v.iter().step_by(2).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178016,
                "title": "java-solution-o-n-time-beats-98-84",
                "content": "Instead of sorting the original array, we can use a count[] array to count the frequence of each number, and then loop through count[] to chose the smaller one for each pairs.\n\nAs the number is between [-10000, 10000], there is 20001 in total.\nfor each number and the index of count[] array, the mapping relationship is:\n**index = number + 10000**\n\nAfter we have filled count array, loop through count[] to pick elements.\nOnly consider to pick this element if its freq > 0:\n\t1. If we have not picked the 1st element, pick current number, and freq--\n\t2. If we have picked the 1st element, skip current number by freq--\n\n```\nclass Solution {\n    private static final int shift = 10000;\n\n    public int arrayPairSum(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        // to store the freq of of num\n        // each index maps to number \"index - shift\"\n        int[] count = new int[2 * shift + 1];\n\n        for (int num : nums) {\n            int index = num + shift;\n            count[index]++;\n        }\n\n        int res = 0;\n        boolean first = true; // need to chose first element\n        for (int index = 0; index < count.length; index++) {\n            while (count[index] != 0) {\n                if (first) {\n                    int num = index - shift;\n                    res += num;\n                    count[index]--;\n                    first = false;\n                } else { // has chosen the first element, skip the second\n                    count[index]--;\n                    first = true;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private static final int shift = 10000;\n\n    public int arrayPairSum(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        // to store the freq of of num\n        // each index maps to number \"index - shift\"\n        int[] count = new int[2 * shift + 1];\n\n        for (int num : nums) {\n            int index = num + shift;\n            count[index]++;\n        }\n\n        int res = 0;\n        boolean first = true; // need to chose first element\n        for (int index = 0; index < count.length; index++) {\n            while (count[index] != 0) {\n                if (first) {\n                    int num = index - shift;\n                    res += num;\n                    count[index]--;\n                    first = false;\n                } else { // has chosen the first element, skip the second\n                    count[index]--;\n                    first = true;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 155653,
                "title": "go-solution-with-quicksort",
                "content": "```\\nfunc sort(nums []int) []int{\\n    if len(nums) == 0{\\n        return []int{}\\n    }\\n    max := nums[0]\\n    var left_res, right_res, res []int\\n    for i := 1; i < len(nums); i++{\\n        if nums[i] < max{\\n            left_res = append(left_res, nums[i])\\n        } else {\\n            right_res = append(right_res, nums[i])\\n        }   \\n    }\\n    left_res = sort(left_res)\\n    right_res = sort(right_res)\\n    res = append(res, left_res...)\\n    res = append(res, max)\\n    res = append(res, right_res...)\\n    return res\\n}\\n\\nfunc arrayPairSum(nums []int) int {\\n    res := 0\\n    nums = sort(nums)\\n    for i := 0; i < len(nums); i += 2{\\n        res = res + nums[i]\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sort(nums []int) []int{\\n    if len(nums) == 0{\\n        return []int{}\\n    }\\n    max := nums[0]\\n    var left_res, right_res, res []int\\n    for i := 1; i < len(nums); i++{\\n        if nums[i] < max{\\n            left_res = append(left_res, nums[i])\\n        } else {\\n            right_res = append(right_res, nums[i])\\n        }   \\n    }\\n    left_res = sort(left_res)\\n    right_res = sort(right_res)\\n    res = append(res, left_res...)\\n    res = append(res, max)\\n    res = append(res, right_res...)\\n    return res\\n}\\n\\nfunc arrayPairSum(nums []int) int {\\n    res := 0\\n    nums = sort(nums)\\n    for i := 0; i < len(nums); i += 2{\\n        res = res + nums[i]\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102200,
                "title": "4-lines-c",
                "content": "```\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i += 2) sum += nums[i];\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i += 2) sum += nums[i];\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680964,
                "title": "java-13-ms-beats-94-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int result = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0;i < nums.length ; i += 2){\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int result = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0;i < nums.length ; i += 2){\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164255,
                "title": "sort-the-array-awesome-logic",
                "content": "\\n\\n# Sort the Array\\n```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        nums=sorted(nums)\\n        count=0\\n        for i in range(0,len(nums),2):\\n            count+=nums[i]\\n        return count\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        nums=sorted(nums)\\n        count=0\\n        for i in range(0,len(nums),2):\\n            count+=nums[i]\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956618,
                "title": "10ms-solution-easy-solution-o-nlogn-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Code\\n```\\nclass Solution \\n{\\n    public int arrayPairSum(int[] nums) \\n    {\\n        int n = nums.length, answer = 0;\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < n; i += 2)\\n            answer += nums[i];\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int arrayPairSum(int[] nums) \\n    {\\n        int n = nums.length, answer = 0;\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < n; i += 2)\\n            answer += nums[i];\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786806,
                "title": "c-fast-solution-0ms-solution",
                "content": "nums = [6,2,6,5,1,2]\\n\\nbasically first we have sort the array\\nnum=[1,2,2,5,6,6]\\n               i\\n\\nsum=0;\\nso we have to start with i=nums.size()-1;\\nwe have to run the loop until we our value of i >=1\\n\\nNow we have to calculate the minimum  of value min(nums[i],nums[i-1]);\\nfor( int i=nums.size()-1,i>=1;i-=2)\\n\\n   sum+= min(nums[i],nums[i-1]);\\n\\n1. sum+= min(nums[5],nums[4]);  // min(6,6) => 6  // sum=0+6 //i=5-2=3\\n2. sum+= min(nums[3],nums[2]);  // min(5,2) => 2  // sum=6+2 //i=3-2=1\\n3. sum+= min(nums[1],nums[0]);  // min(2,1) => 1  // sum=8+1 //         i=1-2=-1\\n \\nso value of i<1 so return the value of sum=9;\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n    //           i\\n    // 1 2 2 5 6 6\\n    sort(nums.begin(),nums.end());\\n    int sum=0;\\n    int n= nums.size()-1;\\n    for( int i=n;i>=1;i-=2){\\n      sum+= min(nums[i],nums[i-1]);  \\n    }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n    //           i\\n    // 1 2 2 5 6 6\\n    sort(nums.begin(),nums.end());\\n    int sum=0;\\n    int n= nums.size()-1;\\n    for( int i=n;i>=1;i-=2){\\n      sum+= min(nums[i],nums[i-1]);  \\n    }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621031,
                "title": "python-219-ms-one-liner-simplest-approach",
                "content": "\\t\\t return sum(sorted(nums)[::2])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\t return sum(sorted(nums)[::2])\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1864422,
                "title": "array-partition-1-runtime-beats-47-python-easy",
                "content": "Sort the array and start the for loop from index 1 and then iterate after every two elements and store minimum between current element and its previous element in an array and then return the sum of the all the elements of the array.\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l = []\\n        for i in range(1,len(nums),2):\\n            l.append(min(nums[i],nums[i-1]))\\n        return sum(l)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Sort the array and start the for loop from index 1 and then iterate after every two elements and store minimum between current element and its previous element in an array and then return the sum of the all the elements of the array.\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l = []\\n        for i in range(1,len(nums),2):\\n            l.append(min(nums[i],nums[i-1]))\\n        return sum(l)",
                "codeTag": "Java"
            },
            {
                "id": 1661447,
                "title": "easiest-pythn-solution",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        res = 0\\n        nums.sort()\\n        for i in range(0, len(nums), 2):\\n            res += nums[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        res = 0\\n        nums.sort()\\n        for i in range(0, len(nums), 2):\\n            res += nums[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632602,
                "title": "array-partition-1-greedy-technique-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int maxi = 0;\\n        for(int i=0; i<nums.size(); i = i+2){\\n            maxi += min(nums[i],nums[i+1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int maxi = 0;\\n        for(int i=0; i<nums.size(); i = i+2){\\n            maxi += min(nums[i],nums[i+1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304873,
                "title": "java-easy-solution",
                "content": "\\n\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t class Solution {\\n    public int arrayPairSum(int[] nums) {\\n         int sum=0;\\n         Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i=i+2)\\n        {\\n               sum += nums[i];  \\n        }\\n            return sum; \\n        \\n     }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int arrayPairSum(int[] nums) {\\n         int sum=0;\\n         Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i=i+2)\\n        {\\n               sum += nums[i];  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1233393,
                "title": "python-3-o-n-logn-beats-92-time-and-97-space",
                "content": "Just Sort the array and sum up odd position elements.\\n\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        n=len(nums)//2\\n        nums.sort()\\n        i=0\\n        j=n\\n        if n%2!=0:\\n            j+=1\\n        ans=0\\n        while(i<n):\\n            ans+=nums[i]\\n            if j<n+n:\\n                ans+=nums[j]\\n            i+=2\\n            j+=2\\n        return ans\\n            \\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        n=len(nums)//2\\n        nums.sort()\\n        i=0\\n        j=n\\n        if n%2!=0:\\n            j+=1\\n        ans=0\\n        while(i<n):\\n            ans+=nums[i]\\n            if j<n+n:\\n                ans+=nums[j]\\n            i+=2\\n            j+=2\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217700,
                "title": "with-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n      int sum=0;\\n       sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n      int sum=0;\\n       sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212699,
                "title": "90-faster-code",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int sum = 0;\\n        for(int i=0 ; i<nums.size() ; i+=2)\\n        {\\n            sum+= min(nums[i] , nums[i+1]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int sum = 0;\\n        for(int i=0 ; i<nums.size() ; i+=2)\\n        {\\n            sum+= min(nums[i] , nums[i+1]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009718,
                "title": "1-line-python-solution",
                "content": "``` python\\nreturn sum(sorted(nums)[::2])\\n```",
                "solutionTags": [],
                "code": "``` python\\nreturn sum(sorted(nums)[::2])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951024,
                "title": "java-solution-using-sort",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += Math.min(nums[i], nums[i+1]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += Math.min(nums[i], nums[i+1]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887444,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 719771,
                "title": "python-solution-by-exactly-one-row-code",
                "content": "# I love Python \\n\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n    \\n        return sum(sorted(nums)[::2])",
                "solutionTags": [],
                "code": "# I love Python \\n\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n    \\n        return sum(sorted(nums)[::2])",
                "codeTag": "Java"
            },
            {
                "id": 593640,
                "title": "simple-python-solution-using-sorting",
                "content": "I was hoping to do in Time less than O(NlogN) but I couldn\\u2019t resist the simplicity \\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort() \\n        return sum(nums[::2])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort() \\n        return sum(nums[::2])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 474451,
                "title": "java-simple-solution-100-time-and-space",
                "content": "```\\npublic int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i+=2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i+=2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 448845,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int ArrayPairSum(int[] nums) {\\n        return nums.OrderBy(x => x).Where((x, i) => i % 2 == 0).Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ArrayPairSum(int[] nums) {\\n        return nums.OrderBy(x => x).Where((x, i) => i % 2 == 0).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317246,
                "title": "o-n-java-solution-based-on-counting-sort-algorithm-algorithm-explained-and-coded-in-simple-way",
                "content": "pre requisite for understanding the code is knowing the concept of counting algorithm\\n\\nIn this problem, we first sort the array , then we take the odd element of each pair of elements within the array.\\n\\n**Counting algorithm is used when the range of the array is known which in our case is 200001 { -10000 to 10000}.**\\nEg {-8,-5,3,-5,3,-8,3}\\nA.1. We find out the occurence of each element in the array and maintain it in the array variable named ``count`` in the given code snippet.\\nrange :  min - max + 1 = 3 - (-8) + 1 = 12\\n-8 will be in the index 0, then -5 in index 3 and 3 in the index 5\\ncount[0] = 3, count[3] = 2, count[5] = 3\\nA.2. Copy each element in another array named ``output`` based on the frequency of the element which is maintained in the count array\\nAfter copying the array in output[] = {-8,-8,-8,-5,-5,3,3,3}\\nAs we can notice, -8 starts from index 0 and continues till index 2 till its occurence frequency, -5 from index 3 and so on.\\n\\nB.1. Once we have the sorted array, we do the summation of the odd elements of the sorted array.\\n\\n\\nHere is the simple code snippet  with comments to undertand better.\\n\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        // counting sort algorithm\\n        int max = Arrays.stream(nums).max().getAsInt(); \\n        int min = Arrays.stream(nums).min().getAsInt(); \\n        int range = max - min + 1; \\n        int count[] = new int[range]; \\n        int output[] = new int[nums.length];\\n        int sum = 0, p = 0;\\n        \\n        // for each index, increment the count of occurence of the element in that index\\n        for (int i = 0; i < nums.length; i++)  \\n        { \\n            count[nums[i] - min]++; \\n        } \\n  \\n        // copying the elements based on occurence into other array\\n        for(int i=0;i<count.length;i++)\\n        {\\n            while(count[i]>0)\\n            {\\n                output[p++] = min + i;\\n                count[i]--;\\n            }\\n                \\n        }\\n        \\n        // main logic for the problem description\\n        // taking the first element of each pair in the array since in sorted array,\\n        // the first element of the pair would be minimum\\n        for(int i = 0; i < output.length; i++){\\n            if(i % 2 == 0){\\n                sum += output[i]; \\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nAlso providing a link to understand the counting algorithm\\n[https://www.youtube.com/watch?v=OKd534EWcdk](http://)\\nHope this helps.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        // counting sort algorithm\\n        int max = Arrays.stream(nums).max().getAsInt(); \\n        int min = Arrays.stream(nums).min().getAsInt(); \\n        int range = max - min + 1; \\n        int count[] = new int[range]; \\n        int output[] = new int[nums.length];\\n        int sum = 0, p = 0;\\n        \\n        // for each index, increment the count of occurence of the element in that index\\n        for (int i = 0; i < nums.length; i++)  \\n        { \\n            count[nums[i] - min]++; \\n        } \\n  \\n        // copying the elements based on occurence into other array\\n        for(int i=0;i<count.length;i++)\\n        {\\n            while(count[i]>0)\\n            {\\n                output[p++] = min + i;\\n                count[i]--;\\n            }\\n                \\n        }\\n        \\n        // main logic for the problem description\\n        // taking the first element of each pair in the array since in sorted array,\\n        // the first element of the pair would be minimum\\n        for(int i = 0; i < output.length; i++){\\n            if(i % 2 == 0){\\n                sum += output[i]; \\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280954,
                "title": "python3-one-line-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209149,
                "title": "python3-faster-than-99",
                "content": "```\\nreturn sum([x for x in sorted(nums)[::2]])",
                "solutionTags": [],
                "code": "```\\nreturn sum([x for x in sorted(nums)[::2]])",
                "codeTag": "Unknown"
            },
            {
                "id": 182906,
                "title": "javascript",
                "content": "```\nvar arrayPairSum = function(nums) {\n    nums.sort((a, b) => (a - b));\n    let result = 0;\n    for(let i = 0; i < nums.length; i = i + 2){\n        result += nums[i];\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar arrayPairSum = function(nums) {\n    nums.sort((a, b) => (a - b));\n    let result = 0;\n    for(let i = 0; i < nums.length; i = i + 2){\n        result += nums[i];\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180812,
                "title": "using-built-in-sort-in-go",
                "content": "```\\nfunc arrayPairSum(nums []int) int {\\n    sort.Ints(nums)\\n    sum := 0\\n    for i := 0; i < len(nums); i+=2 {\\n        sum += nums[i]\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc arrayPairSum(nums []int) int {\\n    sort.Ints(nums)\\n    sum := 0\\n    for i := 0; i < len(nums); i+=2 {\\n        sum += nums[i]\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149237,
                "title": "easy-understanding-java-solution-beats-98",
                "content": "```\\n    public int arrayPairSum(int[] nums) {\\n        int[] bucket = new int[20001];\\n        for(int i: nums) bucket[i + 10000] ++;\\n        int ct = 0;\\n        int result = 0;\\n        for(int i = 0; ct < nums.length; i ++){\\n            for (int j = 0; j < bucket[i]; j++){\\n                if (ct % 2 == 0){\\n                    result += (i - 10000);                   \\n                }\\n                ct ++;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int arrayPairSum(int[] nums) {\\n        int[] bucket = new int[20001];\\n        for(int i: nums) bucket[i + 10000] ++;\\n        int ct = 0;\\n        int result = 0;\\n        for(int i = 0; ct < nums.length; i ++){\\n            for (int j = 0; j < bucket[i]; j++){\\n                if (ct % 2 == 0){\\n                    result += (i - 10000);                   \\n                }\\n                ct ++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132650,
                "title": "one-line-javascript-solution",
                "content": "```\\nvar arrayPairSum = function(nums) {\\n    return nums.sort((a,b) => a-b).filter((el, ind) => ind%2 == 0).reduce((a,b) => a+b);    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n    return nums.sort((a,b) => a-b).filter((el, ind) => ind%2 == 0).reduce((a,b) => a+b);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126738,
                "title": "one-line-python3",
                "content": "Algorithm: If you sort the array, you will find just need to find the index 0, 2, 4... and sums them together.\\n```\\nreturn sum(sorted(nums)[::2])\\n```",
                "solutionTags": [],
                "code": "```\\nreturn sum(sorted(nums)[::2])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4107311,
                "title": "c-easiest-solution-explained",
                "content": "\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n# Approach\\n***(Also explained in the code)***\\n\\n- We need **maximum sum of minimum pair element from each iteration** and have to return that **maximum sum**.\\n- We **can\\'t** use same element **twice**, so we **sorted** the array and summed alternate elements and returned it, which **satisfied all conditions**. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        // Sort the input array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int sum = 0;\\n        \\n        // Iterate through the sorted array, skipping every other element\\n        for(int i = 0; i < nums.size(); i = i + 2) {\\n            sum += nums[i];\\n        }\\n        \\n        // Return the sum of the selected elements\\n        return sum;\\n    }\\n};\\n\\n```\\n\\n\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        // Sort the input array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int sum = 0;\\n        \\n        // Iterate through the sorted array, skipping every other element\\n        for(int i = 0; i < nums.size(); i = i + 2) {\\n            sum += nums[i];\\n        }\\n        \\n        // Return the sum of the selected elements\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783919,
                "title": "js-onelinner",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    return nums.sort((a,b)=>a-b).filter((e,i)=>i%2==0).reduce((ac,cu)=>ac+cu,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    return nums.sort((a,b)=>a-b).filter((e,i)=>i%2==0).reduce((ac,cu)=>ac+cu,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3673930,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou have to find maximum elements leaving one element more than it for the pair. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and find the sum of elements with every element with a even index. \\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        int sum = 0; \\n        for(int i=0; i<nums.size(); i += 2) sum += nums[i]; \\n        return sum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        int sum = 0; \\n        for(int i=0; i<nums.size(); i += 2) sum += nums[i]; \\n        return sum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622000,
                "title": "c-very-simple-sorting",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ (sorting)\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n// Don\\'t try to find min(Ai, Bi), since it\\'s sorted we know Ai will be the min\\n// So index 0, 2, 4 ... will have the minimum\\n\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int result = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i += 2) {\\n           result += nums[i]; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// Don\\'t try to find min(Ai, Bi), since it\\'s sorted we know Ai will be the min\\n// So index 0, 2, 4 ... will have the minimum\\n\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int result = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i += 2) {\\n           result += nums[i]; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554085,
                "title": "array-partition-tc-o-nlogn-sc-1-100-beat-ac-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe arrayPairSum function takes a vector of integers nums as input. It first sorts the array in ascending order using the sort function from the C++ standard library. Then, it iterates through the sorted array starting from the first element (index 0) and increments the index by 2 in each iteration. It adds the current element to the sum variable. Finally, it returns the sum as the result.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution works by taking advantage of the fact that we want to maximize the sum of the minimum values in each pair. By sorting the array, the minimum values will always be at the even indices. So, by summing up every second element, we ensure that we include the minimum values in the sum while maximizing it.\\n\\n# Complexity\\n- Time complexity: O(n long n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n log n), where n is the size of the input array. This is because the sorting operation takes O(n log n) time complexity. The iteration through the sorted array takes O(n/2) time complexity, which is equivalent to O(n). However, the dominant factor is the sorting operation.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the solution only uses a constant amount of additional space, regardless of the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n       nums.sort()  # Sort the list in ascending order\\n\\n       sum = 0\\n       # Iterate through the sorted list and sum up every second element\\n       for i in range(0, len(nums), 2):\\n          sum += nums[i]\\n\\n       return sum```\\n cpp solution\\nint arrayPairSum(vector<int>& nums) {\\n    // Sort the array in ascending order\\n    sort(nums.begin(), nums.end());\\n\\n    int sum = 0;\\n    // Iterate through the sorted array and sum up every second element\\n    for (int i = 0; i < nums.size(); i += 2) {\\n        sum += nums[i];\\n    }\\n\\n    return sum;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n       nums.sort()  # Sort the list in ascending order\\n\\n       sum = 0\\n       # Iterate through the sorted list and sum up every second element\\n       for i in range(0, len(nums), 2):\\n          sum += nums[i]\\n\\n       return sum```",
                "codeTag": "Java"
            },
            {
                "id": 3483656,
                "title": "java-solution-by-aj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479064,
                "title": "python-1-liner-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        # nums.sort()\\n        # s=0\\n        # for i in range(0,len(nums),2):\\n        #     s+=min(nums[i],nums[i+1])\\n        # return s\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        # nums.sort()\\n        # s=0\\n        # for i in range(0,len(nums),2):\\n        #     s+=min(nums[i],nums[i+1])\\n        # return s\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431304,
                "title": "2-one-liner-1-detailed-python3-beat-97-4-259ms",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        #1st Approach\\n        nums.sort()\\n        count = 0\\n        for i in range(0, len(nums),2):\\n            count += nums[i]\\n        return count\\n\\n\\n        #2nd Approach\\n        return sum(nums[i] for i in range(0, len(nums),2))\\n\\n        #3rd Approach\\n        return sum(nums[0:len(nums):2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        #1st Approach\\n        nums.sort()\\n        count = 0\\n        for i in range(0, len(nums),2):\\n            count += nums[i]\\n        return count\\n\\n\\n        #2nd Approach\\n        return sum(nums[i] for i in range(0, len(nums),2))\\n\\n        #3rd Approach\\n        return sum(nums[0:len(nums):2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400055,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for (int num : nums)\\n        {\\n            if (num > max)\\n                max = num;\\n            if (num < min)\\n                min = num;\\n        }\\n        int *nums_count = new int[max - min + 1]{};\\n        for (auto num : nums)\\n        {\\n            nums_count[num - min] += 1;\\n        }\\n        int min_pair_sum = 0;\\n        int skip = false;\\n        for (int i = 0; i < (max - min + 1); i++)\\n        {\\n            while (nums_count[i] > 0)\\n            {\\n                if (false == skip)\\n                {\\n                    min_pair_sum += (i + min);\\n                    skip = true;\\n                }\\n                else \\n                {\\n                    skip = false;\\n                }\\n                nums_count[i] -= 1;\\n            }    \\n        }\\n        delete[] nums_count;\\n        return min_pair_sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```\\n\\n```Java []\\nclass Solution {\\n  public static final int MAX_N = 10000;\\n    public static int arrayPairSum(int[] nums) {\\n    \\n      int minN = nums[0];\\n      int maxN = minN;\\n      int counts[] = new int[2*MAX_N+1];\\n      \\n      for (final int n: nums) {\\n        counts[n + MAX_N]++;\\n        if (minN > n) {\\n          minN = n;\\n        } else if (maxN < n) {\\n          maxN = n;\\n        }\\n      }\\n      int offset = 0;\\n      int total = 0;\\n    \\n      for (int n = minN; n <= maxN; ++n) {\\n        int i = n + MAX_N;\\n        int freq = counts[i];\\n        \\n        if (freq > 0) {\\n          if (freq - offset > 0) {\\n            total += ((freq + 1 - offset) >> 1) * n;\\n          }\\n          counts[i] = 0;\\n          offset = offset^(freq & 1);\\n        }\\n      }\\n      return total;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for (int num : nums)\\n        {\\n            if (num > max)\\n                max = num;\\n            if (num < min)\\n                min = num;\\n        }\\n        int *nums_count = new int[max - min + 1]{};\\n        for (auto num : nums)\\n        {\\n            nums_count[num - min] += 1;\\n        }\\n        int min_pair_sum = 0;\\n        int skip = false;\\n        for (int i = 0; i < (max - min + 1); i++)\\n        {\\n            while (nums_count[i] > 0)\\n            {\\n                if (false == skip)\\n                {\\n                    min_pair_sum += (i + min);\\n                    skip = true;\\n                }\\n                else \\n                {\\n                    skip = false;\\n                }\\n                nums_count[i] -= 1;\\n            }    \\n        }\\n        delete[] nums_count;\\n        return min_pair_sum;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```\n```Java []\\nclass Solution {\\n  public static final int MAX_N = 10000;\\n    public static int arrayPairSum(int[] nums) {\\n    \\n      int minN = nums[0];\\n      int maxN = minN;\\n      int counts[] = new int[2*MAX_N+1];\\n      \\n      for (final int n: nums) {\\n        counts[n + MAX_N]++;\\n        if (minN > n) {\\n          minN = n;\\n        } else if (maxN < n) {\\n          maxN = n;\\n        }\\n      }\\n      int offset = 0;\\n      int total = 0;\\n    \\n      for (int n = minN; n <= maxN; ++n) {\\n        int i = n + MAX_N;\\n        int freq = counts[i];\\n        \\n        if (freq > 0) {\\n          if (freq - offset > 0) {\\n            total += ((freq + 1 - offset) >> 1) * n;\\n          }\\n          counts[i] = 0;\\n          offset = offset^(freq & 1);\\n        }\\n      }\\n      return total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321171,
                "title": "1-liner-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,ans=0,0\\n        while i<len(nums):\\n            ans+=min(nums[i],nums[i+1])\\n            i+=2\\n        return ans\\n```\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,ans=0,0\\n        while i<len(nums):\\n            ans+=min(nums[i],nums[i+1])\\n            i+=2\\n        return ans\\n```\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319752,
                "title": "simplest-python-code-with-bonus-one-liner-sort",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i in range(0, len(nums), 2):\\n            res += nums[i]\\n        return res\\n        \\n```\\none-liner:\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i in range(0, len(nums), 2):\\n            res += nums[i]\\n        return res\\n        \\n```\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260013,
                "title": "code-in-c-easy-to-understand-beats-100-solution-please-upvote-it-if-its-help-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint cmp(const void *a, const void* b){\\n    return (*(int*) a-*(int*) b);\\n}\\n\\nint arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}\\nreturn sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void *a, const void* b){\\n    return (*(int*) a-*(int*) b);\\n}\\n\\nint arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}\\nreturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3252175,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n          sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n          sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155054,
                "title": "super-easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i += 2)\\n            sum += nums[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i += 2)\\n            sum += nums[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135538,
                "title": "simple-c-solution-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we have sorted the array in ascending order.\\nnow in for loop we incremented i by i=i+2 mean it will pick the smaller value ( or we can say minimum value of consecutuve 2)\\nthen in max=max+nums[i];\\ne.g-\\nint sum=0\\n[4,10,5,3,2,8]\\napplying sorting:\\n[2,3,4,5,8,10]\\noutput will be sum=sum+2+4+8=14.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int max=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i=i+2){\\n            max+=nums[i];\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int max=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i=i+2){\\n            max+=nums[i];\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131679,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int res=0;\\n        for(int i=0;i<arr.size();i+=2)\\n        {\\n            res+=arr[i];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int res=0;\\n        for(int i=0;i<arr.size();i+=2)\\n        {\\n            res+=arr[i];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057171,
                "title": "java-sorting-explained",
                "content": "# Please Upvote :D\\n---\\n- We will first sort the array.\\n- Say our array is `[1, 2, 3, 4, 5, 6]`.\\n- The duos which will give us the optimal solution are `[1, 2]`, `[3, 4]` and `[5, 6]`. \\n- So we iterate from index 0 (because we need the minimum of each duo) and add every alternate element (skipping the maximum of each duo).\\n``` java []\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);  \\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            ans += nums[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);  \\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            ans += nums[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972765,
                "title": "easy-java-solution-using-arrays-sort",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the array\\n- Take a variable\\n- Create a loop and iterate for +2\\n- Add value of array to to variable througout the loop\\n- Return the variable\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums){\\n    int n=nums.length,res=0;\\n    Arrays.sort(nums);\\n    for(int i=0;i<n;i+=2){\\n        res+=nums[i];\\n    }\\n    return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums){\\n    int n=nums.length,res=0;\\n    Arrays.sort(nums);\\n    for(int i=0;i<n;i+=2){\\n        res+=nums[i];\\n    }\\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796907,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i+=2) {\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i+=2) {\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602235,
                "title": "simple-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let ans = 0;\\n    for(let i=0;i<nums.length;i=i+2){\\n        ans += nums[i];\\n    }\\n    return ans;\\n};\\n```\\n\\nConsider upvote if you find it helpful \\uD83D\\uDE00",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let ans = 0;\\n    for(let i=0;i<nums.length;i=i+2){\\n        ans += nums[i];\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2583877,
                "title": "array-partition",
                "content": "int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i=i+2)\\n        {\\n            sum=sum+nums[i];\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i=i+2)\\n        {\\n            sum=sum+nums[i];\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 2583874,
                "title": "c-solution-efficient-solution",
                "content": "class Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int res = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i= i+2)\\n        {\\n            res = res + nums[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int res = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i= i+2)\\n        {\\n            res = res + nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2505409,
                "title": "o-nlogn-easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n     Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || i%2==0){\\n                sum+=nums[i];\\n            }\\n            }\\n        return sum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n     Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || i%2==0){\\n                sum+=nums[i];\\n            }\\n            }\\n        return sum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497948,
                "title": "c-easy-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n    \\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        int k;\\n        \\n        for(int i=0;i<nums.size();i=i+2)\\n        {\\n            int j = i+1;\\n             k = min(nums[i],nums[j]);\\n            \\n            res=res+k;\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n    \\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        int k;\\n        \\n        for(int i=0;i<nums.size();i=i+2)\\n        {\\n            int j = i+1;\\n             k = min(nums[i],nums[j]);\\n            \\n            res=res+k;\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482273,
                "title": "python-not-sure-if-it-is-good-so-please-review",
                "content": "def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[::2])",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[::2])",
                "codeTag": "Python3"
            },
            {
                "id": 2393679,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n     int res=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2){\\n            res+=min(nums[i],nums[i+1]);  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n     int res=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2){\\n            res+=min(nums[i],nums[i+1]);  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084698,
                "title": "easy-javascript-solution-with-sort-method-and-loop",
                "content": "```\\nvar arrayPairSum = function(nums) {\\n  let sumMin = 0\\n  nums.sort((a, b) => b-a)\\n  for (let i = 1; i < nums.length; i+=2) {\\n    sumMin += nums[i]\\n  }\\n\\n  return sumMin\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n  let sumMin = 0\\n  nums.sort((a, b) => b-a)\\n  for (let i = 1; i < nums.length; i+=2) {\\n    sumMin += nums[i]\\n  }\\n\\n  return sumMin\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872621,
                "title": "array-partition-i-solution-java",
                "content": "class Solution {\\n  public int arrayPairSum(int[] nums) {\\n    int ans = 0;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < nums.length; i += 2)\\n      ans += nums[i];\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "class Solution {\\n  public int arrayPairSum(int[] nums) {\\n    int ans = 0;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < nums.length; i += 2)\\n      ans += nums[i];\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1864543,
                "title": "java-optimized-easy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        \\n        int [] arr = new int [20002];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i] + 10000]++;\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                nums[j] = i - 10000;\\n                arr[i]--; j++; i--;\\n            } \\n        }\\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length-1;i+=2){\\n            sum += Math.min(nums[i],nums[i+1]);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        \\n        int [] arr = new int [20002];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i] + 10000]++;\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                nums[j] = i - 10000;\\n                arr[i]--; j++; i--;\\n            } \\n        }\\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length-1;i+=2){\\n            sum += Math.min(nums[i],nums[i+1]);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697415,
                "title": "java-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            sum+=Math.min(nums[i],nums[i+1]);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**Do upvote if you find this useful**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            sum+=Math.min(nums[i],nums[i+1]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599517,
                "title": "python-super-easy-and-super-fast",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort(), \\n        sum = 0\\n        for i in nums[::2]:\\n            sum += i\\n        return sum\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort(), \\n        sum = 0\\n        for i in nums[::2]:\\n            sum += i\\n        return sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506953,
                "title": "c-92-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int ans{0};\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i{0};i<n-1;i+=2){\\n         ans+=min(nums[i],nums[i+1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int ans{0};\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i{0};i<n-1;i+=2){\\n         ans+=min(nums[i],nums[i+1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432853,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355576,
                "title": "c",
                "content": "```\\nint arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<nums.size();i=i+2){\\n            ans=ans+nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<nums.size();i=i+2){\\n            ans=ans+nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351339,
                "title": "python3-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233560,
                "title": "simple-c-solution",
                "content": "In this we approach we just assume that to get maximum of minimum elements we always have to make pair according to the sorted order of the vector .\\n\\n\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int ans=0;\\n       sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2){\\n            ans+=nums[i];\\n     \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int ans=0;\\n       sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2){\\n            ans+=nums[i];\\n     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1187425,
                "title": "solution-easy-c",
                "content": "\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1179454,
                "title": "very-easy-and-simple-c",
                "content": "Method:\\nfirst sort the entire array. Why?\\nans: when you sort and pair, All the larger number goes to the end and when we pair the larger numbers together we get the min of that pair to be large and adding the that number to summation maximizes it.\\neg:\\n1,15,4,6,13,7,11,3,17,12\\nnow suppose imagine if i didnt sort and take min values of 2 numbers accordingly then the pair would be like\\n(1,15),(4,6),(13,7),(11,3),(17,12)\\nsummation of min values of above pair is=1+4+7+3+12=27\\nbut if I sort take summation= 1,3,4,6,7,11,12,13,15,17\\npairs(1,3) (4,6),(7,11),(12,13),(15,17)\\nsummation of min values of above pair is=1+4+7+11+12+15=50\\nso if you observe the sorted array all the min values appear in even position so just do the summation of the values at even position. Hence incrementing i value 2 times\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {   sum+=nums[i];\\n       i++;\\n            }\\n        return sum;\\n    }\\n};\\n```\\nthanks :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {   sum+=nums[i];\\n       i++;\\n            }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176789,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        int ans=0;\\n        for(int i=0;i<nums.size();i+=2){\\n            ans+=min(nums[i],nums[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        int ans=0;\\n        for(int i=0;i<nums.size();i+=2){\\n            ans+=min(nums[i],nums[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122253,
                "title": "solution-array-partition-i",
                "content": "```swift\\nclass Solution {\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        var arr = nums\\n        arr = arr.sorted()\\n        var res = 0\\n        for i in 0..<arr.count {\\n            if i & 1 != 0 {\\n                res += min(arr[i], arr[i - 1])\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        var arr = nums\\n        arr = arr.sorted()\\n        var res = 0\\n        for i in 0..<arr.count {\\n            if i & 1 != 0 {\\n                res += min(arr[i], arr[i - 1])\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035902,
                "title": "c-easy-solution",
                "content": "```\\nint arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991522,
                "title": "python-3-solution-with-explanation-80-faster",
                "content": "We have an unsorted array with n numbers and we want to find the combination of pairs min(ai,bi) such that we maximize the sum of these. While we may try to approach the problem by brute force and test every combination, this will at least require a time complexity of O(n^2). A much faster and easier approach is to take into account the following:\\n\\nIn order to maximize the sum of pairs min(ai,bi), we want to combine the smallest elements with the second smallest elements, while we combine the biggest elements with the second biggest elements. For example, if we have **nums = {1,4,3,6,2,5}**, the two smallest elements are **{1,2}**, then **{3,4}**, and then **{5,6}**. Therefore, the chosen element for each pairs is **min{1,2}=1**, **min{3,4}=3**, **min{5,6}**, and the maximum sum is **1+3+5=9**. Note that any other combination, such as **{1,5}**, will prevent us from taking a bigger number (here, 5), and thus the sum will be necessarily smaller.\\n\\nWith this in mind, the simplest approach is to sort our array from smallest to biggest, so that each pair of numbers is already adjacent to each other. For example, with **nums = {1,4,3,6,2,5}** the sorted array would be **nums = {1,2,3,4,5,6}**, and we immediatly see that we have our pairs that maximize the sum. One may be tempted here to then create a For loop and sum **min(nums[i],nums[i+1])**. However, since we only want the minimum number of each pair and we already know where they are located (every even index of the array), we can simply sum the even-index elements of the array to find our solution (~80% faster than other solutions)\\n\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums.sort[0::2])\\n```\\n\\nNote that we can still iterate over the even-indexed elements, although this approach is slightly slower (just ~70% faster than other solutions)\\n\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_sum = 0\\n        for i in range(0,len(nums),2):\\n            max_sum += nums[i]\\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums.sort[0::2])\\n```\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_sum = 0\\n        for i in range(0,len(nums),2):\\n            max_sum += nums[i]\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979545,
                "title": "python-1-liner-c-simple-and-easy-approach",
                "content": "**Python:**\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum([n for i, n in enumerate(sorted(nums)) if not i%2])\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int res = 0;\\n        for (int i = 0; i<nums.size(); i+=2)\\n            res += nums[i];\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum([n for i, n in enumerate(sorted(nums)) if not i%2])\\n```\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int res = 0;\\n        for (int i = 0; i<nums.size(); i+=2)\\n            res += nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968356,
                "title": "python-3-beat-94",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[0::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[0::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757820,
                "title": "golang-solution",
                "content": "IDK why people are creating hashMaps for this.\\nThis simple solution works.\\n```\\nfunc arrayPairSum(arr []int) int {\\n\\tsort.Ints(arr)\\n\\n\\tvar sum int = 0\\n\\tfor i := 0; i < len(arr); i += 2 {\\n\\t\\tsum += arr[i]\\n\\t}\\n\\treturn sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc arrayPairSum(arr []int) int {\\n\\tsort.Ints(arr)\\n\\n\\tvar sum int = 0\\n\\tfor i := 0; i < len(arr); i += 2 {\\n\\t\\tsum += arr[i]\\n\\t}\\n\\treturn sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702049,
                "title": "clean-java-100-o-n-time",
                "content": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int result=0;\\n        int n = nums.length>>1;\\n        int[] bucket = new int[20001];\\n        for(int num:nums){\\n            bucket[num+10000]+=1;\\n        }\\n        int i=0;\\n        while(n-- > 0){\\n            while(bucket[i]==0) i++;\\n            result += (i-10000);\\n            bucket[i]--;\\n            while(bucket[i]==0) i++;\\n            bucket[i]--;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nFor a more detailed explanation look at first part of the counting sort which is exactly what we do in our example. The only difference is that we need to add 10000, since our range of nums[i] is(-10000,10000) and we cannot access an array by negative values. Example: buckets[-1] -> Error;\\nhttps://www.youtube.com/watch?v=7zuGmKfUt7s",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int result=0;\\n        int n = nums.length>>1;\\n        int[] bucket = new int[20001];\\n        for(int num:nums){\\n            bucket[num+10000]+=1;\\n        }\\n        int i=0;\\n        while(n-- > 0){\\n            while(bucket[i]==0) i++;\\n            result += (i-10000);\\n            bucket[i]--;\\n            while(bucket[i]==0) i++;\\n            bucket[i]--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606700,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0,count = 0, n = nums.size();\\n        priority_queue <int, vector<int>, greater<int>> pq (begin(nums), end(nums));\\n        while(count < n/2){\\n            sum += pq.top();\\n            pq.pop();pq.pop();\\n            count++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum = 0,count = 0, n = nums.size();\\n        priority_queue <int, vector<int>, greater<int>> pq (begin(nums), end(nums));\\n        while(count < n/2){\\n            sum += pq.top();\\n            pq.pop();pq.pop();\\n            count++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544536,
                "title": "python-syntax-observation-several-solutions-list-comprehension-slice-notation-range",
                "content": "### Leetcode: 561. Array Partition I.\\n\\nFirst need to sort an array, and then sum elements under even indices.\\n\\n\\n![Elements under even indices are minimum one in pairs](https://assets.leetcode.com/users/user9697n/image_1584638942.png)\\n\\n\\nList comprehension:\\n\\n```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 300 ms, faster than 41.47% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.4 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum([value for index,value in enumerate(sorted(nums)) if 0 == index%2])\\n```\\n\\nPython [slice notation](https://stackoverflow.com/a/509295/8574922):\\n\\n```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 292 ms, faster than 61.69% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.3 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```\\n\\n[Range](https://docs.python.org/3/library/functions.html#func-range):\\n\\n```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 280 ms, faster than 92.06% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.4 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums = sorted(nums)\\n        for i in range(0,len(nums),2):\\n            ans += nums[i]\\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 300 ms, faster than 41.47% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.4 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum([value for index,value in enumerate(sorted(nums)) if 0 == index%2])\\n```\n```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 292 ms, faster than 61.69% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.3 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```\n```Python\\n\\'\\'\\'\\n561. Array Partition I\\nhttps://leetcode.com/problems/array-partition-i/\\nRuntime: 280 ms, faster than 92.06% of Python3 online submissions for Array Partition I.\\nMemory Usage: 15.4 MB, less than 6.06% of Python3 online submissions for Array Partition I.\\n\\'\\'\\'\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums = sorted(nums)\\n        for i in range(0,len(nums),2):\\n            ans += nums[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520605,
                "title": "java-simple-solution-using-sorting",
                "content": "```\\npublic int arrayPairSum(int[] nums) {\\n        int n=nums.length/2;\\n        int sum=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int arrayPairSum(int[] nums) {\\n        int n=nums.length/2;\\n        int sum=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411825,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410890,
                "title": "java-5-line-simple-solution",
                "content": "```\\npublic int arrayPairSum(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint sum = 0;\\n\\tfor(int i=0; i<nums.length; i+=2)\\n\\t\\tsum += nums[i];\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int arrayPairSum(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint sum = 0;\\n\\tfor(int i=0; i<nums.length; i+=2)\\n\\t\\tsum += nums[i];\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356274,
                "title": "python-97-8-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# how we are going to solve: \\n\\t\\t# get the smaller of the 2 smallest numbers and add to total, afterwards repeat\\n        s = sorted(nums) \\n\\t\\t# e.g. sorts to [1, 2, 3, 4]\\n        total = 0\\n        for i in s[::2]: #\\n            # e.g. [1,2,3,4] becomes [1, 3], which gets the minimum values\\n            total += i\\n\\t\\t\\t# add minimum values to total value\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# how we are going to solve: \\n\\t\\t# get the smaller of the 2 smallest numbers and add to total, afterwards repeat\\n        s = sorted(nums) \\n\\t\\t# e.g. sorts to [1, 2, 3, 4]\\n        total = 0\\n        for i in s[::2]: #\\n            # e.g. [1,2,3,4] becomes [1, 3], which gets the minimum values\\n            total += i\\n\\t\\t\\t# add minimum values to total value\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325097,
                "title": "python-simple-solution-with-a-brief-explain",
                "content": "Let the smallest element in `nums` be `least`, and the second smallest element be `second`. In the answer pair list, `least` must be bound with `second`! Because no matter which pair `least` is in, the min value of that pair is `least`. If `least` is not bound with `second`, the min value of the pair of `second` would be `second`.  In fact, that pair could have been made up of two larger number than `second`. So do not let `second` harm others! Just combine `least` with `second`, and combine the two smallest elements in the rest array, and repeat this until all elements are paired.\\nMy thought comes from greedy algorithm.\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum(nums[::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296726,
                "title": "easy-to-understand-java-answer",
                "content": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for ( int i = 0 ; i < nums.length; i = i + 2 ){\\n            sum = Math.min(nums[i],nums[i+1]) + sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for ( int i = 0 ; i < nums.length; i = i + 2 ){\\n            sum = Math.min(nums[i],nums[i+1]) + sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284789,
                "title": "simple-java-solution",
                "content": "```class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length - 1; i += 2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length - 1; i += 2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 255708,
                "title": "python-code-with-comments-easy-to-understand-codegirl",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #sort the array \\n        new=sorted(nums)\\n        \\n        #take every other element , first and third and fifth etc \\n        new=new[::2]\\n        \\n        #add the elements of the list \\n        return sum(new)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #sort the array \\n        new=sorted(nums)\\n        \\n        #take every other element , first and third and fifth etc \\n        new=new[::2]\\n        \\n        #add the elements of the list \\n        return sum(new)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 245310,
                "title": "simple-java-program",
                "content": "class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int result = 0;\\n\\t\\t//add nums[0] nums[2] nums[4] \\u2026\\u2026 nums[n-2] nums[n]\\n        for(int i = 0; i < nums.length; ){\\n            result = result + nums[i];\\n            i = i + 2;\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int result = 0;\\n\\t\\t//add nums[0] nums[2] nums[4] \\u2026\\u2026 nums[n-2] nums[n]\\n        for(int i = 0; i < nums.length; ){\\n            result = result + nums[i];\\n            i = i + 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 226182,
                "title": "one-line-python3",
                "content": "```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum([v for v in sorted(nums)[:-1:2]])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return sum([v for v in sorted(nums)[:-1:2]])",
                "codeTag": "Java"
            },
            {
                "id": 180838,
                "title": "beats-100-by-using-bucket-sort-in-go-o-n-52-ms",
                "content": "It\\'s basically the idea of [bucket sort](https://en.wikipedia.org/wiki/Bucket_sort).\\n\\n```\\nfunc arrayPairSum(nums []int) int {\\n    var buckets [20001]int\\n    for _, v := range nums {\\n        buckets[v+10000]++\\n    }\\n    sum := 0\\n    odd := true\\n    for i := 0; i < len(buckets); i++ {\\n        for buckets[i] > 0 {\\n            if odd {\\n                sum += i - 10000\\n            }\\n            odd = !odd\\n            buckets[i]--\\n        }\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc arrayPairSum(nums []int) int {\\n    var buckets [20001]int\\n    for _, v := range nums {\\n        buckets[v+10000]++\\n    }\\n    sum := 0\\n    odd := true\\n    for i := 0; i < len(buckets); i++ {\\n        for buckets[i] > 0 {\\n            if odd {\\n                sum += i - 10000\\n            }\\n            odd = !odd\\n            buckets[i]--\\n        }\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178063,
                "title": "clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158095,
                "title": "python-one-liner",
                "content": "```python\\n\"\"\"\\nsort and sum the even indices (the even indices are always min in a pair, given the array is sorted)\\n\"\"\"\\nreturn sum(sorted(nums)[::2]) \\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nsort and sum the even indices (the even indices are always min in a pair, given the array is sorted)\\n\"\"\"\\nreturn sum(sorted(nums)[::2]) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155731,
                "title": "two-lines-python-solution-easy-to-understand",
                "content": "class Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return sum(nums[0::2])",
                "solutionTags": [],
                "code": "class Solution:\\n    def arrayPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return sum(nums[0::2])",
                "codeTag": "Java"
            },
            {
                "id": 149110,
                "title": "a-two-pointer-solution",
                "content": "I saw someone ask for two pointer solution. So here is one, Hope my code is easy to read.\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = nums.length - 2;\\n        int n = nums.length / 2;\\n        int result = 0;\\n        boolean odd = false;\\n        \\n        if(n % 2 == 1) {\\n            odd = true;\\n        }\\n        \\n        while(i < j) {\\n            result += nums[i];\\n            result += nums[j];\\n            i += 2;\\n            j -= 2;\\n        }\\n        \\n        if(odd) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = nums.length - 2;\\n        int n = nums.length / 2;\\n        int result = 0;\\n        boolean odd = false;\\n        \\n        if(n % 2 == 1) {\\n            odd = true;\\n        }\\n        \\n        while(i < j) {\\n            result += nums[i];\\n            result += nums[j];\\n            i += 2;\\n            j -= 2;\\n        }\\n        \\n        if(odd) {\\n            result += nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142972,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun arrayPairSum(nums: IntArray): Int {\\n        nums.sort()\\n        return nums.filterIndexed { index, _ -> index % 2 == 0 }.sum()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arrayPairSum(nums: IntArray): Int {\\n        nums.sort()\\n        return nums.filterIndexed { index, _ -> index % 2 == 0 }.sum()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126022,
                "title": "easy-to-understand-python",
                "content": "**Algorithm in English:**\\nIf we want to maximize the sum, we want to pair high numbers with high numbers and low numbers with low numbers. For example, for the trivial case of input [1,1,10,10], If we we make pairs (1,10) and (1,10) , we would get a sum of 2. But if we make pairs (1,1) and (10,10), we would get a sum of 11. So to get the largest sum:\\n\\n1) sort the input nums\\n2) for every 2 elements in the sorted array, add the smaller one to the sum\\n3) return the sum\\n\\nNote that there is a trick at step 2. on the line \"sumV += nums[i]\", a more straightforward way to do this would be \"sumV += min(nums[i] , nums[i+1])\". In a sorted array, however, nums[i] will always be smaller than nums[i+1]. Using this trick improved the score from beating 50% submissions to beating 94% submissions.\\n\\n**Space and time complexities:**\\nO(N Log N) for time complexity, since the bottleneck is sorting nums\\nO(1) for space complexity, because we are modifying nums in place and because we are just storing sum\\n\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        nums = sorted(nums)\\n        sumV = 0\\n        \\n        for i in range(0, len(nums), 2):\\n            sumV += nums[i]\\n        \\n        return sumV\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums):\\n        nums = sorted(nums)\\n        sumV = 0\\n        \\n        for i in range(0, len(nums), 2):\\n            sumV += nums[i]\\n        \\n        return sumV\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117620,
                "title": "c-solution",
                "content": "Just would like to share the idea to resolve this problem. So directly use the built-in sorting method.\n```\npublic class Solution {\n    public int ArrayPairSum(int[] nums) {\n            int sum = 0;\n\n            Array.Sort(nums);\n\n            for (var i = 0; i < nums.Length; i += 2)\n                sum += nums[i];\n\n            return sum;\n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    public int ArrayPairSum(int[] nums) {\n            int sum = 0;\n\n            Array.Sort(nums);\n\n            for (var i = 0; i < nums.Length; i += 2)\n                sum += nums[i];\n\n            return sum;\n    }",
                "codeTag": "Java"
            },
            {
                "id": 102194,
                "title": "swift-solution-12ms",
                "content": "\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        let tempArray = nums.sorted(by: <)\\n        var result = 0\\n        for value in tempArray.enumerated() {\\n            if(value.offset % 2 == 0){\\n                result+=value.element\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        let tempArray = nums.sorted(by: <)\\n        var result = 0\\n        for value in tempArray.enumerated() {\\n            if(value.offset % 2 == 0){\\n                result+=value.element\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 102202,
                "title": "java-solution-and-straightforward-explanation",
                "content": "Assume there is an array:\\na1 < a2 < a3 < a4 ...... < a2n\\nsum = ?\\n\\nAs we all known, a1 = min(a1, ai)   (1 < i <= 2n). \\nSo the sum which we want to figure out must include the smallest number a1. When we remove a1 from the given array, which number do you want to killed at the same time? As far as I see, the best answer is a2.\\n\\na3 < a4 < a5 < a6.... < a2n\\nsum = a1 + ?\\n\\nNow, a3 is the smallest number of array!\\nI believe you have already know all story here.\\n\\na5 < a6 < a7 < ... < a2n\\nsum = a1 + a3 + ?\\n \\n...\\n\\nsum = a1 + a3 + .... + a(2n - 1)\\n\\n\\nMy first solution:\\n```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nSince we know the range of array's integers, bucket sort is a faster sort algorithm.\\n```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int[] array = new int[20001];\\n        for (int i = 0; i < nums.length; i++) {\\n            array[nums[i] + 10000]++;\\n        }\\n        int sum = 0;\\n        boolean smaller = true;\\n        for (int i = 0; i < array.length;) {\\n            if (array[i] > 0) {\\n                if (smaller) {\\n                    sum += i - 10000;\\n                }\\n                smaller = !smaller;\\n                array[i]--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int[] array = new int[20001];\\n        for (int i = 0; i < nums.length; i++) {\\n            array[nums[i] + 10000]++;\\n        }\\n        int sum = 0;\\n        boolean smaller = true;\\n        for (int i = 0; i < array.length;) {\\n            if (array[i] > 0) {\\n                if (smaller) {\\n                    sum += i - 10000;\\n                }\\n                smaller = !smaller;\\n                array[i]--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102213,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    var number = 0;\\n    nums.sort(function(a,b){return a-b});\\n    for (var i = 0; i < nums.length; i=i+2) {\\n    \\tnumber += nums[i];\\n    }\\n    return number;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayPairSum = function(nums) {\\n    var number = 0;\\n    nums.sort(function(a,b){return a-b});\\n    for (var i = 0; i < nums.length; i=i+2) {\\n    \\tnumber += nums[i];\\n    }\\n    return number;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102227,
                "title": "easy-javascript-sort-function-solution",
                "content": "Here is the simplest JavaScript solution I could think of. Use the sort function to sort array quickly then simply add up every second index.\\n\\n***\\nvar arrayPairSum = function(nums) {\\n   \\n    nums.sort(function(a, b){return a-b});//sort the array\\n   \\n    var result = 0;\\n   \\n    for(var i = 0; i < nums.length; i=i+2){\\n        result += nums[i];\\n    }\\n    return result;\\n    \\n};\\n***",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "Here is the simplest JavaScript solution I could think of. Use the sort function to sort array quickly then simply add up every second index.\\n\\n***\\nvar arrayPairSum = function(nums) {\\n   \\n    nums.sort(function(a, b){return a-b});//sort the array\\n   \\n    var result = 0;\\n   \\n    for(var i = 0; i < nums.length; i=i+2){\\n        result += nums[i];\\n    }\\n    return result;\\n    \\n};\\n***",
                "codeTag": "Unknown"
            },
            {
                "id": 102228,
                "title": "javascript-solution-write-out-quicksort",
                "content": "```\\nvar arrayPairSum = function(nums) {\\n    // understanding the prob: https://discuss.leetcode.com/topic/87682/please-explain-the-question-doesn-t-make-sense\\n    // get the largest possible sum of MIN of the pair.\\n    // eg: [1,2,3,4] => (1,2) and (3,4).  min(1,2) + min(3,4) = 4\\n    // so the core is to understand:  why (1,2) and (3,4) would result to best possible sum?\\n    // intuitive: to get the best possible sum, need to make the min number in the pair as large as possible.\\n    // as proof in https://discuss.leetcode.com/topic/87206/java-solution-sorting-and-rough-proof-of-algorithm/3 ,\\n    // cont'd , in order to make |ai - bi| smallest, THEY SHOULD BE ADJACENT\\n    // solution: sort, then add 1st, 3rd... elem of the sorted array\\n\\n    // quick sort \\n    // partition arr first, then quicksort smaller part(from code, recursive, check backwards one by one), then quicksort bigger part(recursive, check forward one by one)\\n    var p = 0;  // first index of arr, arr[p...r]\\n    var r = nums.length - 1;  // last index of arr, arr[p...r]\\n    var i;  // the last index of \"smaller part\"\\n    var pivot, j, save, q;\\n    var result = 0;\\n\\n    var quickSort = function(A, p, r) {\\n        if (p < r) {\\n            q = partition(A, p, r);\\n            // smaller part, and bigger part\\n            quickSort(A, p, q - 1);\\n            quickSort(A, q + 1, r);\\n        }\\n    }\\n    \\n    var partition = function(nums, p, r) {\\n        pivot = nums[r];\\n        i = p - 1;\\n        for (j = p; j < r; j++) {\\n            if (nums[j] <= pivot) {\\n                i++;\\n                // if current elem is smaller than pivot, and there are bigger-than-pivot checked elem(s), switch cur with the first bigger-than-pivot-checked elem\\n                // if not, just switch with itself, so no change\\n                save = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = save;\\n            }\\n        }\\n        // insert as separator\\n        save = nums[r];\\n        nums[r] = nums[i+1];\\n        nums[i+1] = save;\\n\\n        return i+1;\\n    }\\n\\n    // test partition\\n    console.log(partition(nums, p, r));\\n\\n    quickSort(nums, p, r);\\n    console.log(nums);\\n\\n    // add 1st, 3rd elems of array\\n    for (i = 0; i < nums.length; i += 2) {\\n        result += nums[i];\\n    }\\n\\n    return result;\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nvar arrayPairSum = function(nums) {\\n    // understanding the prob: https://discuss.leetcode.com/topic/87682/please-explain-the-question-doesn-t-make-sense\\n    // get the largest possible sum of MIN of the pair.\\n    // eg: [1,2,3,4] => (1,2) and (3,4).  min(1,2) + min(3,4) = 4\\n    // so the core is to understand:  why (1,2) and (3,4) would result to best possible sum?\\n    // intuitive: to get the best possible sum, need to make the min number in the pair as large as possible.\\n    // as proof in https://discuss.leetcode.com/topic/87206/java-solution-sorting-and-rough-proof-of-algorithm/3 ,\\n    // cont'd , in order to make |ai - bi| smallest, THEY SHOULD BE ADJACENT\\n    // solution: sort, then add 1st, 3rd... elem of the sorted array\\n\\n    // quick sort \\n    // partition arr first, then quicksort smaller part(from code, recursive, check backwards one by one), then quicksort bigger part(recursive, check forward one by one)\\n    var p = 0;  // first index of arr, arr[p...r]\\n    var r = nums.length - 1;  // last index of arr, arr[p...r]\\n    var i;  // the last index of \"smaller part\"\\n    var pivot, j, save, q;\\n    var result = 0;\\n\\n    var quickSort = function(A, p, r) {\\n        if (p < r) {\\n            q = partition(A, p, r);\\n            // smaller part, and bigger part\\n            quickSort(A, p, q - 1);\\n            quickSort(A, q + 1, r);\\n        }\\n    }\\n    \\n    var partition = function(nums, p, r) {\\n        pivot = nums[r];\\n        i = p - 1;\\n        for (j = p; j < r; j++) {\\n            if (nums[j] <= pivot) {\\n                i++;\\n                // if current elem is smaller than pivot, and there are bigger-than-pivot checked elem(s), switch cur with the first bigger-than-pivot-checked elem\\n                // if not, just switch with itself, so no change\\n                save = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = save;\\n            }\\n        }\\n        // insert as separator\\n        save = nums[r];\\n        nums[r] = nums[i+1];\\n        nums[i+1] = save;\\n\\n        return i+1;\\n    }\\n\\n    // test partition\\n    console.log(partition(nums, p, r));\\n\\n    quickSort(nums, p, r);\\n    console.log(nums);\\n\\n    // add 1st, 3rd elems of array\\n    for (i = 0; i < nums.length; i += 2) {\\n        result += nums[i];\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102246,
                "title": "o-n-java-solution-without-sorting",
                "content": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int n = nums.length >> 1;\\n        // Since all the integers in the array \"nums\" is in the range of [-10000, 10000], using an array \"m\" \\n        // to track how many times each integer in above range appears in \"nums\". For example, if there \\n        // are 3 integers of \"10\" in \"nums\", m[10000 + 10] =  3; if there is ONE integer of \"-10000\", m[0] = 1, etc. \\n        int[] m = new int[20001];\\n        // After below for loop,  m[0] + m[1] + ... + m[20001] = 2n\\n        for (int num : nums) m[num + 10000] += 1;\\n        int sum = 0;\\n        int i = 0;\\n        // Getting n pairs by visiting \"m\", which is essentially equivalent to visiting the sorted input array like other sorting approaches.\\n        while (n-- > 0) {\\n            // m[i] == 0 means integer \"i - 10000\" doesn't exist in input array or it has been used up in previous pairs.\\n            while (m[i] == 0) i++;\\n            sum += (i - 10000);\\n            m[i]--;\\n            while (m[i] == 0) i++;\\n            m[i]--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int n = nums.length >> 1;\\n        // Since all the integers in the array \"nums\" is in the range of [-10000, 10000], using an array \"m\" \\n        // to track how many times each integer in above range appears in \"nums\". For example, if there \\n        // are 3 integers of \"10\" in \"nums\", m[10000 + 10] =  3; if there is ONE integer of \"-10000\", m[0] = 1, etc. \\n        int[] m = new int[20001];\\n        // After below for loop,  m[0] + m[1] + ... + m[20001] = 2n\\n        for (int num : nums) m[num + 10000] += 1;\\n        int sum = 0;\\n        int i = 0;\\n        // Getting n pairs by visiting \"m\", which is essentially equivalent to visiting the sorted input array like other sorting approaches.\\n        while (n-- > 0) {\\n            // m[i] == 0 means integer \"i - 10000\" doesn't exist in input array or it has been used up in previous pairs.\\n            while (m[i] == 0) i++;\\n            sum += (i - 10000);\\n            m[i]--;\\n            while (m[i] == 0) i++;\\n            m[i]--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994549,
                "title": "easy-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n func arrayPairSum(_ nums: [Int]) -> Int {\\n    var sortedNum = nums.sorted()\\n    var sum = 0\\n    var i = 0\\n    var j = 1\\n    \\n    while j < sortedNum.count {\\n        sum += min(sortedNum[i], sortedNum[j])\\n        i += 2\\n        j += 2\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n func arrayPairSum(_ nums: [Int]) -> Int {\\n    var sortedNum = nums.sorted()\\n    var sum = 0\\n    var i = 0\\n    var j = 1\\n    \\n    while j < sortedNum.count {\\n        sum += min(sortedNum[i], sortedNum[j])\\n        i += 2\\n        j += 2\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984887,
                "title": "simple-and-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOptimal pairing would be pair of two greater numbers together so that min of the pair is maximum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array\\n2. Add every alternative element\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for (int i=0;i<nums.length;i=i+2){\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for (int i=0;i<nums.length;i=i+2){\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954157,
                "title": "fast-and-beginners-friendly-beats-95-53-using-quick-sort",
                "content": "**Runtime 12ms**\\n**Beats: 95.53%**\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        quickSort(nums, 0, nums.length - 1);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i+=2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    int partition(int[] arr, int low, int high) {\\n        int pivot = arr[high];\\n        int i = (low - 1);\\n\\n        for (int j = low; j <= high - 1; j++) {\\n            if (arr[j] < pivot) {\\n                i++;\\n                swap(arr, i, j);\\n            }\\n        }\\n        swap(arr, i + 1, high);\\n        return (i + 1);\\n    }\\n    void quickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int pi = partition(arr, low, high);\\n            quickSort(arr, low, pi - 1);\\n            quickSort(arr, pi + 1, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayPairSum(int[] nums) {\\n        quickSort(nums, 0, nums.length - 1);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i+=2) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    int partition(int[] arr, int low, int high) {\\n        int pivot = arr[high];\\n        int i = (low - 1);\\n\\n        for (int j = low; j <= high - 1; j++) {\\n            if (arr[j] < pivot) {\\n                i++;\\n                swap(arr, i, j);\\n            }\\n        }\\n        swap(arr, i + 1, high);\\n        return (i + 1);\\n    }\\n    void quickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int pi = partition(arr, low, high);\\n            quickSort(arr, low, pi - 1);\\n            quickSort(arr, pi + 1, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903451,
                "title": "easiest-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887860,
                "title": "array-partition-c-solution",
                "content": "# Intuition\\nsort the array and sum all min values in K pairs to get the maximized sum. \\n\\n\\n# Complexity\\n- Time complexity : O(NlogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = n/2;\\n        int mini = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++){\\n            mini += min(nums[i],nums[i+1]);\\n            i++;\\n    }\\n        return mini;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = n/2;\\n        int mini = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++){\\n            mini += min(nums[i],nums[i+1]);\\n            i++;\\n    }\\n        return mini;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870653,
                "title": "simplest-4-line-logic-beats-100-runtime-detailed-explanation",
                "content": "# Approach\\n1. `return sum([nums[i] for i in range(0,len(nums),2)])`: Here, a list comprehension is used to extract the smaller elements of each pair from the sorted array and calculate their sum. The list comprehension iterates over the indices of the sorted array nums starting from `0` with a step size of `2`. This way, it selects every other element, which corresponds to the `smaller element` of `each pair`.\\n\\n2. For example, if the input array is `nums = [5, 1, 3, 4]`, after sorting it becomes `[1, 3, 4, 5]`. The pairs are `(1, 3)` and `(4, 5)`. The smaller elements in each pair are `1` and `4`. The function would then return the sum of these smaller elements: `1 + 4 = 5`.\\n\\n# Complexity\\n- ### Time Complexity:\\n\\n1. `Sorting:` The time complexity of sorting an `array` of length `2n` is $O(n log n)$. The `sort()` function typically uses a variant of the `quicksort` algorithm, which has an `average time complexity` of $O(n log n)$.\\n\\n2. `List Comprehension:` The list comprehension in the return statement iterates over the array of length `n` (`half of the original array`). Since each iteration takes constant time (extracting elements from the array), the time complexity of the list comprehension is $O(n)$.\\n\\n3. Overall, the dominant operation is the sorting step with a time complexity of $O(n log n)$. Thus, the `overall time complexity` of the code is $O(n log n)$.\\n\\n- ### Space Complexity:\\n\\n1. `Sorting:` The `sort()` function generally performs an `in-place` sorting, meaning it doesn\\'t create a new array. Therefore, the `space complexity` of the sorting step is $O(1)$.\\n\\n2. `List Comprehension:` The list comprehension creates a new list to store the smaller elements of each pair. The size of this list is `n` (`half of the original array`). Thus, the `space complexity` of the list comprehension is $O(n)$.\\n\\n3. Overall, the `space complexity` is `dominated` by the list created in the `list comprehension`, which is $O(n)$.\\n\\nIn summary, the `time complexity` of the code is $O(n log n)$, and the `space complexity` is $O(n)$.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        nums.sort()\\n        return sum([nums[i] for i in range(0,len(nums),2)])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayPairSum(self, nums):\\n        nums.sort()\\n        return sum([nums[i] for i in range(0,len(nums),2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815803,
                "title": "simple-c-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;\\n        int sum = 0;\\n        for(int i=0;i<nums.size()-1;i=i+2){\\n            sum+=min(nums[i],nums[i+1]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;\\n        int sum = 0;\\n        for(int i=0;i<nums.size()-1;i=i+2){\\n            sum+=min(nums[i],nums[i+1]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775307,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        var sorted = nums.sorted(by: >)\\n        let n = nums.count\\n        var i = 0\\n        var sum = 0\\n        while i < n{\\n            let mini = min(sorted[i],sorted[i+1])\\n            sum += mini\\n            i += 2\\n        }\\n        return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arrayPairSum(_ nums: [Int]) -> Int {\\n        var sorted = nums.sorted(by: >)\\n        let n = nums.count\\n        var i = 0\\n        var sum = 0\\n        while i < n{\\n            let mini = min(sorted[i],sorted[i+1])\\n            sum += mini\\n            i += 2\\n        }\\n        return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765805,
                "title": "simple-approach",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int n = size(nums);\\n        sort(begin(nums), end(nums));\\n\\n        int ans=0;\\n        for(int i=0; i<n; i+=2)\\n        {\\n            ans+=nums[i];\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/e091be88-b7d0-4dd1-9474-0970bd6f38fe_1689361967.050657.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        int n = size(nums);\\n        sort(begin(nums), end(nums));\\n\\n        int ans=0;\\n        for(int i=0; i<n; i+=2)\\n        {\\n            ans+=nums[i];\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664541,
                "title": "python-easy-solution-sorting",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        tot=0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                tot+=nums[i]\\n        return tot\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        tot=0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                tot+=nums[i]\\n        return tot\\n            \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564623,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1565126,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568280,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1565537,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1567601,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1566894,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1566800,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568204,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568029,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568217,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1564623,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1565126,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568280,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1565537,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1567601,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1566894,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1566800,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568204,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568029,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1568217,
                "content": [
                    {
                        "username": "djordan",
                        "content": "So if we are given [1.2.3.4], is this a possibility?\\n\\n(1,4) and (2,3)\\n\\nIn that case, won't the correct answer be 5. Our goal is to get the largest possible sum from the above 4 integers. So, how can 4 be the answer?\\n\\nThanks"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@kerku](/kerku) One element allowed only once in pairing :)"
                    },
                    {
                        "username": "HimalayaJhala",
                        "content": "Actually it is :\n\nmin(1,4) + min(2,3) = 1 + 2 --> 3 \n\nAnd from such pairs and adding min of each pair , we have to find max  sum."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "kerku",
                        "content": "[@ArpanSaha2102000](/ArpanSaha2102000) there is a pair min(2,3) + min(3,4) --> 2 + 3 which will give 5 as a result. why this is not considered as a max sum of minimum values?"
                    },
                    {
                        "username": "ArpanSaha2102000",
                        "content": "we need minimum value number of the pairs and sum those  integers  and among all the possible outcome  we need to return the minimum value so , that\\'s way we can\\'t return 5  \\n"
                    },
                    {
                        "username": "vedanshi555",
                        "content": "nope, we need to sum up the minimum number of a pair ,, so here the minimum number from (1,4) would be 1 and from (2,3) = 2 , so the sum is 1+2 =3 which is not the largest number that we can get:)"
                    },
                    {
                        "username": "megatron99",
                        "content": "1. We choose two numbers to make a pair.\\n2. Then we take min(a,b) = val\\n3. This sum of val\\'s has to be maximum.\\n\\nSo, in all the pairs we make , if we take a bigger number and a very small number and take min of these two numbers then we are just wasting away the bigger number as it could be used with some other number for pairing so that it will contribute to the final sum.\\n\\nSo, when we do sorting , we make the adjacent numbers numerically close to each others. So, we can take  pairwise elements like 1st and 2nd elements, 3rd and 4th element.. etc so reduce the difference between two numbers in each pair.\\n\\nexample: \\n\\ninput = [1, 1000, 3, 999]\\n\\nThen if we take (1,1000) and (3,999) as pairs :\\n\\nmin1 = min(1,1000) = 1;\\nmin2 = min(3,999) = 3;\\n\\nFinal sum = min1 + min2 = 4;\\n\\n-------\\nBut if we sorted the array, we can choose adjacent numbers in the array as the pairs.\\n\\nthen: input = [1,3,999,1000]\\nmin1 = min(1,3)\\nmin2 = min(999,1000)\\n\\nfinal sum  = min1 + min2 = 1 + 999 = 1000;\\n\\n\\n---\\nWe can clearly observe how we get the difference and I hope you understood why sorting of array is needed here."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "we dont need to find the minimum after sorting,first sort ,then just traverse the array by 2 and increase the sum,because left index is always greater than the right index.So neeed to take the minimum"
                    },
                    {
                        "username": "aman_111singh",
                        "content": "but we need maximum sum which is 1000 so why will be go for 4 plz reply ?"
                    },
                    {
                        "username": "interist32",
                        "content": "The key to understanding the problem in my case was:\\nGiven **2n** integers. We need to create **n** pairs. Which means that the number of pairs is **half** of the given array.\\nExample:\\n[1,2,3,4]\\nWe have 4 elements and have to create 4/2=2 pairs from this. What pairs? Take a look which 2 pairs might be created:\\n\\n(1,2) and (3,4) - on possible pair\\n(1,3) and (2,4) - another one\\n(1,4) and (2,3) - the last one.\\nOne more time, we can\\'t create (1,2) and (2,3) for example, because this pair can\\'t give us the original array if we join them.\\n\\n*If you still confused at this point, imagine 4 people and split them to 2 different pairs. One man can\\'t be in two pairs simultaneously (A-ha?).*\\n\\nNext, we need to decide which of these 3 pairs gives us maximum if we take the minimal element of each of them, i.e.:\\n\\nmin(1,2) + min(3,4) = 1 + 3 = 4\\nmin(1,3) + min(2,4) = 1 + 2 = 3\\nmin(1,4) + min(2,3) = 1 + 2 = 3\\nThe first one gives us the maximum. Here\\'s the answer.\\n\\nHope it helps someone."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Beautifully explained. "
                    },
                    {
                        "username": "prince1724",
                        "content": "Well explained. Thank  you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    },
                    {
                        "username": "MikeDuan",
                        "content": "How can we use two-pointer technique to solve this problem?"
                    },
                    {
                        "username": "Chuxel",
                        "content": "Don\\'t know why this problem is inside this topic: https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/1154/"
                    },
                    {
                        "username": "kjs01",
                        "content": "I\\'m also working on that Explore Card, and couldn\\'t figure out what this problem has anything to do with Two Pointers. Really confused... "
                    },
                    {
                        "username": "vazodair",
                        "content": "yes, I\\'m inside that topic and it doesn\\'t make any sense"
                    },
                    {
                        "username": "deadbeat253",
                        "content": "The current explanation does not make much sense."
                    },
                    {
                        "username": "rgiliyal",
                        "content": "Question: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\\nthe example given was, \\n[1,4,3,2] and the answer 4\\n\\nis it that i need to check all the possible 8 arrays that are of length n , and compute their sums and look for the greatest sum of them all? \\n\\ni am not clear of the question. Will someone please explain it to me?"
                    },
                    {
                        "username": "edzaferovic",
                        "content": "The question is asking us to group the array into pairs of two and add up all the mins of all the pairs and output the result. The catch is to find what the max output could be. In the example the array is [1,4,3,2] so you could pair (1,4) and (3,2) which would give you an output of 3 since the min of (1,4) = 1 and (3,2) = 2. You can also pair them (1,2) and (3,4) which would return you 4 since (1,2) = 1 and (3,4) = 3. \\n\\nThe simple way of approaching this is to sort the array and add every other number increment the loop by 2 instead of 1. The reason why this works is because you can never get the max number in the array so instead you get the next best thing which is the number before it. \\n"
                    },
                    {
                        "username": "noruledev",
                        "content": "So, what is the solution using the \"two-pointer technique\"? All the solutions provided in the forum don\\'t seem to use it at all..."
                    },
                    {
                        "username": "Chikamso",
                        "content": "The code is not helpful at all so yeah"
                    }
                ]
            },
            {
                "id": 1567988,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1572896,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1572628,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 2035822,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1846506,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1573317,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1572823,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 1572367,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 2054308,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 2054246,
                "content": [
                    {
                        "username": "silonov",
                        "content": "#### Proof\\nSuppose we have an optimal solution:\\n`S_maximum = min(a_smallest, a_j) + S_other` where `a_smallest` is the smallest number in the integer set and `a_j` is greater or equal to `a_smallest`.\\n\\nLet us proof the following statement.\\nIf there is a number (or numbers) `a_between_a_smallest_and_a_j` between `a_smallest` and `a_j` then it must satisfy to the condition: the second number paired with `a_between_a_smallest_and_a_j` **can be only with the same value** as `a_between_a_smallest_and_a_j`, i.e. there are two variants for optimal solution:\\n* `S_maximum =  min(a_smallest, a_j) + S_other`, where `a_j` - next smallest after `a_smallest`\\n* `S_maximum = min(a_smallest, a_j) + min(a2, a2) + min(a3, a3) + ... + S_other`, where `a_smallest <= a2 <= a3 <= a_j`.\\n\\nWe prove by contradiction.\\nSuppose there is a number `a_i` between:  `a_smallest < a_i < a_j`  in solution. His paired number is `a_k`. So the optimal sum looks like: `S_maximum = min(a_smallest, a_j) + min(a_i, a_k) + S_other.`\\nIf `a_i < a_k`, then we can get greater sum with `S_maximum = min(a_smallest, a_i) + min(a_k, a_j) + S_other`, because `a_j > a_i` and `a_k > a_i` . Contradiction!\\nIf `a_i > a_k`, then we can greater sum with `S_maximum = min(a_smallest, a_k) + min(a_i, a_j) + S_other`. Contradiction!\\nSo for fixed smallest number `a1` the optimal solution looks like: `min(a1, a2) + other` where `a2` - next smallest after `a1` or `min(a1, aj) + min(a2, a2) + min(a3, a3) + other` where `a1 <= a2 <= a3 <= aj`. Both this variants we can rewrote without decreasing sum into `min(a1, a2) + min(a2, a3) + min(a3, a3) + min(a3, aj) + min(a4, a5)`  where `a1<=a2=a2(second)=a3=a3=a3=a3<=aj` - *but this is just sorted numbers paired*! So `a_smallest` can be *only* paired with next smallest number. Iterating through `S_other` with this logic we just get solution with sorting idea.\\n\\n\\n\\n#### Main idea\\nThe logic behind this is if we have an optimal solution `S_max = min(a_smallest, a_k) + S_optimal_other` we can replace `a_k` with the next smallest number after `a_smallest` (`a_smallest_2`) and put `a_k` in old `a_smallest_2` position without decreasing sum. Repeating this trick for `S_optimal_other` we get sorted pairs."
                    },
                    {
                        "username": "azariven",
                        "content": "\\'\\'\\'\\nreturn sum(sorted(nums)[::2])\\n\\'\\'\\'"
                    },
                    {
                        "username": "luoxiayizhi",
                        "content": "is this a sort problem?\\ntry to sort from small to big.then add the even index number?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "yes"
                    },
                    {
                        "username": "karts2306",
                        "content": "Find the pattern for finding most optimal pairing of get maximised sum of minimum numbers. It\\'s easily possible after sorting. If sorted the arrays then pair the elements as it is, the even position numbers will be the minimum numbers which are give the sum of maximised answer"
                    },
                    {
                        "username": "karts2306",
                        "content": "[@TasneemAyham](/TasneemAyham) Haha,  We\\'ve all been there! Happy coding....!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "MANN!!! I thought about 2-pointers and recursion and all kinds of stuff. And then you just come and tell me to sort!!!\nWhere's your conscience bro???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Just sort the array and do even numbers sum you get the answer"
                    },
                    {
                        "username": "ImUneeck",
                        "content": "I don\\'t think I\\'ve ever heard of an array of 2n size. Aren\\'t all array sizes n? \\n\\nThe way I want to solve this seems strange. You say we should group integers, (a, b) so does that mean, lets say arr[0] = a and arr[1] = b? \\n\\nAlso are we supposed to add the integers together, or add up the amount of total integer groups? If that\\'s the case then why not just get the size of the array and split it to find the answer?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "2n means the size of array is even"
                    },
                    {
                        "username": "Iwillcrackit",
                        "content": "Any other way to solve other than sorting array prior?"
                    },
                    {
                        "username": "www2019",
                        "content": "Proving with the idea of exchange arguments. Considered the sorted array a_1, a_2, ,,,, a_{2n-1}, a_{2n}, and let S = {  (a_1, a_i), .... } be a pairing with the maximal sum. We claim that a_i equals to a_2, otherwise there are two pairs (a_1, a_i) and (a_2, a_j) in S, with min(a_i, a_j) > a_2. Define \\'\\n\\nS0 = S - { (a_1, a_i), (a_2, a_j) }\\n\\nand let\\'s construct a new pairing S1\\n\\nS1 = S0  + { (a_1, a_2), (a_i, a_j) }\\n\\nSUM(S) = SUM(S0) + min(a_1, a_i) + min(a_2, a_j) = SUM(S0) + a_1 + a_2\\nSUM(S1) = SUM(S0) + min(a_1, a_2) + min(a_i, a_j) = SUM(S0) + a_1 + min(a_i, a_j)\\n\\nAs min(a_i, a_j) > a_2, SUM(S1) is larger than SUM(S), a contradition. That is, (a_1, a_2) must be a pair in S. Repeating this aruments shows S is { (a_1, a_2), (a_3, a_4), ... (a_{2n-1}, a_2n) }. #"
                    },
                    {
                        "username": "Musfik41",
                        "content": "Do we really have to sort the given array?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "It\\'s runs with low TC and SC. Why do you have any other faster/more efficient way?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "The method name should be \"arrayPairMaxSum\"😅"
                    }
                ]
            },
            {
                "id": 2047435,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 2032930,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 2002518,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1961120,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1871906,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1782447,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1766634,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1760379,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1746155,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            },
            {
                "id": 1704030,
                "content": [
                    {
                        "username": "jorido",
                        "content": "Since we are maximizing the sum of the **minimum** integers of pairs, we need to make sure we are not _wasting_ a large number. Intuitively, with the example [1,2,3,4], we do not want to waste 3 or 4 by pairing it up with a 1. Furthermore, it becomes a matter of wasting the smaller numbers. For instance, anything paired with a 1 will be wasted as it is the smallest integer in the array; followingly, you want to pair 1 with the next smallest number so a larger number is utilized in the sum in another pair. Hopefully this helps the intuition come to you!"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "just see the hint\\uD83E\\uDD21\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Sorting nums` is the catch here, sort nums and you will find the answer!!!\\n`Here is the code implementation, Beats 100% Runtime with Detailed Explanation:`\\nhttps://leetcode.com/problems/array-partition/solutions/3870653/simplest-4-line-logic-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "The intution of this problem is not simple. It is not like other easy marked leetcode question. This one needs more brainstorming."
                    },
                    {
                        "username": "user7459sI",
                        "content": "I suggest the following approach:\\n1. Sort array using counting sort\\n2. Iterate over even index in sorted array and add number on this index to sum\\n\\nTip: For sorting array of both positive and negative integers, you need to add offset to the negative integer during first run and then subtract this offset when sorting in the second run\\n\\nBelow is pseudocode for counting sort with negative integers:\\n ```\\nfn sort(array) {\\n    minNumber := min(array)\\n    maxNumber := max(array)\\n\\n   offset = 0\\n   if minNumber < 0 { // this means that negative integer was found and the offset should not be 0\\n      offset = -minNumber\\n   }\\n  \\n  memory = []\\n  for number in array {\\n      // first run - add offset value\\n      memory[number + offset] += 1\\n  }\\n\\nsorted = []\\nfor number := 0; number < memory.length; number++ {\\n    for ocurrences =  memory[number]; ocurrences > 0; ocurrences-- {\\n      // second run - subtract offset\\n      sorted.push(number - offfset)\\n  }\\n  return sorted\\n}\\n```"
                    },
                    {
                        "username": "Mr_Daker",
                        "content": "Is this problem possible to solve in O(N) TC?"
                    },
                    {
                        "username": "davronbek6",
                        "content": "what structure we use to pair them"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/561_array_partition.cpp"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": "C++ Solution\\nStep1: sort the array.\\nStep2: Iterate over the pair of arrays to get min element and add it to counter variable pairsum.\\n\\nCode:\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int pairsum = min(nums[0],nums[1]);\\n        for(int i=2;i<nums.size()-1;i+=2){\\n           pairsum += min(nums[i],nums[i+1]);\\n        }\\n        return pairsum;\\n    }\\n};\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I honestly find the text terrible. \\n\\nsay [1,2,3,4] or [1,4,3,2]\\nresults in best pair: (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\\n\\nex2: [6,2,6,5,1,2] or [1,2,2,5,6,6]\\nThe optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\\n\\nApparently in ex2 I smell some two pointer logic going on here and a random (6,6) \\nIn ex1 I see an i+2 pattern for the sorted array."
                    }
                ]
            }
        ]
    }
]