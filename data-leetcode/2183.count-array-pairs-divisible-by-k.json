[
    {
        "title": "Count Array Pairs Divisible by K",
        "question_content": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:\n\n\t0 <= i < j <= n - 1 and\n\tnums[i] * nums[j] is divisible by k.\n\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 7\nExplanation: \nThe 7 pairs of indices whose corresponding products are divisible by 2 are\n(0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).\nTheir products are 2, 4, 6, 8, 10, 12, and 20 respectively.\nOther pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2.    \n\nExample 2:\n\nInput: nums = [1,2,3,4], k = 5\nOutput: 0\nExplanation: There does not exist any pair of indices whose corresponding product is divisible by 5.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i], k <= 105",
        "solutions": [
            {
                "id": 1785906,
                "title": "how-gcd-a-k-gcd-b-k-k-0-explained-with-example",
                "content": "## Intuition\\nLet\\'s first understand this property:\\n\\n<b>If (a*b)%k==0, then\\ngcd(a,k) * gcd(b,k) % k is also 0</b>\\n\\nLet\\u2019s assume two numbers 504 and 819. Their prime factorization can be written as:\\n\\n504 = (2^3) * (3^2) * 7\\n819 = (3^2) * 7 * 13\\n\\nNow gcd(504,819) = 63 and 63 = (3^2) * 7\\n\\n<b>gcd(a,b) is the multiplication of common prime factors of a and b.</b>\\n\\nComing back to the statement\\nHow gcd(a,k) * gcd(b,k) % k is 0 ?\\n\\nFor any number to be divisble by k it need to have atleast all the prime factors of k.\\n\\ngcd(a,k) = Multiplication of all prime factors of k available in a.\\nand\\ngcd(b,k) = Multiplication of all prime factors of k available in b.\\n\\nIf gcd(a,k) * gcd(b,k) % k is 0, it means some of the prime factors of k are contributed by a and some of the prime factors of k are contributed by b and thier multiplication has all the prime factors of k which means a*b is divisble by k.\\n\\nWe dont care about prime factors of a or b which are not prime factors of k because they will not help us in making a*b divisible by k.\\n\\nExample:\\n\\nLet k=84, a=24, b=273\\n\\nk = 84 = (2^2) * 3 * 7\\na = 24 = (2^3) * 3\\nb = 273 =  3 * 7 * 13\\n\\ngcd(a,k) = (2^2) * 3 (Common prime factors of a and k)\\ngcd(b,k) = 7 * 3 (Common prime factors of b and k)\\n\\ngcd(a,k) * gcd(b,k) = (2^2) * (3^2) * 7\\nwhich has all prime factors of k thus a*b is divisble by k.\\n\\n## Now the solution:\\n\\nAs compared to checking for every pair, if we check for gcd of every number with k then the operations will be less because the number of prime factors of a number will be less.\\n\\nCode:\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<ll, ll> gcdCount;\\n        ll ans = 0;\\n        for (ll i = 0; i < nums.size(); ++i)\\n        {\\n            ll currgcd = __gcd(nums[i], k);\\n            for (auto &[gc_d, count] : gcdCount)\\n                if ((currgcd * gc_d) % k == 0)\\n                    ans += count;\\n            gcdCount[currgcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Time Complexity - O(N*sqrt(K))\\n\\nWhy sqrt(K):\\nSince we are taking gcd, it means we are considering factors of K and the number of factors of K will not be above 2*sqrt(K).\\n\\nI hope you got the logic.\\n\\nYou can ask your questions in comment section.\\n\\nPlease upvote if you found this helpful.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<ll, ll> gcdCount;\\n        ll ans = 0;\\n        for (ll i = 0; i < nums.size(); ++i)\\n        {\\n            ll currgcd = __gcd(nums[i], k);\\n            for (auto &[gc_d, count] : gcdCount)\\n                if ((currgcd * gc_d) % k == 0)\\n                    ans += count;\\n            gcdCount[currgcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784712,
                "title": "python-o-nsqrt-k-easy-understand-solution",
                "content": "* Firstly, generate all divisors of k.\\n* Secondly, for each index `i` in `nums`, count the number of index `j` hold: \\n    * `j < i`\\n\\t* `nums[j] MOD k/GCD(k, nums[i]) == 0`\\n*  Obviously, `k/GCD(k, nums[i])` is a divisor of k. Therefore, we just need a counter to maintain the number of elements on the left divisible for each divisor of k.\\n* Complexity: \\n\\t* Time: O(N * sqrt(K))\\n\\t* Space: O(sqrt(K))\\n\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        N, output = len(nums), 0\\n        divisors = []\\n        counter = Counter()\\n        \\n        for i in range(1, k + 1):\\n            if k % i == 0:\\n                divisors.append(i)\\n        \\n        for i in range(0, N):\\n            remainder = k // math.gcd(k, nums[i])\\n            output += counter[remainder]\\n            for divisor in divisors:\\n                if nums[i] % divisor == 0:\\n                    counter[divisor] += 1\\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        N, output = len(nums), 0\\n        divisors = []\\n        counter = Counter()\\n        \\n        for i in range(1, k + 1):\\n            if k % i == 0:\\n                divisors.append(i)\\n        \\n        for i in range(0, N):\\n            remainder = k // math.gcd(k, nums[i])\\n            output += counter[remainder]\\n            for divisor in divisors:\\n                if nums[i] % divisor == 0:\\n                    counter[divisor] += 1\\n            \\n        return output\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785027,
                "title": "java-c-python-easy-and-concise-with-explanation",
                "content": "# **Explanation**\\nCount all elements greatest common divisor with `k`.\\nFor each pair `(a, b)` of divisors, check if `a * b % k == 0`\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog100000 + k * k)`\\nSpace `O(k)`\\nwhere `k` is the number of divisors of `k`.\\n\\n# **Value of K**\\nprovided by @megurine\\n83160 and 98280 have the biggest number of diviors, which is 128.\\n83160 = 11*7*5*3*3*3*2*2*2\\n98280 = 13*7*5*3*3*3*2*2*2\\n\\nprovided by @endlesscheng\\nMaximal number of divisors of any n-digit number\\nhttps://oeis.org/A066150\\n<br>\\n\\n**Java**\\nby @blackspinner\\n```java\\n    public long countPairs(int[] nums, int k) {\\n        Map<Long, Long> cnt = new HashMap<>();\\n        long res = 0L;\\n        for (int x : nums) {\\n            cnt.merge(BigInteger.valueOf(x).gcd(BigInteger.valueOf(k)).longValue(), 1L, Long::sum);\\n        }\\n        for (long x : cnt.keySet()) {\\n            for (long y : cnt.keySet()) {\\n                if (x <= y && x * y % k == 0L) {\\n                    res += x < y ? cnt.get(x) * cnt.get(y) : cnt.get(x) * (cnt.get(x) - 1L) / 2L;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nby @alexunxus\\n```\\nlong long coutPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (int& nu: nums) {\\n            mp[gcd(nu, k)]++;\\n        }\\n        long long res = 0;\\n        for (auto& [a, c1]: mp) {\\n            for (auto & [b, c2]: mp) {\\n                if (a <= b && a*(long) b %k == 0) {\\n                    res += a < b?(long)c1*c2:(long)c1*(c1-1)/2;\\n                }\\n            }\\n        }\\n        return res;    \\n    }\\n```\\n**Python**\\n```py\\n    def coutPairs(self, A, k):\\n        cnt = Counter(math.gcd(a, k) for a in A)\\n        res = 0\\n        for a in cnt:\\n            for b in cnt:\\n                if a <= b and a * b % k == 0:\\n                    res += cnt[a] * cnt[b] if a < b else cnt[a] * (cnt[a] - 1) // 2\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countPairs(int[] nums, int k) {\\n        Map<Long, Long> cnt = new HashMap<>();\\n        long res = 0L;\\n        for (int x : nums) {\\n            cnt.merge(BigInteger.valueOf(x).gcd(BigInteger.valueOf(k)).longValue(), 1L, Long::sum);\\n        }\\n        for (long x : cnt.keySet()) {\\n            for (long y : cnt.keySet()) {\\n                if (x <= y && x * y % k == 0L) {\\n                    res += x < y ? cnt.get(x) * cnt.get(y) : cnt.get(x) * (cnt.get(x) - 1L) / 2L;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nlong long coutPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (int& nu: nums) {\\n            mp[gcd(nu, k)]++;\\n        }\\n        long long res = 0;\\n        for (auto& [a, c1]: mp) {\\n            for (auto & [b, c2]: mp) {\\n                if (a <= b && a*(long) b %k == 0) {\\n                    res += a < b?(long)c1*c2:(long)c1*(c1-1)/2;\\n                }\\n            }\\n        }\\n        return res;    \\n    }\\n```\n```py\\n    def coutPairs(self, A, k):\\n        cnt = Counter(math.gcd(a, k) for a in A)\\n        res = 0\\n        for a in cnt:\\n            for b in cnt:\\n                if a <= b and a * b % k == 0:\\n                    res += cnt[a] * cnt[b] if a < b else cnt[a] * (cnt[a] - 1) // 2\\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784821,
                "title": "java-counting-previous-numbers-by-gcds",
                "content": "For a given number, only the gcd between current number `num[i]` and k need to be considered. All we need to do is to count/group the numbers by the gcds. And if `gcd(num[i], k) *  gcd(num[j], k)` is divisible by k , `num[i] * num[j]` should also be divisible.\\n\\n```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Integer> gcdMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = findGcd(nums[i], k);\\n            for (int num : gcdMap.keySet()) {\\n                if ((long) gcd * num % k == 0) { // Need to convert gcd(i) * gcd(j) to long, sad java\\n                    result += gcdMap.get(num);\\n                }\\n            }\\n            gcdMap.put(gcd, gcdMap.getOrDefault(gcd, 0) + 1);\\n        }\\n        return result;\\n    }\\n    private int findGcd(int x, int y) {\\n        if (x < y) {\\n            return findGcd(y, x);\\n        }\\n        return y == 0 ? x : findGcd(y, x % y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Integer> gcdMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = findGcd(nums[i], k);\\n            for (int num : gcdMap.keySet()) {\\n                if ((long) gcd * num % k == 0) { // Need to convert gcd(i) * gcd(j) to long, sad java\\n                    result += gcdMap.get(num);\\n                }\\n            }\\n            gcdMap.put(gcd, gcdMap.getOrDefault(gcd, 0) + 1);\\n        }\\n        return result;\\n    }\\n    private int findGcd(int x, int y) {\\n        if (x < y) {\\n            return findGcd(y, x);\\n        }\\n        return y == 0 ? x : findGcd(y, x % y);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785099,
                "title": "c-solution-gcd-with-comments",
                "content": "I tried writing more detailed comments below, hope it helps!\\n```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> factorCount;\\n        long long result =0;\\n        int previousIndexCount = 0; // stores any Index that was traversed before\\n        for (int i=0;i<nums.size(); i++){\\n            int factor = gcd(nums[i], k); // this is the \"useful\" part of nums[i]\\n            int missingFactor = k/factor; // what other factor is needed to form k\\n            \\n            if (missingFactor==1){ // if missingFactor is 1, the that means nums[i] can match with any previous index to form a pair, k*n %k == 0\\n                result += previousIndexCount;\\n            }else{ // if m is not 1, we can check if any previous index has the missing factor\\n                for (auto it=factorCount.begin(); it!=factorCount.end(); it++){\\n                    if ( it->first % missingFactor == 0){\\n                        result += it->second;\\n                    }\\n                }\\n            }\\n            // only add the \"useful\" factor part to the map\\n            factorCount[factor]++;\\n            previousIndexCount++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> factorCount;\\n        long long result =0;\\n        int previousIndexCount = 0; // stores any Index that was traversed before\\n        for (int i=0;i<nums.size(); i++){\\n            int factor = gcd(nums[i], k); // this is the \"useful\" part of nums[i]\\n            int missingFactor = k/factor; // what other factor is needed to form k\\n            \\n            if (missingFactor==1){ // if missingFactor is 1, the that means nums[i] can match with any previous index to form a pair, k*n %k == 0\\n                result += previousIndexCount;\\n            }else{ // if m is not 1, we can check if any previous index has the missing factor\\n                for (auto it=factorCount.begin(); it!=factorCount.end(); it++){\\n                    if ( it->first % missingFactor == 0){\\n                        result += it->second;\\n                    }\\n                }\\n            }\\n            // only add the \"useful\" factor part to the map\\n            factorCount[factor]++;\\n            previousIndexCount++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786669,
                "title": "just-like-two-sum-hashmap",
                "content": "**It\\'s just like two sum in that we were storing the remaining part if the target sum was 10 and we found 7 we were storing the 10-7 in hashmap so if we found 3 we will return it\\'s index from there same we need to find the product which is divisible by k so for example if we need to make a pair which is divisible by 10 so by far we have found 12 so the [gcd](https://byjus.com/maths/greatest-common-divisor/) of 12,10 will be 2 now what is the other counter we need to find it is 5 hence if we find 5\\'s multiple or 5 we will add this pair to answer**\\n`So the time complexity here won\\'t be O(n^2) because a number can only have limited factors hence for 10^5 the max will be (10^5)^1/2 so at max the loop will iterate upto 100 - 200 (roughly) `\\n```py\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() #hashmap dicitionary of python\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            x = math.gcd(k,nums[i]) #ex: 10 = k and we have nums[i] as 12 so gcd will be 2\\n            want = k // x #what do we want from upper ex: we need 5\\n            for num in counter:\\n                if num % want == 0: #so if we find a number that is divisible by 5 then we can multiply it to 12 and make it a factor of 10 for ex we find 20 so it will be 240 which is divisible by 10 hence we will add it to answer\\n                    ans += counter[num] #we are adding the freq as we can find no of numbers that have same factor\\n            counter[x] += 1 #here we are increasing the freq of 2 so that if we find 5 next time we can add these to the answer\\n        return ans\\n```\\n```java\\npublic class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        // Create a HashMap to count the occurrences of numbers\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        int ans = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcdResult = gcd(k, nums[i]); // Calculate the GCD of \\'k\\' and \\'nums[i]\\'\\n            int desiredFactor = k / gcdResult; // Calculate the desired factor to form a pair with \\'nums[i]\\'\\n\\n            for (int num : counter.keySet()) {\\n                if (num % desiredFactor == 0) {\\n                    // If \\'num\\' is divisible by the desired factor, it can form pairs with \\'nums[i]\\'\\n                    // Add the frequency of \\'num\\' to the answer\\n                    ans += counter.get(num);\\n                }\\n            }\\n\\n            // Increase the count of \\'gcdResult\\' in the HashMap\\n            counter.put(gcdResult, counter.getOrDefault(gcdResult, 0) + 1);\\n        }\\n\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```py\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() #hashmap dicitionary of python\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            x = math.gcd(k,nums[i]) #ex: 10 = k and we have nums[i] as 12 so gcd will be 2\\n            want = k // x #what do we want from upper ex: we need 5\\n            for num in counter:\\n                if num % want == 0: #so if we find a number that is divisible by 5 then we can multiply it to 12 and make it a factor of 10 for ex we find 20 so it will be 240 which is divisible by 10 hence we will add it to answer\\n                    ans += counter[num] #we are adding the freq as we can find no of numbers that have same factor\\n            counter[x] += 1 #here we are increasing the freq of 2 so that if we find 5 next time we can add these to the answer\\n        return ans\\n```\n```java\\npublic class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        // Create a HashMap to count the occurrences of numbers\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        int ans = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcdResult = gcd(k, nums[i]); // Calculate the GCD of \\'k\\' and \\'nums[i]\\'\\n            int desiredFactor = k / gcdResult; // Calculate the desired factor to form a pair with \\'nums[i]\\'\\n\\n            for (int num : counter.keySet()) {\\n                if (num % desiredFactor == 0) {\\n                    // If \\'num\\' is divisible by the desired factor, it can form pairs with \\'nums[i]\\'\\n                    // Add the frequency of \\'num\\' to the answer\\n                    ans += counter.get(num);\\n                }\\n            }\\n\\n            // Increase the count of \\'gcdResult\\' in the HashMap\\n            counter.put(gcdResult, counter.getOrDefault(gcdResult, 0) + 1);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785662,
                "title": "python-line-by-line-detailed-explanation",
                "content": "#### Based on [this solution](https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1784712/Python-O(Nsqrt(K))-Easy-understand-solution) here is a  line by line detial explanations\\n---\\n\\n##### nums = [2,3,4,6,8],  k = 4\\n\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        N, output = len(nums), 0\\n        divisors = []\\n        counter = Counter()\\n        \\n        for i in range(1, k + 1):\\n            if k % i == 0:\\n                divisors.append(i)\\n```\\n**For each number, there is the smallest value to multiply that makes it divisible by \\'k\\'**\\nex:  6 should be multiplied by at least 2 to be divisible by 4\\n\\t&nbsp;&nbsp;&nbsp;&nbsp; 4 should be multiplied by at least 1 to be divisible by 4\\n\\t&nbsp;&nbsp;&nbsp;&nbsp; 3 should be multiplied by at least 4 to be divisible by 4\\n\\t\\n**Divisors collects all the posiibility of those smallest numbers**\\n > divisor = [1,2,4]\\n \\n\\n```\\n        for i in range(0, N):\\n            remainder = k // math.gcd(k, nums[i])\\n\\t\\t\\toutput += counter[remainder]\\n```\\n**remainder calculate how much num[i] should at least be multiplied to be divisible by \\'k\\'**\\nEx: num[i] = 6 -> reminder = 4 //  gcd(4,6) = 2\\n**\"counter[remainder]\" indicates how many numbers in \\'nums\\' are divisible by remainder(2)**\\n```\\n            for divisor in divisors:\\n                if nums[i] % divisor == 0:\\n                    counter[divisor] += 1\\n            \\n        return output\\n```\\n**Then define which group num[i] belongs to**\\nEx: nums[i] = 6, then nums[i] is divisible by 1, 2\\n\\t&nbsp;&nbsp;&nbsp;&nbsp; whick mean if the remainder of nums[n] is 1 or 2 it can pair with \\'6\\' \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        N, output = len(nums), 0\\n        divisors = []\\n        counter = Counter()\\n        \\n        for i in range(1, k + 1):\\n            if k % i == 0:\\n                divisors.append(i)\\n```\n```\\n        for i in range(0, N):\\n            remainder = k // math.gcd(k, nums[i])\\n\\t\\t\\toutput += counter[remainder]\\n```\n```\\n            for divisor in divisors:\\n                if nums[i] % divisor == 0:\\n                    counter[divisor] += 1\\n            \\n        return output\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784714,
                "title": "easy-c-solution-o-nlogn-using-count-of-multiples-and-gcd",
                "content": "We know that a number n is divisible by a number m if ,\\n   GCD(n,m) =m\\n\\nsimilarly   (nums[i] * nums[j]) is divisible by k if   their GCD is k .\\nknowing this if we just precalculate count of how many numbers are divisible by a number num( say) (for all num 1 to 10^5)\\n\\nthen we just need to loop for each element of array and finding out the remaing number( remaining_factor) needed to be multiplied  to it so as to make the GCD equals to k.\\nthen for this number the count of pairs will be as much as the multiple of remaining_factor present in array (ignoring the number itself)\\n\\nThus adding count of pairs for each i in nums we will get our answer . we will have to divide the final answer by 2 as we have counted each pair twice for any pair (i , j) .\\n\\nTime -  O(n * log(n) )    // both finding the multiples for all i [0,n] and taking gcd for each element with k takes  nlogn time . so worst case time complexity is (nlogn) \\n\\nSpace -  O(n)   // we need two arrays of size n .\\n\\n```\\nclass Solution {\\npublic:\\n    int count[100001];\\n    int count_of_multiples[100001];\\n    \\n    long long coutPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)  count[nums[i]]++;  // counting frequency of elements\\n        \\n        for(int i=1;i<100001;i++){\\n            for(int j=i;j<100001;j=j+i)  count_of_multiples[i]+=count[j]; //counting total elements present in array which are multiple of i\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long factor=__gcd(k,nums[i]);\\n            long long remaining_factor= ( k / factor);\\n            long long j = count_of_multiples[remaining_factor];\\n            if(nums[i]%remaining_factor==0)j--;        // if nums[i] itself is multiple of remaining factor then we to ignore it as  i!=j\\n            ans+=j;\\n        }\\n        \\n        ans/=2;                                        // as we have counted any distinct pair (i,j) two times , we need to take them only once\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count[100001];\\n    int count_of_multiples[100001];\\n    \\n    long long coutPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)  count[nums[i]]++;  // counting frequency of elements\\n        \\n        for(int i=1;i<100001;i++){\\n            for(int j=i;j<100001;j=j+i)  count_of_multiples[i]+=count[j]; //counting total elements present in array which are multiple of i\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long factor=__gcd(k,nums[i]);\\n            long long remaining_factor= ( k / factor);\\n            long long j = count_of_multiples[remaining_factor];\\n            if(nums[i]%remaining_factor==0)j--;        // if nums[i] itself is multiple of remaining factor then we to ignore it as  i!=j\\n            ans+=j;\\n        }\\n        \\n        ans/=2;                                        // as we have counted any distinct pair (i,j) two times , we need to take them only once\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784768,
                "title": "c-o-nsqrt-n-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx = 1e5 + 5;\\n    void update(vector<long long>& divisors, int num) {\\n\\t\\t//update divisors of num\\n        for(int i = 1; i * i <= num; i++) {\\n            if(num % i == 0) {\\n                if(i == num / i) divisors[i]++;\\n                else {\\n                    divisors[i]++;\\n                    divisors[num/i]++;\\n                }\\n            }\\n        }\\n    }\\n    long long coutPairs(vector<int>& nums, int k) {\\n        vector<long long> divisors(mx, 0LL);\\n        long long res = 0LL;\\n        for(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t//number to be multiplied with num[i] to make it divisible by k\\n            int r = k / (__gcd(nums[i], k));\\n\\t\\t\\t\\n\\t\\t\\t//numbers with divisors r\\n            res += (long long)divisors[r];\\n\\t\\t\\t\\n\\t\\t\\t//update the divisors of num[i]\\n            update(divisors, nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx = 1e5 + 5;\\n    void update(vector<long long>& divisors, int num) {\\n\\t\\t//update divisors of num\\n        for(int i = 1; i * i <= num; i++) {\\n            if(num % i == 0) {\\n                if(i == num / i) divisors[i]++;\\n                else {\\n                    divisors[i]++;\\n                    divisors[num/i]++;\\n                }\\n            }\\n        }\\n    }\\n    long long coutPairs(vector<int>& nums, int k) {\\n        vector<long long> divisors(mx, 0LL);\\n        long long res = 0LL;\\n        for(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t//number to be multiplied with num[i] to make it divisible by k\\n            int r = k / (__gcd(nums[i], k));\\n\\t\\t\\t\\n\\t\\t\\t//numbers with divisors r\\n            res += (long long)divisors[r];\\n\\t\\t\\t\\n\\t\\t\\t//update the divisors of num[i]\\n            update(divisors, nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1789583,
                "title": "map-gcd-faster-than-80",
                "content": "```\\nDO UPVOTE PLS ;))\\n\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int gcd=__gcd(nums[i],k);\\n            int needed_num=k/gcd; // gcd(a,k) *gcd(b,k)%k==0 is same as a*b%k==0\\n            for(auto x:m)\\n            {\\n                if(x.first%needed_num==0)\\n                    ans+=x.second;\\n            }\\n            m[gcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nDO UPVOTE PLS ;))\\n\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int gcd=__gcd(nums[i],k);\\n            int needed_num=k/gcd; // gcd(a,k) *gcd(b,k)%k==0 is same as a*b%k==0\\n            for(auto x:m)\\n            {\\n                if(x.first%needed_num==0)\\n                    ans+=x.second;\\n            }\\n            m[gcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785319,
                "title": "c-o-n-sqrt-k-solution-with-gcd-with-comments-and-explanation",
                "content": "## Basic strategy\\n* We process the numbers one by one traversing from left to right.\\n* At any index `j`, we\\'re looking for all indices `i` (`i < j`) such that `nums[i] * nums[j] = 0 (mod k)`.\\n  Let\\'s write it as `x * a = 0 (mod k)` substituting `a` for `nums[j]` and `x` for (a possible) `nums[i]` for readability.\\n  We\\'re looking for (count of) all `x`s that satisfy the above and which we\\'ve **already encountered before** in our traversal.\\n\\n## Some maths now\\n* What are the solutions for the linear recurrence `a*x = b (mod k)` ?\\nThere could be infinitely many solutions depending upon whether `gcd(a, k)` divides `b` or not.\\nIn our case, `b` is `0`. So, there are infinitely many solutions.\\n(But we\\'re looking for only those that occur in our array before `a` in left to right traversal)\\n* In general, when there are more than one solution, we express the set of all possible solutions as\\n  `x = x_0 + n * r (mod k)` where\\n  `x_0 = b / gcd(a, k)` \\n  `r = k / gcd(a, k)`  -------------------------------------------------- **(1)**\\n  and `0 <= n < gcd(a, k)`\\n* In our case, `x_0 = 0` so, the above simplifies to\\n  `x = n * r (mod k)` for `0 <= n < gcd(a, k)` ------------- **(2)**\\n  This can be written as\\n  `x = q*k + n*r` for some integer `q` ------------------------------ **(3)**\\n  `x = q*r*gcd(a,k) + n*r` or\\n  `x = r*(q*gcd(a,k) + n)` ------------------------------------------ **(4)**\\n* From the above, we can see that `r` is a divisor of `k` (from (1)) and also that `r` is a divisor of `x`.\\n  In fact, (3) tells us that any number divisible by `r` is a solution to our equation.\\n  Why?\\n  Well, let `x` be divisible by `r`. So we can write\\n  `x = r * Q` for some integer `Q`\\n  By Euclid\\'s division lemma, any integer `Q` can be writen as\\n  `Q = p*quot + rem` for any positive `p` such that `0 <= rem < p`.\\n  If we use `gcd(a, k)` for `p`, we get\\n  `x = r * Q = r * (gcd(a,k)*qout + rem)` where `0 <= rem < gcd(a,k)`\\n  This is exactly the form of (4).\\n\\n## Back to the main problem\\nCool, coming back to our problem, and armed with the maths we did before, we can calculate\\n`r = k / gcd(nums[j], k)`\\nand then count all `nums[i]` that we\\'ve seen before  which are divisibly by `r`.\\n\\nSo, we\\'d need to determine all divisors of `k` and the keep track of the count of all numbers we\\'ve\\nseen before in our traversal that are divisible by each of these divisors\\nWe can keep these counts updated as we traverse.\\n\\n## Complexity\\n* Time: For each number, we go over all divisors of `k`. A tight bound on the number of divisors can be had, but `sqrt(k)` is a good upper bound (since divisors occur in pairs). So time complexity is `O(n * sqrt(k))`. This could be considered amortized cost as the amortized `O(1)` cost of unordered_map access is should also be in there.\\n* Space: `sqrt(k)` each for the divisors vector and the the unordered_map. So `O(sqrt(k))` in total.\\n```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        using sum_type = long long;\\n        \\n        // divisor -> count of nums seen so far divisible by divisor\\n        unordered_map<int,int> nums_divisible_by_divisor;\\n        vector<int> divisors;\\n        \\n        // Populate the divisors of `k`\\n        for(int i = 1; i <= k; i++) {\\n            if(k % i == 0)\\n                divisors.push_back(i);\\n        }\\n        \\n        sum_type total = 0;\\n        \\n        for(auto const &num: nums) {\\n            // Refer to the text outside of code, to get the significance of `r`\\n            int r = k / gcd(num, k);\\n            \\n            // We do this to avoid adding elements in the hashmap while doing lookup.\\n            // That might be convenient syntax wise, but we could end up adding\\n            // quite a few useless values in the hashmap. It would not lead to\\n            // incorrect results, but might trigger some rebalancing which is unnecessary.\\n            if(auto it = nums_divisible_by_divisor.find(r); it != nums_divisible_by_divisor.end())\\n                total += it->second;\\n            \\n            // This is where we update the divisor -> counts map for the incoming number `num`\\n            // and maintain the \"seen so far\" invariant.\\n            for(auto const &divisor : divisors) {\\n                if(num % divisor == 0)\\n                    nums_divisible_by_divisor[divisor]++;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        using sum_type = long long;\\n        \\n        // divisor -> count of nums seen so far divisible by divisor\\n        unordered_map<int,int> nums_divisible_by_divisor;\\n        vector<int> divisors;\\n        \\n        // Populate the divisors of `k`\\n        for(int i = 1; i <= k; i++) {\\n            if(k % i == 0)\\n                divisors.push_back(i);\\n        }\\n        \\n        sum_type total = 0;\\n        \\n        for(auto const &num: nums) {\\n            // Refer to the text outside of code, to get the significance of `r`\\n            int r = k / gcd(num, k);\\n            \\n            // We do this to avoid adding elements in the hashmap while doing lookup.\\n            // That might be convenient syntax wise, but we could end up adding\\n            // quite a few useless values in the hashmap. It would not lead to\\n            // incorrect results, but might trigger some rebalancing which is unnecessary.\\n            if(auto it = nums_divisible_by_divisor.find(r); it != nums_divisible_by_divisor.end())\\n                total += it->second;\\n            \\n            // This is where we update the divisor -> counts map for the incoming number `num`\\n            // and maintain the \"seen so far\" invariant.\\n            for(auto const &divisor : divisors) {\\n                if(num % divisor == 0)\\n                    nums_divisible_by_divisor[divisor]++;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784801,
                "title": "python3-factors",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/793daa0aab0733bfadd4041fdaa6f8bdd38fe229) for solutions of weekly 281. \\n\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        factors = []\\n        for x in range(1, int(sqrt(k))+1):\\n            if k % x == 0: factors.append(x)\\n        ans = 0 \\n        freq = Counter()\\n        for x in nums: \\n            x = gcd(x, k)\\n            ans += freq[k//x]\\n            for f in factors: \\n                if x % f == 0 and f <= x//f: \\n                    freq[f] += 1\\n                    if f < x//f: freq[x//f] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        factors = []\\n        for x in range(1, int(sqrt(k))+1):\\n            if k % x == 0: factors.append(x)\\n        ans = 0 \\n        freq = Counter()\\n        for x in nums: \\n            x = gcd(x, k)\\n            ans += freq[k//x]\\n            for f in factors: \\n                if x % f == 0 and f <= x//f: \\n                    freq[f] += 1\\n                    if f < x//f: freq[x//f] += 1\\n        return ans \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786783,
                "title": "go-gcd-count-with-detailed-explanation",
                "content": "For this problem, we wish to find all pairs of numbers `(a,b)` such that `a*b % k == 0`.\\nIt\\'s clear that doing this for all pairs is too expensive, so we need to somehow group \\nnumbers together.\\n\\nFirst, some background.\\n\\nAll numbers have a prime factorization. For example, `192 = 2*2*2*7*7`. \\nFor prime numbers, the factor is simply itself times 1.\\n\\nThe greatest common denominator of two numbers, i.e. `gcd(a,b)` is the common\\nprime factorizations of a and b. For example, given `a = 192 = 2*2*2*7*7` and \\n`b = 21 = 3*7`, the GCD is `7`.\\n\\nWhen we take the GCD (`a,k`) of each element `a` in `nums`, we remove all\\nprime factors from each element that are not in common with `k`. We know \\nthat there aren\\'t that many of these factors - in fact, we can find all factors \\nthat evenly divide k in `O(sqrt(N))` time, so there are *at most* sqrt(N) factors.\\n\\nLet\\'s take an example from one of the test cases:\\n\\n```\\nnums = [8, 10, 2, 5, 9, 6, 3, 8, 2]\\nk = 6\\n```\\n\\nNow, `k = 6 = 3*2`. The only possible factors that divide k are `6, 3, 2, 1`, so\\nthere can be at most 4 different numbers after doing `gcd(a,k)`:\\n\\n```\\nnums = [8, 10, 2, 5, 9, 6, 3, 8, 2]\\nfactors = [2*2*2, 2*5, 2, 5, 3*3, 3*2, 3, 2*2*2, 2]\\nk = 2*3\\ncommon_factors = [2, 2, 2, 1, 3, 6, 3, 2, 2]\\n```\\n\\nNotice how few factors there are.\\n\\nNow comes the interesting part: since `gcd(a,k)` captures common prime factors\\nbetween `a` and `k`, then any `gcd(a,k) * gcd(b,k)` where `a` and `b` contain\\nall factors in `k` must be evenly divisible by `k`. If a factor exists e.g.\\ntwice, it will just create a larger number still divisible by `k`.\\n\\nTherefore, `gcd(a,k)*gcd(b,k) % k = 0` if `(a * b) % k = 0`.\\n\\nThe final tricky part is when `a` == `b`. This can happen when e.g. `k` is a square\\nand `a` is its root, or when `a` is equal to `k`. \\n\\nFor this case, the number of unique pairs is `n(n-1)/2`: there are `n` elements to \\nchoose from in the first element, then `n-1`, hence `n*(n-1)`. Then divide by \\nhalf to removeduplicates.\\n\\n# Solution\\n\\n```go\\nfunc countPairs(nums []int, k int) int64 {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n    \\n\\tn := int(math.Sqrt(float64(k)))\\n\\tgcds := make(map[int]int, n)\\n\\tfor _, num := range nums {\\n\\t\\tgcds[gcd(num, k)]++\\n\\t}\\n\\n\\tvar res int\\n\\tfor a, n1 := range gcds {\\n\\t\\tfor b, n2 := range gcds {\\n\\t\\t\\tif a > b || (a*b)%k != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif a != b {\\n\\t\\t\\t\\tres += n1 * n2\\n\\t\\t\\t} else { // a == b\\n\\t\\t\\t\\tres += n1 * (n1 - 1) / 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nnums = [8, 10, 2, 5, 9, 6, 3, 8, 2]\\nk = 6\\n```\n```\\nnums = [8, 10, 2, 5, 9, 6, 3, 8, 2]\\nfactors = [2*2*2, 2*5, 2, 5, 3*3, 3*2, 3, 2*2*2, 2]\\nk = 2*3\\ncommon_factors = [2, 2, 2, 1, 3, 6, 3, 2, 2]\\n```\n```go\\nfunc countPairs(nums []int, k int) int64 {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n    \\n\\tn := int(math.Sqrt(float64(k)))\\n\\tgcds := make(map[int]int, n)\\n\\tfor _, num := range nums {\\n\\t\\tgcds[gcd(num, k)]++\\n\\t}\\n\\n\\tvar res int\\n\\tfor a, n1 := range gcds {\\n\\t\\tfor b, n2 := range gcds {\\n\\t\\t\\tif a > b || (a*b)%k != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif a != b {\\n\\t\\t\\t\\tres += n1 * n2\\n\\t\\t\\t} else { // a == b\\n\\t\\t\\t\\tres += n1 * (n1 - 1) / 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857122,
                "title": "simple-solution-using-gcd",
                "content": "```\\n//The condition given to us is (a*b % k==0)\\n// So we can rewrite the above condition that if any factor of k is present in a and any other factor of k is present in b then their multiplication will be divisble by k\\n\\n// so gcd(a,k) * gcd(b,k) % k==0 \\n\\n\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        long ans=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int val:nums){\\n            int gcd1=gcd(val,k);\\n            \\n            for(int gcd2:hm.keySet()){\\n                if((long)gcd1*gcd2 % k==0){\\n                    ans+=hm.get(gcd2);\\n                }\\n            }\\n            \\n            hm.put(gcd1,hm.getOrDefault(gcd1,0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    //function to calculate gcd \\n   \\n    public int gcd(int n1,int n2)\\n    {\\n        while(n1%n2!=0){\\n            int rem=n1%n2;\\n            n1=n2;\\n            n2=rem;\\n        }\\n        return n2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//The condition given to us is (a*b % k==0)\\n// So we can rewrite the above condition that if any factor of k is present in a and any other factor of k is present in b then their multiplication will be divisble by k\\n\\n// so gcd(a,k) * gcd(b,k) % k==0 \\n\\n\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        long ans=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int val:nums){\\n            int gcd1=gcd(val,k);\\n            \\n            for(int gcd2:hm.keySet()){\\n                if((long)gcd1*gcd2 % k==0){\\n                    ans+=hm.get(gcd2);\\n                }\\n            }\\n            \\n            hm.put(gcd1,hm.getOrDefault(gcd1,0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    //function to calculate gcd \\n   \\n    public int gcd(int n1,int n2)\\n    {\\n        while(n1%n2!=0){\\n            int rem=n1%n2;\\n            n1=n2;\\n            n2=rem;\\n        }\\n        return n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785481,
                "title": "c-o-n-n-solution-easy-to-understand-with-comments-and-procedure",
                "content": "```\\n// My aproach is first store the factors of all used numbers globally \\n// Then iterate to the array nums\\n// and find the maximum factor of nums[i]\\n// which is also a factor of our number k and store it in variable num (Can be easily done by gcd(nums[i], k))\\n\\n// Then adding all the count of previous numbers \\n// who are divisible by k / num\\n\\n// Example [1, 2, 3, 4 5] k = 2\\n\\n// In iteration 0 our count = [0, 0, 0, 0, 0, 0] and so on, not necessary for this example\\n// nums[0] = 1, gcd(nums[0], k) is 1 so make num = 1\\n// now in previous numbers the numbers which are divisible by (k / num = 2) are count[k / num] = 0\\n// make ans += 0\\n// ans -> 0\\n// increase the count of the factors of num[0], so updated count = [0, 1, 0, 0, 0, 0]\\n\\n// iteration 1\\n// num[1] = 2, gcd(num[1], k) is num = 2\\n// so count previous numbers which are divisible by (k / num = 1) is count[k / num] = 1\\n// ans += count[k / num]\\n// ans -> 1\\n// update count with factors , count = [0, 2, 1, 0, 0, 0]\\n\\n// iteration 2\\n// num[2] = 3, gcd(num[2], k) is num = 1\\n// ans += (count[k / num] = 1)\\n// ans -> 2\\n// count = [0, 3, 1, 1, 0, 0]\\n\\n// iteration 3\\n// num[3] = 4, gcd(num[3], k) is num = 2\\n// ans += (count[k / num] = 1)\\n// ans -> 5\\n// count = [0, 4, 3, 1, 0, 0]\\n\\n// iteration 4\\n// num[4] = 5, gcd(num[4], k) is num = 1\\n// ans += (count[k / num] = 2)\\n// ans -> 7\\n// count = [0, 5, 3, 1, 0, 1]\\n\\n// finally return ans = 7\\n\\n// Global variables to store the factors of a number\\n\\nvector<int> factors[100001];\\nbool check = false;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n//\\t\\tBefore executing the program, checking whether factors are initialised or not\\n\\n\\t\\tif (!check) {\\n            check = true;\\n            \\n            for (int i = 1; i < 100001; i++)\\n                for (int j = i; j < 100001; j += i)\\n                    factors[j].push_back(i);\\n        }\\n\\t\\t\\n        int count[100001] = {0};\\n        long long ans = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n//         To check what is the maximum factor that can be achived from the number nums[i] that also exist in k.\\n\\n            int num = __gcd(nums[i], k);\\n\\t\\t\\t\\n//         Adding all the numbers who are previous to the ith element and are divisibe by k / num.\\n\\t\\t\\t\\n            ans += count[k / num];\\n\\t\\t\\t\\n//         Updating the count of all the factors of numbers untill ith index.\\n            \\n            for (int j = 0; j < factors[nums[i]].size(); j++)\\n                count[factors[nums[i]][j]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// My aproach is first store the factors of all used numbers globally \\n// Then iterate to the array nums\\n// and find the maximum factor of nums[i]\\n// which is also a factor of our number k and store it in variable num (Can be easily done by gcd(nums[i], k))\\n\\n// Then adding all the count of previous numbers \\n// who are divisible by k / num\\n\\n// Example [1, 2, 3, 4 5] k = 2\\n\\n// In iteration 0 our count = [0, 0, 0, 0, 0, 0] and so on, not necessary for this example\\n// nums[0] = 1, gcd(nums[0], k) is 1 so make num = 1\\n// now in previous numbers the numbers which are divisible by (k / num = 2) are count[k / num] = 0\\n// make ans += 0\\n// ans -> 0\\n// increase the count of the factors of num[0], so updated count = [0, 1, 0, 0, 0, 0]\\n\\n// iteration 1\\n// num[1] = 2, gcd(num[1], k) is num = 2\\n// so count previous numbers which are divisible by (k / num = 1) is count[k / num] = 1\\n// ans += count[k / num]\\n// ans -> 1\\n// update count with factors , count = [0, 2, 1, 0, 0, 0]\\n\\n// iteration 2\\n// num[2] = 3, gcd(num[2], k) is num = 1\\n// ans += (count[k / num] = 1)\\n// ans -> 2\\n// count = [0, 3, 1, 1, 0, 0]\\n\\n// iteration 3\\n// num[3] = 4, gcd(num[3], k) is num = 2\\n// ans += (count[k / num] = 1)\\n// ans -> 5\\n// count = [0, 4, 3, 1, 0, 0]\\n\\n// iteration 4\\n// num[4] = 5, gcd(num[4], k) is num = 1\\n// ans += (count[k / num] = 2)\\n// ans -> 7\\n// count = [0, 5, 3, 1, 0, 1]\\n\\n// finally return ans = 7\\n\\n// Global variables to store the factors of a number\\n\\nvector<int> factors[100001];\\nbool check = false;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n//\\t\\tBefore executing the program, checking whether factors are initialised or not\\n\\n\\t\\tif (!check) {\\n            check = true;\\n            \\n            for (int i = 1; i < 100001; i++)\\n                for (int j = i; j < 100001; j += i)\\n                    factors[j].push_back(i);\\n        }\\n\\t\\t\\n        int count[100001] = {0};\\n        long long ans = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n//         To check what is the maximum factor that can be achived from the number nums[i] that also exist in k.\\n\\n            int num = __gcd(nums[i], k);\\n\\t\\t\\t\\n//         Adding all the numbers who are previous to the ith element and are divisibe by k / num.\\n\\t\\t\\t\\n            ans += count[k / num];\\n\\t\\t\\t\\n//         Updating the count of all the factors of numbers untill ith index.\\n            \\n            for (int j = 0; j < factors[nums[i]].size(); j++)\\n                count[factors[nums[i]][j]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785229,
                "title": "c-gcd-factors-and-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long coutPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll cnt = 0;// cnt variable to store the ans\\n        \\n        vector<int > f;// vector to store the factors of k\\n        for (int i=1; i<=sqrt(k); i++)\\n        {\\n            if (k%i == 0)\\n            {\\n                if (k/i == i)\\n                    f.push_back(i);\\n                else \\n                {\\n                    f.push_back(i);\\n                    f.push_back(k/i);\\n                }\\n            }\\n        }\\n        \\n        map<int, vector<int>> mp;// map to store the index of element in vector corresponding to their factors\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<f.size();j++)\\n            {\\n                if(nums[i]%f[j]==0)\\n                    mp[f[j]].push_back(i);\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<n;i++)// traversing through each element in nums\\n        {\\n            if(nums[i]%k==0)// if nums[i] is divisible by k, then it can pair with all element ahead of it\\n            {\\n                cnt+=(ll)(n-i-1);\\n            }\\n            else // we it will pair with all elements which has factor k/gcd(nums[i],k)\\n            {\\n                int x1 = gcd(nums[i],k);\\n                auto it = upper_bound(mp[k/x1].begin(),mp[k/x1].end(),i);\\n                int idx = it-mp[k/x1].begin();\\n                cnt+=(ll)(mp[k/x1].size()-idx);\\n            }\\n        }\\n        return cnt;// returning the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long coutPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll cnt = 0;// cnt variable to store the ans\\n        \\n        vector<int > f;// vector to store the factors of k\\n        for (int i=1; i<=sqrt(k); i++)\\n        {\\n            if (k%i == 0)\\n            {\\n                if (k/i == i)\\n                    f.push_back(i);\\n                else \\n                {\\n                    f.push_back(i);\\n                    f.push_back(k/i);\\n                }\\n            }\\n        }\\n        \\n        map<int, vector<int>> mp;// map to store the index of element in vector corresponding to their factors\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<f.size();j++)\\n            {\\n                if(nums[i]%f[j]==0)\\n                    mp[f[j]].push_back(i);\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<n;i++)// traversing through each element in nums\\n        {\\n            if(nums[i]%k==0)// if nums[i] is divisible by k, then it can pair with all element ahead of it\\n            {\\n                cnt+=(ll)(n-i-1);\\n            }\\n            else // we it will pair with all elements which has factor k/gcd(nums[i],k)\\n            {\\n                int x1 = gcd(nums[i],k);\\n                auto it = upper_bound(mp[k/x1].begin(),mp[k/x1].end(),i);\\n                int idx = it-mp[k/x1].begin();\\n                cnt+=(ll)(mp[k/x1].size()-idx);\\n            }\\n        }\\n        return cnt;// returning the ans\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3327970,
                "title": "c-gcd-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        unordered_map<long long int,int> mp;\\n        for(auto &i: nums){\\n            int g = __gcd(i,k);\\n            for(auto &i: mp){\\n                if((i.first*1LL*g)%k==0){\\n                    ans += i.second;\\n                }\\n            }\\n            mp[g]++;\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        unordered_map<long long int,int> mp;\\n        for(auto &i: nums){\\n            int g = __gcd(i,k);\\n            for(auto &i: mp){\\n                if((i.first*1LL*g)%k==0){\\n                    ans += i.second;\\n                }\\n            }\\n            mp[g]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316231,
                "title": "c-easy-to-understand-simple-gcd-hashmap-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<ll,ll> mp;\\n        ll n=nums.size();\\n        for(ll i=0;i<n;i++)\\n        {\\n            nums[i]=__gcd(nums[i],k);\\n            mp[nums[i]]++;\\n        }\\n        ll ans=0;\\n        for(auto &x:mp)\\n        {\\n            for(auto &y:mp)\\n            {\\n                if((x.first*y.first)%k==0)\\n                {\\n                    if(x.first==y.first)\\n                    {\\n                        ans+=(mp[x.first]-1)*mp[y.first];   \\n                    }\\n                    else\\n                    {\\n                        ans+=(mp[x.first]*mp[y.first]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<ll,ll> mp;\\n        ll n=nums.size();\\n        for(ll i=0;i<n;i++)\\n        {\\n            nums[i]=__gcd(nums[i],k);\\n            mp[nums[i]]++;\\n        }\\n        ll ans=0;\\n        for(auto &x:mp)\\n        {\\n            for(auto &y:mp)\\n            {\\n                if((x.first*y.first)%k==0)\\n                {\\n                    if(x.first==y.first)\\n                    {\\n                        ans+=(mp[x.first]-1)*mp[y.first];   \\n                    }\\n                    else\\n                    {\\n                        ans+=(mp[x.first]*mp[y.first]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802744,
                "title": "2183-count-array-pairs-divisible-by-k",
                "content": "long long countPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            int x=__gcd(nums[i],k);\\n            int want=k/x;\\n            for(auto it : m)\\n            {\\n                if(it.first%want==0)\\n                {\\n                    ans=ans+it.second;\\n                }\\n                }\\n            m[x]++;\\n        }\\n        return ans;\\n    }\\n};![image](https://assets.leetcode.com/users/images/8baf77c4-5373-4070-a7cd-afd0d4bddfcb_1645935368.7631962.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "long long countPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            int x=__gcd(nums[i],k);\\n            int want=k/x;\\n            for(auto it : m)\\n            {\\n                if(it.first%want==0)\\n                {\\n                    ans=ans+it.second;\\n                }\\n                }\\n            m[x]++;\\n        }\\n        return ans;\\n    }\\n};![image](https://assets.leetcode.com/users/images/8baf77c4-5373-4070-a7cd-afd0d4bddfcb_1645935368.7631962.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1784998,
                "title": "c-solution-with-explanation",
                "content": "\\nFor this question, what we actually care about is the remainder of numbers in nums divided by k rather than numbers themselves. This is because \\n    Let\\n    num1 = a * k + b, 0 <= b < k , num2 = c * k + d, 0 <= d < k\\n    Then\\n    num1 * num2 = (a * c) * (k * k) + (a * d + b * c) * k + b * d\\n    num1 * num2 % k = b * d % k = (num1 % k) * (num2 % k) % k\\n\\nAs a result, we should get the remainder for every number in the array, and get the frequency for each remainder.\\n\\n    unordered_map <long long, long long> res_cnt;\\n    for (int num : nums) {\\n        res_cnt[num % k]++;\\n    }\\n\\nAfter that, a brute force solution will be iterating through all the remainder values in two for loops, check whether the product of remainders is a multiple of k. If so, we multiply the frequencies for these two remainders and add it to final results. We only add when remainder in inner loop is greater than or equal to remainder in outer loop for deduplication and if remainders are same, we will use count * (count - 1) / 2 instead of count * count, because we are choosing two elements from same set rather than choosing one element from each set.\\n\\n    long long ret = 0;\\n    for (auto const [num1, count1] : res_cnt) {\\n        for (auto const [num2, count2] : res_cnt) {\\n            if (num1 < num2) {\\n                continue;\\n            }\\n\\n            if (num1 * num2 % k != 0) {\\n                continue;\\n            }\\n\\n            if (num1 == num2) {\\n                ret += count1 * (count1 - 1) / 2;\\n            } else {\\n                ret += count1 * count2;\\n            }\\n        }\\n    }\\n\\nThis solution, however, is not very efficient, with k*k complexity. We need to find alternative solution with reduced complexity.\\nFor every non-zero remainder num1, we need to find all the non-zero remainders num2, such that num1 * num2 % k == 0. Previously we are iterating through all remainders to find them, which is O(k) complexity for each num1.\\nNote among all possible values of num2, there is the smallest one, and we call it num2_min. We can calculate it by \\n    num2_min = lcm(num1, k) / num1\\nThis is obtained directly from the definition of lcm( Least Common Multiple).\\nWe note that all num2 are multiples of num2_min. eg \\n    num1 = 4, k = 20, num2_min = 5, num2 = 5,10,15\\n    num1 = 12, k = 20, num2_min = 5, num2 = 5,10,15\\n\\nWe can prove this as follows.\\nGiven num1 * num2_min % k = 0, num1 * num2 % k = 0 let  num2 = a * num2_min + b, a,b are integers and 0 <= b < num2_min  then num1 * (num2 - a * num2_min) % k = 0 that is num1 * b % k = 0 since num2_min is already the smallest positive integer such that num1 * num2 = 0 and considering b < num2_min we can conclude that b = 0 ! which means any num2 is a multiple of num2_min.\\nIn that case, we need to iterate only k/num2_min different remainders and calculate number of combinations.\\nOf course, any number, which is already a multiple of k, can be paired with any other number, and the product is still multiple of k. We will also add these pairs to final result.\\n\\n```\\nclass Solution {\\n   public:\\n    // adding const to signature so that tests are easier to write.\\n    long long countPairs(const vector<int>& nums, int k) {\\n        unordered_map<long long, long long> res_cnt;\\n        for (int num : nums) {\\n            res_cnt[num % k]++;\\n        }\\n \\n        long long ret = 0;\\n        const long long total_number = nums.size();\\n        for (auto const [num1, count1] : res_cnt) {\\n            if (num1 == 0) {\\n                // numbers in this bucket are already multiple of k,\\n                // thus any multiple of these numbers are also multiple of k.\\n                // (num1 is multiple of k while num2 is not) + (both num1 and\\n                // num2 are multiple of k)\\n                ret += count1 * (total_number - count1) +\\n                       count1 * (count1 - 1) / 2;\\n                continue;\\n            }\\n \\n            // smallest num2 so that num1 * num2 % k == 0, when num1 is fixed\\n            const long long num2_min = lcm(num1, (long long)(k)) / num1;\\n            for (long long num2 = num2_min; num2 < k; num2 += num2_min) {\\n                if (num2 < num1) {\\n                    continue;\\n                }\\n \\n                if (num2 == num1) {\\n                    ret += count1 * (count1 - 1) / 2;\\n                    continue;\\n                }\\n \\n                if (res_cnt.count(num2) == 0) {\\n                    continue;\\n                }\\n \\n                ret += count1 * res_cnt.at(num2);\\n            }\\n        }\\n \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    // adding const to signature so that tests are easier to write.\\n    long long countPairs(const vector<int>& nums, int k) {\\n        unordered_map<long long, long long> res_cnt;\\n        for (int num : nums) {\\n            res_cnt[num % k]++;\\n        }\\n \\n        long long ret = 0;\\n        const long long total_number = nums.size();\\n        for (auto const [num1, count1] : res_cnt) {\\n            if (num1 == 0) {\\n                // numbers in this bucket are already multiple of k,\\n                // thus any multiple of these numbers are also multiple of k.\\n                // (num1 is multiple of k while num2 is not) + (both num1 and\\n                // num2 are multiple of k)\\n                ret += count1 * (total_number - count1) +\\n                       count1 * (count1 - 1) / 2;\\n                continue;\\n            }\\n \\n            // smallest num2 so that num1 * num2 % k == 0, when num1 is fixed\\n            const long long num2_min = lcm(num1, (long long)(k)) / num1;\\n            for (long long num2 = num2_min; num2 < k; num2 += num2_min) {\\n                if (num2 < num1) {\\n                    continue;\\n                }\\n \\n                if (num2 == num1) {\\n                    ret += count1 * (count1 - 1) / 2;\\n                    continue;\\n                }\\n \\n                if (res_cnt.count(num2) == 0) {\\n                    continue;\\n                }\\n \\n                ret += count1 * res_cnt.at(num2);\\n            }\\n        }\\n \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015214,
                "title": "c-here-s-a-sweet-and-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe time complexity is bound to exceed in the bruteforce `O(n^2)` solution, so we need to come up with something better.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can achieve that with a bit of precomputational maths, taking the help of GCDs. \\nThe code uses an unordered map (gcdCount) to keep track of the count of numbers that share the same GCD (highest common factor) value. It iterates through the nums vector and, for each element, calculates the GCD with the target value \"k.\" It then checks the count of elements with a GCD that is a multiple of \"k\" and accumulates these counts.\\n\\n\\n# Complexity\\n- **Time complexity:** $$O(N*sqrt(k))$$ \\n- - The outer loop iterates over the entire area, ie, N times.\\n- - In each iteration, `gcd` function takes `O(log(min(num, k)))` time, and the inner loop takes `O(sqrt(k))` time because our map contains at max `2*sqrt(k)` factors of k, the latter taking more time, leading to overall $$O(N*sqrt(k))$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $$O(sqrt(k))$$ \\n- - The maximum number of factors any number `k` can have is `2*sqrt(k)`. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThe code for this problem is fairly simple:\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map <int, int> gcdCount;\\n        long long cnt = 0;\\n        for (int num: nums) {\\n            int hcf = gcd(num, k); //highest common factor (another name for gcd)\\n            int required = k/hcf;\\n            for (pair<int, int> p: gcdCount) {\\n                if (p.first % required == 0) cnt += p.second;\\n            }\\n            gcdCount[hcf]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map <int, int> gcdCount;\\n        long long cnt = 0;\\n        for (int num: nums) {\\n            int hcf = gcd(num, k); //highest common factor (another name for gcd)\\n            int required = k/hcf;\\n            for (pair<int, int> p: gcdCount) {\\n                if (p.first % required == 0) cnt += p.second;\\n            }\\n            gcdCount[hcf]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002759,
                "title": "174-ms-faster-then-94-89-c-with-explanation-o-n-k-time-complexity",
                "content": "The idea behind using gcd is that ```(n1 * n2 % k == 0)``` is the same as ```(gcd(n1,k) * gcd(n2,k)) % k == 0```\\nThis allows us to compare only the gcd\\'s to each other instead of comparing all the numbers.\\n\\nI read in a [post](https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1785906/How-gcd(ak)-*-gcd(bk)-k-0-oror-Explained-with-example) that **the amount of gcd\\'s is atleast limited to 2*sqrt(k)**. For [k<=100k] this would mean a max of 625 gcd\\'s . However when testing I got 96 gcd\\'s max, but I might have missed some. There also cannot be more gcd\\'s then there are numbers. This means there is a great speed increase compared to comparing all numbers against each other.\\n\\nFor a explanation on why ```(n1 * n2 % k == 0)``` is the same as ```(gcd(n1,k) * gcd(n2,k)) % k == 0``` see the [post](https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1785906/How-gcd(ak)-*-gcd(bk)-k-0-oror-Explained-with-example).\\n\\nAllot of people choose to keep a list of gcd\\'s together with a count of those gcd\\'s. I see nothing wrong with this. But then they compare to this list for each number in nums. I think it would be faster to just compare the gcd\\'s against each other in a seperate loop. (note I do know allot of people did this already but non of those posts apear in Most votes). [An example of comparing against gcd\\'s for each number by rupak:](https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1785906/How-gcd(ak)-*-gcd(bk)-k-0-oror-Explained-with-example)\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<ll, ll> gcdCount;\\n        ll ans = 0;\\n        for (ll i = 0; i < nums.size(); ++i)\\n        {\\n            ll currgcd = __gcd(nums[i], k);\\n            for (auto &[gc_d, count] : gcdCount)\\n                if ((currgcd * gc_d) % k == 0)\\n                    ans += count;\\n            gcdCount[currgcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHe says that this has a time complexity of  **O(N*sqrt(K))**. \\n\\nInstead comparing gcd\\'s in a seperate loop would change the N into sqrt(K) here. However you still need to itterate over N so I would belief that this would cause the time complexity to be O(sqrt(K)*sqrt(K) + N) = **O(K+N)**.  (I have not been educated on this stuff and my measured time does not show such a great speedUp, so please correct me if I am wrong)\\n\\n\\n### **Implimentation**:\\nFirst I go over all numbers and determine the gcd(num,k) off all values:\\n```\\nstd::unordered_map<int/*gcd*/,int /*count*/> gcds;//count of gcds for each num\\nfor(const int& num:nums){//for each num \\n\\t gcds[__gcd(num, k)]++;//calculate the gcd and increase its count in gcds map\\n}\\n```\\nWhen a gcd pair is valid, the count of those gcd\\'s can be used to calculate the combinations of numbers that are valid.\\nwhen gcd1 != gcd2 the count increase simply equals ```count1*count2```. When gcd1 == gcd2 the count increase is ```(count1 * (count1 - 1))/2```\\n\\nUsing this I can compare each gcd to all other gcd\\'s and itself. \\n```\\n//look for matches of gcd that indicate a valid pair. for this I used gcd2 % (k/gcd1) == 0\\nfor(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n\\tconst int kDivGcd1 = k/(it1->first);// k/gcd1\\n\\t\\n\\t//For all gcds that come after this one (and this one aswell) in the list of gcds.\\n\\tfor(auto it2 = it1; it2 != gcds.cend(); it2++){\\n\\t\\tif((it2->first % kDivGcd1) == 0){//if match [gcd2 % kDivGcd1 == 0]\\n\\t\\t\\tif(it1 == it2)   //if gcd1 == gcd2\\n\\t\\t\\t\\trCount += ((long long)it1->second * (long long)(it2->second-1))/2; //rCount += (count * (count-1))/2\\n\\t\\t\\telse //if gcd1 != gcd2\\n\\t\\t\\t\\trCount += (long long)it1->second * (long long)(it2->second); //rCount += count1*count2\\n\\t\\t}\\n\\t}\\n}\\n```\\nnote: ```((gcd1 * gcd2) % k == 0)``` was changed into: ```gcd2 % (k/gcd1) == 0```. This works because k%gcd1 == 0. This usefull because it allows us to calculate k/gcd1 just one time. \\n\\n\\nAdding this to the the prev-code:\\n```\\nlong long countPairs(vector<int>& nums, int k) {\\n        std::unordered_map<int/*gcd*/,int /*count*/> gcds;//count of gcds for each num\\n        long long rCount = 0;\\n        \\n        for(const int& num:nums){\\n            gcds[__gcd(num, k)]++;//calculate the gcd and increase its count in gcds map\\n        }\\n        \\n        //look for matches of gcd that indicate a valid pair. for this I used gcd2 % (k/gcd1) == 0\\n        for(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n            const int kDivGcd1 = k/(it1->first);// k/gcd1\\n\\t\\t\\t//For all gcds that come after this one (and this one aswell) in the list of gcds\\n            for(auto it2 = it1; it2 != gcds.cend(); it2++){\\n                if((it2->first % kDivGcd1) == 0){//if match [gcd2 % kDivGcd1 == 0]\\n                    if(it1 == it2)\\n                        rCount += ((long long)it1->second * (long long)(it2->second-1))/2; //rCount += (count * (count-1))/2\\n                    else\\n                        rCount += (long long)it1->second * (long long)(it2->second); //rCount += count1*count2\\n                }\\n            }\\n\\n        }\\n        \\n        return rCount;\\n    }\\n```\\nor if you hate comments:\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        std::unordered_map<int/*gcd*/,int /*count*/> gcds;\\n        long long rCount = 0;\\n        for(const int& num:nums) gcds[__gcd(num, k)]++;\\n        \\n        for(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n            const int kDivGcd1 = k/(it1->first);\\n            for(auto it2 = it1; it2 != gcds.cend(); it2++){\\n                if((it2->first % kDivGcd1) == 0){\\n                    if(it1 == it2)rCount += ((long long)it1->second * (long long)(it2->second-1))/2;\\n                    else rCount += (long long)it1->second * (long long)(it2->second); \\n                }\\n            }\\n        }\\n        return rCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```(n1 * n2 % k == 0)```\n```(gcd(n1,k) * gcd(n2,k)) % k == 0```\n```(n1 * n2 % k == 0)```\n```(gcd(n1,k) * gcd(n2,k)) % k == 0```\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<ll, ll> gcdCount;\\n        ll ans = 0;\\n        for (ll i = 0; i < nums.size(); ++i)\\n        {\\n            ll currgcd = __gcd(nums[i], k);\\n            for (auto &[gc_d, count] : gcdCount)\\n                if ((currgcd * gc_d) % k == 0)\\n                    ans += count;\\n            gcdCount[currgcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nstd::unordered_map<int/*gcd*/,int /*count*/> gcds;//count of gcds for each num\\nfor(const int& num:nums){//for each num \\n\\t gcds[__gcd(num, k)]++;//calculate the gcd and increase its count in gcds map\\n}\\n```\n```count1*count2```\n```(count1 * (count1 - 1))/2```\n```\\n//look for matches of gcd that indicate a valid pair. for this I used gcd2 % (k/gcd1) == 0\\nfor(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n\\tconst int kDivGcd1 = k/(it1->first);// k/gcd1\\n\\t\\n\\t//For all gcds that come after this one (and this one aswell) in the list of gcds.\\n\\tfor(auto it2 = it1; it2 != gcds.cend(); it2++){\\n\\t\\tif((it2->first % kDivGcd1) == 0){//if match [gcd2 % kDivGcd1 == 0]\\n\\t\\t\\tif(it1 == it2)   //if gcd1 == gcd2\\n\\t\\t\\t\\trCount += ((long long)it1->second * (long long)(it2->second-1))/2; //rCount += (count * (count-1))/2\\n\\t\\t\\telse //if gcd1 != gcd2\\n\\t\\t\\t\\trCount += (long long)it1->second * (long long)(it2->second); //rCount += count1*count2\\n\\t\\t}\\n\\t}\\n}\\n```\n```((gcd1 * gcd2) % k == 0)```\n```gcd2 % (k/gcd1) == 0```\n```\\nlong long countPairs(vector<int>& nums, int k) {\\n        std::unordered_map<int/*gcd*/,int /*count*/> gcds;//count of gcds for each num\\n        long long rCount = 0;\\n        \\n        for(const int& num:nums){\\n            gcds[__gcd(num, k)]++;//calculate the gcd and increase its count in gcds map\\n        }\\n        \\n        //look for matches of gcd that indicate a valid pair. for this I used gcd2 % (k/gcd1) == 0\\n        for(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n            const int kDivGcd1 = k/(it1->first);// k/gcd1\\n\\t\\t\\t//For all gcds that come after this one (and this one aswell) in the list of gcds\\n            for(auto it2 = it1; it2 != gcds.cend(); it2++){\\n                if((it2->first % kDivGcd1) == 0){//if match [gcd2 % kDivGcd1 == 0]\\n                    if(it1 == it2)\\n                        rCount += ((long long)it1->second * (long long)(it2->second-1))/2; //rCount += (count * (count-1))/2\\n                    else\\n                        rCount += (long long)it1->second * (long long)(it2->second); //rCount += count1*count2\\n                }\\n            }\\n\\n        }\\n        \\n        return rCount;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        std::unordered_map<int/*gcd*/,int /*count*/> gcds;\\n        long long rCount = 0;\\n        for(const int& num:nums) gcds[__gcd(num, k)]++;\\n        \\n        for(auto it1 = gcds.begin(); it1 != gcds.cend();it1++){\\n            const int kDivGcd1 = k/(it1->first);\\n            for(auto it2 = it1; it2 != gcds.cend(); it2++){\\n                if((it2->first % kDivGcd1) == 0){\\n                    if(it1 == it2)rCount += ((long long)it1->second * (long long)(it2->second-1))/2;\\n                    else rCount += (long long)it1->second * (long long)(it2->second); \\n                }\\n            }\\n        }\\n        return rCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798938,
                "title": "c-gcd",
                "content": "```\\nlong long countPairs(vector<int>& nums, int k) \\n    {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto ele:nums)\\n        {\\n            long long gcd = __gcd(k,ele);\\n            long long x=k/gcd;\\n            \\n            for(auto it:mp)\\n                if(it.first%x==0) \\n                    ans+=it.second;\\n            \\n             mp[gcd]++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long countPairs(vector<int>& nums, int k) \\n    {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto ele:nums)\\n        {\\n            long long gcd = __gcd(k,ele);\\n            long long x=k/gcd;\\n            \\n            for(auto it:mp)\\n                if(it.first%x==0) \\n                    ans+=it.second;\\n            \\n             mp[gcd]++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785361,
                "title": "gcd-keep-count-of-prime-factors-of-k-c",
                "content": "For each element in nums find out that, what should be multiplied with this elemet to make it divisble by k, that is given by \"rem=k/gcd(k,nums[i])\". \\nNow chek in map that how many time rem has been found in past, and update ans.\\nAlso each time find out the prime factors of nums[i] and update it\\'s count in map\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll coutPairs(vector<int> &a, int k){\\n      ll ans=0;\\n     unordered_map<ll,ll>mp;\\n     for(int x:a)\\n     {\\n         int rem=(k/ __gcd(x,k));\\n         ans+=mp[rem];\\n         for(int i=1;i*i<=x;i++)\\n         {\\n             if(x%i==0)\\n             {\\n                 mp[i]++;\\n                 if(i*i !=x)\\n                 {\\n                     mp[x/i]++;\\n                 }\\n             }\\n         }\\n      }\\n     return ans;\\n }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll coutPairs(vector<int> &a, int k){\\n      ll ans=0;\\n     unordered_map<ll,ll>mp;\\n     for(int x:a)\\n     {\\n         int rem=(k/ __gcd(x,k));\\n         ans+=mp[rem];\\n         for(int i=1;i*i<=x;i++)\\n         {\\n             if(x%i==0)\\n             {\\n                 mp[i]++;\\n                 if(i*i !=x)\\n                 {\\n                     mp[x/i]++;\\n                 }\\n             }\\n         }\\n      }\\n     return ans;\\n }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785250,
                "title": "java-solution-gcd-and-divisors-sum-n-sqrt-k",
                "content": "```X * Y divisble by K```. If we know the value of ```X```  and ```K``` then we can get minimum ```Y``` from ```K / gcd(X, K)```.\\nExample: ```[1, 2, 3, 4, 5]`` and ```K = 2```\\n* If we select 0 index number from the array then X = 1 and K = 2 then minimum Y = 2. Now we need to know how many numbers from index 1 to 4 (2, 3, 4, 5) which has divisor Y = 2.  There are 2 numbers (2 , 4) have divisors 2. So add 2 to the answer.\\n\\n* If we select 1 index number from the array then X = 2 and K = 2 then minimum Y = 1. Now we need to know how many number from index 2 to 4(3, 4, 5) which has divisor Y = 1. There are 3 numers (3, 4, 5) have divisors 1. So add 3 to the answer.\\n\\n* If we select 2 index number from the array then X = 3 and K = 2 then minimum Y = 2. Now we need to know how many number from index 3 to 4 (4, 5) which has divisor Y = 2. There is only 1 number(4) has divisors 2. So add 1 to the answer.\\n\\n* If we select 3 index number from the array then X = 4 and K = 2 then minimum Y = 1. Now we need to know how many number from index 4 to 4 (5) which has divisor Y = 1. There is only 1 number(5) has divisors 1. So add 1 to the answer.\\n\\nTotal: 2 + 3 + 1 + 1 = 7\\n\\nTo get the count of divisors, we update frequency array for the divisor of every numbers.\\n\\ncode:\\n```\\npublic int gcd(int a, int b) {\\n        int c;\\n        while (b != 0) {\\n            c = a % b;\\n            a = b;\\n            b = c;\\n        }\\n        return a;\\n    }\\n    \\n    public long coutPairs(int[] nums, int k) {\\n        int[] freq = new int[1000005];\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 1; j * j <= tmp; j++) {\\n                if (nums[i] % j == 0) {\\n                    freq[j]++;\\n                    if (nums[i] / j != j) {\\n                        freq[nums[i] / j]++;\\n                    }\\n                }\\n            }\\n        }\\n        long ans = 0L;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 1; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    freq[j]--;\\n                    if (nums[i] / j != j) {\\n                        freq[nums[i] / j]--;\\n                    }\\n                }\\n            }\\n            int g = gcd(nums[i], k);\\n            g = k / g;\\n            ans += (long)freq[g];\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```X * Y divisble by K```\n```X```\n```K```\n```Y```\n```K / gcd(X, K)```\n```[1, 2, 3, 4, 5]`` and ```\n```\\n* If we select 0 index number from the array then X = 1 and K = 2 then minimum Y = 2. Now we need to know how many numbers from index 1 to 4 (2, 3, 4, 5) which has divisor Y = 2.  There are 2 numbers (2 , 4) have divisors 2. So add 2 to the answer.\\n\\n* If we select 1 index number from the array then X = 2 and K = 2 then minimum Y = 1. Now we need to know how many number from index 2 to 4(3, 4, 5) which has divisor Y = 1. There are 3 numers (3, 4, 5) have divisors 1. So add 3 to the answer.\\n\\n* If we select 2 index number from the array then X = 3 and K = 2 then minimum Y = 2. Now we need to know how many number from index 3 to 4 (4, 5) which has divisor Y = 2. There is only 1 number(4) has divisors 2. So add 1 to the answer.\\n\\n* If we select 3 index number from the array then X = 4 and K = 2 then minimum Y = 1. Now we need to know how many number from index 4 to 4 (5) which has divisor Y = 1. There is only 1 number(5) has divisors 1. So add 1 to the answer.\\n\\nTotal: 2 + 3 + 1 + 1 = 7\\n\\nTo get the count of divisors, we update frequency array for the divisor of every numbers.\\n\\ncode:\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785187,
                "title": "javascript-gcd-count-352ms",
                "content": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst coutPairs = (a, k) => {\\n    let f = Array(1e5 + 1).fill(0), gcdData = [], res = 0;\\n    for (const x of a) {\\n        let g = gcd(x, k);\\n        for (const y of gcdData) {\\n            if (g * y % k == 0) res += f[y];\\n        }\\n        if (f[g] == 0) gcdData.push(g);\\n        f[g]++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst coutPairs = (a, k) => {\\n    let f = Array(1e5 + 1).fill(0), gcdData = [], res = 0;\\n    for (const x of a) {\\n        let g = gcd(x, k);\\n        for (const y of gcdData) {\\n            if (g * y % k == 0) res += f[y];\\n        }\\n        if (f[g] == 0) gcdData.push(g);\\n        f[g]++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785083,
                "title": "java-solution-when-i-did-not-know-what-gcd-is",
                "content": "I didn\\'t know what GCD was and didn\\'t know the formular, all I was think is, assume k = a * b and a <=b, if I find all num in the nums array that\\'s divisible to a in SetA and all num that\\'s divisible to b in SetB, then I have a pair when I selete 1 element in setA and 1 element in SetB. Then the number of total pairs is size of setA * size of setB - number of duplicate counts\\n```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long n = (long) nums.length;\\n        if (k==1) {\\n            return (n*(n-1))/2;\\n        }\\n        \\n        long ret = 0;\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n\\t\\t// when k = 12, this map is like:\\n\\t\\t// 1:12\\n\\t\\t// 2:6\\n\\t\\t// 3:4\\n        for(int i=1; i<=k/2; i++) {\\n            if(k % i == 0) {\\n                int temp = k/i;\\n                map.put(i, temp);\\n            }\\n        }\\n        for(int a: map.keySet()) {\\n            int b = map.get(a); // k = a * b and a <= b\\n\\t\\t\\tHashSet<Integer> setA = new HashSet<>();\\n            HashSet<Integer> setB = new HashSet<>();\\n\\t\\t\\t// save all num[i] that\\'s divisible to a in setA\\n\\t\\t\\t// save all num[i] that\\'s divisible to b in setB\\n\\t\\t\\t// then if I select 1 element from setA and 1 element from setB I got a pair that multiplication is divisible to k\\n            for(int i=0; i<nums.length; i++) {\\n                if(nums[i] % a == 0) {\\n                    setA.add(i);\\n                } \\n                if(nums[i] % b == 0) {\\n                    setB.add(i);\\n\\t\\t\\t\\t\\t// marking this number to -1 so that next round, I don\\'t need to count it again\\n                    nums[i] = -1;\\n                }\\n            }\\n            if(a == 1) {\\n                long sizeB = (long) setB.size();\\n\\t\\t\\t\\t// - (sizeB * (sizeB-1))/2 remove duplicate counts\\n                ret += sizeB * (n -1) - (sizeB * (sizeB -1))/2;\\n            } else {\\n                HashSet<Integer> set = new HashSet<>();\\n                for(int x: setA) set.add(x);\\n                for(int x: setB) set.add(x);\\n                long sizeA = (long) setA.size();\\n                long sizeB = (long) setB.size();\\n\\t\\t\\t\\t// overlap is the number of common num in setA and setB\\n                long overlap = sizeA + sizeB - (long) set.size();\\n\\t\\t\\t\\t// - overlay removes the scenario where we selected same element from setA and setB\\n\\t\\t\\t\\t// - (overlap * (overlap-1))/2 remove duplicate counts\\n                ret += sizeA * sizeB - overlap - (overlap * (overlap-1))/2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long n = (long) nums.length;\\n        if (k==1) {\\n            return (n*(n-1))/2;\\n        }\\n        \\n        long ret = 0;\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n\\t\\t// when k = 12, this map is like:\\n\\t\\t// 1:12\\n\\t\\t// 2:6\\n\\t\\t// 3:4\\n        for(int i=1; i<=k/2; i++) {\\n            if(k % i == 0) {\\n                int temp = k/i;\\n                map.put(i, temp);\\n            }\\n        }\\n        for(int a: map.keySet()) {\\n            int b = map.get(a); // k = a * b and a <= b\\n\\t\\t\\tHashSet<Integer> setA = new HashSet<>();\\n            HashSet<Integer> setB = new HashSet<>();\\n\\t\\t\\t// save all num[i] that\\'s divisible to a in setA\\n\\t\\t\\t// save all num[i] that\\'s divisible to b in setB\\n\\t\\t\\t// then if I select 1 element from setA and 1 element from setB I got a pair that multiplication is divisible to k\\n            for(int i=0; i<nums.length; i++) {\\n                if(nums[i] % a == 0) {\\n                    setA.add(i);\\n                } \\n                if(nums[i] % b == 0) {\\n                    setB.add(i);\\n\\t\\t\\t\\t\\t// marking this number to -1 so that next round, I don\\'t need to count it again\\n                    nums[i] = -1;\\n                }\\n            }\\n            if(a == 1) {\\n                long sizeB = (long) setB.size();\\n\\t\\t\\t\\t// - (sizeB * (sizeB-1))/2 remove duplicate counts\\n                ret += sizeB * (n -1) - (sizeB * (sizeB -1))/2;\\n            } else {\\n                HashSet<Integer> set = new HashSet<>();\\n                for(int x: setA) set.add(x);\\n                for(int x: setB) set.add(x);\\n                long sizeA = (long) setA.size();\\n                long sizeB = (long) setB.size();\\n\\t\\t\\t\\t// overlap is the number of common num in setA and setB\\n                long overlap = sizeA + sizeB - (long) set.size();\\n\\t\\t\\t\\t// - overlay removes the scenario where we selected same element from setA and setB\\n\\t\\t\\t\\t// - (overlap * (overlap-1))/2 remove duplicate counts\\n                ret += sizeA * sizeB - overlap - (overlap * (overlap-1))/2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784790,
                "title": "java-gcd-simple-solution",
                "content": "```\\nclass Solution {\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    public long coutPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Long, Long> map = new HashMap<>();\\n        for(int num: nums){\\n            long key = (long)gcd(num, k);\\n            map.put(key, map.getOrDefault(key, 0l)+1l);\\n        }\\n        System.out.println(map.toString());\\n        \\n        long count = 0l;\\n        Set<String> set = new HashSet<>();\\n        for(long k1: map.keySet()){\\n            for(long k2: map.keySet()){\\n                String str = k2+\"$\"+k1;\\n                if(k1>k2) str = k1+\"$\"+k2;\\n                \\n                if(k1!=k2 && !set.contains(str) && (k1*k2)% k == 0){\\n                    set.add(str);\\n                    count += map.get(k1)*map.get(k2);\\n                }\\n            }\\n        }\\n        \\n        for(long k1: map.keySet()){\\n            if((k1*k1)%k == 0){\\n                long val = map.get(k1);\\n                count += (val)*(val-1)/2;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    public long coutPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Long, Long> map = new HashMap<>();\\n        for(int num: nums){\\n            long key = (long)gcd(num, k);\\n            map.put(key, map.getOrDefault(key, 0l)+1l);\\n        }\\n        System.out.println(map.toString());\\n        \\n        long count = 0l;\\n        Set<String> set = new HashSet<>();\\n        for(long k1: map.keySet()){\\n            for(long k2: map.keySet()){\\n                String str = k2+\"$\"+k1;\\n                if(k1>k2) str = k1+\"$\"+k2;\\n                \\n                if(k1!=k2 && !set.contains(str) && (k1*k2)% k == 0){\\n                    set.add(str);\\n                    count += map.get(k1)*map.get(k2);\\n                }\\n            }\\n        }\\n        \\n        for(long k1: map.keySet()){\\n            if((k1*k1)%k == 0){\\n                long val = map.get(k1);\\n                count += (val)*(val-1)/2;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784741,
                "title": "simple-o-nsqrt-n-solution-c-with-explanation",
                "content": "I have created an array muls  in which muls[i] is the count of multiples of i in the nums. \\nWe will simply iterate through each element and find what\\'s the maximum it can contribute so that product become k...ofcourse it will be gcd of nums[i] and k. Then we will find the multiple of k/gcd which has already occurred.\\n\\n```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        vector<int>muls(100001,0);\\n        int n=nums.size();\\n        long long int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int g=__gcd(nums[i],k);\\n            ans+=(muls[k/g]);\\n            for(int j=1;j<=int(sqrt(nums[i]));j++) //for finding divisors of nums[i]\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    int div2=nums[i]/j;\\n                    muls[j]++;\\n                    if(j!=div2)\\n                    {\\n                        muls[div2]++;\\n                    }\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        vector<int>muls(100001,0);\\n        int n=nums.size();\\n        long long int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int g=__gcd(nums[i],k);\\n            ans+=(muls[k/g]);\\n            for(int j=1;j<=int(sqrt(nums[i]));j++) //for finding divisors of nums[i]\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    int div2=nums[i]/j;\\n                    muls[j]++;\\n                    if(j!=div2)\\n                    {\\n                        muls[div2]++;\\n                    }",
                "codeTag": "C++"
            },
            {
                "id": 3761453,
                "title": "c-solution-100-faster-using-gcd-with-proper-detailed-comments-intution-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly i thought of a brute force solution of N^2 where i check for each element and then i observerd a pattern that if i take the gcd of a number with k and multiplying it with other number\\'s gcd with k.\\nIf it gives me value >=k then i can add it to my answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is quite simple and obvious approach.\\nWe traverse from nums from ltor and for each i in nums we check if there exists someone with gcd of k/gcd(nums[i],k) if it does then add  to my answer the number of times such gcd exists.\\nAnd after that i put the current gcd to my map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*sqrt(k))\\nAs the outer loop will traverse N times and inner loop will traverse the number of times factors of k.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(k)) \\nAs we are using an unordered map to store the factors of k.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            //gcd of current number\\n            int curr = gcd(nums[i],k);\\n            for(auto it : mp){\\n                //checking if any gcd exists with value k/curr\\n                if((1LL*curr*(it.first))%k == 0){\\n            //if it does then adding to my ans number of such gcd\\'s\\n                    ans += it.second;\\n                }\\n            }\\n            //finally adding it to my map\\n            mp[gcd(nums[i],k)]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            //gcd of current number\\n            int curr = gcd(nums[i],k);\\n            for(auto it : mp){\\n                //checking if any gcd exists with value k/curr\\n                if((1LL*curr*(it.first))%k == 0){\\n            //if it does then adding to my ans number of such gcd\\'s\\n                    ans += it.second;\\n                }\\n            }\\n            //finally adding it to my map\\n            mp[gcd(nums[i],k)]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146609,
                "title": "python-short-math",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(x, y):\\n            while x % y != 0: x, y = y, x % y\\n            return y\\n        gcds, cnt, ans = [gcd(num, k) for num in nums], defaultdict(int), 0\\n        for g in gcds: cnt[k // g] += 1\\n        for g in gcds:\\n            for f in cnt: ans += cnt[f] if not g % f else 0\\n            ans -= not g % (k // g) \\n        return ans // 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(x, y):\\n            while x % y != 0: x, y = y, x % y\\n            return y\\n        gcds, cnt, ans = [gcd(num, k) for num in nums], defaultdict(int), 0\\n        for g in gcds: cnt[k // g] += 1\\n        for g in gcds:\\n            for f in cnt: ans += cnt[f] if not g % f else 0\\n            ans -= not g % (k // g) \\n        return ans // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040946,
                "title": "different-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to simulate number of pairs with a^b = k problem in this. I try to find the smallest number which when multiplied by a number will be divisible by k. I calculate by this by lcm(num,k)/num. Then i count all the index which have this smallest number in them. I can do this by keeping track of factors of every number i process.\\n\\n# Complexity\\n- Time complexity: $$O(n*sqrt(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long LCM(int a, int b){\\n        long long x = a * 1LL * b;\\n        long long y = (long long)__gcd(a,b);\\n        return x/y;\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long cnt = 0;\\n        unordered_map<int, long long> mp;\\n        for(auto it : nums){\\n            int need = (int)(LCM(it,k)/(long long)it);\\n            cnt += mp[need];\\n            for (int i=1; i<=sqrt(it); i++)\\n            {\\n                if (it%i == 0)\\n                {\\n                    if (it/i == i)\\n                        mp[i]++;\\n                    else{\\n                        mp[i]++;\\n                        mp[it/i]++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long LCM(int a, int b){\\n        long long x = a * 1LL * b;\\n        long long y = (long long)__gcd(a,b);\\n        return x/y;\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long cnt = 0;\\n        unordered_map<int, long long> mp;\\n        for(auto it : nums){\\n            int need = (int)(LCM(it,k)/(long long)it);\\n            cnt += mp[need];\\n            for (int i=1; i<=sqrt(it); i++)\\n            {\\n                if (it%i == 0)\\n                {\\n                    if (it/i == i)\\n                        mp[i]++;\\n                    else{\\n                        mp[i]++;\\n                        mp[it/i]++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741010,
                "title": "java-easy-solution-using-hashmap-and-gcd-approach",
                "content": "```\\nclass Solution {\\n    \\n    private int gcd(int a, int b)\\n    {\\n        if(b % a == 0) return a;\\n        \\n        return gcd(b % a, a);\\n    }\\n    \\n    public long countPairs(int[] nums, int k) {\\n        \\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums)\\n        {\\n            int gcd1 = gcd(i, k);\\n            \\n            for(int key : map.keySet())\\n            {\\n                if(((long) gcd1 * key) % k == 0) ans += map.get(key);\\n            }\\n            \\n            map.put(gcd1, map.getOrDefault(gcd1, 0) + 1);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    private int gcd(int a, int b)\\n    {\\n        if(b % a == 0) return a;\\n        \\n        return gcd(b % a, a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2433169,
                "title": "python-solution",
                "content": "\\tfrom math import gcd\\n\\t#it is a simple number theory question\\n\\t# we have taken the prime factorization of any number with respect to the k\\n\\t# and then we find the second number  by gcd1 \\n\\tclass Solution:\\n\\t\\tdef countPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcnt=defaultdict(int)\\n\\t\\t\\tres=0\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tgcd1= gcd(nums[i],k)\\n\\t\\t\\t\\tgcd2=k//gcd1\\n\\t\\t\\t\\tif gcd2==1:\\n\\t\\t\\t\\t\\tres+=i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor x,y in cnt.items():\\n\\t\\t\\t\\t\\t\\tif x%gcd2==0:\\n\\t\\t\\t\\t\\t\\t\\tres+=y\\n\\t\\t\\t\\tcnt[gcd1]+=1\\n\\t\\t\\treturn res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tfrom math import gcd\\n\\t#it is a simple number theory question\\n\\t# we have taken the prime factorization of any number with respect to the k\\n\\t# and then we find the second number  by gcd1 \\n\\tclass Solution:\\n\\t\\tdef countPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcnt=defaultdict(int)\\n\\t\\t\\tres=0\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tgcd1= gcd(nums[i],k)\\n\\t\\t\\t\\tgcd2=k//gcd1\\n\\t\\t\\t\\tif gcd2==1:\\n\\t\\t\\t\\t\\tres+=i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor x,y in cnt.items():\\n\\t\\t\\t\\t\\t\\tif x%gcd2==0:\\n\\t\\t\\t\\t\\t\\t\\tres+=y\\n\\t\\t\\t\\tcnt[gcd1]+=1\\n\\t\\t\\treturn res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2133774,
                "title": "gcd-approach-in-c",
                "content": "```\\n// (n1*n2)%k==0 can be implied in the same way [gcd(n1,k)*gcd(n2,k)]%k==0, we do so because we only \\n// require the prime factors of the numbers.\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<long, long> mp;\\n        long  long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd1= __gcd(nums[i],k);\\n            int gcd2= k/gcd1;\\n            if(gcd2==1) ans+=i;\\n            else{\\n                for( auto it: mp){\\n                    if(it.first % gcd2 == 0) ans+=it.second;\\n                }\\n            }\\n            mp[gcd1]++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<long, long> mp;\\n        long  long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd1= __gcd(nums[i],k);\\n            int gcd2= k/gcd1;\\n            if(gcd2==1) ans+=i;\\n            else{\\n                for( auto it: mp){\\n                    if(it.first % gcd2 == 0) ans+=it.second;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1854485,
                "title": "c-gcd-hash-table-solution",
                "content": "Runtime: 408 ms, faster than 63.57% of C++ online submissions for Count Array Pairs Divisible by K.\\nMemory Usage: 65 MB, less than 82.95% of C++ online submissions for Count Array Pairs Divisible by K.\\n\\n```\\n\\n(n * n2) % k == 0 => (GCD (n1, k) * GCD(n2,k)) % k == 0\\nStore all GCD of num and k frequency in Hash Table \\nand check above condition for previous GCDs and update count\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        \\n        int size = nums.size();\\n        long long count  = 0;\\n        long long v;\\n        \\n        // store GCD frequency\\n        unordered_map<int,int>track;\\n\\n        // loop through nums array and update count based on previous GCD values\\n        for(int &num : nums)\\n        {\\n            int gcdVal = __gcd(num,k);\\n\\n            // update count based on all previous GCD frequency \\n            // if current GCD * previous GCD % k == 0\\n            for(auto &t : track)\\n            {\\n                v = (long long)gcdVal * (long long)t.first;\\n                \\n                if(v % k ==0)count+= t.second;\\n            }\\n        \\n            // update current GCD frequency\\n            track[gcdVal]++;\\n        }\\n        \\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n\\n(n * n2) % k == 0 => (GCD (n1, k) * GCD(n2,k)) % k == 0\\nStore all GCD of num and k frequency in Hash Table \\nand check above condition for previous GCDs and update count\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        \\n        int size = nums.size();\\n        long long count  = 0;\\n        long long v;\\n        \\n        // store GCD frequency\\n        unordered_map<int,int>track;\\n\\n        // loop through nums array and update count based on previous GCD values\\n        for(int &num : nums)\\n        {\\n            int gcdVal = __gcd(num,k);\\n\\n            // update count based on all previous GCD frequency \\n            // if current GCD * previous GCD % k == 0\\n            for(auto &t : track)\\n            {\\n                v = (long long)gcdVal * (long long)t.first;\\n                \\n                if(v % k ==0)count+= t.second;\\n            }\\n        \\n            // update current GCD frequency\\n            track[gcdVal]++;\\n        }\\n        \\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829754,
                "title": "python-count-gcd",
                "content": "Calculate k/ gcd(n1,k) for each n1 in nums. If a n2 is diviable by k/ gcd(n1,k), then (n1,n2) is an available pair\\nAnd since  k/ gcd(n1,k) may repeat, we can use counter to reduce complexity\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b:\\n                a,b = b,a\\n            while a%b :\\n                a,b = b, a%b\\n            return b\\n        g = [k//gcd(n,k) for n in nums]\\n        cnt = collections.Counter(g)\\n        # self-pairs should be excluded\\n        self_pairs = sum(nums[i]%g[i] == 0 for i in range(len(nums)))\\n        # avoid calculate twice for the same number\\n        d = {}\\n        pairs = 0\\n        for i,n in enumerate(nums):\\n            if n not in d:\\n                d[n] = sum(cnt[c] for c in cnt if n%c == 0)\\n            pairs+=d[n]\\n        #each pairs appear twice, so the final result should divide by two\\n        return (pairs -self_pairs )//2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b:\\n                a,b = b,a\\n            while a%b :\\n                a,b = b, a%b\\n            return b\\n        g = [k//gcd(n,k) for n in nums]\\n        cnt = collections.Counter(g)\\n        # self-pairs should be excluded\\n        self_pairs = sum(nums[i]%g[i] == 0 for i in range(len(nums)))\\n        # avoid calculate twice for the same number\\n        d = {}\\n        pairs = 0\\n        for i,n in enumerate(nums):\\n            if n not in d:\\n                d[n] = sum(cnt[c] for c in cnt if n%c == 0)\\n            pairs+=d[n]\\n        #each pairs appear twice, so the final result should divide by two\\n        return (pairs -self_pairs )//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812081,
                "title": "solve-it-in-two-parts",
                "content": "Our answer will arrive by addition from two parts\\n\\n1. when one number is direct multiple of K then it will form pair with every other number in the array ie ans += N - 1.\\nIn the end we subtract mC2 where m is total direct divisible so as to cancel out repeated ones\\n\\n2. we created another array where number which aren\\'t directly divisible by K are present. We assume k will arrive via n1 * n2.\\nn1 arrives from current element i.e v[i] and n2 from all other elements hence we remove gcd(v[i],k) from k.  **g = k / gcd(v[i],k)**\\nAlso maintain a map to store all factors as we travel the array for n2.\\n \\n ```long long ans = 0;\\n        int n = a.size();\\n        long long int count = 0;\\n        vector<int> v;\\n        \\n        // Part 1 \\n        for ( int i = 0; i < n; i++ )\\n        {\\n            if ( a[i]%k == 0 )\\n            {\\n                ans += (n-1);\\n                count++;\\n            }\\n            else if ( __gcd(a[i],k) != 1 )\\n                v.push_back(a[i]);\\n        }\\n        ans -= (count*(count-1))/2;\\n        \\n        \\n        // Part 2\\n        unordered_map<int,int> mp;\\n        for ( int i = 0 ; i < v.size() ; i++ )\\n        {\\n            int g = k / __gcd(v[i],k);\\n            ans += mp[g];\\n            for ( int j = 1 ; j <= sqrt(v[i]) ; j++ )\\n            {\\n                if ( v[i] % j == 0 )\\n                {\\n                    mp[j]++;\\n                    if ( v[i] / j != j )\\n                        mp[v[i]/j]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "Our answer will arrive by addition from two parts\\n\\n1. when one number is direct multiple of K then it will form pair with every other number in the array ie ans += N - 1.\\nIn the end we subtract mC2 where m is total direct divisible so as to cancel out repeated ones\\n\\n2. we created another array where number which aren\\'t directly divisible by K are present. We assume k will arrive via n1 * n2.\\nn1 arrives from current element i.e v[i] and n2 from all other elements hence we remove gcd(v[i],k) from k.  **g = k / gcd(v[i],k)**\\nAlso maintain a map to store all factors as we travel the array for n2.\\n \\n ```long long ans = 0;\\n        int n = a.size();\\n        long long int count = 0;\\n        vector<int> v;\\n        \\n        // Part 1 \\n        for ( int i = 0; i < n; i++ )\\n        {\\n            if ( a[i]%k == 0 )\\n            {\\n                ans += (n-1);\\n                count++;\\n            }\\n            else if ( __gcd(a[i],k) != 1 )\\n                v.push_back(a[i]);\\n        }\\n        ans -= (count*(count-1))/2;\\n        \\n        \\n        // Part 2\\n        unordered_map<int,int> mp;\\n        for ( int i = 0 ; i < v.size() ; i++ )\\n        {\\n            int g = k / __gcd(v[i],k);\\n            ans += mp[g];\\n            for ( int j = 1 ; j <= sqrt(v[i]) ; j++ )\\n            {\\n                if ( v[i] % j == 0 )\\n                {\\n                    mp[j]++;\\n                    if ( v[i] / j != j )\\n                        mp[v[i]/j]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1794118,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = collections.defaultdict(int)\\n        for i,n in enumerate(nums):\\n            d[math.gcd(n,k)] += 1\\n        ans = 0\\n        for a in d:\\n            for b in d:\\n                if b >= a and a*b%k == 0:\\n                    if a != b:\\n                        ans += d[a]*d[b]\\n                    else:\\n                        ans += d[a]*(d[a]-1)//2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = collections.defaultdict(int)\\n        for i,n in enumerate(nums):\\n            d[math.gcd(n,k)] += 1\\n        ans = 0\\n        for a in d:\\n            for b in d:\\n                if b >= a and a*b%k == 0:\\n                    if a != b:\\n                        ans += d[a]*d[b]\\n                    else:\\n                        ans += d[a]*(d[a]-1)//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792516,
                "title": "for-beginners-how-to-conquer-this-problem-some-key-points-explanation",
                "content": "In my opinion, the key points are:\\n\\n1. the length of all the divisors (or maybe it\\'s called factors) of k, would be **very small**. especially consider the length of original array nums, 1e5. (you could check other posts for a specific academic estimation of this length if you are interested, now assuming it is m).\\n\\n2. therefore, instead of checking every pair of nums, which n^2 would be 1e10, we could naturally think of another idea: let the gcd(greatest common divisor) of (each number, k) represent that number, ignore other useless information, and only finding suitable pairs based on their gcds.\\n\\n3. to get every gcd of a number and k, if you don\\'t know the gcd API, my idea was like, o(k) to get all the divisors, 1e5, and just one pass of all the divisors from greatest to smallest to find gcd. (remember m, the length of total divisors, is significantly small). Therefore, finding each number\\'s gcd would be o(n * m)\\n\\n```\\nvoid getGcdArr(int k, vector<int> &gcd, unordered_map<int, int> &m) {\\n        int id = 0;\\n        gcd.push_back(1);\\n        m[1] = 0;\\n        for (int i = 2; i <= k / 2; i++) {\\n            if (k % i == 0) {\\n                gcd.push_back(i);\\n                m[i] = ++id;\\n            }\\n        }\\n        gcd.push_back(k);\\n        m[k] = ++id;\\n    }\\n    int getGcd(int num, vector<int> &gcd) {\\n        int n = gcd.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (num % gcd[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n\\n4. to find each valid pair. let me share my intuitive and more complicated idea. for divisor A, assume B = k / A, B would also be a divisor. to avoid duplicates, only counting pairs (A < B); and to contain all the possible cases, count every C > B where C = B * some number. I hope my intuitive solution would help with understanding best solutions which is more clean, simple and elegant.\\n\\n```\\nfor (int i = 0; i < n; i++) { \\n            int A = gcd[i];\\n            int B = k / A;\\n            int idx = max(num2idx[B], i);    // I store the idx of each divisor (factor)\\n            while (idx < n) {\\n                if (gcd[idx] % B == 0) {\\n                    if (i == idx) {\\n                        res += (long long)cnt[i] * (long long)(cnt[i] - 1) / 2;\\n                    } else {\\n                        res += (long long)cnt[i] * (long long)cnt[idx];\\n                    }\\n                }\\n                idx++;\\n            }\\n        }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid getGcdArr(int k, vector<int> &gcd, unordered_map<int, int> &m) {\\n        int id = 0;\\n        gcd.push_back(1);\\n        m[1] = 0;\\n        for (int i = 2; i <= k / 2; i++) {\\n            if (k % i == 0) {\\n                gcd.push_back(i);\\n                m[i] = ++id;\\n            }\\n        }\\n        gcd.push_back(k);\\n        m[k] = ++id;\\n    }\\n    int getGcd(int num, vector<int> &gcd) {\\n        int n = gcd.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (num % gcd[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\nfor (int i = 0; i < n; i++) { \\n            int A = gcd[i];\\n            int B = k / A;\\n            int idx = max(num2idx[B], i);    // I store the idx of each divisor (factor)\\n            while (idx < n) {\\n                if (gcd[idx] % B == 0) {\\n                    if (i == idx) {\\n                        res += (long long)cnt[i] * (long long)(cnt[i] - 1) / 2;\\n                    } else {\\n                        res += (long long)cnt[i] * (long long)cnt[idx];\\n                    }\\n                }\\n                idx++;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1789043,
                "title": "c-100-fast-gcd-clean-code",
                "content": "```class Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int ele : nums){\\n            long long gcd = __gcd(k,ele);\\n            long long x = k / gcd;\\n            \\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(it->first % x == 0) ans += it->second;\\n            }\\n             mp[gcd]++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int ele : nums){\\n            long long gcd = __gcd(k,ele);\\n            long long x = k / gcd;\\n            \\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(it->first % x == 0) ans += it->second;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1789042,
                "title": "c-100-fast-gcd-clean-code",
                "content": "```class Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int ele : nums){\\n            long long gcd = __gcd(k,ele);\\n            long long x = k / gcd;\\n            \\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(it->first % x == 0) ans += it->second;\\n            }\\n             mp[gcd]++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int ele : nums){\\n            long long gcd = __gcd(k,ele);\\n            long long x = k / gcd;\\n            \\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(it->first % x == 0) ans += it->second;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786281,
                "title": "javascript-gcd",
                "content": "explanation in korean\\nhttps://enumclass.tistory.com/253\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar coutPairs = function(nums, k) {\\n    let divisors = getDivisor(k);\\n    let counters = new Array(k+1).fill(0);\\n    let result = 0;\\n\\n    for(const num of nums){\\n        let val = Math.floor(k / gcd(k, num));\\n        result += counters[val];\\n\\n        for(const divisor of divisors){\\n            if(num % divisor === 0){\\n                counters[divisor]++;\\n            }\\n        }\\n        console.log(counters)\\n    }\\n\\n    return result;\\n\\n};\\n\\n\\nfunction gcd(a,b){ //a\\uAC00 \\uD06C\\uACE0, b\\uAC00 \\uC791\\uC740\\uAC70\\n    if(b === 0) return a;\\n    if(a < b) {\\n        return gcd(b,a);\\n    } else {\\n        return gcd(b, a%b)\\n    }\\n}\\n\\nfunction getDivisor(k){\\n    let arr = new Array();\\n\\n    for(let i = 1; i <= k; i++){\\n        if(k % i === 0){\\n            arr.push(i);\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar coutPairs = function(nums, k) {\\n    let divisors = getDivisor(k);\\n    let counters = new Array(k+1).fill(0);\\n    let result = 0;\\n\\n    for(const num of nums){\\n        let val = Math.floor(k / gcd(k, num));\\n        result += counters[val];\\n\\n        for(const divisor of divisors){\\n            if(num % divisor === 0){\\n                counters[divisor]++;\\n            }\\n        }\\n        console.log(counters)\\n    }\\n\\n    return result;\\n\\n};\\n\\n\\nfunction gcd(a,b){ //a\\uAC00 \\uD06C\\uACE0, b\\uAC00 \\uC791\\uC740\\uAC70\\n    if(b === 0) return a;\\n    if(a < b) {\\n        return gcd(b,a);\\n    } else {\\n        return gcd(b, a%b)\\n    }\\n}\\n\\nfunction getDivisor(k){\\n    let arr = new Array();\\n\\n    for(let i = 1; i <= k; i++){\\n        if(k % i === 0){\\n            arr.push(i);\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786163,
                "title": "java-soln-with-explanation",
                "content": "Idea ===> If we break into components let\\'s say k = 4*25 = 100. And a = 128 and b = 50.\\nThen 4 will divide 128 and 25 will divide 50. So what we have to do is that we need to find gcd(a,k) and gcd(b,k) such that their multiple gcd(a,k)*gcd(b,k) is able to divide k.\\n\\nint x = gcd(a,k)\\nint want = k/x\\nkeep a map where we add all gcds\\nif there is gcd which is able to get divide by want. add its count.\\n```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        long count = 0L;\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        for(int i=0; i< n; i++){\\n            int gd = gcd(nums[i],k);\\n            int want = k/gd;\\n            for(int p: map.keySet()){\\n                if(p%want == 0){\\n                    count += map.get(p);\\n                }\\n            }\\n            map.put(gd,map.getOrDefault(gd,0L)+1L);\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(a>b){return gcd(b,a);}\\n        if(a==0){return b;}\\n        return gcd(a,b%a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        long count = 0L;\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        for(int i=0; i< n; i++){\\n            int gd = gcd(nums[i],k);\\n            int want = k/gd;\\n            for(int p: map.keySet()){\\n                if(p%want == 0){\\n                    count += map.get(p);\\n                }\\n            }\\n            map.put(gd,map.getOrDefault(gd,0L)+1L);\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(a>b){return gcd(b,a);}\\n        if(a==0){return b;}\\n        return gcd(a,b%a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785782,
                "title": "c-11-in-30-lines-save-gcds-to-unordered-map-124ms",
                "content": "e.g.\\n[1,2,3,4,5]\\nas same as\\n[1,2,1,2,1]\\nas same as\\n1 appear 3 time\\n2 appear 2 time\\narray [0...k] O(k^2)\\nuse map to reduce time further:\\nmap O(sqrt(k)^2)\\n\\ncase k=15 (3*a, 5*b) is legal\\n\\ntraverse i,j in map:\\nself cnt[i]*(cnt[i]-1)/2\\nother cnt[i]*cnt[j]\\n\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ret = 0;\\n\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) {\\n            //printf(\"%d \\\\n\", __gcd(k, num));\\n            cnt[__gcd(k, num)]++;\\n        }\\n\\n        for (auto [i,cnti] : cnt) {\\n            if (cnt[i] == 0) continue; // TLE if not continue\\n            for (auto [j,cntj] : cnt) {\\n                if (j < i) continue; // dup\\n                if (((long long)i*j)%k) continue; // WA\\n                if (i == j) {\\n                    //printf(\"cnt[%d]=%d %d\\\\n\", i, cnt[i], cnt[i]-1);\\n                    ret += (long long)cnt[i] * (cnt[i]-1) /2;\\n                } else {\\n                    //printf(\"cnt[%d]=%d cnt[%d]=%d\\\\n\", i, cnt[i], j, cnt[j]);\\n                    ret += (long long)cnt[i] * cnt[j];\\n                }\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ret = 0;\\n\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) {\\n            //printf(\"%d \\\\n\", __gcd(k, num));\\n            cnt[__gcd(k, num)]++;\\n        }\\n\\n        for (auto [i,cnti] : cnt) {\\n            if (cnt[i] == 0) continue; // TLE if not continue\\n            for (auto [j,cntj] : cnt) {\\n                if (j < i) continue; // dup\\n                if (((long long)i*j)%k) continue; // WA\\n                if (i == j) {\\n                    //printf(\"cnt[%d]=%d %d\\\\n\", i, cnt[i], cnt[i]-1);\\n                    ret += (long long)cnt[i] * (cnt[i]-1) /2;\\n                } else {\\n                    //printf(\"cnt[%d]=%d cnt[%d]=%d\\\\n\", i, cnt[i], j, cnt[j]);\\n                    ret += (long long)cnt[i] * cnt[j];\\n                }\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785366,
                "title": "can-someone-help-me-to-complete-this-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        \\n        long long ans=0;\\n        long long even=0,odd=0, k_multiple=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]%2==0){\\n                even++;\\n            }else{\\n                odd++;\\n            }\\n            \\n            if(nums[i]%k==0){\\n                k_multiple++;\\n            }\\n        }\\n        \\n        if(k%2==0){\\n            ans=even*odd+even/2;\\n        }else{\\n            if(k_multiple != 0){\\n                ans=(nums.size()-k_multiple)*odd + odd/2;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        \\n        long long ans=0;\\n        long long even=0,odd=0, k_multiple=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]%2==0){\\n                even++;\\n            }else{\\n                odd++;\\n            }\\n            \\n            if(nums[i]%k==0){\\n                k_multiple++;\\n            }\\n        }\\n        \\n        if(k%2==0){\\n            ans=even*odd+even/2;\\n        }else{\\n            if(k_multiple != 0){\\n                ans=(nums.size()-k_multiple)*odd + odd/2;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785032,
                "title": "incremental-count-greatest-common-divisor-and-their-factors",
                "content": "time: O(n sqrt(n)) or O(n log n) ?.   Thanks to ye15.\\n\\n```\\nfrom math import gcd, sqrt\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        factors = []\\n        for i in range(1, k+1):\\n            if k % i == 0:\\n                factors.append(i)\\n        # print(\"factors:\", factors)\\n                \\n        ans = 0\\n        gcd_freq = defaultdict(int)\\n        for v in nums:\\n            gc = gcd(v, k)\\n            other = k // gc\\n            if other in gcd_freq:\\n                ans += gcd_freq[other]\\n            \\n            for f in factors:\\n                if gc % f == 0:\\n                    gcd_freq[f] += 1\\n\\n        # print(gcd_freq)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import gcd, sqrt\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        factors = []\\n        for i in range(1, k+1):\\n            if k % i == 0:\\n                factors.append(i)\\n        # print(\"factors:\", factors)\\n                \\n        ans = 0\\n        gcd_freq = defaultdict(int)\\n        for v in nums:\\n            gc = gcd(v, k)\\n            other = k // gc\\n            if other in gcd_freq:\\n                ans += gcd_freq[other]\\n            \\n            for f in factors:\\n                if gc % f == 0:\\n                    gcd_freq[f] += 1\\n\\n        # print(gcd_freq)\\n        return ans\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784860,
                "title": "python-solution-simple",
                "content": "#### **Algorithm:**\\n* First find factors of all the numbers from **1** to **10^5**.\\n* Create a list **store** of size **10^5** and set all the values to zero.\\n* Initialize **ans=0**.\\n* Then for each number **i** in **nums**:\\n    1. find the **gcd(i, k)**.\\n   1. **min_fact = k/gcd**\\n   1. **ans += store[min_fact]**\\n   1. Now for each factor **j** of **i**,increment **store[j]** by **1**.\\n* Finally return **ans**.\\n\\n### Code:\\n```\\nimport math\\nn = 10**5+1\\nfacts = [[] for i in range(n)]\\nfor i in range(1,n):\\n    for j in range(i,n,i):\\n        facts[j].append(i)\\n\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        store = [0]*(10**5+1)\\n        ans = 0\\n        for i in nums:\\n            GCD = math.gcd(i,k)\\n            min_fact = k//GCD\\n            ans += store[min_fact]\\n            for j in facts[i]:\\n                store[j]+=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nn = 10**5+1\\nfacts = [[] for i in range(n)]\\nfor i in range(1,n):\\n    for j in range(i,n,i):\\n        facts[j].append(i)\\n\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        store = [0]*(10**5+1)\\n        ans = 0\\n        for i in nums:\\n            GCD = math.gcd(i,k)\\n            min_fact = k//GCD\\n            ans += store[min_fact]\\n            for j in facts[i]:\\n                store[j]+=1\\n        return ans\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784800,
                "title": "java-count-entries-by-greatest-common-divisor",
                "content": "```\\n    public long coutPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long output = 0;\\n        for (int num : nums) {\\n            int gcd = countPairs(k, num);\\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) if (((long) gcd * entry.getKey()) % k == 0) output += entry.getValue();\\n            map.put(gcd, map.getOrDefault(gcd, 0) + 1);\\n        }\\n        return output;\\n    }\\n    \\n    private int countPairs(int i, int j) {\\n        return i == 0 ? j : countPairs(j % i, i);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long coutPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long output = 0;\\n        for (int num : nums) {\\n            int gcd = countPairs(k, num);\\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) if (((long) gcd * entry.getKey()) % k == 0) output += entry.getValue();\\n            map.put(gcd, map.getOrDefault(gcd, 0) + 1);\\n        }\\n        return output;\\n    }\\n    \\n    private int countPairs(int i, int j) {\\n        return i == 0 ? j : countPairs(j % i, i);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784733,
                "title": "python-clear-solution-with-explanation",
                "content": "Idea\\nThe problem asks us to find all pair **(a, b)** that **a * b** could be dividable by **k**. When traverse the array and we see **a**, we could calculate **gcd(a, k)**, and record remaining **r = k // gcd(a, k)**. When we see **b**, we check all previous **r** to see if **b** could be devided by **r**. If yes, we found a pair.\\n\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if b > a:\\n                return gcd(b, a)\\n            if a % b == 0:\\n                return b\\n            else:\\n                return gcd(b, a % b)\\n        \\n        res = 0\\n        div = 0\\n        n = len(nums)\\n\\n        # use cnt to record num of remaining of k//gcd(a, k)\\n        cnt = defaultdict(int)\\n        for num in nums:\\n            # special handling for number that could be divied by k directly\\n            # it could be paired with any other element.\\n            # But it\\'s possible that there are more than one such number, \\n            # we use div to count number and substract it to avoid duplicate count\\n            if num % k == 0:\\n                res += n - 1 - div\\n                div += 1\\n            else:\\n                # for each remaing of r from previous element, we check if r is dividable by num\\n                # if yes, we found pairs\\n                for key in cnt.keys():\\n                    if num % key == 0:\\n                        res += cnt[key]\\n\\n                # add r for current num\\n                g = gcd(num, k)\\n                cnt[k//g] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if b > a:\\n                return gcd(b, a)\\n            if a % b == 0:\\n                return b\\n            else:\\n                return gcd(b, a % b)\\n        \\n        res = 0\\n        div = 0\\n        n = len(nums)\\n\\n        # use cnt to record num of remaining of k//gcd(a, k)\\n        cnt = defaultdict(int)\\n        for num in nums:\\n            # special handling for number that could be divied by k directly\\n            # it could be paired with any other element.\\n            # But it\\'s possible that there are more than one such number, \\n            # we use div to count number and substract it to avoid duplicate count\\n            if num % k == 0:\\n                res += n - 1 - div\\n                div += 1\\n            else:\\n                # for each remaing of r from previous element, we check if r is dividable by num\\n                # if yes, we found pairs\\n                for key in cnt.keys():\\n                    if num % key == 0:\\n                        res += cnt[key]\\n\\n                # add r for current num\\n                g = gcd(num, k)\\n                cnt[k//g] += 1\\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784728,
                "title": "c-o-n-sqrt-10-5-time-o-10-5-space",
                "content": "```\\n/*\\n\\n(pair_left, pair_right)\\nWe enumerate the pair_left from end to start, and try to find how many pair_right are valid.\\n\\nFor example, a = [30, 14, 19] and k = 3 * 5 * 7 = 105.\\nFor 30, we only care about the largest divisor which is 15, that 105 % 15 = 0, \\nand we then try to find 105/15 = 7, how many a[i] such that a[i] % 7 = 0.\\n\\nNote below i, j, x are not same as in the code.\\n\\nWe use c[i] to represent how many a[j] in the array a such that a[j] % i = 0 and k % i = 0.\\n\\nFor each a[i] from end to start, we find the largest number x, such that k % x = 0 and a[i] % x = 0.\\nWe only care about the largest x, such that k/x is the lowest requirement for all pair_right a[j] such as a[j] % (k/x) = 0.\\nSo for current pair_left which is a[i], the final result should add c[k/x].\\n*/\\n\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& a, int k) {\\n        long long ret = 0;\\n        vector<int>c(100005, 0);\\n        int n = a.size();\\n        for(int i = n-1;i>=0;i--){\\n\\t\\t    // UPDATE: small improvement.\\n            int x = __gcd(a[i], k);\\n            int mx = 0;\\n            // use tmp to save, so we don\\'t need to do the loop again.\\n            vector<int>tmp;\\n            for(int j = 1;j*j<=x;j++){\\n               if(x%j==0){\\n                    int tt = j;\\n                    mx = max(mx, tt);\\n                    tmp.push_back(tt);\\n                    tt = x/j;\\n                    if(tt!=j){\\n                        mx = max(mx, tt);\\n                        tmp.push_back(tt);\\n                    }\\n                }\\n            }\\n            if(mx!=0){\\n                ret += c[k/mx];\\n            }\\n            for(auto tt : tmp)c[tt]++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n\\n(pair_left, pair_right)\\nWe enumerate the pair_left from end to start, and try to find how many pair_right are valid.\\n\\nFor example, a = [30, 14, 19] and k = 3 * 5 * 7 = 105.\\nFor 30, we only care about the largest divisor which is 15, that 105 % 15 = 0, \\nand we then try to find 105/15 = 7, how many a[i] such that a[i] % 7 = 0.\\n\\nNote below i, j, x are not same as in the code.\\n\\nWe use c[i] to represent how many a[j] in the array a such that a[j] % i = 0 and k % i = 0.\\n\\nFor each a[i] from end to start, we find the largest number x, such that k % x = 0 and a[i] % x = 0.\\nWe only care about the largest x, such that k/x is the lowest requirement for all pair_right a[j] such as a[j] % (k/x) = 0.\\nSo for current pair_left which is a[i], the final result should add c[k/x].\\n*/\\n\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& a, int k) {\\n        long long ret = 0;\\n        vector<int>c(100005, 0);\\n        int n = a.size();\\n        for(int i = n-1;i>=0;i--){\\n\\t\\t    // UPDATE: small improvement.\\n            int x = __gcd(a[i], k);\\n            int mx = 0;\\n            // use tmp to save, so we don\\'t need to do the loop again.\\n            vector<int>tmp;\\n            for(int j = 1;j*j<=x;j++){\\n               if(x%j==0){\\n                    int tt = j;\\n                    mx = max(mx, tt);\\n                    tmp.push_back(tt);\\n                    tt = x/j;\\n                    if(tt!=j){\\n                        mx = max(mx, tt);\\n                        tmp.push_back(tt);\\n                    }\\n                }\\n            }\\n            if(mx!=0){\\n                ret += c[k/mx];\\n            }\\n            for(auto tt : tmp)c[tt]++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784710,
                "title": "python-o-n-k-1-3-easy-code-with-explanation-get-all-factors",
                "content": "## Explanation:\\n1. We can get all factors of `k` first.\\n2. For each `num`  in `nums`, `k // gcd(num, k)` will be the multiplier that num needs that make the result is divisible by `k`.\\n3. We use `counter` to maintain how many numbers is divisible by factors of `k`.\\n\\n\\n## Solutions:\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        # Generate all factors of k\\n        factors = []\\n        for i in range(1, int(k ** 0.5) + 1):\\n            if k % i == 0:\\n                factors.append(i)\\n\\t\\t\\t\\t# To prevent us from putting the same number into it\\n                if k // i != i:\\n                    factors.append(k // i)\\n        \\n        res = 0\\n        counter = collections.Counter()\\n        for num in nums:\\n            # `k // math.gcd(num, k)` is the smallest factor that makes `num` multiply it will be divisible by k\\n            res += counter[k // math.gcd(num, k)]\\n            \\n            for factor in factors:\\n                # if num % factor == 0, means if can provide this factor for other `num` to multiply and make it divisible by k\\n                if num % factor == 0:\\n                    counter[factor] += 1\\n        return res\\n```\\n\\n## Complexcity\\nTime Complexity: O(N * (k^1/3)) //  N = len(nums)\\nSpace Complexity: O(k^1/3)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        # Generate all factors of k\\n        factors = []\\n        for i in range(1, int(k ** 0.5) + 1):\\n            if k % i == 0:\\n                factors.append(i)\\n\\t\\t\\t\\t# To prevent us from putting the same number into it\\n                if k // i != i:\\n                    factors.append(k // i)\\n        \\n        res = 0\\n        counter = collections.Counter()\\n        for num in nums:\\n            # `k // math.gcd(num, k)` is the smallest factor that makes `num` multiply it will be divisible by k\\n            res += counter[k // math.gcd(num, k)]\\n            \\n            for factor in factors:\\n                # if num % factor == 0, means if can provide this factor for other `num` to multiply and make it divisible by k\\n                if num % factor == 0:\\n                    counter[factor] += 1\\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3786848,
                "title": "c-fast-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n        public long CountPairs(int[] nums, int k)\\n        {\\n            Dictionary<int, int> map = new Dictionary<int, int>();\\n\\n            long count = 0;\\n            foreach(int n in nums)\\n            {\\n                int i = gcd(n, k);\\n\\n                foreach(var e in map)\\n                {\\n                    int j = e.Key;\\n                    int cnt = e.Value;\\n                    count += (long)i * j % k == 0 ? cnt : 0;\\n                }\\n                if (map.Keys.Contains(i))\\n                {\\n                    map[i] += 1;\\n                }\\n                else\\n                {\\n                    map.Add(i, 1);\\n                }\\n            }\\n            return count;\\n        }\\n\\n        int gcd(int a, int b)\\n        {\\n            if (a < b)\\n            {\\n                return gcd(b, a);\\n            }\\n            if (a % b == 0)\\n            {\\n                return b;\\n            }\\n            return gcd(b, a % b);\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        public long CountPairs(int[] nums, int k)\\n        {\\n            Dictionary<int, int> map = new Dictionary<int, int>();\\n\\n            long count = 0;\\n            foreach(int n in nums)\\n            {\\n                int i = gcd(n, k);\\n\\n                foreach(var e in map)\\n                {\\n                    int j = e.Key;\\n                    int cnt = e.Value;\\n                    count += (long)i * j % k == 0 ? cnt : 0;\\n                }\\n                if (map.Keys.Contains(i))\\n                {\\n                    map[i] += 1;\\n                }\\n                else\\n                {\\n                    map.Add(i, 1);\\n                }\\n            }\\n            return count;\\n        }\\n\\n        int gcd(int a, int b)\\n        {\\n            if (a < b)\\n            {\\n                return gcd(b, a);\\n            }\\n            if (a % b == 0)\\n            {\\n                return b;\\n            }\\n            return gcd(b, a % b);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784912,
                "title": "count-array-pairs-divisible-by-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm counts pairs of numbers in the list where their Greatest Common Divisor (GCD)is divisible by k. The GCD represents the largest common factor between two numbers.We can achieve this by calculating the GCD of each number with k and counting their frequencies.\\n\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom math import gcd\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(int)\\n        for i in nums:\\n            d[gcd(i, k)] += 1\\n\\n        ans = 0\\n\\n        for i in d.keys():\\n            for j in d.keys():\\n                if (i * j) % k == 0:\\n                    if i < j:\\n                        ans += d[i] * d[j]\\n                    elif j == i:\\n                        ans += d[i] * (d[i] - 1) // 2\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import gcd\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(int)\\n        for i in nums:\\n            d[gcd(i, k)] += 1\\n\\n        ans = 0\\n\\n        for i in d.keys():\\n            for j in d.keys():\\n                if (i * j) % k == 0:\\n                    if i < j:\\n                        ans += d[i] * d[j]\\n                    elif j == i:\\n                        ans += d[i] * (d[i] - 1) // 2\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571479,
                "title": "gcd-based-solution-with-o-n-log-k-u-2-complexity",
                "content": "# Approach\\nComplexity of straightforward approach is $$O(n^2)$$.\\n```cpp\\nfor(auto i=0;i<nums.size()-1;i++)\\n    for(auto j=i+1;j<nums.size();j++)\\n        if(nums[i]*nums[j]%k == 0) res++;\\n```\\n\\nWe can significantly decrease this complexity by reducing n to the number of unique gcds (great common divisors) $$u=unique\\\\_gcds\\\\_count(nums,k)$$. We can do it thanks to property:\\n$$n_1 * n_2 \\\\mod{k} =0 \\\\Leftrightarrow gcd(n_1,k)*gcd(n_2,k) \\\\mod{k} = 0$$\\nIn this case complexity will be $$O(n\\\\log k+u^2)$$, where $$\\\\log k$$ - is complexity of $$gcd(num,k)$$ operation. \\n\\nTo further reduce complexity we account for some special cases:\\n-  if $$n_i \\\\mod{k} = 0$$, then $$n_i*x \\\\mod{k} = 0$$, where $$x$$ - is any integer number.\\n- if $$gcd(n_i,k) = 1$$, then $$n_i*x \\\\mod{k} = 0$$ only if $$x \\\\mod{k}=0$$.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log k+u^2)$$, where u is number of unique gcds of nums with k.\\n\\n- Space complexity: $$O(u)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> gcds;\\n\\n        // count of numbers that are divisible by k without a reminder\\n        long long dc = 0;\\n\\n        for(size_t i=0;i<nums.size();i++){\\n            if(nums[i]%k==0){\\n                dc++;\\n            } else {\\n                auto d = gcd(k, nums[i]);\\n                if(d != 1) gcds[d]+=1;\\n            }\\n        }\\n\\n        // count of pairs where one number is divisible by k\\n        long long res = dc*(nums.size()-dc);\\n        // count of pairs where both numbers are divisible by k\\n        res += dc*(dc-1)/2;\\n\\n        for(auto it = gcds.begin();it != gcds.end();it++){\\n            auto q = k/it->first;\\n            for(auto it2 = it; it2 != gcds.end(); it2++){\\n                if(it2->first%q==0){\\n                    if(it->first == it2->first) res+= (it->second-1)*it->second/2;\\n                    else res += it->second*it2->second;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nfor(auto i=0;i<nums.size()-1;i++)\\n    for(auto j=i+1;j<nums.size();j++)\\n        if(nums[i]*nums[j]%k == 0) res++;\\n```\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> gcds;\\n\\n        // count of numbers that are divisible by k without a reminder\\n        long long dc = 0;\\n\\n        for(size_t i=0;i<nums.size();i++){\\n            if(nums[i]%k==0){\\n                dc++;\\n            } else {\\n                auto d = gcd(k, nums[i]);\\n                if(d != 1) gcds[d]+=1;\\n            }\\n        }\\n\\n        // count of pairs where one number is divisible by k\\n        long long res = dc*(nums.size()-dc);\\n        // count of pairs where both numbers are divisible by k\\n        res += dc*(dc-1)/2;\\n\\n        for(auto it = gcds.begin();it != gcds.end();it++){\\n            auto q = k/it->first;\\n            for(auto it2 = it; it2 != gcds.end(); it2++){\\n                if(it2->first%q==0){\\n                    if(it->first == it2->first) res+= (it->second-1)*it->second/2;\\n                    else res += it->second*it2->second;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442332,
                "title": "ruby-solution-with-mod-and-factorization-100-100",
                "content": "# Intuition\\nNumbers can be grouped together based on modulo and factors of k.\\n\\n# Approach\\n1. Change each number to itself mod k.\\n2. Count all the pairs where one of the numbers is itself a multiple of k, then remove those numbers.\\n3. Find the (lesser) factors of k.\\n4. Assign each number in the array to a factor of k if possible, choosing the largest factor of k possible.  (For example, if k is 12, assign each number in the array to 6, 4, 3, or 2 if any of those are factors.)  Count how many numbers there are for each factor.\\n5. Look at pairs of factors and see which multiply to make (a multiple of) k.  Multiply the counts of these factors and add to total, dividing by 2 to avoid double counting.  If a number multiplied by *itself* can get a multiple of k (e.g., 6 * 6 = 36, a multiple of 12), subtract the elements you double-counted.\\n6. Return the total (as an integer, not a float).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + k)$$, with *n* being the length of nums\\n\\n- Space complexity:\\n$$O(f)$$, where *f* is the number of factors of k; this would be $$O(log(k))$$ in the worst case.  (Nums is modified in place, so it doesn\\'t take up extra space.)  \\n\\n# Code\\n```\\ndef count_pairs(nums, k)\\n    nums.map! { |num| num % k }\\n\\n    count = nums.count { |num| num == 0 }\\n    total = count * nums.length - count * (count + 1) / 2\\n    nums.reject! { |num| num == 0 }\\n    \\n    factors = factors(k).reverse\\n    count = Hash.new\\n\\n    factors.each do |factor|\\n        count[factor] = nums.count { |num| num % factor == 0 }\\n        nums.reject! { |num| num % factor == 0 }\\n    end\\n\\n    count.each do |k1,v1|\\n        count.each do |k2,v2|\\n            if k1 * k2 % k == 0\\n                total += v1 * v2 / 2.0\\n                total -= v1 / 2.0 if k1 == k2\\n            end\\n        end\\n    end\\n\\n    total.to_i\\nend\\n\\ndef factors(k)\\n    arr = []\\n    (2...k).each { |n| arr << n if k % n == 0 }\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef count_pairs(nums, k)\\n    nums.map! { |num| num % k }\\n\\n    count = nums.count { |num| num == 0 }\\n    total = count * nums.length - count * (count + 1) / 2\\n    nums.reject! { |num| num == 0 }\\n    \\n    factors = factors(k).reverse\\n    count = Hash.new\\n\\n    factors.each do |factor|\\n        count[factor] = nums.count { |num| num % factor == 0 }\\n        nums.reject! { |num| num % factor == 0 }\\n    end\\n\\n    count.each do |k1,v1|\\n        count.each do |k2,v2|\\n            if k1 * k2 % k == 0\\n                total += v1 * v2 / 2.0\\n                total -= v1 / 2.0 if k1 == k2\\n            end\\n        end\\n    end\\n\\n    total.to_i\\nend\\n\\ndef factors(k)\\n    arr = []\\n    (2...k).each { |n| arr << n if k % n == 0 }\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3388106,
                "title": "c-o-n-log-m",
                "content": "The idea is that we want to combine elements that consist of different divisors of `k`. We reduce every number to a divisor of `k`. If we combine these divisors and they are divisible by `k` then these two numbers are divisible by `k`. The number of divisors of `k` scale with `O(sqrt(K))`.\\n\\nIn this case to reduce numbers to divisors we use `gcd` which has time complexity `O(log(M))` where `M` is `M = min(MAXNUM, K) <= 10^5`.\\n\\nTime O(N * log(M) + O(K)), Space O(sqrt(K)):\\n```\\nlong long countPairs(vector<int>& a, int k) {\\n    long ret = 0;\\n    unordered_map <long, long> m;\\n    for (auto x : a) // O(N)\\n        m[gcd(x, k)]++;  // O(log(min(x,k)))\\n    for (auto [a, c] : m) // O(sqrt(K))\\n        for (auto [b, d] : m) // O(sqrt(K))\\n            if (a <= b && (a * b) % k == 0) \\n                ret += a != b ? c * d \\n                    : c * (c - 1) / 2;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long countPairs(vector<int>& a, int k) {\\n    long ret = 0;\\n    unordered_map <long, long> m;\\n    for (auto x : a) // O(N)\\n        m[gcd(x, k)]++;  // O(log(min(x,k)))\\n    for (auto [a, c] : m) // O(sqrt(K))\\n        for (auto [b, d] : m) // O(sqrt(K))\\n            if (a <= b && (a * b) % k == 0) \\n                ret += a != b ? c * d \\n                    : c * (c - 1) / 2;\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3378112,
                "title": "c-commented-o-n-sqrt-mx",
                "content": "# Approach\\nThe optimized approach for this problem involves using a **combination of gcd and divisor counting to count** the number of pairs whose product is divisible by k.\\n\\nFirstly, we initialize a divisors array to count the number of divisors of each element in the input array. We also initialize a variable res to keep track of the final count of pairs.\\n\\nFor each element in the input array, we calculate the number r such that r*nums[i] is divisible by k. To do this, we use the gcd function to find the gcd of nums[i] and k, and then divide k by this gcd. This gives us the number r that we need to multiply with nums[i] to make it divisible by k.\\n\\nNext, we add the number of elements with divisors r to our result res. This is because the product of any element in the input array with an element that has a divisor of r will be divisible by k.\\n\\nFinally, we update the divisors array for nums[i] and move on to the next element in the input array. To update the divisors array for nums[i], we iterate from 1 to sqrt(mx) and increment the divisors count for any divisor of nums[i].\\n\\nAt the end, the value of res will give us the total count of pairs whose product is divisible by k.\\n\\nThis approach has a time complexity of O(n*sqrt(mx)), where n is the size of the input array and mx is the maximum possible value of an element in the array. The space complexity is O(mx), to store the divisors array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(n*sqrt(mx))**\\n where n is the size of the input array and mx is the maximum possible value of an element in the array (1e5 + 5 in this case). This is because we iterate over each element of the input array and update the divisors array for each element by iterating from 1 to sqrt(mx) and checking if the current number is a divisor of the element.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(mx)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mx = 1e5 + 5; // maximum number of possible divisors\\n    \\n    // update divisors of num in the divisors array\\n    void update(vector<long long>& divisors, int num) {\\n        for(int i = 1; i * i <= num; i++) {\\n            if(num % i == 0) {\\n                if(i == num / i) divisors[i]++;\\n                else {\\n                    divisors[i]++;\\n                    divisors[num/i]++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<long long> divisors(mx, 0LL); // array to store the divisors of each number\\n        long long res = 0LL; // result variable to count the number of pairs divisible by k\\n        \\n        // iterate over each number in the input array\\n        for(int i = 0; i < nums.size(); i++) {\\n            int r = k / (__gcd(nums[i], k)); // calculate the gcd factor of the current number to be paired with\\n            \\n            res += divisors[r]; // add the number of pairs already computed for the current gcd factor\\n            \\n            update(divisors, nums[i]); // update the divisors array for the current number\\n        }\\n        \\n        return res; // return the final count of pairs divisible by k\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx = 1e5 + 5; // maximum number of possible divisors\\n    \\n    // update divisors of num in the divisors array\\n    void update(vector<long long>& divisors, int num) {\\n        for(int i = 1; i * i <= num; i++) {\\n            if(num % i == 0) {\\n                if(i == num / i) divisors[i]++;\\n                else {\\n                    divisors[i]++;\\n                    divisors[num/i]++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<long long> divisors(mx, 0LL); // array to store the divisors of each number\\n        long long res = 0LL; // result variable to count the number of pairs divisible by k\\n        \\n        // iterate over each number in the input array\\n        for(int i = 0; i < nums.size(); i++) {\\n            int r = k / (__gcd(nums[i], k)); // calculate the gcd factor of the current number to be paired with\\n            \\n            res += divisors[r]; // add the number of pairs already computed for the current gcd factor\\n            \\n            update(divisors, nums[i]); // update the divisors array for the current number\\n        }\\n        \\n        return res; // return the final count of pairs divisible by k\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357086,
                "title": "alternative-approach-not-based-on-number-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany solutions are based on a Number Thoery that if a * b % k == 0, then gcd(a, k) * gcd(b, k) % k == 0. This approach is excellent, but needs math background.\\nMy solution using a different idea, that one might found approachable if he/she knows little about math and number theroy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a hashtable (in c++, unordered_map<int, vector<int>> factors) to keep track of the index. For example, if the array is [12, 13, 5] (12 has factors 1, 2, 3, 4, 6, 12; 13 has factors 1, 13; 5 has factors 1, 5). The hashtable looks like this:\\nhashtable[1] = [0, 1, 2] //num[0], num[1] num[2] all divisible by 1\\nhashtable[2] = [0] // only num[0] = 12 is divisible by 2\\nhahstable[3] = [0]\\nhashtable[4] = [0]\\nhashtable[5] = [2] // only num[2] = 5 is divisible by 5\\n...\\n...\\nThen, convince yourself the following, in order for a * b % k == 0, gcd(a, k) * someInteger == k. How many integers are there in the array, so that gcd(a, k) * SomeInteger == k? Then, we use binary search on the hashtable[].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nMy approach is O(n sqrt n), which is slower than O(n sqrt k), but still works.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int, vector<int>> factors;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = 1; j <= sqrt(nums[i]); ++j){\\n                //if(factors.find(nums[i]) != factors.end()){continue;}\\n                if(nums[i] % j == 0){\\n                    factors[j].push_back(i);\\n                    if(j != nums[i]/j){\\n                        factors[nums[i]/j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int x_i = k / gcd(nums[i], k);\\n            // if x_i == 1, then gcd(nums[i], k) = k, all pairs are divisible by k\\n            // but i think this case could be handled by general cases so no special dealing\\n            auto itr = factors.find(x_i);\\n            if(itr != factors.end()){\\n                auto find = upper_bound(itr->second.begin(), itr->second.end(), i);\\n                ans += (itr->second.end() - find);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int, vector<int>> factors;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = 1; j <= sqrt(nums[i]); ++j){\\n                //if(factors.find(nums[i]) != factors.end()){continue;}\\n                if(nums[i] % j == 0){\\n                    factors[j].push_back(i);\\n                    if(j != nums[i]/j){\\n                        factors[nums[i]/j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int x_i = k / gcd(nums[i], k);\\n            // if x_i == 1, then gcd(nums[i], k) = k, all pairs are divisible by k\\n            // but i think this case could be handled by general cases so no special dealing\\n            auto itr = factors.find(x_i);\\n            if(itr != factors.end()){\\n                auto find = upper_bound(itr->second.begin(), itr->second.end(), i);\\n                ans += (itr->second.end() - find);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228831,
                "title": "dart-gcd-intuitive-solution-explained",
                "content": "# Approach\\nAs short gcd of n1 * gcd of n2 = k, if we find gcd of nums[i] as n1 and looking for gcd of n2 in left elements. n2 = k/n1.\\n\\n# Complexity\\n- Time complexity:\\nO(N*(Depends on GCDs))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int countPairs(List<int> nums, int k) {\\n    int n = nums.length;\\n    HashMap<int, int> cnt = HashMap();\\n    int res = 0;\\n\\n    int gcd(int x, int y) => x.gcd(y);\\n\\n    for (var i = 0; i < n; i++) {\\n      var gcd1 = gcd(nums[i], k);\\n      var gcd2 = k ~/ gcd1;\\n\\n      // Current element is already divisible k itself.\\n      if (gcd2 == 1) {\\n        res += i;\\n      } else {\\n        // Looking for require gcd in map, if found add count to result.\\n        for (var e in cnt.entries) {\\n          if (e.key % gcd2 == 0) {\\n            res += e.value;\\n          }\\n        }\\n      }\\n      // Add current gcd.\\n      cnt.update(gcd1, (value) => value + 1, ifAbsent: () => 1);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int countPairs(List<int> nums, int k) {\\n    int n = nums.length;\\n    HashMap<int, int> cnt = HashMap();\\n    int res = 0;\\n\\n    int gcd(int x, int y) => x.gcd(y);\\n\\n    for (var i = 0; i < n; i++) {\\n      var gcd1 = gcd(nums[i], k);\\n      var gcd2 = k ~/ gcd1;\\n\\n      // Current element is already divisible k itself.\\n      if (gcd2 == 1) {\\n        res += i;\\n      } else {\\n        // Looking for require gcd in map, if found add count to result.\\n        for (var e in cnt.entries) {\\n          if (e.key % gcd2 == 0) {\\n            res += e.value;\\n          }\\n        }\\n      }\\n      // Add current gcd.\\n      cnt.update(gcd1, (value) => value + 1, ifAbsent: () => 1);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144082,
                "title": "java-solution-using-hashmap",
                "content": "\\n- Time complexity:\\nO(N*sqrt(k))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n\\n        HashMap <Integer, Integer> hm= new HashMap<>();\\n        long sum=0;\\n        for(int i=0; i<nums.length; i++){\\n            int gcd=Getgcd(nums[i], k);\\n\\n            for(int ky: hm.keySet()){\\n                if((long) gcd*ky%k==0){\\n                    sum=sum+hm.get(ky);\\n                }\\n            }\\n\\n            hm.put(gcd, hm.getOrDefault(gcd, 0)+1);\\n        }\\n\\n        return sum;\\n    }\\n\\n    private static int Getgcd(int x, int y){\\n        if(y==0){\\n            return x;\\n        }\\n\\n        if(y>x){\\n            return Getgcd(y, x);\\n        }\\n        else{\\n            return Getgcd(y, x%y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n\\n        HashMap <Integer, Integer> hm= new HashMap<>();\\n        long sum=0;\\n        for(int i=0; i<nums.length; i++){\\n            int gcd=Getgcd(nums[i], k);\\n\\n            for(int ky: hm.keySet()){\\n                if((long) gcd*ky%k==0){\\n                    sum=sum+hm.get(ky);\\n                }\\n            }\\n\\n            hm.put(gcd, hm.getOrDefault(gcd, 0)+1);\\n        }\\n\\n        return sum;\\n    }\\n\\n    private static int Getgcd(int x, int y){\\n        if(y==0){\\n            return x;\\n        }\\n\\n        if(y>x){\\n            return Getgcd(y, x);\\n        }\\n        else{\\n            return Getgcd(y, x%y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094540,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\nUsed some basic math\\n\\n# Approach\\n1.stored all the divisor of k in a map\\n2.Traverse through the array and check if nums[i] is divisible by any of the divisor of k\\n3.If it is divisible then check then add m[k/(that divisor)] to the answer\\n4.return your answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- dd your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<int,int>m;\\n        int x=sqrt(k);\\n        for(int i=1; i<=x; i++){\\n            if(k%i==0){\\n                m[i]=0;\\n                m[k/i]=0;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int prev=1;\\n            for(auto it:m){\\n               if(nums[i]%it.first==0){\\n                   ans+=m[k/it.first];   \\n                   prev=it.first;\\n               }\\n            }\\n            m[prev]++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<int,int>m;\\n        int x=sqrt(k);\\n        for(int i=1; i<=x; i++){\\n            if(k%i==0){\\n                m[i]=0;\\n                m[k/i]=0;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int prev=1;\\n            for(auto it:m){\\n               if(nums[i]%it.first==0){\\n                   ans+=m[k/it.first];   \\n                   prev=it.first;\\n               }\\n            }\\n            m[prev]++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023185,
                "title": "gcd-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nevery number is nothing but product of it\\'s primefactors*1\\nunderstanding of gcd:- gcd of 2 numbers is product of common primefactors \\nx = 20 pf = 2 * **2** * **5**\\ny = 15 pf = 3 * **2** * **5**\\ngcd(x,y) = **2** * **5**\\na number is divisible by k means the number has same prime factors as k . so if we have a number x whose gcd(k,x) is g (g is product of some primefactors of k ) we have to pair this number with a number whose has rest of prime factors.\\nk = 6  pf = 2 * 3\\nx = 20 pf = 2 * 2 * 5\\ny = 15 pf = 3 * 5\\nx * y=300 pf = 2 * 2 * 5 * 3 * 5\\nx * y has common prime factors with k = k\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake an array of gcd with k vs cnt \\niterate over the frequency array and pair with all the numbers who have gcd = n*(k/i) n=1,2,3...\\nNote: if a number can pair with itself then pairs = cnt choose 2\\navoid double counting.\\n# Complexity\\n- Time complexity:$$O(k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        long cnt = 0;\\n        long[] cntgcd = new long[k+1];\\n        for(int i : nums){\\n            int gcd = gcd(i ,k);\\n            cntgcd[gcd]++;\\n        }\\n        for(int i = 1; i < k ; i++){\\n            if(cntgcd[i] == 0)continue;\\n            int rest = k/i;\\n            long subc = 0;\\n            if(rest <= i){\\n                for(int j = 1 ; j*rest <= k ; j++){\\n                    if(j*rest < i)continue;\\n                    if(j*rest == i){\\n                        subc += cntgcd[i]*(cntgcd[i]-1)/2;\\n                        continue;\\n                    }\\n                    subc += cntgcd[i]*cntgcd[j*rest];\\n                }\\n                // subc = cntgcd[i]*cntgcd[k];\\n            }else{\\n                for(int j = 1 ; j*rest <= k ; j++){\\n                    subc += cntgcd[i]*cntgcd[j*rest];\\n                }\\n            }\\n            // System.out.println(subc);\\n            cnt += subc;\\n        }\\n        cnt += cntgcd[k]*(cntgcd[k]-1)/2;\\n        // System.out.println(cnt);\\n        return cnt;\\n    }\\n\\n    public int gcd(int a , int b){\\n        while(b!= 0){\\n            int t = a%b;\\n            a =b;\\n            b = t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        long cnt = 0;\\n        long[] cntgcd = new long[k+1];\\n        for(int i : nums){\\n            int gcd = gcd(i ,k);\\n            cntgcd[gcd]++;\\n        }\\n        for(int i = 1; i < k ; i++){\\n            if(cntgcd[i] == 0)continue;\\n            int rest = k/i;\\n            long subc = 0;\\n            if(rest <= i){\\n                for(int j = 1 ; j*rest <= k ; j++){\\n                    if(j*rest < i)continue;\\n                    if(j*rest == i){\\n                        subc += cntgcd[i]*(cntgcd[i]-1)/2;\\n                        continue;\\n                    }\\n                    subc += cntgcd[i]*cntgcd[j*rest];\\n                }\\n                // subc = cntgcd[i]*cntgcd[k];\\n            }else{\\n                for(int j = 1 ; j*rest <= k ; j++){\\n                    subc += cntgcd[i]*cntgcd[j*rest];\\n                }\\n            }\\n            // System.out.println(subc);\\n            cnt += subc;\\n        }\\n        cnt += cntgcd[k]*(cntgcd[k]-1)/2;\\n        // System.out.println(cnt);\\n        return cnt;\\n    }\\n\\n    public int gcd(int a , int b){\\n        while(b!= 0){\\n            int t = a%b;\\n            a =b;\\n            b = t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013461,
                "title": "python-optimization-is-in-reducing-size-of-input-array",
                "content": "```\\nfrom collections import Counter\\nfrom itertools import combinations_with_replacement\\nfrom math import comb, gcd\\n\\n\\nclass Solution:\\n    def countPairs(self, A: list[int], k: int) -> int:\\n        cnt = Counter(gcd(a, k) for a in A)  # gcd(a, k) is the only usable part of \"a\" during divisibility check. So\\n        # if k = 6 then 2 is equivalent to 4, 8, 10 etc. This is how, we reduce the size of \"A\" and apparently this\\n        # is the only optimization possible\\n\\n        output = 0\\n\\n        for a, b in combinations_with_replacement(cnt, 2):\\n            # now that we iterate all the possible pairs (I was wondering if there could be an optimal approach for\\n            # this, but then checked solution provided by others to discover that no such solution had been discovered),\\n            # so rest of it becomes trivial\\n            if a * b % k == 0:\\n                output += comb(cnt[a], 2) if a == b else cnt[a] * cnt[b]\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom itertools import combinations_with_replacement\\nfrom math import comb, gcd\\n\\n\\nclass Solution:\\n    def countPairs(self, A: list[int], k: int) -> int:\\n        cnt = Counter(gcd(a, k) for a in A)  # gcd(a, k) is the only usable part of \"a\" during divisibility check. So\\n        # if k = 6 then 2 is equivalent to 4, 8, 10 etc. This is how, we reduce the size of \"A\" and apparently this\\n        # is the only optimization possible\\n\\n        output = 0\\n\\n        for a, b in combinations_with_replacement(cnt, 2):\\n            # now that we iterate all the possible pairs (I was wondering if there could be an optimal approach for\\n            # this, but then checked solution provided by others to discover that no such solution had been discovered),\\n            # so rest of it becomes trivial\\n            if a * b % k == 0:\\n                output += comb(cnt[a], 2) if a == b else cnt[a] * cnt[b]\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902927,
                "title": "math-prime-numbers",
                "content": "```\\nfunction countPairs(nums: number[], k: number): number {\\n    const modNums = nums.map((x) => x % k);\\n    modNums.sort((a, b) => a - b);\\n    const modCount = new Array<number>(k);\\n\\n    for (let i = 0; i < k; i++) {\\n      modCount[i] = 0;\\n    }\\n\\n    for (let i = 0; i < modNums.length; i++) {\\n      modCount[modNums[i]] += 1;\\n    }\\n    let count = 0;\\n    if (modCount[0] > 0) {\\n      let n = nums.length;\\n      let k = modCount[0];\\n      count += n * k - (k * (k + 1)) / 2;\\n    }\\n\\n    const gcd = (a: number, b: number): number => {\\n        if (b == 0) {\\n            return a;\\n        }\\n  \\n        return gcd(b, a % b);\\n    };\\n\\n    for (let i = 2; i < k; i++) {\\n      if (modCount[i] === 0) continue;\\n      let _gcd = gcd(i, k);\\n      if (_gcd === 1) continue;\\n      let r = k / _gcd;\\n      let f = Math.ceil(i / r) * r;\\n      let n = modCount[i];\\n      if (f === i) {\\n        count += (n * (n - 1)) / 2;\\n        f += r;\\n      }\\n\\n      for(let j = f; j < k; j += r) {\\n        let k = modCount[j];\\n        count += n * k;\\n      }\\n\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction countPairs(nums: number[], k: number): number {\\n    const modNums = nums.map((x) => x % k);\\n    modNums.sort((a, b) => a - b);\\n    const modCount = new Array<number>(k);\\n\\n    for (let i = 0; i < k; i++) {\\n      modCount[i] = 0;\\n    }\\n\\n    for (let i = 0; i < modNums.length; i++) {\\n      modCount[modNums[i]] += 1;\\n    }\\n    let count = 0;\\n    if (modCount[0] > 0) {\\n      let n = nums.length;\\n      let k = modCount[0];\\n      count += n * k - (k * (k + 1)) / 2;\\n    }\\n\\n    const gcd = (a: number, b: number): number => {\\n        if (b == 0) {\\n            return a;\\n        }\\n  \\n        return gcd(b, a % b);\\n    };\\n\\n    for (let i = 2; i < k; i++) {\\n      if (modCount[i] === 0) continue;\\n      let _gcd = gcd(i, k);\\n      if (_gcd === 1) continue;\\n      let r = k / _gcd;\\n      let f = Math.ceil(i / r) * r;\\n      let n = modCount[i];\\n      if (f === i) {\\n        count += (n * (n - 1)) / 2;\\n        f += r;\\n      }\\n\\n      for(let j = f; j < k; j += r) {\\n        let k = modCount[j];\\n        count += n * k;\\n      }\\n\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886558,
                "title": "python-solutions",
                "content": "1st solution:\\n```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n\\tans, d = 0, defaultdict(int)\\n\\tfor n in nums:\\n\\t\\tans += sum(d[x] for x in d if n%x==0)\\n\\t\\td[k/gcd(n, k)] += 1\\n\\treturn ans\\n```\\n\\n2nd solution:\\n```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n\\tans, d = 0, defaultdict(int)\\n\\tdiv = [i for i in range(1, k+1) if k%i==0]\\n\\tfor n in nums:\\n\\t\\tans += d[k//gcd(n, k)]\\n\\t\\tfor x in div:\\n\\t\\t\\tif n%x==0:\\n\\t\\t\\t\\td[x] += 1\\n\\treturn ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n\\tans, d = 0, defaultdict(int)\\n\\tfor n in nums:\\n\\t\\tans += sum(d[x] for x in d if n%x==0)\\n\\t\\td[k/gcd(n, k)] += 1\\n\\treturn ans\\n```\n```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n\\tans, d = 0, defaultdict(int)\\n\\tdiv = [i for i in range(1, k+1) if k%i==0]\\n\\tfor n in nums:\\n\\t\\tans += d[k//gcd(n, k)]\\n\\t\\tfor x in div:\\n\\t\\t\\tif n%x==0:\\n\\t\\t\\t\\td[x] += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2820278,
                "title": "easy-understanding-c-solution",
                "content": "**```\\n *  if i*j / k == 0 , it means factors of i and j is match with factors of k \\n\\n   *   i * j / k ==> (i1*i2*..) * (j1*j2*..)/(k1*k2*k3...) => (i1*i2*...) / (k1*k3*..)\\n\\n  *   some factors of k is gone to be cancel by factors of j , we need to find those number which contain remaining factors\\n\\n  *  for every nums[j] , find number b/w  0...j-1 which contain k/gcd(k,nums[j]) as factor , gcd(k,num[j]) are those factors that match  with nums[j].\\n**\\n\\n time complexity : O(N)\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n    \\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        vector<int> v;\\n        for(int i=1;i*i<=k;i++)\\n        {\\n            if(k%i == 0) v.push_back(i);\\n            if(k/i != i && k%i == 0) v.push_back(k/i);\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans += mp[k/__gcd(k,nums[i])];\\n            for(auto it : v)\\n            {\\n                if(nums[i]%it == 0) mp[it]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n *  if i*j / k == 0 , it means factors of i and j is match with factors of k \\n\\n   *   i * j / k ==> (i1*i2*..) * (j1*j2*..)/(k1*k2*k3...) => (i1*i2*...) / (k1*k3*..)\\n\\n  *   some factors of k is gone to be cancel by factors of j , we need to find those number which contain remaining factors\\n\\n  *  for every nums[j] , find number b/w  0...j-1 which contain k/gcd(k,nums[j]) as factor , gcd(k,num[j]) are those factors that match  with nums[j].\\n**\\n\\n time complexity : O(N)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808609,
                "title": "javascript-gcd-nums-i-k-gcd-nums-j-k-k-0",
                "content": "```\\n//The condition given to us is (nums[i] * nums[j] % k === 0)\\n// We can rewrite the above condition such that if any factor of k is present in nums[i] and any other factor of k is present in nums[j] then nums[i] * nums[j] will be divisble by k\\n\\n// so gcd(nums[i], k) * gcd(nums[j], k) % k === 0 \\n\\nfunction gcd(n1, n2) {\\n    while (n1 % n2 !== 0) {\\n        let rem = n1 % n2;\\n        n1 = n2;\\n        n2 = rem;\\n    }\\n    return n2;\\n}\\n\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    const hashMap = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let gcd1 = gcd(nums[i], k);\\n        \\n        for (let gcd2 of hashMap.keys()) {\\n            if (gcd1 * gcd2 % k === 0) count += hashMap.get(gcd2);\\n        }\\n        \\n        if (hashMap.has(gcd1)) hashMap.set(gcd1, hashMap.get(gcd1) + 1);\\n        else hashMap.set(gcd1, 1);\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//The condition given to us is (nums[i] * nums[j] % k === 0)\\n// We can rewrite the above condition such that if any factor of k is present in nums[i] and any other factor of k is present in nums[j] then nums[i] * nums[j] will be divisble by k\\n\\n// so gcd(nums[i], k) * gcd(nums[j], k) % k === 0 \\n\\nfunction gcd(n1, n2) {\\n    while (n1 % n2 !== 0) {\\n        let rem = n1 % n2;\\n        n1 = n2;\\n        n2 = rem;\\n    }\\n    return n2;\\n}\\n\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    const hashMap = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let gcd1 = gcd(nums[i], k);\\n        \\n        for (let gcd2 of hashMap.keys()) {\\n            if (gcd1 * gcd2 % k === 0) count += hashMap.get(gcd2);\\n        }\\n        \\n        if (hashMap.has(gcd1)) hashMap.set(gcd1, hashMap.get(gcd1) + 1);\\n        else hashMap.set(gcd1, 1);\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790630,
                "title": "very-easy-to-understand-hashmap-approach-with-gcd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        unordered_map <int, int> mp;\\n        int m=*max_element(nums.begin(), nums.end());\\n\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int g=__gcd(k, nums[i]);\\n            int t=k/g;\\n            //cout<<g<<\" \"<<t<<endl;\\n            if(g==k)\\n            {\\n                ans+=i;\\n            }\\n            else\\n            {\\n                for(auto it: mp)\\n                {\\n                    if(it.first%t==0)\\n                        ans+=it.second;\\n                }\\n            }\\n            mp[g]++;\\n            //cout<<ans<<endl;\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        unordered_map <int, int> mp;\\n        int m=*max_element(nums.begin(), nums.end());\\n\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int g=__gcd(k, nums[i]);\\n            int t=k/g;\\n            //cout<<g<<\" \"<<t<<endl;\\n            if(g==k)\\n            {\\n                ans+=i;\\n            }\\n            else\\n            {\\n                for(auto it: mp)\\n                {\\n                    if(it.first%t==0)\\n                        ans+=it.second;\\n                }\\n            }\\n            mp[g]++;\\n            //cout<<ans<<endl;\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2761966,
                "title": "c-solution-with-logic-easy-and-simple-sort-code",
                "content": "----------------- Main Logic------------------\\n**(Num1 * Num2) % k == 0\\nis Equivalent to \\n(Gcd(Num1,k) * Gcd(Num2,k)) % k == 0**\\n\\nFor eg -> Num1 = 4, Num2 = 3 , k = 6\\nfactors of 4 = 2 * 2 \\nfactors of 3 = 3\\nfactors of 6 = 2 * 3\\n\\nApply above logic and see yourself (Do yourself exercise for better understanding)\\n\\n# Code\\n```\\n// If it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int gc(int a,int b){\\n        // base case\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gc(b%a,a);\\n    }\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int val1 = gc(nums[i],k);\\n            for(auto it : mp){\\n                int val2 = it.first;\\n                if((val1 *1LL* val2) % k == 0){\\n                    ans += it.second;\\n                }\\n            }\\n            mp[val1]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\n// If it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int gc(int a,int b){\\n        // base case\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gc(b%a,a);\\n    }\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int val1 = gc(nums[i],k);\\n            for(auto it : mp){\\n                int val2 = it.first;\\n                if((val1 *1LL* val2) % k == 0){\\n                    ans += it.second;\\n                }\\n            }\\n            mp[val1]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642204,
                "title": "rust-easy-solution",
                "content": "See the comments.\\n\\n```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn count_pairs(nums: Vec<i32>, k: i32) -> i64 {\\n\\t\\tfn gcd(x: i32, y: i32) -> i32 {\\n\\t\\t\\tlet (mut x, mut y) = (x, y);\\n\\t\\t\\twhile y != 0 { let t = x % y; x = y; y = t; }\\n\\t\\t\\tx\\n\\t\\t}\\n\\t\\tlet d = (1..=k).filter(|&i| k % i == 0).collect::<Vec<_>>();\\t// find all divisors of k\\n\\t\\tlet mut r = HashMap::new();\\t// for divisor-to-index mapping\\n\\t\\tfor (i, &x) in d.iter().enumerate() { r.insert(x, i); }\\n\\t\\tlet mut ans: i64 = 0;\\n\\t\\tlet mut a = vec![0; d.len()];\\t// # elements which can be divided by d[i]\\n\\t\\tfor &x in &nums {\\n\\t\\t\\tlet g = gcd(x, k);\\n\\t\\t\\tans += a[r[&(k / g)]] as i64;\\n\\t\\t\\tfor i in 0..d.len() {\\n\\t\\t\\t\\tif x % d[i] == 0 { a[i] += 1; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn count_pairs(nums: Vec<i32>, k: i32) -> i64 {\\n\\t\\tfn gcd(x: i32, y: i32) -> i32 {\\n\\t\\t\\tlet (mut x, mut y) = (x, y);\\n\\t\\t\\twhile y != 0 { let t = x % y; x = y; y = t; }\\n\\t\\t\\tx\\n\\t\\t}\\n\\t\\tlet d = (1..=k).filter(|&i| k % i == 0).collect::<Vec<_>>();\\t// find all divisors of k\\n\\t\\tlet mut r = HashMap::new();\\t// for divisor-to-index mapping\\n\\t\\tfor (i, &x) in d.iter().enumerate() { r.insert(x, i); }\\n\\t\\tlet mut ans: i64 = 0;\\n\\t\\tlet mut a = vec![0; d.len()];\\t// # elements which can be divided by d[i]\\n\\t\\tfor &x in &nums {\\n\\t\\t\\tlet g = gcd(x, k);\\n\\t\\t\\tans += a[r[&(k / g)]] as i64;\\n\\t\\t\\tfor i in 0..d.len() {\\n\\t\\t\\t\\tif x % d[i] == 0 { a[i] += 1; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616631,
                "title": "simple-math-solution-c",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int d) {\\n        map<int, int> freq;\\n        for (auto & e: nums){\\n            freq[__gcd(e, d)]++;    \\n        }\\n        ll ans = 0;\\n        for (auto & [k , v] : freq){\\n            for (auto & [k1, v1]: freq){\\n                if (k == k1){\\n                    if (1ll * k * k1 % d == 0){\\n                        ans += 1ll * v * (v - 1) / 2;\\n                    }\\n                }else if (k < k1){\\n                    if (1ll * k * k1 % d == 0){\\n                        ans += 1ll * v * v1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int d) {\\n        map<int, int> freq;\\n        for (auto & e: nums){\\n            freq[__gcd(e, d)]++;    \\n        }\\n        ll ans = 0;\\n        for (auto & [k , v] : freq){\\n            for (auto & [k1, v1]: freq){\\n                if (k == k1){\\n                    if (1ll * k * k1 % d == 0){\\n                        ans += 1ll * v * (v - 1) / 2;\\n                    }\\n                }else if (k < k1){\\n                    if (1ll * k * k1 % d == 0){\\n                        ans += 1ll * v * v1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603108,
                "title": "easy-solution-in-python-with-93-35-acceptance",
                "content": "from math import*\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        lst=[]\\n        for i in nums:\\n            c=gcd(i,k)\\n            lst.append(c)\\n        d=Counter(lst)\\n        #print(cnt)\\n        r = 0\\n        for a in d:\\n            for b in d:\\n                if a <= b and a * b % k == 0:\\n                    if a < b:\\n                        r += d[a] * d[b]\\n                    else:\\n                        r+=d[a] * (d[a] - 1) // 2\\n                    \\n                      \\n        return r",
                "solutionTags": [],
                "code": "from math import*\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        lst=[]\\n        for i in nums:\\n            c=gcd(i,k)\\n            lst.append(c)\\n        d=Counter(lst)\\n        #print(cnt)\\n        r = 0\\n        for a in d:\\n            for b in d:\\n                if a <= b and a * b % k == 0:\\n                    if a < b:\\n                        r += d[a] * d[b]\\n                    else:\\n                        r+=d[a] * (d[a] - 1) // 2\\n                    \\n                      \\n        return r",
                "codeTag": "Java"
            },
            {
                "id": 2517718,
                "title": "c-gcd-and-hashmap-approach-comments-included",
                "content": "```\\n    // get all the divisors for k\\n    \\n    std::vector<int> divisors;\\n    divisors.reserve(k);\\n    \\n    for (auto i = 1; i <= k; ++i)\\n      if (k % i == 0)\\n        divisors.push_back(i);\\n    \\n    std::unordered_map<int, int> divisibles;\\n    //                 ---  ---\\n    //               divisor count\\n    \\n    long long count = 0;\\n    \\n    for (auto i = 0; i != nums.size(); ++i)\\n    {\\n      int g = std::gcd(nums[i], k);\\n      \\n      int target = k/g;\\n      \\n      count += divisibles[target];\\n      \\n      \\n      for (auto &divisor: divisors)\\n        if (nums[i] % divisor == 0)\\n          divisibles[divisor] ++;\\n    }\\n    \\n    return count;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    // get all the divisors for k\\n    \\n    std::vector<int> divisors;\\n    divisors.reserve(k);\\n    \\n    for (auto i = 1; i <= k; ++i)\\n      if (k % i == 0)\\n        divisors.push_back(i);\\n    \\n    std::unordered_map<int, int> divisibles;\\n    //                 ---  ---\\n    //               divisor count\\n    \\n    long long count = 0;\\n    \\n    for (auto i = 0; i != nums.size(); ++i)\\n    {\\n      int g = std::gcd(nums[i], k);\\n      \\n      int target = k/g;\\n      \\n      count += divisibles[target];\\n      \\n      \\n      for (auto &divisor: divisors)\\n        if (nums[i] % divisor == 0)\\n          divisibles[divisor] ++;\\n    }\\n    \\n    return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463173,
                "title": "100-easy-solution",
                "content": "\\n\\n  long long ans=0;\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             int gcd=__gcd(nums[i],k);\\n            int needed_num=k/gcd; \\n            for(auto x:m)\\n            {\\n                if(x.first%needed_num==0)\\n                    ans+=x.second;\\n            }\\n            m[gcd]++;\\n            \\n        }\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "\\n\\n  long long ans=0;\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             int gcd=__gcd(nums[i],k);\\n            int needed_num=k/gcd; \\n            for(auto x:m)\\n            {\\n                if(x.first%needed_num==0)\\n                    ans+=x.second;\\n            }\\n            m[gcd]++;\\n            \\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2350263,
                "title": "c-thinking-process",
                "content": "Obviously n^2 woud not have worked. i thought of finding complementing pairs. \\nhow to find complement. by multiplying two numbers and directly checking. but since n^2 is expensive. its better to reduce search space by creating hashmaps and storing the gcd of k with all numbers.\\n\\nproduct of two numbers div by k is same is product of (gcd of number 1 & k ) with (gcd of number 2 & k).\\nwe are doing smart count over here then.\\n\\n```\\nclass Solution {\\npublic:\\n \\n    long long countPairs(vector<int>& nums, int k) {\\n        \\n      map<int,int> mp;\\n        long long ans = 0;\\n        int ct = nums.size()-1;\\n        for(int i=0;i<nums.size();i=i+1)\\n        {\\n            int x  = __gcd(nums[i],k);\\n            if(x%k==0){ans = ans + ct;ct--;}\\n            else{mp[x]++;}\\n        }\\n        \\n        \\n       for(auto i = mp.begin(); i != mp.end(); i++)\\n       {   \\n           auto it=i;\\n           if(((long long)it->first*(long long)it->first)%k==0){ans = ans + ((long long)(i->second)*(i->second-1))/2;}\\n           it++;\\n           for(;it != mp.end(); it++)\\n           {\\n               if((i->first*it->first)%k==0){ans = ans + i->second*it->second;}\\n           }\\n       }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    long long countPairs(vector<int>& nums, int k) {\\n        \\n      map<int,int> mp;\\n        long long ans = 0;\\n        int ct = nums.size()-1;\\n        for(int i=0;i<nums.size();i=i+1)\\n        {\\n            int x  = __gcd(nums[i],k);\\n            if(x%k==0){ans = ans + ct;ct--;}\\n            else{mp[x]++;}\\n        }\\n        \\n        \\n       for(auto i = mp.begin(); i != mp.end(); i++)\\n       {   \\n           auto it=i;\\n           if(((long long)it->first*(long long)it->first)%k==0){ans = ans + ((long long)(i->second)*(i->second-1))/2;}\\n           it++;\\n           for(;it != mp.end(); it++)\\n           {\\n               if((i->first*it->first)%k==0){ans = ans + i->second*it->second;}\\n           }\\n       }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348080,
                "title": "gcd-java-kind-of-similar-to-2344-minimum-deletions-to-make-array-divisible",
                "content": "This problem reminds me of https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/ during contest 2 weeks ago. \\n\\nI had read the constraint wrong (thought it was up to 1e5) and got TLE and wasted 30 minutes trying to optimize my \"supposedly\" O(3e7) solution. Later I realized it was actually up to 1e9, which makes my sol O(3e9), so all that time and effort went down the drain and I was placed 2500th :(\\n[I thought I read the constraint carefully, but I did not, and I did not bother to double check when the first TLE, a huge mistake]\\n\\nIronically, the TLE solution I implemented for that problem is nearly identical to my solution to this problem.\\nFor this problem, the constraint is actually 1e5 max for each number, so we can factor it and check. Increment each factor by 1 if a number has it, and count on the fly. Use gcd to find the other part quick.\\n\\n#### Java\\n\\n```Java\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        int[] map = new int[100001];\\n        long ans = 0;\\n        for (int n : nums){\\n            int w = k / gcd(k, n);\\n            for (int i = 1; i*i <= n; i++){\\n                if (n % i == 0){\\n                    map[i]++;\\n                    if (i*i!=n){\\n                        map[n/i]++;\\n                    }\\n                }\\n            }\\n            ans += map[w] - (n % w == 0? 1 : 0);\\n        }\\n        return ans;\\n    }\\n\\n    private int gcd(int a, int b){\\n        return a == 0? b : gcd(b%a, a);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        int[] map = new int[100001];\\n        long ans = 0;\\n        for (int n : nums){\\n            int w = k / gcd(k, n);\\n            for (int i = 1; i*i <= n; i++){\\n                if (n % i == 0){\\n                    map[i]++;\\n                    if (i*i!=n){\\n                        map[n/i]++;\\n                    }\\n                }\\n            }\\n            ans += map[w] - (n % w == 0? 1 : 0);\\n        }\\n        return ans;\\n    }\\n\\n    private int gcd(int a, int b){\\n        return a == 0? b : gcd(b%a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298265,
                "title": "python-short-solution-similar-to-target-sum",
                "content": "```\\nd=defaultdict(int)\\n        count=0\\n        for i in range(len(nums)):\\n            x=math.gcd(nums[i],k)\\n            req=k//x\\n            for c in d:\\n                if c%req==0:\\n                    count+=d[c]\\n            d[x]+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nd=defaultdict(int)\\n        count=0\\n        for i in range(len(nums)):\\n            x=math.gcd(nums[i],k)\\n            req=k//x\\n            for c in d:\\n                if c%req==0:\\n                    count+=d[c]\\n            d[x]+=1\\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2205289,
                "title": "java-gcd-hashmap",
                "content": "```\\nclass Solution {\\n    public long countPairs(int a[], int k)\\n    {\\n        int n=a.length;\\n        \\n        //GCD-->num of elements\\n        HashMap<Integer,Long> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int gcd=GCD(a[i],k);\\n            map.put(gcd,map.getOrDefault(gcd,0L)+1L);\\n        }\\n        \\n        \\n        long ans=0L;\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(!map.containsKey(i))\\n            continue;\\n            \\n            long mul=i*i;\\n            \\n            //nC2\\n            if(i==k || mul%k==0)\\n            ans+=(map.get(i)*(map.get(i)-1))/2L;\\n            \\n            \\n            for(int j=i+1;j<=k;j++)\\n            {\\n                if(!map.containsKey(j))\\n                continue;\\n                \\n                long m=i*j;\\n                \\n                if(m%k==0 || j==k)\\n                ans+=(long)map.get(i)*map.get(j);\\n            }\\n        \\n        }\\n    \\n        return ans;\\n    }\\n    \\n    public int GCD(int a,int b)\\n    {\\n        if(b==0)\\n        return a;\\n        return GCD(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countPairs(int a[], int k)\\n    {\\n        int n=a.length;\\n        \\n        //GCD-->num of elements\\n        HashMap<Integer,Long> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int gcd=GCD(a[i],k);\\n            map.put(gcd,map.getOrDefault(gcd,0L)+1L);\\n        }\\n        \\n        \\n        long ans=0L;\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(!map.containsKey(i))\\n            continue;\\n            \\n            long mul=i*i;\\n            \\n            //nC2\\n            if(i==k || mul%k==0)\\n            ans+=(map.get(i)*(map.get(i)-1))/2L;\\n            \\n            \\n            for(int j=i+1;j<=k;j++)\\n            {\\n                if(!map.containsKey(j))\\n                continue;\\n                \\n                long m=i*j;\\n                \\n                if(m%k==0 || j==k)\\n                ans+=(long)map.get(i)*map.get(j);\\n            }\\n        \\n        }\\n    \\n        return ans;\\n    }\\n    \\n    public int GCD(int a,int b)\\n    {\\n        if(b==0)\\n        return a;\\n        return GCD(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201009,
                "title": "java-o-k-log-k-n-solution",
                "content": "```\\nclass Solution {\\n    long gcd(long a, long b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    public long countPairs(int[] nums, int k) {\\n        long[] f = new long[k];\\n        long nonZeros = 0;\\n        for(int v:nums){\\n            f[v%k]++;\\n            if(v%k!=0) nonZeros++;\\n        }\\n        long ans = 0;\\n        if(f[0]>0){\\n            ans += (f[0]*(f[0]-1))/2;\\n            ans += (f[0]*nonZeros);\\n        }\\n        long[] fp = new long[k+1];\\n        for(int i=1;i<k;i++){\\n            int j=i;\\n            while(j<k){\\n                fp[i]+=f[j];\\n                j+=i;\\n            }\\n        }\\n        long ans1 = 0;\\n        for(long i=1;i<k;i++){\\n            if(f[(int) i]==0) continue;\\n            long j = k/gcd(i,k);\\n            ans1 += (f[(int) i]*fp[(int) j]);\\n            if(i%j==0){\\n                ans1 -= (f[(int) i]*f[(int) i]);\\n                ans1 += (f[(int) i]*(f[(int) i]-1));\\n            }\\n        }\\n        ans += (ans1/2);\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime complexity:\\n(K/1 + K/2 + K/3 + ... K/K) + N = O(K log K + N)\\n\\nSpace complexity:\\nO(K)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long gcd(long a, long b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    public long countPairs(int[] nums, int k) {\\n        long[] f = new long[k];\\n        long nonZeros = 0;\\n        for(int v:nums){\\n            f[v%k]++;\\n            if(v%k!=0) nonZeros++;\\n        }\\n        long ans = 0;\\n        if(f[0]>0){\\n            ans += (f[0]*(f[0]-1))/2;\\n            ans += (f[0]*nonZeros);\\n        }\\n        long[] fp = new long[k+1];\\n        for(int i=1;i<k;i++){\\n            int j=i;\\n            while(j<k){\\n                fp[i]+=f[j];\\n                j+=i;\\n            }\\n        }\\n        long ans1 = 0;\\n        for(long i=1;i<k;i++){\\n            if(f[(int) i]==0) continue;\\n            long j = k/gcd(i,k);\\n            ans1 += (f[(int) i]*fp[(int) j]);\\n            if(i%j==0){\\n                ans1 -= (f[(int) i]*f[(int) i]);\\n                ans1 += (f[(int) i]*(f[(int) i]-1));\\n            }\\n        }\\n        ans += (ans1/2);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131360,
                "title": "c-map-gcd-begineers",
                "content": "\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            long long  gcd= __gcd(nums[i],k);\\n            long long  a= k/gcd;\\n            for(auto it :m){\\n                if(it.first%a==0){\\n                    ans=ans+it.second;\\n                }}\\n                m[gcd]++;\\n            \\n        }\\n        return ans;\\n",
                "solutionTags": [],
                "code": "\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            long long  gcd= __gcd(nums[i],k);\\n            long long  a= k/gcd;\\n            for(auto it :m){\\n                if(it.first%a==0){\\n                    ans=ans+it.second;\\n                }}\\n                m[gcd]++;\\n            \\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2124063,
                "title": "c-using-gcd",
                "content": "```\\nlong long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> cnt;  \\n        long long ans = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int gcd1 = __gcd(nums[i],k);\\n            int gcd2 = k/gcd1;\\n            \\n            if(gcd2 == 1) ans+=i;\\n            else{\\n                // for(int j=0;j<i;j++){\\n                //     if(nums[j]%gcd2 == 0) ans++;\\n                // }\\n                for(auto it:cnt){\\n                    if(it.first % gcd2 == 0) ans+=it.second;\\n                }\\n            }\\n            cnt[gcd1]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> cnt;  \\n        long long ans = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int gcd1 = __gcd(nums[i],k);\\n            int gcd2 = k/gcd1;\\n            \\n            if(gcd2 == 1) ans+=i;\\n            else{\\n                // for(int j=0;j<i;j++){\\n                //     if(nums[j]%gcd2 == 0) ans++;\\n                // }\\n                for(auto it:cnt){\\n                    if(it.first % gcd2 == 0) ans+=it.second;\\n                }\\n            }\\n            cnt[gcd1]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106673,
                "title": "c-solution-gcd-hashmap-explained",
                "content": "* The element of a pair (i,j) product gives a multiple of k. If and only if one of the element is a factor/multiple of k. \\n* Therefore we can say that [gcd(i,k) * gcd(j,k)] %k == 0.\\n\\n**Code:**\\n\\n```class Solution\\n{\\npublic:\\n    long long countPairs(vector<int> &nums, int k)\\n    {\\n        long long p = 0;\\n        unordered_map<int, int> mp;\\n        for (auto ele : nums)\\n        {\\n            long long gcd = __gcd(k, ele);\\n            long long x = k / gcd;\\n\\n            for (auto it : mp)\\n                if (it.first % x == 0)\\n                    p += it.second;\\n            mp[gcd]++;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```class Solution\\n{\\npublic:\\n    long long countPairs(vector<int> &nums, int k)\\n    {\\n        long long p = 0;\\n        unordered_map<int, int> mp;\\n        for (auto ele : nums)\\n        {\\n            long long gcd = __gcd(k, ele);\\n            long long x = k / gcd;\\n\\n            for (auto it : mp)\\n                if (it.first % x == 0)\\n                    p += it.second;\\n            mp[gcd]++;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067490,
                "title": "python-3-o-n-k-5-time-o-k-space",
                "content": "![image](https://assets.leetcode.com/users/images/6a7624d6-5b39-4840-8723-2d7fdd668fb0_1653327519.163324.png)\\n\\n\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(N * k^.5)T O(k)S \"\"\"\\n        c = collections.Counter(math.gcd(n, k) for n in nums)\\n        return sum(c[a] * c[b] if a != b else math.comb(c[a], 2) for a, b in itertools.combinations_with_replacement(c, 2) if a * b % k == 0)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/6a7624d6-5b39-4840-8723-2d7fdd668fb0_1653327519.163324.png)\\n\\n\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(N * k^.5)T O(k)S \"\"\"\\n        c = collections.Counter(math.gcd(n, k) for n in nums)\\n        return sum(c[a] * c[b] if a != b else math.comb(c[a], 2) for a, b in itertools.combinations_with_replacement(c, 2) if a * b % k == 0)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2027610,
                "title": "python-o-ntau-n-use-lcm-v-k-v-to-search-satisfied-pairs",
                "content": "The key idea is that for a value pair (v, u) that v * u % k == 0, means u is divisible by lcm(v, k) // v, so we can count how many values can be divided evenly by lcm(v, k) // v. For numbers is multiple of k, we count it with (n - 1). For simplicity, we count all pair twice.\\n```\\nfrom collections import Counter\\nfrom math import lcm\\n\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n, cnt, fac_cnt = len(nums), Counter(nums), dict()\\n        if k == 1: return n * (n - 1) // 2\\n        for i in range(2, k // 2 + 1):\\n            if k % i == 0: fac_cnt[i] = 0\\n        rmi, sp = [], 0\\n        for v, c in cnt.items():\\n            if v % k == 0:\\n                rmi.append(v)\\n                sp += c\\n                continue\\n            for f in fac_cnt:\\n                if v % f == 0: fac_cnt[f] += c\\n        for v in rmi: cnt.pop(v)\\n        ans = sp * (n - sp) * 2 + sp * (sp - 1)\\n        for v, c in cnt.items():\\n            m = lcm(v, k) // v\\n            if m in fac_cnt: ans += c * (fac_cnt[m] - (0 if v % m else c))\\n            if (v * v) % k == 0: ans += c * (c - 1)\\n        return ans // 2\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom math import lcm\\n\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n, cnt, fac_cnt = len(nums), Counter(nums), dict()\\n        if k == 1: return n * (n - 1) // 2\\n        for i in range(2, k // 2 + 1):\\n            if k % i == 0: fac_cnt[i] = 0\\n        rmi, sp = [], 0\\n        for v, c in cnt.items():\\n            if v % k == 0:\\n                rmi.append(v)\\n                sp += c\\n                continue\\n            for f in fac_cnt:\\n                if v % f == 0: fac_cnt[f] += c\\n        for v in rmi: cnt.pop(v)\\n        ans = sp * (n - sp) * 2 + sp * (sp - 1)\\n        for v, c in cnt.items():\\n            m = lcm(v, k) // v\\n            if m in fac_cnt: ans += c * (fac_cnt[m] - (0 if v % m else c))\\n            if (v * v) % k == 0: ans += c * (c - 1)\\n        return ans // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020090,
                "title": "python-version-using-gcd",
                "content": "this is the Python version inspired by the post by votrubac. thanks to his detailed explanation and patience teaching us the gcd trick!\\n```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            while a*b!=0:\\n                if a<b:\\n                    a,b=b,a\\n                c=a%b\\n                b,a=b,c\\n            return a+b    \\n        m={}\\n        for i,c in enumerate(nums):\\n            temp=gcd(c,k)\\n            if temp not in m:\\n                m[temp]=0\\n            m[temp]+=1\\n        res=0\\n        #print(m)\\n        for k1,v1 in m.items():\\n            if k1*k1%k==0:\\n                res+=v1*(v1-1)//2\\n            for k2,v2 in m.items():\\n                if k2<=k1: continue\\n                else:\\n                    if k1*k2%k==0:\\n                        res+=v1*v2\\n            #print(f\"k1={k1},v={v1}, res={res}\")\\n        return res",
                "solutionTags": [],
                "code": "this is the Python version inspired by the post by votrubac. thanks to his detailed explanation and patience teaching us the gcd trick!\\n```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            while a*b!=0:\\n                if a<b:\\n                    a,b=b,a\\n                c=a%b\\n                b,a=b,c\\n            return a+b    \\n        m={}\\n        for i,c in enumerate(nums):\\n            temp=gcd(c,k)\\n            if temp not in m:\\n                m[temp]=0\\n            m[temp]+=1\\n        res=0\\n        #print(m)\\n        for k1,v1 in m.items():\\n            if k1*k1%k==0:\\n                res+=v1*(v1-1)//2\\n            for k2,v2 in m.items():\\n                if k2<=k1: continue\\n                else:\\n                    if k1*k2%k==0:\\n                        res+=v1*v2\\n            #print(f\"k1={k1},v={v1}, res={res}\")\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2000539,
                "title": "c-gcd-easy-simple-solution",
                "content": "\\tpublic:\\n\\t\\tlong long countPairs(vector<int>& nums, int k) {\\n     \\n        unordered_map<long long int, long long int>mp;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            long long gcd = __gcd(nums[i], k);\\n            long long required = k/gcd;\\n            for(auto it:mp){\\n                if(it.first%required==0)\\n                    ans += it.second;\\n            }\\n            mp[gcd]++;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tlong long countPairs(vector<int>& nums, int k) {\\n     \\n        unordered_map<long long int, long long int>mp;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            long long gcd = __gcd(nums[i], k);\\n            long long required = k/gcd;\\n            for(auto it:mp){\\n                if(it.first%required==0)\\n                    ans += it.second;\\n            }\\n            mp[gcd]++;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1992446,
                "title": "c-10-line",
                "content": "```\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> numFactor;\\n        for(int i=1;i<=sqrt(k+1);i++) \\n            if(k % i == 0) numFactor[i], numFactor[k/i];\\n        long long res = 0;\\n        for(auto x:nums){\\n            int y = k/gcd(x,k);\\n            res += numFactor[y];            \\n            for(auto& [factor, n] : numFactor)  \\n                if(x%factor == 0) n++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> numFactor;\\n        for(int i=1;i<=sqrt(k+1);i++) \\n            if(k % i == 0) numFactor[i], numFactor[k/i];\\n        long long res = 0;\\n        for(auto x:nums){\\n            int y = k/gcd(x,k);\\n            res += numFactor[y];            \\n            for(auto& [factor, n] : numFactor)  \\n                if(x%factor == 0) n++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1932919,
                "title": "c-gcd-hashing-solution-with-explanation",
                "content": "<h1>Approach</h1>\\nthe element of a pair *(i,j)* product gives a multiple of k. If and only if one of the element is a factor/multiple of k.\\ntherefore we can say that either [gcd(i,k) * gcd(j,k)] %k == 0.\\n<hr>\\n-> if gcd(i,k) can either be k or 1 or j (j divides k).\\nlong long x = k/gcd ; gives the remaining gcd we need to get of the other elements.\\n\\t\\nSince we are iterating over the array and adding it in the map. we will not consider repeated pairs as only one of them will consider the previous element.\\n(2,4)\\n(4,2) \\nonly one will be considered depending on what occurs later.\\n\\n<h1> Code </h1>\\n\\n```\\nlong long countPairs(vector<int>& nums, int k) {\\n       \\n       long long ans = 0;\\n       unordered_map<int, int> mp;\\n       for(auto ele:nums){\\n           long long gcd = __gcd(k,ele);\\n           long long x=k/gcd;\\n           \\n           for(auto it:mp)\\n               if(it.first%x==0) \\n                   ans+=it.second;\\n            mp[gcd]++;\\n       }\\n       return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long countPairs(vector<int>& nums, int k) {\\n       \\n       long long ans = 0;\\n       unordered_map<int, int> mp;\\n       for(auto ele:nums){\\n           long long gcd = __gcd(k,ele);\\n           long long x=k/gcd;\\n           \\n           for(auto it:mp)\\n               if(it.first%x==0) \\n                   ans+=it.second;\\n            mp[gcd]++;\\n       }\\n       return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900031,
                "title": "c-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<long long> g(k + 1);\\n        for (int i : nums) {\\n            ++g[gcd(max(i, k), min(i, k))];\\n        }\\n\\n        long long res = g[k] * (g[k] - 1) / 2;\\n        for (int i = 1; i < k; ++i) {\\n            if (!g[i]) {\\n                continue;\\n            }\\n\\n            int q = k / i;\\n            for (int j = q; j <= k; j += q) {\\n                if (j == i) {\\n                    res += g[i] * (g[i] - 1) / 2;\\n                } else if (j > i) {\\n                    res += g[i] * g[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<long long> g(k + 1);\\n        for (int i : nums) {\\n            ++g[gcd(max(i, k), min(i, k))];\\n        }\\n\\n        long long res = g[k] * (g[k] - 1) / 2;\\n        for (int i = 1; i < k; ++i) {\\n            if (!g[i]) {\\n                continue;\\n            }\\n\\n            int q = k / i;\\n            for (int j = q; j <= k; j += q) {\\n                if (j == i) {\\n                    res += g[i] * (g[i] - 1) / 2;\\n                } else if (j > i) {\\n                    res += g[i] * g[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844739,
                "title": "what-is-the-reason-for-using-gcd-here",
                "content": "in all discussions i am seeing that every one uses gcd",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1843170,
                "title": "solution",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        import math\\n        from collections import defaultdict\\n        d=defaultdict(int)\\n        \\n        for i in nums:\\n            d[math.gcd(i,k)]+=1\\n        result=0\\n        for i in d:\\n            for j in d:\\n                if j>=i and (i*j)%k==0:\\n                    if i!=j:\\n                        result+=(d[i]*d[j])\\n                    else:\\n                        result+=(d[i]*(d[i]-1)//2)\\n        return result\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        import math\\n        from collections import defaultdict\\n        d=defaultdict(int)\\n        \\n        for i in nums:\\n            d[math.gcd(i,k)]+=1\\n        result=0\\n        for i in d:\\n            for j in d:\\n                if j>=i and (i*j)%k==0:\\n                    if i!=j:\\n                        result+=(d[i]*d[j])\\n                    else:\\n                        result+=(d[i]*(d[i]-1)//2)\\n        return result\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799877,
                "title": "o-maxnum-log-maxnum",
                "content": "maxNum is the maximum among the values of nums and k.\\n\\nI hope the code is self-descriptive enough.\\n\\n```\\nstatic const int MAXN = (int)1e5+5;\\nbool isPrime[MAXN];\\nstd::unordered_map<int,int> primes[MAXN];\\nint inNums[MAXN];\\nint divisibleInNums[MAXN];\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        int maxNum = max(k, *max_element(nums.begin(), nums.end()));\\n        \\n        for (const int& num : nums){\\n            primes[num].clear();\\n        }\\n        primes[k].clear();\\n        \\n        fill(inNums, inNums + maxNum + 1, 0);\\n        for (const int& num : nums) {\\n            inNums[num]++;\\n        }\\n\\t\\t\\n        // These two for loops and the inner while loop will take O(maxNum *(log maxNum)) in total.\\n        // If you take the summation of cnt over all numbers (2...maxNum), it is bound by maxNum * log(maxNum)\\n        fill(isPrime, isPrime + maxNum + 1, true);\\n        isPrime[0] = false;\\n        isPrime[1] = false;\\n        for (int i = 2; i <= maxNum; i++) {\\n            if (!isPrime[i]) {\\n                continue;\\n            }\\n            for (int j = i; j <= maxNum; j+=i) {\\n                if (j != i) {\\n                    isPrime[j] = false;\\n                }\\n                if (j == k or inNums[j] > 0) {\\n                    int temp = j;\\n                    int cnt = 0;\\n                    while(temp % i == 0) {\\n                        temp /= i;\\n                        cnt++;\\n                    }\\n                    primes[j][i] = cnt;\\n                }\\n            }\\n        }\\n        \\n        fill(divisibleInNums, divisibleInNums + maxNum + 1, 0);\\n        divisibleInNums[1] = int(nums.size());\\n        for (int i = 2; i <= maxNum; i++) {\\n            for (int j = i; j <= maxNum; j+=i) {\\n                if (inNums[j]) {\\n                    divisibleInNums[i] = divisibleInNums[i] + inNums[j];\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        const std::unordered_map<int,int>& primesOfK = primes[k];\\n        for (const int& num : nums) {\\n            int requiredNum = 1;\\n            const std::unordered_map<int,int>& primesOfNum = primes[num];\\n            // These two inner loops take O(log(maxNum)) because we create requiredNum \\n            // by multiplication of its prime factors. Also, note that requiredNum <= maxNum\\n            for (const auto& [prime, primePowOfK] : primesOfK) {\\n                int primePowOfNum = primesOfNum.find(prime) == primesOfNum.end() ? 0 : primesOfNum.at(prime);\\n                int requiredPow = max(0, primePowOfK - primePowOfNum);\\n                for (int i = 0; i < requiredPow; i++) {\\n                    requiredNum *= prime;\\n                }\\n            }\\n            assert(requiredNum <= maxNum);\\n            ans += num % requiredNum == 0 ? divisibleInNums[requiredNum] - 1 : divisibleInNums[requiredNum];            \\n        }\\n        // Divide by two because we return (i, j) s.t. i < j\\n        return ans >> 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const int MAXN = (int)1e5+5;\\nbool isPrime[MAXN];\\nstd::unordered_map<int,int> primes[MAXN];\\nint inNums[MAXN];\\nint divisibleInNums[MAXN];\\n\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        int maxNum = max(k, *max_element(nums.begin(), nums.end()));\\n        \\n        for (const int& num : nums){\\n            primes[num].clear();\\n        }\\n        primes[k].clear();\\n        \\n        fill(inNums, inNums + maxNum + 1, 0);\\n        for (const int& num : nums) {\\n            inNums[num]++;\\n        }\\n\\t\\t\\n        // These two for loops and the inner while loop will take O(maxNum *(log maxNum)) in total.\\n        // If you take the summation of cnt over all numbers (2...maxNum), it is bound by maxNum * log(maxNum)\\n        fill(isPrime, isPrime + maxNum + 1, true);\\n        isPrime[0] = false;\\n        isPrime[1] = false;\\n        for (int i = 2; i <= maxNum; i++) {\\n            if (!isPrime[i]) {\\n                continue;\\n            }\\n            for (int j = i; j <= maxNum; j+=i) {\\n                if (j != i) {\\n                    isPrime[j] = false;\\n                }\\n                if (j == k or inNums[j] > 0) {\\n                    int temp = j;\\n                    int cnt = 0;\\n                    while(temp % i == 0) {\\n                        temp /= i;\\n                        cnt++;\\n                    }\\n                    primes[j][i] = cnt;\\n                }\\n            }\\n        }\\n        \\n        fill(divisibleInNums, divisibleInNums + maxNum + 1, 0);\\n        divisibleInNums[1] = int(nums.size());\\n        for (int i = 2; i <= maxNum; i++) {\\n            for (int j = i; j <= maxNum; j+=i) {\\n                if (inNums[j]) {\\n                    divisibleInNums[i] = divisibleInNums[i] + inNums[j];\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        const std::unordered_map<int,int>& primesOfK = primes[k];\\n        for (const int& num : nums) {\\n            int requiredNum = 1;\\n            const std::unordered_map<int,int>& primesOfNum = primes[num];\\n            // These two inner loops take O(log(maxNum)) because we create requiredNum \\n            // by multiplication of its prime factors. Also, note that requiredNum <= maxNum\\n            for (const auto& [prime, primePowOfK] : primesOfK) {\\n                int primePowOfNum = primesOfNum.find(prime) == primesOfNum.end() ? 0 : primesOfNum.at(prime);\\n                int requiredPow = max(0, primePowOfK - primePowOfNum);\\n                for (int i = 0; i < requiredPow; i++) {\\n                    requiredNum *= prime;\\n                }\\n            }\\n            assert(requiredNum <= maxNum);\\n            ans += num % requiredNum == 0 ? divisibleInNums[requiredNum] - 1 : divisibleInNums[requiredNum];            \\n        }\\n        // Divide by two because we return (i, j) s.t. i < j\\n        return ans >> 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795726,
                "title": "count-array-pairs-divisible-by-k-java-solution",
                "content": "```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) \\n    {\\n        HashMap<Integer,Integer> hm=new HashMap<>();//all left gcds are stored here\\n        long c=0;\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int gcd1=gcd(nums[i],k);\\n            int gcd2=k/gcd1;\\n            //if gcd of the no is itself equal to k,then no matter what no you multiply it with,you get               //it divisible by k\\n            if(gcd2 == 1)\\n                c+=i;\\n            //i\\'ll have to check every guy who is a multiply of gcd2\\n            else\\n            {\\n                //this stores all left gcd\\n                for(Integer key: hm.keySet()) \\n                {\\n                    if(key%gcd2 == 0)\\n                        c+=hm.get(key);\\n                }\\n      \\n                \\n            }\\n            if(hm.containsKey(gcd1))\\n                hm.put(gcd1,hm.get(gcd1)+1);\\n            else\\n                hm.put(gcd1,1);\\n        }\\n        return c;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countPairs(int[] nums, int k) \\n    {\\n        HashMap<Integer,Integer> hm=new HashMap<>();//all left gcds are stored here\\n        long c=0;\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int gcd1=gcd(nums[i],k);\\n            int gcd2=k/gcd1;\\n            //if gcd of the no is itself equal to k,then no matter what no you multiply it with,you get               //it divisible by k\\n            if(gcd2 == 1)\\n                c+=i;\\n            //i\\'ll have to check every guy who is a multiply of gcd2\\n            else\\n            {\\n                //this stores all left gcd\\n                for(Integer key: hm.keySet()) \\n                {\\n                    if(key%gcd2 == 0)\\n                        c+=hm.get(key);\\n                }\\n      \\n                \\n            }\\n            if(hm.containsKey(gcd1))\\n                hm.put(gcd1,hm.get(gcd1)+1);\\n            else\\n                hm.put(gcd1,1);\\n        }\\n        return c;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794241,
                "title": "java-solution-using-gcd",
                "content": "import java.math.*;\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        \\n        Map<Integer,Integer> mp=new HashMap<>();\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int n1=nums[i];\\n            BigInteger a=new BigInteger(n1+\"\");\\n            BigInteger b=new BigInteger(k+\"\");\\n            BigInteger gcd1=a.gcd(b);\\n            long gcd2=gcd1.longValue();\\n            int t=(int)gcd2;\\n            for(Integer st:mp.keySet())\\n            {\\n                if((long)t*st%k==0)\\n                    ans+=mp.get(st);\\n            }\\n            \\n            if(mp.containsKey(t))\\n            {\\n                int ct=mp.get(t)+1;\\n                mp.put(t,ct);\\n            }\\n            else\\n                mp.put(t,1);\\n        }\\n        System.out.print(mp);\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countPairs(int[] nums, int k) {\\n        \\n        Map<Integer,Integer> mp=new HashMap<>();\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int n1=nums[i];\\n            BigInteger a=new BigInteger(n1+\"\");\\n            BigInteger b=new BigInteger(k+\"\");\\n            BigInteger gcd1=a.gcd(b);\\n            long gcd2=gcd1.longValue();\\n            int t=(int)gcd2;\\n            for(Integer st:mp.keySet())\\n            {\\n                if((long)t*st%k==0)\\n                    ans+=mp.get(st);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1792448,
                "title": "java-solution-with-dry-run-easy-to-understand",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/d57ead05-377f-47d4-95da-031bc0fd20d0_1645559154.997276.jpeg)\\n\\n\\n\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        ArrayList<int[]> factorsCount = new ArrayList();\\n        for(int i = 1; i * i <= k; i++){\\n            if(k % i == 0){\\n                factorsCount.add(new int[]{i, 0});\\n                if(k / i != i)\\n                    factorsCount.add(new int[]{k/i, 0});\\n            }\\n        }\\n        long result = 0;\\n        for(int num: nums){\\n            int gcd = gcd(num, k);\\n            for(int[] factorCount : factorsCount){\\n                result += ((long)gcd * factorCount[0]) % k == 0 ? factorCount[1] : 0;\\n                if(factorCount[0] == gcd)\\n                    factorCount[1]++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b == 0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countPairs(int[] nums, int k) {\\n        ArrayList<int[]> factorsCount = new ArrayList();\\n        for(int i = 1; i * i <= k; i++){\\n            if(k % i == 0){\\n                factorsCount.add(new int[]{i, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1791786,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(NlogN)***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    int gcd(int a, int b)\\n    {   \\n        if(b == 0)\\n            return a;\\n        \\n        return gcd(b, a % b);\\n    }\\n    \\n    long long countPairs(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x = gcd(arr[i], k);\\n            \\n            int y = k / x ;\\n            \\n            for(auto it : mp)\\n            {\\n                if(it.first % y == 0)\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n            \\n            mp[x]++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int gcd(int a, int b)\\n    {   \\n        if(b == 0)\\n            return a;\\n        \\n        return gcd(b, a % b);\\n    }\\n    \\n    long long countPairs(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x = gcd(arr[i], k);\\n            \\n            int y = k / x ;\\n            \\n            for(auto it : mp)\\n            {\\n                if(it.first % y == 0)\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n            \\n            mp[x]++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791434,
                "title": "faster-99-8-short-python",
                "content": "```\\nfrom math import gcd\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def countPairs(self, nums, k: int) -> int:\\n\\t\\t# count divisors of k in nums\\n        ct = defaultdict(int)\\n        for a in nums:\\n            ct[gcd(a, k)] += 1\\n        arr, m = list(ct.keys()), len(ct)\\n\\n        def count(d1, d2):\\n            if (d1 * d2) % k != 0: return 0\\n            if d1 != d2: return ct[d1] * ct[d2]\\n            return ct[d1] * (ct[d1] - 1) // 2\\n\\t\\t\\n\\t\\t# loop through pairs of divisors of k\\n        return sum(count(arr[i], arr[j]) for i in range(m) for j in range(i, m))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def countPairs(self, nums, k: int) -> int:\\n\\t\\t# count divisors of k in nums\\n        ct = defaultdict(int)\\n        for a in nums:\\n            ct[gcd(a, k)] += 1\\n        arr, m = list(ct.keys()), len(ct)\\n\\n        def count(d1, d2):\\n            if (d1 * d2) % k != 0: return 0\\n            if d1 != d2: return ct[d1] * ct[d2]\\n            return ct[d1] * (ct[d1] - 1) // 2\\n\\t\\t\\n\\t\\t# loop through pairs of divisors of k\\n        return sum(count(arr[i], arr[j]) for i in range(m) for j in range(i, m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790601,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextFac(int f, int ff) {\\n        return (f + ff - 1) / ff * ff;\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> fac(k + 1);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] %= k;\\n            int f = __gcd(k, nums[i]);\\n            ++fac[f];\\n        }\\n        long long sol = 0;\\n        for (int i = 1; i <= k; i++) {\\n            if (fac[i] > 0) {\\n                int op = k / i;\\n                int nxt = nextFac(i, op);\\n                if (i == nxt) {\\n                    sol += ((long long) fac[i] * (fac[i] - 1)) / 2;\\n                    nxt += op;\\n                }\\n                for (int j = nxt; j <= k; j += op) {\\n                    sol += (long long) fac[i] * fac[j];\\n                    \\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextFac(int f, int ff) {\\n        return (f + ff - 1) / ff * ff;\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> fac(k + 1);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] %= k;\\n            int f = __gcd(k, nums[i]);\\n            ++fac[f];\\n        }\\n        long long sol = 0;\\n        for (int i = 1; i <= k; i++) {\\n            if (fac[i] > 0) {\\n                int op = k / i;\\n                int nxt = nextFac(i, op);\\n                if (i == nxt) {\\n                    sol += ((long long) fac[i] * (fac[i] - 1)) / 2;\\n                    nxt += op;\\n                }\\n                for (int j = nxt; j <= k; j += op) {\\n                    sol += (long long) fac[i] * fac[j];\\n                    \\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790187,
                "title": "c-gcd-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k)\\n    {\\n         int len  = nums.size();\\n        map<int,int>mpp;\\n        long long int ans  = 0;\\n        for(int i=0;i<len;i++)\\n        {\\n            int num =  nums[i];\\n            int gcdd=  __gcd(num,k);\\n            int req = k/gcdd;\\n            for(auto mp : mpp)\\n            {\\n                if((mp.first) % req==0)\\n                {\\n                    ans = ans + mp.second;\\n                }\\n            }\\n             mpp[gcdd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k)\\n    {\\n         int len  = nums.size();\\n        map<int,int>mpp;\\n        long long int ans  = 0;\\n        for(int i=0;i<len;i++)\\n        {\\n            int num =  nums[i];\\n            int gcdd=  __gcd(num,k);\\n            int req = k/gcdd;\\n            for(auto mp : mpp)\\n            {\\n                if((mp.first) % req==0)\\n                {\\n                    ans = ans + mp.second;\\n                }\\n            }\\n             mpp[gcdd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790141,
                "title": "c-using-dictionary",
                "content": "\\n\\t\\tstatic int GCD(int a, int b)\\n        {\\n            return b == 0 ? a : GCD(b, a % b);\\n        }\\n\\t\\t\\n\\t\\tpublic long GetCount(int[] nums, int k)\\n        {\\n            List<int> GCDnum = new List<int>();\\n            Dictionary<int, int> count = new Dictionary<int, int>();\\n\\n            foreach (var num in nums)\\n            {\\n                GCDnum.Add(GCD(num, k));\\n            }\\n            count = GCDnum.GroupBy(x => x).Where(x => x.Any()).ToDictionary(x => x.Key, x => x.Count()); ;\\n            long solve = 0;\\n\\n            foreach (var i in count.Keys)\\n            {\\n                foreach (var j in count.Keys)\\n                {\\n                    if (i >= j && (long)i * j % k == 0)\\n                    {\\n                        solve += i == j ? (long)count[i] * (count[i] - 1) / 2 : (long)count[i] * count[j];\\n                    }\\n                }\\n            }\\n\\n            return solve;\\n        }",
                "solutionTags": [],
                "code": "\\n\\t\\tstatic int GCD(int a, int b)\\n        {\\n            return b == 0 ? a : GCD(b, a % b);\\n        }\\n\\t\\t\\n\\t\\tpublic long GetCount(int[] nums, int k)\\n        {\\n            List<int> GCDnum = new List<int>();\\n            Dictionary<int, int> count = new Dictionary<int, int>();\\n\\n            foreach (var num in nums)\\n            {\\n                GCDnum.Add(GCD(num, k));\\n            }\\n            count = GCDnum.GroupBy(x => x).Where(x => x.Any()).ToDictionary(x => x.Key, x => x.Count()); ;\\n            long solve = 0;\\n\\n            foreach (var i in count.Keys)\\n            {\\n                foreach (var j in count.Keys)\\n                {\\n                    if (i >= j && (long)i * j % k == 0)\\n                    {\\n                        solve += i == j ? (long)count[i] * (count[i] - 1) / 2 : (long)count[i] * count[j];\\n                    }\\n                }\\n            }\\n\\n            return solve;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1789614,
                "title": "python-binary-search-fast-than-100-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def binarySearch(self, target, arr):\\n        if len(arr) == 0:\\n            return 0\\n        if arr[-1] < target:\\n            return len(arr)\\n        if arr[0] > target:\\n            return 0\\n        i = 0\\n        j = len(arr) - 1\\n        while i < j:\\n            mid = (j - i)//2 + i\\n            if arr[mid] < target:\\n                i = mid + 1\\n            else:\\n                j = mid\\n        \\n        return i\\n    \\n    \\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        # find divisors of k:\\n        divisors = [k]\\n        for i in range(1, k//2+1):\\n            if k % i == 0:\\n                divisors.append(i)\\n        \\n        arr_dict = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            for candidate in divisors:\\n                if num % candidate == 0:\\n                    arr_dict[candidate].append(idx)\\n                    \\n        self.arr_dict = arr_dict\\n        \\n         \\n        count = 0\\n        for i in range(1, len(nums)):\\n            g = gcd(k, nums[i])\\n            \\n            divisible_count = self.binarySearch(i, self.arr_dict[k//g])\\n            count += divisible_count\\n            \\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def binarySearch(self, target, arr):\\n        if len(arr) == 0:\\n            return 0\\n        if arr[-1] < target:\\n            return len(arr)\\n        if arr[0] > target:\\n            return 0\\n        i = 0\\n        j = len(arr) - 1\\n        while i < j:\\n            mid = (j - i)//2 + i\\n            if arr[mid] < target:\\n                i = mid + 1\\n            else:\\n                j = mid\\n        \\n        return i\\n    \\n    \\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        # find divisors of k:\\n        divisors = [k]\\n        for i in range(1, k//2+1):\\n            if k % i == 0:\\n                divisors.append(i)\\n        \\n        arr_dict = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            for candidate in divisors:\\n                if num % candidate == 0:\\n                    arr_dict[candidate].append(idx)\\n                    \\n        self.arr_dict = arr_dict\\n        \\n         \\n        count = 0\\n        for i in range(1, len(nums)):\\n            g = gcd(k, nums[i])\\n            \\n            divisible_count = self.binarySearch(i, self.arr_dict[k//g])\\n            count += divisible_count\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789305,
                "title": "c-gcd-number-theory-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<long long, long long> mp;\\n        long long i,n=nums.size();\\n        long long ans=0;\\n        long long gcd1, gcd2;\\n        for(i=0;i<n;i++){\\n            gcd1= __gcd(nums[i], k);\\n            gcd2= k/gcd1;\\n            if(gcd2==1){\\n                ans+=i;\\n            }else{\\n                for(auto it:mp){\\n                    if(it.first%gcd2 ==0)\\n                        ans+=it.second;\\n                }\\n            }\\n            mp[gcd1]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<long long, long long> mp;\\n        long long i,n=nums.size();\\n        long long ans=0;\\n        long long gcd1, gcd2;\\n        for(i=0;i<n;i++){\\n            gcd1= __gcd(nums[i], k);\\n            gcd2= k/gcd1;\\n            if(gcd2==1){\\n                ans+=i;\\n            }else{\\n                for(auto it:mp){\\n                    if(it.first%gcd2 ==0)\\n                        ans+=it.second;\\n                }\\n            }\\n            mp[gcd1]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789078,
                "title": "python-use-gcds-o-nlogk-time",
                "content": "The number of factors of a number k is O(logk). So the time complexity is O(nlogk)\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            while a > 0:\\n                a, b = b%a,\\n            return b\\n        \\n        factors = {}\\n        i = 1\\n        while i*i <= k:\\n            if k%i == 0:\\n                factors[i] = 0\\n                factors[k//i] = 0\\n            i += 1\\n        res = 0\\n        for e in nums:\\n            gcd_e = gcd(e,k)\\n            for f in factors:\\n                if gcd_e * f % k == 0:\\n                    res += factors[f]\\n            factors[gcd_e] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            while a > 0:\\n                a, b = b%a,\\n            return b\\n        \\n        factors = {}\\n        i = 1\\n        while i*i <= k:\\n            if k%i == 0:\\n                factors[i] = 0\\n                factors[k//i] = 0\\n            i += 1\\n        res = 0\\n        for e in nums:\\n            gcd_e = gcd(e,k)\\n            for f in factors:\\n                if gcd_e * f % k == 0:\\n                    res += factors[f]\\n            factors[gcd_e] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788967,
                "title": "c-slow-but-easy-to-come-up-solution",
                "content": "```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long countPairs(vector<int>& a, int k) {\\n        vector<int> divisors;\\n        for(int i = 1; i <= k; ++i) {\\n            if(k%i==0) divisors.push_back(i);\\n        }\\n        map<int, int> m;\\n        map<int, vector<int>> t;\\n        for(auto it = divisors.begin(); it != divisors.end(); ++it) {\\n            int v = *it;\\n            for(auto it2 = divisors.begin(); it2 != it; ++it2) {\\n                int x = *it2;\\n                if(v%x==0) t[v].push_back(x);\\n            }\\n            t[v].push_back(v);\\n        }\\n        for(auto v : a) {\\n            int gcd = __gcd(v, k);\\n            for(auto x : t[gcd]) m[x]++;\\n        }\\n        ll ans = 0;\\n        for(auto v : a) {\\n            int gcd = __gcd(v, k);\\n            int rgcd = k/gcd;\\n            ans += m[rgcd]-(gcd%rgcd==0);\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long countPairs(vector<int>& a, int k) {\\n        vector<int> divisors;\\n        for(int i = 1; i <= k; ++i) {\\n            if(k%i==0) divisors.push_back(i);\\n        }\\n        map<int, int> m;\\n        map<int, vector<int>> t;\\n        for(auto it = divisors.begin(); it != divisors.end(); ++it) {\\n            int v = *it;\\n            for(auto it2 = divisors.begin(); it2 != it; ++it2) {\\n                int x = *it2;\\n                if(v%x==0) t[v].push_back(x);\\n            }\\n            t[v].push_back(v);\\n        }\\n        for(auto v : a) {\\n            int gcd = __gcd(v, k);\\n            for(auto x : t[gcd]) m[x]++;\\n        }\\n        ll ans = 0;\\n        for(auto v : a) {\\n            int gcd = __gcd(v, k);\\n            int rgcd = k/gcd;\\n            ans += m[rgcd]-(gcd%rgcd==0);\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788862,
                "title": "runtime-312-ms-faster-than-100-00-of-c-online-submissions-for-count-array-pairs-divisible-by-k",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x = __gcd(k,nums[i]);\\n            int gcd = k/x;\\n            for(auto it:mp)\\n            {\\n                if(it.first % gcd == 0)\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x = __gcd(k,nums[i]);\\n            int gcd = k/x;\\n            for(auto it:mp)\\n            {\\n                if(it.first % gcd == 0)\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788458,
                "title": "c-count-array-pairs-divisble-by-k-fast",
                "content": "```\\nclass Solution {\\npublic:\\n  long long countPairs(vector<int>& nums, int k) {\\n\\n    // get all the divisors for k\\n    \\n    std::vector<int> divisors;\\n    divisors.reserve(k);\\n    \\n    for (auto i = 1; i <= k; ++i)\\n      if (k % i == 0)\\n        divisors.push_back(i);\\n    \\n    std::unordered_map<int, int> divisibles;\\n    //                 ---  ---\\n    //               divisor count\\n    \\n    long long count = 0;\\n    \\n    for (auto i = 0; i != nums.size(); ++i)\\n    {\\n      int g = std::gcd(nums[i], k);\\n      \\n      int target = k/g;\\n      \\n      count += divisibles[target];\\n      \\n      \\n      for (auto &divisor: divisors)\\n        if (nums[i] % divisor == 0)\\n          divisibles[divisor] ++;\\n    }\\n    \\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  long long countPairs(vector<int>& nums, int k) {\\n\\n    // get all the divisors for k\\n    \\n    std::vector<int> divisors;\\n    divisors.reserve(k);\\n    \\n    for (auto i = 1; i <= k; ++i)\\n      if (k % i == 0)\\n        divisors.push_back(i);\\n    \\n    std::unordered_map<int, int> divisibles;\\n    //                 ---  ---\\n    //               divisor count\\n    \\n    long long count = 0;\\n    \\n    for (auto i = 0; i != nums.size(); ++i)\\n    {\\n      int g = std::gcd(nums[i], k);\\n      \\n      int target = k/g;\\n      \\n      count += divisibles[target];\\n      \\n      \\n      for (auto &divisor: divisors)\\n        if (nums[i] % divisor == 0)\\n          divisibles[divisor] ++;\\n    }\\n    \\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787998,
                "title": "c-2183-count-array-pairs-divisible-by-k",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<int> factors; \\n        for (int x = 1; x <= sqrt(k); ++x) \\n            if (k % x == 0) factors.push_back(x); \\n        long long ans = 0; \\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) {\\n            x = gcd(x, k); \\n            ans += freq[k/x]; \\n            for (auto& f : factors) \\n                if (x % f == 0 && f <= x/f) {\\n                    ++freq[f]; \\n                    if (f < x/f) ++freq[x/f]; \\n                }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        vector<int> factors; \\n        for (int x = 1; x <= sqrt(k); ++x) \\n            if (k % x == 0) factors.push_back(x); \\n        long long ans = 0; \\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) {\\n            x = gcd(x, k); \\n            ans += freq[k/x]; \\n            for (auto& f : factors) \\n                if (x % f == 0 && f <= x/f) {\\n                    ++freq[f]; \\n                    if (f < x/f) ++freq[x/f]; \\n                }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787718,
                "title": "2183-count-array-pairs-divisible-by-k",
                "content": "class Solution {\\n    public long countPairs(int[] nums, int k) {\\n         Map<Integer,Integer> map=new HashMap();\\n        long count=0;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          int gcd1=findgcd(nums[i],k);\\n            for(int gcd2:map.keySet())\\n            {\\n                if(gcd2*gcd1%k==0)\\n                {\\n                    count+=map.get(gcd2);\\n                }\\n            }\\n            map.put(gcd1,map.getOrDefault(gcd1,0)+1);\\n            \\n        }\\n        return count;\\n        \\n    }\\n    int findgcd(int x,int y)\\n    {\\n        while(x%y!=0)\\n        {\\n            int rem=x%y;\\n            x=y;\\n            y=rem;;\\n        }\\n        return y;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long countPairs(int[] nums, int k) {\\n         Map<Integer,Integer> map=new HashMap();\\n        long count=0;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          int gcd1=findgcd(nums[i],k);\\n            for(int gcd2:map.keySet())\\n            {\\n                if(gcd2*gcd1%k==0)\\n                {\\n                    count+=map.get(gcd2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1787000,
                "title": "my-java-solution-by-counting-gcd",
                "content": "```\\n// if n1 * n2 % k == 0, then gcd(n1, k) * gcd(n2, k) % k == 0.\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        GCD gcd = new GCD();\\n        long pairCount = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int number : nums) {\\n            int currentGCD = gcd.findGCD(number, k);\\n            for (int num : map.keySet()) {\\n                if ((long)currentGCD * num % k == 0) {\\n                    pairCount += map.get(num);\\n                }\\n            }\\n            map.put(currentGCD, map.getOrDefault(currentGCD, 0) + 1);\\n        }\\n        return pairCount;\\n    }\\n}\\n\\nclass GCD {\\n    public int findGCD(int n1, int n2) {\\n        if (n2 == 0) {\\n            return n1;\\n        }\\n        return findGCD(n2, n1 % n2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n// if n1 * n2 % k == 0, then gcd(n1, k) * gcd(n2, k) % k == 0.\\nclass Solution {\\n    public long countPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        GCD gcd = new GCD();\\n        long pairCount = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int number : nums) {\\n            int currentGCD = gcd.findGCD(number, k);\\n            for (int num : map.keySet()) {\\n                if ((long)currentGCD * num % k == 0) {\\n                    pairCount += map.get(num);\\n                }\\n            }\\n            map.put(currentGCD, map.getOrDefault(currentGCD, 0) + 1);\\n        }\\n        return pairCount;\\n    }\\n}\\n\\nclass GCD {\\n    public int findGCD(int n1, int n2) {\\n        if (n2 == 0) {\\n            return n1;\\n        }\\n        return findGCD(n2, n1 % n2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786723,
                "title": "python-3-100-time-gcds-hash-table",
                "content": "![image](https://assets.leetcode.com/users/images/d600dfc8-7e55-4100-adfb-8c958422af1d_1645371971.7513654.png)\\n\\nCode is a bit lengthy, by counting occurrence of GCDs. \\n\\nPre-processing:\\n\\nCalculate each number\\'s GCD with k, and count for each gcd how many numbers we have. \\n\\nAt the same time, calculate target = k // GCD, which is the **minimum** pair value we are looking for. Use a hash table of target to list all distinct GCDs that await to pair with target. \\n\\nCalculation:\\n\\nFor each target in the hash table, we need to check whether [target, 2 * target, 3 * target ..., k) are in the GCD counter, since if a particular v * target % k == 0, v * n * target % k == 0 too. I had GCD == k excluded and handled separately.\\n\\n\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ct_g = defaultdict(int)\\n        dc_t = defaultdict(set)\\n        \\n        for v in nums:\\n            g = gcd(v, k)\\n            if g == k: # k can be 1, so check g == k ahead of g == 1\\n                ct_g[k] += 1\\n            elif g == 1:\\n                pass # co-primes that can only pair with k-multiples\\n            else:\\n                ct_g[g] += 1 # increase current gcd count\\n                t = k // g # minimum target gcd that can pair with the current\\n                dc_t[t].add(g) # enlist current gcd under target\\n        \\n        ans = 0\\n        if ct_g[k] > 0: # k-multiples\\n            nk = ct_g[k]\\n            ct_g.pop(k)\\n            ans += (n - nk) * nk + comb(nk, 2)\\n        \\n        visited = set()\\n        for t in dc_t: \\n            for g in dc_t[t]:\\n                ng = ct_g[g] # fetch gcd counts that need to pair with t\\n                for tt in range(t, k, t): # check the presence of gcds t, 2*t, 3*t ... < k \\n                    if tt in ct_g and (g, tt) not in visited:\\n                        visited.add((g, tt)) # mark visited\\n                        visited.add((tt, g))\\n                        if tt != g:\\n                            ans += ng * ct_g[tt]\\n                        else:\\n                            ans += comb(ng, 2) # in case t == g == sqrt(k)\\n        return ans\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ct_g = defaultdict(int)\\n        dc_t = defaultdict(set)\\n        \\n        for v in nums:\\n            g = gcd(v, k)\\n            if g == k: # k can be 1, so check g == k ahead of g == 1\\n                ct_g[k] += 1\\n            elif g == 1:\\n                pass # co-primes that can only pair with k-multiples\\n            else:\\n                ct_g[g] += 1 # increase current gcd count\\n                t = k // g # minimum target gcd that can pair with the current\\n                dc_t[t].add(g) # enlist current gcd under target\\n        \\n        ans = 0\\n        if ct_g[k] > 0: # k-multiples\\n            nk = ct_g[k]\\n            ct_g.pop(k)\\n            ans += (n - nk) * nk + comb(nk, 2)\\n        \\n        visited = set()\\n        for t in dc_t: \\n            for g in dc_t[t]:\\n                ng = ct_g[g] # fetch gcd counts that need to pair with t\\n                for tt in range(t, k, t): # check the presence of gcds t, 2*t, 3*t ... < k \\n                    if tt in ct_g and (g, tt) not in visited:\\n                        visited.add((g, tt)) # mark visited\\n                        visited.add((tt, g))\\n                        if tt != g:\\n                            ans += ng * ct_g[tt]\\n                        else:\\n                            ans += comb(ng, 2) # in case t == g == sqrt(k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786611,
                "title": "python-3-counter-and-prime-factorization",
                "content": "* First prime factorization of K\\n* Keep track of number itself could be divisible by K\\n* Convert each number into a product of all primes included e.g., K = 20 (2 * 2 * 5), 70 will be converted into 10 (2 * 5)\\n* Either choose two from the same group or couple with the other group\\n\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        # prime factorization of k\\n        def prime_factors(k):\\n            i = 2\\n            out = []\\n            while pow(i, 2) <= k:\\n                if k % i:\\n                    i += 1\\n                else:\\n                    k //= i\\n                    out.append(i)\\n            if k > 1:\\n                out.append(k)\\n            return out\\n\\n        pf = sorted(prime_factors(k))\\n\\n        # cumulative product of primes included in each num\\n        def helper(x):\\n            mask = 1\\n            for f in pf:\\n                if x < f: break\\n                if not x % f:\\n                    mask *= f\\n                    x //= f\\n            return mask\\n        \\n        # num itself could be divisible  by k or num containing part of primes of k\\n        cnt = Counter(nums)\\n        cnt_factor = defaultdict(int)\\n        zero_factor = 0\\n        for x in cnt:\\n            if x % k == 0:\\n                zero_factor += cnt[x]\\n            else:\\n                cnt_factor[helper(x)] += cnt[x]\\n        \\n        # either choose two from same group or combine with the other group\\n        ans = math.comb(zero_factor, 2) + zero_factor * (len(nums) - zero_factor)\\n        non_zero_factor = list(cnt_factor.keys())\\n        for i in range(len(non_zero_factor)):\\n            a = non_zero_factor[i]\\n            if a * a >= k and not (a * a) % k: ans += math.comb(cnt_factor[a], 2)\\n            for j in range(i):\\n                b = non_zero_factor[j]\\n                if a * b >= k and not (a * b) % k:\\n                    ans += cnt_factor[a] * cnt_factor[b]\\n\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "* First prime factorization of K\\n* Keep track of number itself could be divisible by K\\n* Convert each number into a product of all primes included e.g., K = 20 (2 * 2 * 5), 70 will be converted into 10 (2 * 5)\\n* Either choose two from the same group or couple with the other group\\n\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        # prime factorization of k\\n        def prime_factors(k):\\n            i = 2\\n            out = []\\n            while pow(i, 2) <= k:\\n                if k % i:\\n                    i += 1\\n                else:\\n                    k //= i\\n                    out.append(i)\\n            if k > 1:\\n                out.append(k)\\n            return out\\n\\n        pf = sorted(prime_factors(k))\\n\\n        # cumulative product of primes included in each num\\n        def helper(x):\\n            mask = 1\\n            for f in pf:\\n                if x < f: break\\n                if not x % f:\\n                    mask *= f\\n                    x //= f\\n            return mask\\n        \\n        # num itself could be divisible  by k or num containing part of primes of k\\n        cnt = Counter(nums)\\n        cnt_factor = defaultdict(int)\\n        zero_factor = 0\\n        for x in cnt:\\n            if x % k == 0:\\n                zero_factor += cnt[x]\\n            else:\\n                cnt_factor[helper(x)] += cnt[x]\\n        \\n        # either choose two from same group or combine with the other group\\n        ans = math.comb(zero_factor, 2) + zero_factor * (len(nums) - zero_factor)\\n        non_zero_factor = list(cnt_factor.keys())\\n        for i in range(len(non_zero_factor)):\\n            a = non_zero_factor[i]\\n            if a * a >= k and not (a * a) % k: ans += math.comb(cnt_factor[a], 2)\\n            for j in range(i):\\n                b = non_zero_factor[j]\\n                if a * b >= k and not (a * b) % k:\\n                    ans += cnt_factor[a] * cnt_factor[b]\\n\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1786561,
                "title": "c-solution-using-hashmap-in-o-n-sqrt-k",
                "content": "```\\n void factors_of_k(int k,vector<int>&v)\\n    {\\n      for(int i=1;i*i<=k;i++)\\n      {\\n        if(k%i==0)\\n        v.push_back(i);\\n        if(k/i!=i and k%i==0)\\n        v.push_back(k/i);\\n      }\\n    }\\n    \\n    void count_pairs(vector<int>nums,int k,vector<int>v,long long int &ans)\\n    {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          ans+=m[k/__gcd(nums[i],k)];\\n          for(auto j:v)\\n          {\\n            if(nums[i]%j==0)\\n            m[j]++;\\n          }\\n        }\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n      long long int ans=0;\\n      vector<int>v;\\n      factors_of_k(k,v);\\n      \\n      count_pairs(nums,k,v,ans);\\n      return ans;\\n      \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n void factors_of_k(int k,vector<int>&v)\\n    {\\n      for(int i=1;i*i<=k;i++)\\n      {\\n        if(k%i==0)\\n        v.push_back(i);\\n        if(k/i!=i and k%i==0)\\n        v.push_back(k/i);\\n      }\\n    }\\n    \\n    void count_pairs(vector<int>nums,int k,vector<int>v,long long int &ans)\\n    {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          ans+=m[k/__gcd(nums[i],k)];\\n          for(auto j:v)\\n          {\\n            if(nums[i]%j==0)\\n            m[j]++;\\n          }\\n        }\\n    }\\n    long long countPairs(vector<int>& nums, int k) {\\n      long long int ans=0;\\n      vector<int>v;\\n      factors_of_k(k,v);\\n      \\n      count_pairs(nums,k,v,ans);\\n      return ans;\\n      \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786454,
                "title": "using-gcd-and-basic-counting-principle-o-max-n-k",
                "content": "### Using GCD and Basic counting principle\\nGCD Theorem: if c | a * b then c | gcd(a,c) * gcd(b,c)\\nUsing above idea, create a dictionary thats key is gcd(num, k) and value is number of appereances of value `gcd(num, k)`. Then count all possible different a,b such that k | a * b. \\nRuntime Complexity: O(max(N, K)) because for large K, number of divisors of K is less than sqrt(K)(you can prove it using basic induction)\\n```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def gcd(num, k):\\n            while num != 0 and k != 0:\\n                if num > k:\\n                    num = num % k\\n                else:\\n                    k = k % num\\n            return max(num, k)\\n        divisors = {}\\n        for num in nums:\\n            divisor = gcd(num, k)\\n            divisors[divisor] = divisors.get(divisor, 0) + 1\\n        res = 0\\n        divs = []\\n\\t\\t# 1. count possible multiplication of two same divisors\\n        for divisor, count in divisors.items():\\n            divs.append(divisor)\\n            if count > 1 and (divisor * divisor) % k == 0:\\n                res += count * (count - 1) / 2\\n        # 2. count possible multiplication of two different divisors\\n        for i in range(len(divs)):\\n            count = 0\\n            for j in range(i + 1, len(divs)):\\n                if (divs[i] * divs[j]) % k == 0:\\n                    count += divisors[divs[j]]\\n            res += divisors[divs[i]] * count\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def gcd(num, k):\\n            while num != 0 and k != 0:\\n                if num > k:\\n                    num = num % k\\n                else:\\n                    k = k % num\\n            return max(num, k)\\n        divisors = {}\\n        for num in nums:\\n            divisor = gcd(num, k)\\n            divisors[divisor] = divisors.get(divisor, 0) + 1\\n        res = 0\\n        divs = []\\n\\t\\t# 1. count possible multiplication of two same divisors\\n        for divisor, count in divisors.items():\\n            divs.append(divisor)\\n            if count > 1 and (divisor * divisor) % k == 0:\\n                res += count * (count - 1) / 2\\n        # 2. count possible multiplication of two different divisors\\n        for i in range(len(divs)):\\n            count = 0\\n            for j in range(i + 1, len(divs)):\\n                if (divs[i] * divs[j]) % k == 0:\\n                    count += divisors[divs[j]]\\n            res += divisors[divs[i]] * count\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786439,
                "title": "gcd-solution-beat-100-python3",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dp=[]\\n        for i in range(2,k+1):\\n            if k%i==0:\\n                dp.append(i)\\n        dp1=[0]*len(nums)\\n        for i,num in enumerate(nums):\\n            dp1[i]=gcd(num,k)\\n        c = Counter(dp1)\\n        n=len(dp)\\n        ans=0\\n        for i in range(n):\\n            for j in range(i,n-1):\\n                if dp[i]*dp[j]%k==0:\\n                    if i==j:\\n                        if c[dp[i]]>1:\\n                            ans+=c[dp[i]]*(c[dp[j]]-1)//2\\n                    else:\\n                        ans+=c[dp[i]]*c[dp[j]]\\n                    \\n        ans+=(len(nums)-c[k])*c[k] + max(0,c[k]*(c[k]-1)//2)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dp=[]\\n        for i in range(2,k+1):\\n            if k%i==0:\\n                dp.append(i)\\n        dp1=[0]*len(nums)\\n        for i,num in enumerate(nums):\\n            dp1[i]=gcd(num,k)\\n        c = Counter(dp1)\\n        n=len(dp)\\n        ans=0\\n        for i in range(n):\\n            for j in range(i,n-1):\\n                if dp[i]*dp[j]%k==0:\\n                    if i==j:\\n                        if c[dp[i]]>1:\\n                            ans+=c[dp[i]]*(c[dp[j]]-1)//2\\n                    else:\\n                        ans+=c[dp[i]]*c[dp[j]]\\n                    \\n        ans+=(len(nums)-c[k])*c[k] + max(0,c[k]*(c[k]-1)//2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786384,
                "title": "python-aggregate-numbers-to-decrease-complexity-faster-than-100",
                "content": "The main idea is that transfer each number n into gcd(n, k), and aggregate the same numbers. Since there are at most hundreds of k\\'s factors, we only need O(number of k\\'s factors ^ 2) to check all numbers.\\n```\\ndef gcd(a, b):\\n    r = a % b\\n    if r == 0:\\n        return b\\n    return gcd(b, r)\\n\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = Counter()\\n        for i in range(len(nums)):\\n            d[gcd(nums[i], k)] += 1\\n        arr = []\\n        for key in sorted(d.keys()):\\n            arr.append([key, d[key]])\\n        ans = 0\\n        for i in range(len(arr)):\\n            n = arr[i][0]\\n            nc = arr[i][1]\\n            if n * n % k == 0:\\n                ans += (nc * (nc-1) // 2)\\n            m = k // n\\n            for j in range(len(arr)-1, i, -1):\\n                if arr[j][0] < m:\\n                    break\\n                if n * arr[j][0] % k == 0:\\n                    ans += (nc * arr[j][1])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef gcd(a, b):\\n    r = a % b\\n    if r == 0:\\n        return b\\n    return gcd(b, r)\\n\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d = Counter()\\n        for i in range(len(nums)):\\n            d[gcd(nums[i], k)] += 1\\n        arr = []\\n        for key in sorted(d.keys()):\\n            arr.append([key, d[key]])\\n        ans = 0\\n        for i in range(len(arr)):\\n            n = arr[i][0]\\n            nc = arr[i][1]\\n            if n * n % k == 0:\\n                ans += (nc * (nc-1) // 2)\\n            m = k // n\\n            for j in range(len(arr)-1, i, -1):\\n                if arr[j][0] < m:\\n                    break\\n                if n * arr[j][0] % k == 0:\\n                    ans += (nc * arr[j][1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786195,
                "title": "short-concise-self-explainatory-easiest-solution",
                "content": "class Solution {\\npublic:\\n\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int, long long> map;\\n        long long res = 0;\\n        for(auto i = 0; i < nums.size(); i++){\\n            auto x = nums[i];\\n            long long gcd = __gcd(x, k);\\n            if(x%k){\\n                for(auto &it : map){\\n                    if(it.first * gcd % k == 0){\\n                        res += it.second;\\n                    }\\n                }\\n            }else{\\n                res += i;\\n            }\\n            map[gcd]++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int, long long> map;\\n        long long res = 0;\\n        for(auto i = 0; i < nums.size(); i++){\\n            auto x = nums[i];\\n            long long gcd = __gcd(x, k);\\n            if(x%k){\\n                for(auto &it : map){\\n                    if(it.first * gcd % k == 0){\\n                        res += it.second;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1785915,
                "title": "c-intuitive-solution-sieve-o-maximuma-log-maximuma-solution",
                "content": "What we want is to have two numbers such that product becomes divisible by `k`.\\n\\nWe can look at it in another way. Consider the element `arr[i]`. For this element, we need to find other elements such their product with `arr[i]` becomes divisible by `k`.\\n\\nLet\\'s try to simplify it further. We can take `gcd` of `arr[i]` and `k` and divide both of them by their `gcd`. Let\\'s say reduced k as `required` (you will soon understand why am I naming it as required). After doing this, we can say that **`gcd(arr[i], required) = 1`** or in other words they are **co-prime** to each other.\\n\\nNow let\\'s look at the equation once again (considering `arr[i]` and `required` are in the reduced form):\\n\\n`arr[i] * arr[j] = m * required` \\n\\nSince, `arr[i]` and `required` are co-prime, `arr[j]` has to make the remaining contribution to `required` in `m * required`. \\n\\nSo now we have to count the elements which are divisible by `required`.\\n\\nThis is now a very standard problem. \\n1. With the help of sieve, we can get the count of numbers divisible by an element. \\n2. Then we will iterate over all the **unique** elements of nums and count the number of required elements.\\n\\nFeel free to ask if anything is unclear.\\n\\nHere\\'s the solution (`fr[i]` reresent the count of numbers divisible by `i` and `f[i]` represent the frequency of the number `i`)\\n\\n```\\nclass Solution {\\n    static const int maxN = 100005;\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        long long cnt = 0;\\n        vector<int> fr(100005);\\n        for(int i=0;i<n;i++){\\n            fr[nums[i]]++;\\n        }\\n        auto f = fr;\\n        for(int i=1;i<=100000;i++) {\\n            for(int j=2*i;j<=100000;j+=i) {\\n                fr[i] += fr[j];\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(const int & i : nums) {\\n            int g = __gcd(k, i);\\n            int req = k/g;\\n            if(i%req != 0) {\\n                cnt += (fr[req])*1LL*f[i];\\n            } \\n            else {\\n                cnt += (fr[req]-f[i])*1LL*f[i];\\n                cnt += f[i] *1LL* (f[i]-1);\\n            }\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    static const int maxN = 100005;\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        long long cnt = 0;\\n        vector<int> fr(100005);\\n        for(int i=0;i<n;i++){\\n            fr[nums[i]]++;\\n        }\\n        auto f = fr;\\n        for(int i=1;i<=100000;i++) {\\n            for(int j=2*i;j<=100000;j+=i) {\\n                fr[i] += fr[j];\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(const int & i : nums) {\\n            int g = __gcd(k, i);\\n            int req = k/g;\\n            if(i%req != 0) {\\n                cnt += (fr[req])*1LL*f[i];\\n            } \\n            else {\\n                cnt += (fr[req]-f[i])*1LL*f[i];\\n                cnt += f[i] *1LL* (f[i]-1);\\n            }\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785670,
                "title": "using-gcd-hint-faster-than-100",
                "content": "```\\nclass Solution:\\n  def countPairs(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    tot = 0\\n    all_gcds = []\\n    gcd_freq = defaultdict(lambda: 0)\\n    for num in nums:\\n      g = gcd(num, k)\\n      all_gcds.append(g)\\n      gcd_freq[g] += 1\\n    # len(all_gcds) = O(sqrt(k))  \\n    all_gcds = list(set(all_gcds))\\n    # O(len(all_gcds) ^ 2) = O(k)\\n    for i in range(len(all_gcds)):\\n      g_i = all_gcds[i] # gcd at index i\\n      f_i = gcd_freq[g_i] # frequency of gcd i\\n      if g_i * g_i % k == 0:\\n        tot += (f_i * (f_i - 1)) // 2\\n      for j in range(i + 1, len(all_gcds)):\\n        g_j = all_gcds[j] # gcd at index j\\n        f_j = gcd_freq[g_j] # frequency of gcd j\\n        if g_i * g_j % k == 0:\\n          tot += (f_i * f_j)\\n    return tot\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def countPairs(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    tot = 0\\n    all_gcds = []\\n    gcd_freq = defaultdict(lambda: 0)\\n    for num in nums:\\n      g = gcd(num, k)\\n      all_gcds.append(g)\\n      gcd_freq[g] += 1\\n    # len(all_gcds) = O(sqrt(k))  \\n    all_gcds = list(set(all_gcds))\\n    # O(len(all_gcds) ^ 2) = O(k)\\n    for i in range(len(all_gcds)):\\n      g_i = all_gcds[i] # gcd at index i\\n      f_i = gcd_freq[g_i] # frequency of gcd i\\n      if g_i * g_i % k == 0:\\n        tot += (f_i * (f_i - 1)) // 2\\n      for j in range(i + 1, len(all_gcds)):\\n        g_j = all_gcds[j] # gcd at index j\\n        f_j = gcd_freq[g_j] # frequency of gcd j\\n        if g_i * g_j % k == 0:\\n          tot += (f_i * f_j)\\n    return tot\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785666,
                "title": "cpp-gcd-upsolved-after-contest-little-mistake-during-contest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long int ans=0;\\n        int n=nums.size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_map<int,int> gc;\\n        for(int i=0;i<n;i++){\\n            if(gc.find(nums[i])==gc.end()){\\n                int g=gcd(nums[i],k);\\n                 gc[nums[i]]=g;\\n            }\\n            int g=gc[nums[i]];\\n            if(g!=1){\\n                mp[g].push_back(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                ans+=(n-i-1);\\n            }else{\\n                cout<<\"FOR \"<<nums[i]<<\" \";\\n                int g=gc[nums[i]];\\n                \\n                for(int s=1;s*s<=g;s++){\\n                    if(g%s==0){\\n                        int f=k/s;\\n                        auto &arr=mp[f];\\n                        int kk=lower_bound(arr.begin(),arr.end(),i+1)-arr.begin();\\n                        ans+=(arr.size()-kk);\\n                        if(s*s!=g){\\n                            int ss=g/s;\\n                            int f=k/ss;\\n                            auto &arr=mp[f];\\n                            int kk=lower_bound(arr.begin(),arr.end(),i+1)-arr.begin();\\n                            ans+=(arr.size()-kk);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n            cout<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        long long int ans=0;\\n        int n=nums.size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_map<int,int> gc;\\n        for(int i=0;i<n;i++){\\n            if(gc.find(nums[i])==gc.end()){\\n                int g=gcd(nums[i],k);\\n                 gc[nums[i]]=g;\\n            }\\n            int g=gc[nums[i]];\\n            if(g!=1){\\n                mp[g].push_back(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                ans+=(n-i-1);\\n            }else{\\n                cout<<\"FOR \"<<nums[i]<<\" \";\\n                int g=gc[nums[i]];\\n                \\n                for(int s=1;s*s<=g;s++){\\n                    if(g%s==0){\\n                        int f=k/s;\\n                        auto &arr=mp[f];\\n                        int kk=lower_bound(arr.begin(),arr.end(),i+1)-arr.begin();\\n                        ans+=(arr.size()-kk);\\n                        if(s*s!=g){\\n                            int ss=g/s;\\n                            int f=k/ss;\\n                            auto &arr=mp[f];\\n                            int kk=lower_bound(arr.begin(),arr.end(),i+1)-arr.begin();\\n                            ans+=(arr.size()-kk);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n            cout<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785508,
                "title": "elegant-solution-with-easy-code-iterate-over-multiples-of-each-modulo-class-complement",
                "content": "The main idea is to look at the integers (mod K) and iterate over multiples of each modulo class\\'s complement. \\n\\nFull explanation [here ](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20281)\\n\\n```\\nclass Solution {\\npublic:\\n    long long choose_2(long long n)\\n    {\\n        return n*(n - 1)/2;\\n    }\\n    \\n    void factorise(vector <int> &F, vector <int> &E, int n)\\n    {\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if(n%i == 0)\\n            {\\n                int exponent = 0;\\n                \\n                while(n%i == 0)\\n                {\\n                    n /= i;\\n                    exponent++;\\n                } \\n                \\n                F.push_back(i);\\n                E.push_back(exponent);\\n            }\\n        }\\n        \\n        if(n > 1)\\n        {\\n            F.push_back(n);\\n            E.push_back(1);\\n        }\\n    }\\n    \\n    int get_complement(int n, vector <int> &F, vector <int> &E)\\n    {\\n        int complement = 1;\\n        for(int i = 0; i < F.size(); i++)\\n        {\\n            int f = F[i];\\n            \\n            int exponent_n = 0;\\n            while(n%f == 0)\\n            {\\n                n /= f;\\n                exponent_n++;\\n            }\\n            \\n            while(exponent_n < E[i])\\n            {\\n                complement *= f; \\n                exponent_n++;\\n            }\\n            \\n        }\\n        \\n        return complement;\\n    }\\n    \\n    long long countPairs(vector<int>& A, int k) \\n    {\\n        vector <int> factors, exponent; \\n        factorise(factors, exponent, k);\\n        \\n        vector <long long> frequency(k, 0);\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            frequency[A[i]%k]++;\\n        }\\n        \\n        long long answer = 0;\\n        for(int m = 0; m < k; m++)\\n        {\\n            if(m == 0)\\n            {\\n                long long non_zero = A.size() - frequency[m];\\n                answer += choose_2(frequency[m]) + frequency[m]*non_zero;\\n                continue;\\n            }\\n            \\n            int complement = get_complement(m, factors, exponent);\\n            for(int i = 1; i*complement < k; i++)\\n            {\\n                int complement_multiple = i*complement;   \\n                if(complement_multiple > m)\\n                {\\n                    answer += frequency[m]*frequency[complement_multiple]; \\n                }\\n                else if(i*complement == m)\\n                {\\n                     answer += choose_2(frequency[complement_multiple]);\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long choose_2(long long n)\\n    {\\n        return n*(n - 1)/2;\\n    }\\n    \\n    void factorise(vector <int> &F, vector <int> &E, int n)\\n    {\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if(n%i == 0)\\n            {\\n                int exponent = 0;\\n                \\n                while(n%i == 0)\\n                {\\n                    n /= i;\\n                    exponent++;\\n                } \\n                \\n                F.push_back(i);\\n                E.push_back(exponent);\\n            }\\n        }\\n        \\n        if(n > 1)\\n        {\\n            F.push_back(n);\\n            E.push_back(1);\\n        }\\n    }\\n    \\n    int get_complement(int n, vector <int> &F, vector <int> &E)\\n    {\\n        int complement = 1;\\n        for(int i = 0; i < F.size(); i++)\\n        {\\n            int f = F[i];\\n            \\n            int exponent_n = 0;\\n            while(n%f == 0)\\n            {\\n                n /= f;\\n                exponent_n++;\\n            }\\n            \\n            while(exponent_n < E[i])\\n            {\\n                complement *= f; \\n                exponent_n++;\\n            }\\n            \\n        }\\n        \\n        return complement;\\n    }\\n    \\n    long long countPairs(vector<int>& A, int k) \\n    {\\n        vector <int> factors, exponent; \\n        factorise(factors, exponent, k);\\n        \\n        vector <long long> frequency(k, 0);\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            frequency[A[i]%k]++;\\n        }\\n        \\n        long long answer = 0;\\n        for(int m = 0; m < k; m++)\\n        {\\n            if(m == 0)\\n            {\\n                long long non_zero = A.size() - frequency[m];\\n                answer += choose_2(frequency[m]) + frequency[m]*non_zero;\\n                continue;\\n            }\\n            \\n            int complement = get_complement(m, factors, exponent);\\n            for(int i = 1; i*complement < k; i++)\\n            {\\n                int complement_multiple = i*complement;   \\n                if(complement_multiple > m)\\n                {\\n                    answer += frequency[m]*frequency[complement_multiple]; \\n                }\\n                else if(i*complement == m)\\n                {\\n                     answer += choose_2(frequency[complement_multiple]);\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785474,
                "title": "c-10-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,long long> mp;\\n        long long ans=0;\\n        for(auto n:nums){\\n            int gcd=__gcd(n,k);\\n            int req=k/gcd;\\n            for(auto it:mp)\\n                if(it.first%req==0)\\n                    ans+=it.second;\\n            mp[gcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,long long> mp;\\n        long long ans=0;\\n        for(auto n:nums){\\n            int gcd=__gcd(n,k);\\n            int req=k/gcd;\\n            for(auto it:mp)\\n                if(it.first%req==0)\\n                    ans+=it.second;\\n            mp[gcd]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785399,
                "title": "why-is-my-solution-10-times-faster-than-most-voted-solution-time-complexity-is-similar",
                "content": "```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long res = 0;\\n        Map<Integer, Integer> gcdCounts = new HashMap<>();\\n        for(int num: nums) {\\n            int gcd = getGCD(num, k);\\n            gcdCounts.put(gcd, gcdCounts.getOrDefault(gcd, 0) + 1);\\n        }\\n\\n        List<Integer> gcds = new ArrayList<>(gcdCounts.keySet());      \\n        Collections.sort(gcds, Collections.reverseOrder());\\n    \\n        for(int i = 0; i < gcds.size() && gcds.get(i) >= k / gcds.get(i); ++i) {\\n            int gcd = gcds.get(i);\\n            long count = gcdCounts.get(gcd);\\n            int remainder = k/gcd;\\n            long pairCount = 0;\\n\\n            // pair num that has different gcd\\n            if (gcd == k) {   \\n                pairCount = nums.length - count; \\n            } else if (gcd != remainder) {                 \\n                for(int j = i+1; j < gcds.size() && gcds.get(j) >= remainder; ++j) {\\n                    int divisor = gcds.get(j);\\n                    if (divisor % remainder == 0) {\\n                        pairCount += gcdCounts.get(divisor);\\n                    }\\n                }\\n            }\\n            res += count * pairCount;\\n            \\n            // pair num that has same gcd\\n            if (gcd % remainder == 0) {   \\n                res += count * (count - 1) /2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int getGCD(int n1, int n2) {\\n        if (n2 == 0) return n1;\\n        return getGCD(n2, n1 % n2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long res = 0;\\n        Map<Integer, Integer> gcdCounts = new HashMap<>();\\n        for(int num: nums) {\\n            int gcd = getGCD(num, k);\\n            gcdCounts.put(gcd, gcdCounts.getOrDefault(gcd, 0) + 1);\\n        }\\n\\n        List<Integer> gcds = new ArrayList<>(gcdCounts.keySet());      \\n        Collections.sort(gcds, Collections.reverseOrder());\\n    \\n        for(int i = 0; i < gcds.size() && gcds.get(i) >= k / gcds.get(i); ++i) {\\n            int gcd = gcds.get(i);\\n            long count = gcdCounts.get(gcd);\\n            int remainder = k/gcd;\\n            long pairCount = 0;\\n\\n            // pair num that has different gcd\\n            if (gcd == k) {   \\n                pairCount = nums.length - count; \\n            } else if (gcd != remainder) {                 \\n                for(int j = i+1; j < gcds.size() && gcds.get(j) >= remainder; ++j) {\\n                    int divisor = gcds.get(j);\\n                    if (divisor % remainder == 0) {\\n                        pairCount += gcdCounts.get(divisor);\\n                    }\\n                }\\n            }\\n            res += count * pairCount;\\n            \\n            // pair num that has same gcd\\n            if (gcd % remainder == 0) {   \\n                res += count * (count - 1) /2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int getGCD(int n1, int n2) {\\n        if (n2 == 0) return n1;\\n        return getGCD(n2, n1 % n2);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785271,
                "title": "easiest-c-solution-using-gcd-and-factors",
                "content": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        int factors[100005] = {0};\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int p = __gcd(k, nums[i]);\\n            int q = k/p;\\n            ans += factors[q];\\n            for (int j = 1; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[j]++;\\n                    if (j != nums[i]/j) factors[nums[i]/j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long coutPairs(vector<int>& nums, int k) {\\n        int factors[100005] = {0};\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int p = __gcd(k, nums[i]);\\n            int q = k/p;\\n            ans += factors[q];\\n            for (int j = 1; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[j]++;\\n                    if (j != nums[i]/j) factors[nums[i]/j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785268,
                "title": "c-8-liners-o-n-sqrt-n-gcd-solution",
                "content": "```\\nlong long coutPairs(vector<int>& nums, int k) \\n{\\n\\tlong long result=0,n=nums.size(),t[k+1];\\n\\tmemset(t,0,sizeof(t));\\n\\n\\tfor(int i=0;i<n;i++) t[__gcd(k,nums[i])]++; // the gcd of nums[i] and k\\n\\n\\tfor(int i=1;i<=k;i++)\\n\\t{\\n\\t\\tif(k%i) continue; // skip if not divisible\\n\\n\\t\\tint d=k/i; // the factors to be multiplied to reach k\\n\\t\\tfor(int j=ceil(1.*i/d)*d;j<=k;j+=d) result+=(i==j) ? t[i]*(t[i]-1)/2 : t[i]*t[j]; // if same then C(n,2), else add the products\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long coutPairs(vector<int>& nums, int k) \\n{\\n\\tlong long result=0,n=nums.size(),t[k+1];\\n\\tmemset(t,0,sizeof(t));\\n\\n\\tfor(int i=0;i<n;i++) t[__gcd(k,nums[i])]++; // the gcd of nums[i] and k\\n\\n\\tfor(int i=1;i<=k;i++)\\n\\t{\\n\\t\\tif(k%i) continue; // skip if not divisible\\n\\n\\t\\tint d=k/i; // the factors to be multiplied to reach k\\n\\t\\tfor(int j=ceil(1.*i/d)*d;j<=k;j+=d) result+=(i==j) ? t[i]*(t[i]-1)/2 : t[i]*t[j]; // if same then C(n,2), else add the products\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785137,
                "title": "beats-100-in-memory-and-100-in-time",
                "content": "Description in code comments.\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int gcd(int x, int y)\\n    {\\n        return y == 0 ? x : gcd(y, x % y);\\n    }\\n    ll coutPairs(vector<int>& nums, int k) {\\n        // for every subset of prime factors(meaning our overall array is the powerset.), we will find the count of numbers in array that properly fit.\\n        // then we do simple O(N**2) over the powerset.\\n        // a good way to represent the powerset is simply gcd.\\n        map<int,int>mp;\\n        ll tot = 0;\\n        for(auto &p:nums){\\n            int g = gcd(p, k);\\n            if(mp.find(g) == mp.end())\\n                mp[g] = 0;\\n            mp[g]++;\\n        }\\n        for(auto ptr=mp.begin();ptr != mp.end();ptr++){\\n   //         printf(\"ptr->first:%d, ptr->second:%d\\\\n\", ptr->first, ptr->second);\\n            for(auto rp=ptr;rp != mp.end();rp++){\\n                if(ptr == rp){\\n                    ll s = ll(ptr->second);\\n                    ll y = ll(ptr->first);\\n                    ll t = ll(k);\\n                    if((y*y)%t == 0)\\n                        tot += (s*(s-1))/2;\\n                }\\n                else{\\n                    ll s1 = ll(ptr->second), s2 = ll(rp->second);\\n                    ll y1 = ll(ptr->first), y2 = ll(rp->first), t = ll(k);\\n                    if((y1*y2)%t == 0)\\n                        tot += s1*s2;\\n                }\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int gcd(int x, int y)\\n    {\\n        return y == 0 ? x : gcd(y, x % y);\\n    }\\n    ll coutPairs(vector<int>& nums, int k) {\\n        // for every subset of prime factors(meaning our overall array is the powerset.), we will find the count of numbers in array that properly fit.\\n        // then we do simple O(N**2) over the powerset.\\n        // a good way to represent the powerset is simply gcd.\\n        map<int,int>mp;\\n        ll tot = 0;\\n        for(auto &p:nums){\\n            int g = gcd(p, k);\\n            if(mp.find(g) == mp.end())\\n                mp[g] = 0;\\n            mp[g]++;\\n        }\\n        for(auto ptr=mp.begin();ptr != mp.end();ptr++){\\n   //         printf(\"ptr->first:%d, ptr->second:%d\\\\n\", ptr->first, ptr->second);\\n            for(auto rp=ptr;rp != mp.end();rp++){\\n                if(ptr == rp){\\n                    ll s = ll(ptr->second);\\n                    ll y = ll(ptr->first);\\n                    ll t = ll(k);\\n                    if((y*y)%t == 0)\\n                        tot += (s*(s-1))/2;\\n                }\\n                else{\\n                    ll s1 = ll(ptr->second), s2 = ll(rp->second);\\n                    ll y1 = ll(ptr->first), y2 = ll(rp->first), t = ll(k);\\n                    if((y1*y2)%t == 0)\\n                        tot += s1*s2;\\n                }\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785106,
                "title": "help-correct-my-code-logic-error",
                "content": "I am not sure what is the logic error of my code \\nmy idea is for mod 0 ones, internally it can form pairs\\nand each mod 0 number can form with other numbers out of those mod 0 ones\\n\\nand for other mods, mod1 * mod2 can be valid pair if they are k or multiple of k\\nbut the solution is wrong\\nso what is the issue with this ?\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (b == 0)\\n         return a;\\n        return gcd(b, a % b);\\n    }\\n    string getKey(int first, int second) {\\n        if(first <= second) {\\n            return to_string(first) + \":\" + to_string(second);\\n        }\\n        return to_string(second) + \":\" + to_string(first);\\n    }\\n    \\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long count = 0;\\n        unordered_map<int, int> remainFreq;\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            int remain = nums[idx] % k;\\n            if(remainFreq.find(remain) == remainFreq.end()) {\\n                remainFreq[remain] = 0;\\n            }\\n            remainFreq[remain]++;\\n        }\\n        \\n        int len = nums.size();\\n        unordered_set<string> used;\\n        for(auto entry: remainFreq) {\\n            int mod = entry.first;\\n            int freq = entry.second;\\n            if(mod == 0) {\\n                long long internal = ((freq) * (freq-1)) / 2;\\n                long long outside = ((len - freq) * freq);\\n                long long sum = internal + outside;\\n               // cout<<\"sum for 0:\"<<sum<<endl;\\n                count += sum;\\n                used.insert(getKey(mod, mod));\\n                continue;\\n            }\\n            \\n           \\n            \\n          \\n           // cout<<\"mod\"<<mod<<endl;\\n            int large = (mod * k) / gcd(k, mod) ;\\n           // cout<<\"gcd:\"<<large<<endl;\\n           \\n                int other = large / mod;\\n                string key = getKey(mod, other);\\n                if(used.find(key) != used.end()) {\\n                    continue;\\n                }\\n                if(remainFreq.find(other) != remainFreq.end()) {\\n                    long long outside = freq * ((remainFreq[other]));\\n                    count += outside;\\n                    used.insert(key);\\n                }\\n            \\n            \\n            \\n        }\\n        \\n      /*  for(string key: used) {\\n            cout<<key<<endl;\\n        } */\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (b == 0)\\n         return a;\\n        return gcd(b, a % b);\\n    }\\n    string getKey(int first, int second) {\\n        if(first <= second) {\\n            return to_string(first) + \":\" + to_string(second);\\n        }\\n        return to_string(second) + \":\" + to_string(first);\\n    }\\n    \\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long count = 0;\\n        unordered_map<int, int> remainFreq;\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            int remain = nums[idx] % k;\\n            if(remainFreq.find(remain) == remainFreq.end()) {\\n                remainFreq[remain] = 0;\\n            }\\n            remainFreq[remain]++;\\n        }\\n        \\n        int len = nums.size();\\n        unordered_set<string> used;\\n        for(auto entry: remainFreq) {\\n            int mod = entry.first;\\n            int freq = entry.second;\\n            if(mod == 0) {\\n                long long internal = ((freq) * (freq-1)) / 2;\\n                long long outside = ((len - freq) * freq);\\n                long long sum = internal + outside;\\n               // cout<<\"sum for 0:\"<<sum<<endl;\\n                count += sum;\\n                used.insert(getKey(mod, mod));\\n                continue;\\n            }\\n            \\n           \\n            \\n          \\n           // cout<<\"mod\"<<mod<<endl;\\n            int large = (mod * k) / gcd(k, mod) ;\\n           // cout<<\"gcd:\"<<large<<endl;\\n           \\n                int other = large / mod;\\n                string key = getKey(mod, other);\\n                if(used.find(key) != used.end()) {\\n                    continue;\\n                }\\n                if(remainFreq.find(other) != remainFreq.end()) {\\n                    long long outside = freq * ((remainFreq[other]));\\n                    count += outside;\\n                    used.insert(key);\\n                }\\n            \\n            \\n            \\n        }\\n        \\n      /*  for(string key: used) {\\n            cout<<key<<endl;\\n        } */\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785082,
                "title": "update-divisors-using-gcd",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid update(vector<long long> &d, int num){\\n\\t\\t\\tfor(int i=1; i*i<=num; i++){\\n\\t\\t\\t\\tif(num%i==0){\\n\\t\\t\\t\\t\\tif(num/i == i) d[i]++;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\td[i]++;\\n\\t\\t\\t\\t\\t\\td[num/i]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    long long coutPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long res = 0LL;\\n        int MAXN = 1e5 + 5;\\n        vector<long long> d(MAXN,0);\\n        \\n        for(int i=0; i<n; i++){\\n            int r = k/__gcd(nums[i],k);\\n            res+=(long long)d[r];\\n            update(d,nums[i]);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid update(vector<long long> &d, int num){\\n\\t\\t\\tfor(int i=1; i*i<=num; i++){\\n\\t\\t\\t\\tif(num%i==0){\\n\\t\\t\\t\\t\\tif(num/i == i) d[i]++;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\td[i]++;\\n\\t\\t\\t\\t\\t\\td[num/i]++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1785055,
                "title": "c-count-gcd-with-explanation",
                "content": "Runtime: 190 ms, faster than 100.00% of C++ online submissions for Count Array Pairs Divisible by K.\\nMemory Usage: 65.1 MB, less than 100.00% of C++ online submissions for Count Array Pairs Divisible by K.\\n```\\nclass Solution {\\npublic:\\n    int GCD(int a, int b){\\n        if(b == 0) return a;\\n        else{\\n            return GCD(b, a%b);\\n        }\\n    }\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[0] < b[0];\\n    }\\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int len = nums.size();\\n        // Find the GCD\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > k){\\n                nums[i] = GCD(nums[i], k);\\n            }\\n            else{\\n                nums[i] = GCD(k, nums[i]);\\n            }\\n        }\\n        \\n        // Accumulate the GCD vector\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < nums.size(); i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        // Store into {k/GCD, GCD, number} vector\\n        vector<vector<int>> need(m.size(), {0,0,0});\\n        int n = 0;\\n        for(auto iter = m.begin(); iter != m.end(); iter++, n++){\\n            need[n][0] = k / iter->first;\\n            need[n][1] = iter->first;\\n            need[n][2] = iter->second;\\n        }\\n        // Sort the vector according to the first term (k/GCD)\\n        sort(need.begin(), need.end(), cmp);\\n        \\n        // Traverse the sorted vector\\n        for(int i = 0; i < need.size(); i++){\\n            for(int j = i + 1; j < need.size(); j++){\\n                // One of the number\\'s GCD is k or one\\'s GCD is divisible by another\\'s k/GCD\\n                if(need[i][0] == 1 || need[j][0] == 1 || need[j][1] % need[i][0] == 0){\\n                    ans += (long long)need[i][2] * (long long)need[j][2];\\n                }\\n                // Break when nums[j]\\'s GCD is smaller than nums[i]\\'s k/GCD\\n                else if(need[j][1] < need[i][0]){\\n                    break;\\n                }\\n            }\\n        }\\n        // Add the remaining pairs where nums[i]\\'s GCD is divisible by nums[i]\\'s k/GCD\\n        for(int i = 0; i < need.size(); i++){\\n            if(need[i][1] % need[i][0] == 0){\\n                ans += (long long)need[i][2] * (long long)(need[i][2]  - 1)/ 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int a, int b){\\n        if(b == 0) return a;\\n        else{\\n            return GCD(b, a%b);\\n        }\\n    }\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[0] < b[0];\\n    }\\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int len = nums.size();\\n        // Find the GCD\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > k){\\n                nums[i] = GCD(nums[i], k);\\n            }\\n            else{\\n                nums[i] = GCD(k, nums[i]);\\n            }\\n        }\\n        \\n        // Accumulate the GCD vector\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < nums.size(); i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        // Store into {k/GCD, GCD, number} vector\\n        vector<vector<int>> need(m.size(), {0,0,0});\\n        int n = 0;\\n        for(auto iter = m.begin(); iter != m.end(); iter++, n++){\\n            need[n][0] = k / iter->first;\\n            need[n][1] = iter->first;\\n            need[n][2] = iter->second;\\n        }\\n        // Sort the vector according to the first term (k/GCD)\\n        sort(need.begin(), need.end(), cmp);\\n        \\n        // Traverse the sorted vector\\n        for(int i = 0; i < need.size(); i++){\\n            for(int j = i + 1; j < need.size(); j++){\\n                // One of the number\\'s GCD is k or one\\'s GCD is divisible by another\\'s k/GCD\\n                if(need[i][0] == 1 || need[j][0] == 1 || need[j][1] % need[i][0] == 0){\\n                    ans += (long long)need[i][2] * (long long)need[j][2];\\n                }\\n                // Break when nums[j]\\'s GCD is smaller than nums[i]\\'s k/GCD\\n                else if(need[j][1] < need[i][0]){\\n                    break;\\n                }\\n            }\\n        }\\n        // Add the remaining pairs where nums[i]\\'s GCD is divisible by nums[i]\\'s k/GCD\\n        for(int i = 0; i < need.size(); i++){\\n            if(need[i][1] % need[i][0] == 0){\\n                ans += (long long)need[i][2] * (long long)(need[i][2]  - 1)/ 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785037,
                "title": "c-factor-95",
                "content": "Number of factors < log(100000) <=16\\n```\\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        int cnt[100001]= {};\\n        vector<int> f;\\n        for(int i=2; i*i<=k; i++) {\\n            if(k%i==0) {\\n                f.push_back(i);\\n                int v = k/i;\\n                if(v!=i)\\n                    f.push_back(v);\\n            }\\n        }\\n        f.push_back(k);\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%k==0) {\\n                ret += i;\\n                cnt[k]++;\\n            } else {\\n                int d = gcd(k,nums[i]);\\n                int m = k/d;\\n                for(auto n: f) {\\n                    if(n%m==0) {\\n                        ret += cnt[n];\\n                    }\\n                }\\n                cnt[d]++;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    long long coutPairs(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        int cnt[100001]= {};\\n        vector<int> f;\\n        for(int i=2; i*i<=k; i++) {\\n            if(k%i==0) {\\n                f.push_back(i);\\n                int v = k/i;\\n                if(v!=i)\\n                    f.push_back(v);\\n            }\\n        }\\n        f.push_back(k);\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%k==0) {\\n                ret += i;\\n                cnt[k]++;\\n            } else {\\n                int d = gcd(k,nums[i]);\\n                int m = k/d;\\n                for(auto n: f) {\\n                    if(n%m==0) {\\n                        ret += cnt[n];\\n                    }\\n                }\\n                cnt[d]++;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785034,
                "title": "python-gcd-semi-brute-force-but-faster-than-100",
                "content": "The complexity is not good, but it runs pretty fast somehow.  Not sure why.\\n\\n1. Transform `nums` to its gcd of `k`, and count for each value.  If gcd is `k`, then change it to `0`.\\n2. `0` can make a valid pair with any other number, so calculate its combination count by math.  And then delete `0` as it\\'s been done with.\\n3. `1` cannot make a valid pair with non-`0`, so just delete `1`.\\n4. Brute-force check for the remaining value pairs.\\n\\n```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            g = gcd(nums[i], k)\\n            nums[i] = g if g != k else 0\\n        \\n        c = Counter(nums)\\n        r = 0\\n\\t\\t\\n\\t\\t# 0 to other number\\n        for i in c:\\n            if i == 0: continue\\n            r += c[i]\\n        r *= c[0]\\n\\t\\t\\n\\t\\t# 0 to 0\\n        r += (c[0] * (c[0]-1)) // 2\\n        \\n        del c[0]  # 0 is dealt with\\n        del c[1]  # 1 is useless\\n        \\n\\t\\t# brute-force check for key pairs\\n        ckeys = list(c.keys())\\n        for a in range(len(ckeys)):\\n            i = ckeys[a]\\n            for b in range(a, len(ckeys)):\\n                j = ckeys[b]\\n                if (i * j) % k: continue\\n                if j != i:\\n                    r += c[i] * c[j]\\n                else:\\n                    r += (c[i] * (c[i]-1)) // 2\\n                \\n        return r\\n```\\n\\n**Update**:  (thanks to @lee215)\\n`ckeys` is actually very short, depending on `k` and is about `128` elements at most for the given range of `k`.  Thus, the nested loop is far faster than `O(n^2)` and `O(k^2)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            g = gcd(nums[i], k)\\n            nums[i] = g if g != k else 0\\n        \\n        c = Counter(nums)\\n        r = 0\\n\\t\\t\\n\\t\\t# 0 to other number\\n        for i in c:\\n            if i == 0: continue\\n            r += c[i]\\n        r *= c[0]\\n\\t\\t\\n\\t\\t# 0 to 0\\n        r += (c[0] * (c[0]-1)) // 2\\n        \\n        del c[0]  # 0 is dealt with\\n        del c[1]  # 1 is useless\\n        \\n\\t\\t# brute-force check for key pairs\\n        ckeys = list(c.keys())\\n        for a in range(len(ckeys)):\\n            i = ckeys[a]\\n            for b in range(a, len(ckeys)):\\n                j = ckeys[b]\\n                if (i * j) % k: continue\\n                if j != i:\\n                    r += c[i] * c[j]\\n                else:\\n                    r += (c[i] * (c[i]-1)) // 2\\n                \\n        return r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785019,
                "title": "java-group-by-gcds",
                "content": "```\\n    public long coutPairs(int[] nums, int k) {\\n    \\tMap<Integer, Integer> map = new HashMap<>();\\n        long res = 0;\\n        for (int i : nums) {\\n        \\tint d = gcd(i, k);\\n        \\tmap.put(d, map.getOrDefault(d, 0) + 1);\\n        }\\n        for (int gcd : map.keySet()) {\\n        \\tlong cnt = map.get(gcd);\\n        \\tmap.put(gcd, 0); // avoid duplicated count\\n        \\tint d = k / gcd;\\n        \\tif (gcd % d == 0)  // gcd itself can be a valid pair\\n        \\t\\tres += cnt * (cnt - 1) / 2;\\n        \\tfor (int m : map.keySet())\\n        \\t\\tif (map.get(m) != 0 && m % d == 0)\\n        \\t\\t\\tres += cnt * map.get(m);\\n        }\\n        return res;\\n    }\\n    int gcd(int a, int b) {\\n    \\treturn b == 0 ? a : gcd(b, a % b);\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long coutPairs(int[] nums, int k) {\\n    \\tMap<Integer, Integer> map = new HashMap<>();\\n        long res = 0;\\n        for (int i : nums) {\\n        \\tint d = gcd(i, k);\\n        \\tmap.put(d, map.getOrDefault(d, 0) + 1);\\n        }\\n        for (int gcd : map.keySet()) {\\n        \\tlong cnt = map.get(gcd);\\n        \\tmap.put(gcd, 0); // avoid duplicated count\\n        \\tint d = k / gcd;\\n        \\tif (gcd % d == 0)  // gcd itself can be a valid pair\\n        \\t\\tres += cnt * (cnt - 1) / 2;\\n        \\tfor (int m : map.keySet())\\n        \\t\\tif (map.get(m) != 0 && m % d == 0)\\n        \\t\\t\\tres += cnt * map.get(m);\\n        }\\n        return res;\\n    }\\n    int gcd(int a, int b) {\\n    \\treturn b == 0 ? a : gcd(b, a % b);\\n    }\\n",
                "codeTag": "C++"
            },
            {
                "id": 1785001,
                "title": "python-o-n-o-klogk-beat-100-hashmap-using-gcd",
                "content": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t# We count the numbers by GCD with k\\n        num_dict = Counter()\\n        for num in nums:\\n            key = math.gcd(num, k)\\n            num_dict[key] += 1\\n        \\n\\t\\t# check from the largest to smallest\\n        check = [(x, y) for x, y in sorted(num_dict.items())]\\n        \\n        res = 0\\n\\n        for i in range(len(check)):\\n\\t\\t# Remove largest to avoid double counting\\n            d, cnt = check.pop()\\n\\t\\t\\t# Two special cases: when d == k and d * d % k == 0, we can pick any two numbers inside the group (within group pairs)\\n\\t\\t\\t\\n            if d == k or d * d % k == 0:\\n                res += cnt * (cnt - 1) // 2\\n            d_tmp = k // math.gcd(d, k) # Find the remainder\\n\\t\\t\\t\\n\\t\\t\\t# Calculate cross group pairs\\n            for x, y in check:\\n\\t\\t\\t\\t# find the gcd can be divided by the remainder\\n                if x % d_tmp == 0:\\n                    res += cnt * y\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def coutPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t# We count the numbers by GCD with k\\n        num_dict = Counter()\\n        for num in nums:\\n            key = math.gcd(num, k)\\n            num_dict[key] += 1\\n        \\n\\t\\t# check from the largest to smallest\\n        check = [(x, y) for x, y in sorted(num_dict.items())]\\n        \\n        res = 0\\n\\n        for i in range(len(check)):\\n\\t\\t# Remove largest to avoid double counting\\n            d, cnt = check.pop()\\n\\t\\t\\t# Two special cases: when d == k and d * d % k == 0, we can pick any two numbers inside the group (within group pairs)\\n\\t\\t\\t\\n            if d == k or d * d % k == 0:\\n                res += cnt * (cnt - 1) // 2\\n            d_tmp = k // math.gcd(d, k) # Find the remainder\\n\\t\\t\\t\\n\\t\\t\\t# Calculate cross group pairs\\n            for x, y in check:\\n\\t\\t\\t\\t# find the gcd can be divided by the remainder\\n                if x % d_tmp == 0:\\n                    res += cnt * y\\n        \\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784973,
                "title": "c-171ms-100-simple-gcd-map-space-100-explained",
                "content": "Runtime: 171 ms, faster than 100.00% of C++ online submissions for Count Array Pairs Divisible by K.\\nMemory Usage: 64.9 MB, less than 100.00% of C++ online submissions for Count Array Pairs Divisible by K.\\n\\n**General idea:**\\n**1.** count all GCD from each number and contain it into map\\n**2.** first special case: GCD == K ( count all permutations for this case) \\nimagine that for k = 3 we have GSD = 3 for n = 4 numbers and lenght of vector is equal 7: \\nour answer will add 6 + 5 + 4 + 3 : we calculate it with formula  **((vector.size()-1)  + (vector.size()-n)) * n / 2**\\nand delete it from map\\n**3.** second special case: GSD == 1 => ignore it (**IMPORTENT !!!**) we need do case 2 after case 1 (we can have GSD == 1 and firstly we need to consider this as case 1)\\n**4.** travers from current number in map and check :\\na.) can our current GSD with itself give right answer (imagine that we have GSD = 9 and current gsd = 3 ) so we need to add for our answer all permutations for this current gsd : ans += n*(n-1)/2 (count of all permutations)\\nb) check : our current gsd will have right answer with any greater gsd from map ? if have we add to answer first_gsd * second_gsd\\n```\\nclass Solution {\\npublic:\\n  long long coutPairs(vector<int>& nums, int k) {\\n    long ans = 0;\\n    map<long,long>t;\\n    \\n    for(auto n: nums) t[gcd(n,k)]++;                              //fetch all gcd\\n    \\n    if(t.count(k)){                                               //case 1\\n      ans += ((nums.size()<<1) - t[k] - 1) * t[k] / 2; \\n      t.erase(k);\\n    }\\n    if(t.count(1)) t.erase(1);                                    //case 2\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){                                   //traversal through map\\n      if((it->first * it->first) % k == 0) ans += it->second*(it->second-1)/2;       //if gsd \"good\" for itself\\n      \\n      for(auto it2 = it ; ++it2 != t.end();)                                         //check with all greatest gsd\\n        if( (it->first * it2->first) % k == 0) ans += it->second * it2->second;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long coutPairs(vector<int>& nums, int k) {\\n    long ans = 0;\\n    map<long,long>t;\\n    \\n    for(auto n: nums) t[gcd(n,k)]++;                              //fetch all gcd\\n    \\n    if(t.count(k)){                                               //case 1\\n      ans += ((nums.size()<<1) - t[k] - 1) * t[k] / 2; \\n      t.erase(k);\\n    }\\n    if(t.count(1)) t.erase(1);                                    //case 2\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){                                   //traversal through map\\n      if((it->first * it->first) % k == 0) ans += it->second*(it->second-1)/2;       //if gsd \"good\" for itself\\n      \\n      for(auto it2 = it ; ++it2 != t.end();)                                         //check with all greatest gsd\\n        if( (it->first * it2->first) % k == 0) ans += it->second * it2->second;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784960,
                "title": "python-o-klog-k-gcds",
                "content": "only need to consider the residue of the each number divided by k\\n```\\ndef coutPairs(self, nums: List[int], k: int) -> int:\\n        res=[0]*k\\n        for n in nums:\\n            res[n%k]+=1\\n        ans=res[0]*(len(nums)-1)\\n        for i in range(1,k):\\n            if not res[i]:continue\\n            q=k//math.gcd(k,i)\\n            for j in range(0,k,q):\\n                if j==i:continue\\n                ans+=res[i]*res[j]\\n            if i*i%k==0:\\n                ans+=res[i]*(res[i]-1)\\n        return ans//2\\n```",
                "solutionTags": [],
                "code": "```\\ndef coutPairs(self, nums: List[int], k: int) -> int:\\n        res=[0]*k\\n        for n in nums:\\n            res[n%k]+=1\\n        ans=res[0]*(len(nums)-1)\\n        for i in range(1,k):\\n            if not res[i]:continue\\n            q=k//math.gcd(k,i)\\n            for j in range(0,k,q):\\n                if j==i:continue\\n                ans+=res[i]*res[j]\\n            if i*i%k==0:\\n                ans+=res[i]*(res[i]-1)\\n        return ans//2\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1845969,
                "content": [
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Plssssssssss commment me what is the problem in my code:-\n\n long count = 0;\n        for(int i = 0; i<nums.length; i++){\n            for(int j = i+1; j<nums.length; j++){\n                  if(nums[i] * nums[j] % k == 0 && i<j && j<=nums.length-1){\n                    count++;\n                }\n            }\n        }\n  return count;\n\nTestcases passed: 92/115."
                    },
                    {
                        "username": "allrounderankit",
                        "content": "it gives TLE as your solution is n^2 "
                    },
                    {
                        "username": "asishbosek",
                        "content": "i tried to solve this by expanding (a+b)%k\\nclass Solution {\\n    public long countPairs(int[] arr, int k) {\\n        HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\tif(hs.containsKey((k-arr[i]%k)%k)){\\n\\t\\t\\t\\t\\ths.put((k-arr[i]%k)%k,\\ths.get((k-arr[i]%k)%k)+1);\\n\\t\\t\\t\\tcount+=\\ths.get((k-arr[i]%k)%k);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ths.put((k-arr[i]%k)%k,1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1723800,
                "content": [
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Plssssssssss commment me what is the problem in my code:-\n\n long count = 0;\n        for(int i = 0; i<nums.length; i++){\n            for(int j = i+1; j<nums.length; j++){\n                  if(nums[i] * nums[j] % k == 0 && i<j && j<=nums.length-1){\n                    count++;\n                }\n            }\n        }\n  return count;\n\nTestcases passed: 92/115."
                    },
                    {
                        "username": "allrounderankit",
                        "content": "it gives TLE as your solution is n^2 "
                    },
                    {
                        "username": "asishbosek",
                        "content": "i tried to solve this by expanding (a+b)%k\\nclass Solution {\\n    public long countPairs(int[] arr, int k) {\\n        HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\tif(hs.containsKey((k-arr[i]%k)%k)){\\n\\t\\t\\t\\t\\ths.put((k-arr[i]%k)%k,\\ths.get((k-arr[i]%k)%k)+1);\\n\\t\\t\\t\\tcount+=\\ths.get((k-arr[i]%k)%k);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ths.put((k-arr[i]%k)%k,1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]