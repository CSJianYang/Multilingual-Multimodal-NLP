[
    {
        "title": "Remove All Adjacent Duplicates In String",
        "question_content": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\n&nbsp;\nExample 1:\n\nInput: s = \"abbaca\"\nOutput: \"ca\"\nExplanation: \nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\n\nExample 2:\n\nInput: s = \"azxxzy\"\nOutput: \"ay\"\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 294893,
                "title": "java-c-python-two-pointers-and-stack-solution",
                "content": "## Solution 1: Two Pointers\\n`i` refers to the index to set next character in the output string.\\n`j` refers to the index of current iteration in the input string.\\n\\nIterate characters of `S` one by one by increasing `j`.\\n\\nIf `S[j]` is same as the current last character `S[i - 1]`,\\nwe remove duplicates by doing `i -= 2`.\\n\\nIf `S[j]` is different as the current last character `S[i - 1]`,\\nwe set `S[i] = S[j]` and increment `i++`.\\n<br>\\n\\n**Java**\\n```java\\n    public String removeDuplicates(String s) {\\n        int i = 0, n = s.length();\\n        char[] res = s.toCharArray();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            res[i] = res[j];\\n            if (i > 0 && res[i - 1] == res[i]) // count = 2\\n                i -= 2;\\n        }\\n        return new String(res, 0, i);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string removeDuplicates(string s) {\\n        int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i > 0 && s[i - 1] == s[i]) // count = 2\\n                i -= 2;\\n        }\\n        return s.substr(0, i);\\n    }\\n```\\n<br>\\n\\n## Why This solution\\nYou can easily update this solution to remove more duplicates.\\nNow it\\'s a specil case where we only remove replicates `k = 2`.\\n<br>\\n\\n## Solution 2: Stack\\n\\nKeep a `res` as a characters stack.\\nIterate characters of `S` one by one.\\n\\nIf the next character is same as the last character in `res`,\\npop the last character from `res`.\\nIn this way, we remove a pair of adjacent duplicates characters.\\n\\nIf the next character is different,\\nwe append it to the end of `res`.\\n<br>\\n\\n**C++**\\n```cpp\\n    string removeDuplicates(string S) {\\n        string res = \"\";\\n        for (char& c : S)\\n            if (res.size() && c == res.back())\\n                res.pop_back();\\n            else\\n                res.push_back(c);\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) {\\n                sb.deleteCharAt(size - 1);\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n**Python**\\n```py\\n    def removeDuplicates(self, S):\\n        res = []\\n        for c in S:\\n            if res and res[-1] == c:\\n                res.pop()\\n            else:\\n                res.append(c)\\n        return \"\".join(res)\\n```\\n\\n**Python 1-line**\\n```py\\n    def removeDuplicates(self, S):\\n        return reduce(lambda s, c: s[:-1] if s[-1:] == c else s + c, S)\\n```\\n## **Complexity**\\nThese two solution actually work in the similar way.\\nTime `O(N)` for one pass\\nSpace `O(N)` for output\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public String removeDuplicates(String s) {\\n        int i = 0, n = s.length();\\n        char[] res = s.toCharArray();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            res[i] = res[j];\\n            if (i > 0 && res[i - 1] == res[i]) // count = 2\\n                i -= 2;\\n        }\\n        return new String(res, 0, i);\\n    }\\n```\n```cpp\\n    string removeDuplicates(string s) {\\n        int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i > 0 && s[i - 1] == s[i]) // count = 2\\n                i -= 2;\\n        }\\n        return s.substr(0, i);\\n    }\\n```\n```cpp\\n    string removeDuplicates(string S) {\\n        string res = \"\";\\n        for (char& c : S)\\n            if (res.size() && c == res.back())\\n                res.pop_back();\\n            else\\n                res.push_back(c);\\n        return res;\\n    }\\n```\n```java\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) {\\n                sb.deleteCharAt(size - 1);\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```py\\n    def removeDuplicates(self, S):\\n        res = []\\n        for c in S:\\n            if res and res[-1] == c:\\n                res.pop()\\n            else:\\n                res.append(c)\\n        return \"\".join(res)\\n```\n```py\\n    def removeDuplicates(self, S):\\n        return reduce(lambda s, c: s[:-1] if s[-1:] == c else s + c, S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 294964,
                "title": "java-python-3-three-easy-iterative-codes-w-brief-explanation-analysis-and-follow-up",
                "content": "**Method 1: ArrayDeque**\\n\\nIf current char is same as previous char in the ArrayDeque, pop out the previous char; \\nOtherwise, add current char into the ArrayDeque.\\n\\n\\n```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        for (char c : S.toCharArray()) {\\n            if (!dq.isEmpty() && dq.peekLast() == c) { \\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : dq) { sb.append(c); }\\n        return sb.toString();\\n    }\\n```\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        dq = collections.deque()\\n        for c in S:\\n            if dq and dq[-1] == c:\\n                dq.pop()\\n            else:\\n                dq.append(c)\\n        return \\'\\'.join(dq)\\n```\\nOr just use list:\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for c in S:\\n            if stack and stack[-1] == c:\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\\n\\n**Method 2: StringBuilder.**\\n\\nGet rid of the ArrayDeque in method 1, use only StringBuilder.\\n\\nIf current char is same as the end of the StringBuilder, delete the char at end; otherwise, append it at the end.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) { \\n                sb.deleteCharAt(size - 1); \\n            }else { \\n                sb.append(c); \\n            }\\n        }\\n        return sb.toString();\\n    }\\n``` \\n\\n**Method 3: two pointers**\\n\\nIf current char is same as the end of non-adjacent-duplicate chars, decrease the counter `end` by 1;\\notherwise, copy the current char to its end.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        char[] a = S.toCharArray();\\n        int end = -1;\\n        for (char c : a) {\\n            if (end >= 0 && a[end] == c) { \\n                --end; \\n            }else { \\n                a[++end] = c; \\n            }\\n        }\\n        return String.valueOf(a, 0, end + 1);\\n    }\\n```\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        end, a = -1, list(S)\\n        for c in a:\\n            if end >= 0 and a[end] == c:\\n                end -= 1\\n            else:\\n                end += 1\\n                a[end] = c\\n        return \\'\\'.join(a[: end + 1])\\n```\\n**Analysis for all methods:**\\n\\nTime & space: O(n), where n = S.length().\\n\\n----\\n\\n**Follow-up:**\\n\\nSee follow up [1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/393149/JavaPython-3-O(n)-codes-using-Stack-w-brief-explanation-and-analysis.)\\n\\nQ: What if we are required to **remove all k-in-a-row duplicates in a string (for more-than-k-in-a-row, remove only first k duplicates)**? - credit to **@betterztt**.\\n\\nA: Use 2 stacks, one for characters, and the other for the count of adjacent characters.\\n\\n```java\\n    public String removeDuplicates(String S, int k) {\\n        Deque<Character> charStk = new ArrayDeque<>();\\n        Deque<Integer> cntStk = new ArrayDeque<>();\\n        for (int i = 0; i < S.length(); ++i) {\\n            char c = S.charAt(i);\\n            if (charStk.isEmpty() || charStk.peek() != c) { // no char in stack yet, or top char is different from the current.\\n                charStk.push(c);\\n                cntStk.push(1);\\n            }else if (cntStk.peek() + 1 < k) { // top char is same as the current, but less than k after appending the current.\\n                cntStk.push(cntStk.pop() + 1);\\n            }else { // found k-in-a-row duplicates, remove them.\\n                charStk.pop();\\n                cntStk.pop();\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : charStk) {\\n            int cnt = cntStk.pop();\\n            while (cnt-- > 0) {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString(); // Do NOT forget reverse().\\n    }\\n```\\n```python\\n    def removeDuplicates(self, S: str, k: int) -> str:\\n         stk = []\\n        for char in S:\\n            if not stk or stk[-1][0] != char:\\n                stk.append([char, 1])\\n            elif stk[-1][1] + 1 < k:\\n                stk[-1][1] += 1\\n            else:\\n                stk.pop()\\n        return \\'\\'.join(char * cnt for char, cnt in stk)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Iterator"
                ],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        for (char c : S.toCharArray()) {\\n            if (!dq.isEmpty() && dq.peekLast() == c) { \\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : dq) { sb.append(c); }\\n        return sb.toString();\\n    }\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        dq = collections.deque()\\n        for c in S:\\n            if dq and dq[-1] == c:\\n                dq.pop()\\n            else:\\n                dq.append(c)\\n        return \\'\\'.join(dq)\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for c in S:\\n            if stack and stack[-1] == c:\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\n```\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) { \\n                sb.deleteCharAt(size - 1); \\n            }else { \\n                sb.append(c); \\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```\\n    public String removeDuplicates(String S) {\\n        char[] a = S.toCharArray();\\n        int end = -1;\\n        for (char c : a) {\\n            if (end >= 0 && a[end] == c) { \\n                --end; \\n            }else { \\n                a[++end] = c; \\n            }\\n        }\\n        return String.valueOf(a, 0, end + 1);\\n    }\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        end, a = -1, list(S)\\n        for c in a:\\n            if end >= 0 and a[end] == c:\\n                end -= 1\\n            else:\\n                end += 1\\n                a[end] = c\\n        return \\'\\'.join(a[: end + 1])\\n```\n```java\\n    public String removeDuplicates(String S, int k) {\\n        Deque<Character> charStk = new ArrayDeque<>();\\n        Deque<Integer> cntStk = new ArrayDeque<>();\\n        for (int i = 0; i < S.length(); ++i) {\\n            char c = S.charAt(i);\\n            if (charStk.isEmpty() || charStk.peek() != c) { // no char in stack yet, or top char is different from the current.\\n                charStk.push(c);\\n                cntStk.push(1);\\n            }else if (cntStk.peek() + 1 < k) { // top char is same as the current, but less than k after appending the current.\\n                cntStk.push(cntStk.pop() + 1);\\n            }else { // found k-in-a-row duplicates, remove them.\\n                charStk.pop();\\n                cntStk.pop();\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : charStk) {\\n            int cnt = cntStk.pop();\\n            while (cnt-- > 0) {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString(); // Do NOT forget reverse().\\n    }\\n```\n```python\\n    def removeDuplicates(self, S: str, k: int) -> str:\\n         stk = []\\n        for char in S:\\n            if not stk or stk[-1][0] != char:\\n                stk.append([char, 1])\\n            elif stk[-1][1] + 1 < k:\\n                stk[-1][1] += 1\\n            else:\\n                stk.pop()\\n        return \\'\\'.join(char * cnt for char, cnt in stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2430136,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tans.push_back(s[0]);\\n\\n\\t\\t\\tfor(int i=1 ; i<s.length() ; i++){\\n\\n\\t\\t\\t\\tif(!ans.empty() && s[i] == ans.back()){\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans.push_back(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tans.push_back(s[0]);\\n\\n\\t\\t\\tfor(int i=1 ; i<s.length() ; i++){\\n\\n\\t\\t\\t\\tif(!ans.empty() && s[i] == ans.back()){\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1302208,
                "title": "c-java-python-stack-based-solution-really-clean-concise",
                "content": "**Idea**\\n- Use stack `st` to store non duplicate characters so far.\\n- Iterating each character `c` in string `s`, if the the top of stack is equal to `c` then `st.pop()` else `st.append(c)`.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/7bHcEq4r/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`, where `N` is length of string `S`.\\n- Space: `O(N-D)`, where `D` is a total length for all duplicates.\\n\\n**Next step, try yourself to solve this following up questions:**\\n* [1209. Remove All Adjacent Duplicates K Letters in String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n\\nIf you like this post, please **give it a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**Idea**\\n- Use stack `st` to store non duplicate characters so far.\\n- Iterating each character `c` in string `s`, if the the top of stack is equal to `c` then `st.pop()` else `st.append(c)`.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/7bHcEq4r/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`, where `N` is length of string `S`.\\n- Space: `O(N-D)`, where `D` is a total length for all duplicates.\\n\\n**Next step, try yourself to solve this following up questions:**\\n* [1209. Remove All Adjacent Duplicates K Letters in String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n\\nIf you like this post, please **give it a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 295163,
                "title": "c-5-lines-use-string-as-a-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string a;\\n        for (auto& c : S) \\n            if (a.size() && a.back() == c) a.pop_back();\\n            else a.push_back(c);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string a;\\n        for (auto& c : S) \\n            if (a.size() && a.back() == c) a.pop_back();\\n            else a.push_back(c);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798052,
                "title": "python3-stack-approach-o-n-candy-crush",
                "content": "Think about this as Candy Crush for a single row where you can only crush two candies at a time :) The idea is to have a stack to store the visited chars. If the current char in the string is the same as the last char in the stack, pop the last char from the stack and skip the current char in the string; otherwise, append the current char to the stack.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n    \\t### initialize an empty stack\\n        stack = []\\n\\n        for char in s:\\n        \\t\\n        \\t### This is the case where two adjacent letters are equal\\n        \\t### don\\'t store it and pop the last one from stack,\\n        \\t### Don\\'t forget to check if the stack is empty!\\n            if stack and char==stack[-1]:\\n                stack.pop()\\n\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```\\n\\n**Time complexity** is **O(n)** since we just went over ```s```.\\n\\nRuning the code with an example ```s = \"abbaca\"```\\n```\\n\\t\\t\\t\\tBEFORE\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAFTER\\n\\ti=0\\t\\t\\tstack=[]\\t\\ts[i]=a \\t\\tempty stack, append\\t\\t\\tstack=[a]\\n\\ti=1\\t\\t\\tstack=[a]\\t\\ts[i]=b \\t\\tstack[-1]!=s[i], append\\t\\tstack=[a,b]\\n\\ti=2\\t\\t\\tstack=[a,b]\\t\\ts[i]=b \\t\\tstack[-1]==s[i], pop\\t\\tstack=[a]\\n\\ti=3\\t\\t\\tstack=[a]\\t\\ts[i]=a \\t\\tstack[-1]==s[i], pop\\t\\tstack=[]\\n\\ti=4\\t\\t\\tstack=[]\\t\\ts[i]=c \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c]\\n\\ti=5\\t\\t\\tstack=[c]\\t\\ts[i]=a \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c,a] (result)\\n```\\n\\nOne line from genius [lee215](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/294893/JavaC%2B%2BPython-Two-Pointers-and-Stack-Solution):\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        return reduce(lambda stack, char: stack[:-1] if stack[-1:] == char else stack + char, s)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n    \\t### initialize an empty stack\\n        stack = []\\n\\n        for char in s:\\n        \\t\\n        \\t### This is the case where two adjacent letters are equal\\n        \\t### don\\'t store it and pop the last one from stack,\\n        \\t### Don\\'t forget to check if the stack is empty!\\n            if stack and char==stack[-1]:\\n                stack.pop()\\n\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```\n```s```\n```s = \"abbaca\"```\n```\\n\\t\\t\\t\\tBEFORE\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAFTER\\n\\ti=0\\t\\t\\tstack=[]\\t\\ts[i]=a \\t\\tempty stack, append\\t\\t\\tstack=[a]\\n\\ti=1\\t\\t\\tstack=[a]\\t\\ts[i]=b \\t\\tstack[-1]!=s[i], append\\t\\tstack=[a,b]\\n\\ti=2\\t\\t\\tstack=[a,b]\\t\\ts[i]=b \\t\\tstack[-1]==s[i], pop\\t\\tstack=[a]\\n\\ti=3\\t\\t\\tstack=[a]\\t\\ts[i]=a \\t\\tstack[-1]==s[i], pop\\t\\tstack=[]\\n\\ti=4\\t\\t\\tstack=[]\\t\\ts[i]=c \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c]\\n\\ti=5\\t\\t\\tstack=[c]\\t\\ts[i]=a \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c,a] (result)\\n```\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        return reduce(lambda stack, char: stack[:-1] if stack[-1:] == char else stack + char, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798136,
                "title": "leetcode-the-hard-way-explained-line-by-line-c-python-java-go-kotlin-rust",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nVery similar to [1544. Make The String Great](https://leetcode.com/problems/make-the-string-great/).\\n\\n<iframe src=\"https://leetcode.com/playground/3DAthf6c/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Kotlin",
                    "Rust",
                    "String",
                    "Stack"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nVery similar to [1544. Make The String Great](https://leetcode.com/problems/make-the-string-great/).\\n\\n<iframe src=\"https://leetcode.com/playground/3DAthf6c/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 389304,
                "title": "javascript-easy-to-understand-3-solutions",
                "content": "## Solution 1\\n\\nSince we need to check and remove the previous char by the current char, so it let us think about the stack:\\n1. traverse the string `s`\\n2. for every char, we compare it with the top value in stack\\n\\t- if they are same, pop the top value\\n\\t- otherwise, push the current char into stack\\n3. finally, return the stack as a string\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);\\n  }\\n  return stack.join(\\'\\');\\n};\\n```\\n\\n## Solution 2\\n\\nFor this solution, we use 2 pointers. One for traversal and one for store result:\\n1. the traversal pointer just traverse the string `s`\\n2. the store pointer try to save char into the arr itself just as the `stack` in solution 1\\n3. we compare every new char with the store pointer value and maintain the value of store pointer\\n\\nIn fact, this is just a variant of solution 1.\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const arr = s.split(\\'\\');\\n  let ans = 0;\\n  for (let i = 0; i < arr.length; ++i) {\\n    ans === 0 || arr[i] !== arr[ans - 1] ? (arr[ans++] = arr[i]) : --ans;\\n  }\\n  return arr.slice(0, ans).join(\\'\\');\\n};\\n```\\n\\n## Solution 3\\n\\nFor this solution, we try to deal with all the adjacent duplicates right now, and loop again until there are no more adjacent duplicates.\\nWe also use the RegExp to make the code easy.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const s2 = s.replace(/(.)\\\\1/g, \\'\\');\\n  return s2.length === s.length ? s : removeDuplicates(s2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst removeDuplicates = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);\\n  }\\n  return stack.join(\\'\\');\\n};\\n```\n```js\\nconst removeDuplicates = s => {\\n  const arr = s.split(\\'\\');\\n  let ans = 0;\\n  for (let i = 0; i < arr.length; ++i) {\\n    ans === 0 || arr[i] !== arr[ans - 1] ? (arr[ans++] = arr[i]) : --ans;\\n  }\\n  return arr.slice(0, ans).join(\\'\\');\\n};\\n```\n```js\\nconst removeDuplicates = s => {\\n  const s2 = s.replace(/(.)\\\\1/g, \\'\\');\\n  return s2.length === s.length ? s : removeDuplicates(s2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302217,
                "title": "remove-all-adjacent-duplicates-in-string-simple-solutions-w-explanation",
                "content": "***Solution 1:(Recursion-TLE)***\\n```\\nBrute force way is to simply remove the characters from string whenever you find any adjacent duplicates,\\nand then again restart from start.\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    string ans;\\n    void go(string str,int idx=0)\\n    {\\n        if(idx>=str.length())\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(str[idx]==str[idx+1])\\n        {\\n            if(idx==0)\\n                go(str.substr(idx+2),0);\\n            else\\n                go(str.substr(0,idx)+str.substr(idx+2),0);\\n        }\\n        else\\n        go(str,idx+1);\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        ans=\"\";\\n        go(s);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Solution 2:(Using Stack- Accepted)***\\n```\\n# Optimised Approach:\\n\\n1) We will be using stack for it.\\n\\n2) We will traverse the characters in the string one by one and compare with stack top,\\nif at any time stack.top()==currentCharacter then we pop the element from stack.\\n\\n3) And at last we will form the answer string using the stack elements.\\n\\nLet us simulate the process with the help of an eg:\\nstring : abbaca\\nstack: empty\\n\\nfirst iteration: \\'a\\'\\nstack is empty so we will push \\'a\\' to the stack,\\nstack: |a|\\n\\nsecond iteration: \\'b\\'\\nstack.top() is not equal to \\'b\\',\\nso we will push \\'b\\' to the stack.\\nstack: |b|a|\\n\\nthird iteration: \\'b\\'\\nstack.top() is equal to \\'b\\',\\nso we will pop the element from stack.\\nstack: |a|\\n\\nfourth iteration: \\'a\\'\\nstack.top() is equal to \\'a\\',\\nso we will pop element from the stack.\\nstack: empty\\n\\nFifth iteration: \\'c\\'\\nstack is empty\\nso we will push the element into the stack.\\nstack: |c|\\n\\nSixth iteration: \\'a\\'\\nstack.top() is not equal to \\'a\\',\\nso we will push \\'a\\' to the stack.\\nstack: |a|c|\\n\\nNow, we will pop all the elements from the stack and store them into the answer string,\\nans = \"ac\"\\nas the elements are in reverse order and hence we need to reverse the ans,\\nreverse(ans)\\nans=\"ca\" (FINAL RESULT)\\n```\\n\\n**Time Complexity: O(N)**\\n**Space Complexity: O(N)**\\n**N: length of string**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        stack<char> s;\\n        for(auto i:str)\\n        {\\n            if(s.empty())\\n                s.push(i);\\n            else\\n            {\\n                if(s.top()==i)\\n                {\\n                    s.pop();\\n                }\\n                else\\n                    s.push(i);\\n            }\\n        }\\n        string ans;\\n        while(!s.empty())\\n            ans+=s.top(),s.pop();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n***Solution 3:(Using String as Stack - Accepted)***\\n```\\nIt is just the simple modification of above code,\\ninstead of using stack we can directly use the resultant string for performing pop and push operations.\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        string ans;\\n        for(auto i:str)\\n        {\\n            if(!ans.empty() and ans.back()==i)\\n                ans.pop_back();\\n            else\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***If you found the post useful, then please do consider it for Upvotes\\uD83D\\uDE00\\uD83D\\uDE00***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nBrute force way is to simply remove the characters from string whenever you find any adjacent duplicates,\\nand then again restart from start.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string ans;\\n    void go(string str,int idx=0)\\n    {\\n        if(idx>=str.length())\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(str[idx]==str[idx+1])\\n        {\\n            if(idx==0)\\n                go(str.substr(idx+2),0);\\n            else\\n                go(str.substr(0,idx)+str.substr(idx+2),0);\\n        }\\n        else\\n        go(str,idx+1);\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        ans=\"\";\\n        go(s);\\n        return ans;\\n    }\\n};\\n```\n```\\n# Optimised Approach:\\n\\n1) We will be using stack for it.\\n\\n2) We will traverse the characters in the string one by one and compare with stack top,\\nif at any time stack.top()==currentCharacter then we pop the element from stack.\\n\\n3) And at last we will form the answer string using the stack elements.\\n\\nLet us simulate the process with the help of an eg:\\nstring : abbaca\\nstack: empty\\n\\nfirst iteration: \\'a\\'\\nstack is empty so we will push \\'a\\' to the stack,\\nstack: |a|\\n\\nsecond iteration: \\'b\\'\\nstack.top() is not equal to \\'b\\',\\nso we will push \\'b\\' to the stack.\\nstack: |b|a|\\n\\nthird iteration: \\'b\\'\\nstack.top() is equal to \\'b\\',\\nso we will pop the element from stack.\\nstack: |a|\\n\\nfourth iteration: \\'a\\'\\nstack.top() is equal to \\'a\\',\\nso we will pop element from the stack.\\nstack: empty\\n\\nFifth iteration: \\'c\\'\\nstack is empty\\nso we will push the element into the stack.\\nstack: |c|\\n\\nSixth iteration: \\'a\\'\\nstack.top() is not equal to \\'a\\',\\nso we will push \\'a\\' to the stack.\\nstack: |a|c|\\n\\nNow, we will pop all the elements from the stack and store them into the answer string,\\nans = \"ac\"\\nas the elements are in reverse order and hence we need to reverse the ans,\\nreverse(ans)\\nans=\"ca\" (FINAL RESULT)\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        stack<char> s;\\n        for(auto i:str)\\n        {\\n            if(s.empty())\\n                s.push(i);\\n            else\\n            {\\n                if(s.top()==i)\\n                {\\n                    s.pop();\\n                }\\n                else\\n                    s.push(i);\\n            }\\n        }\\n        string ans;\\n        while(!s.empty())\\n            ans+=s.top(),s.pop();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nIt is just the simple modification of above code,\\ninstead of using stack we can directly use the resultant string for performing pop and push operations.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        string ans;\\n        for(auto i:str)\\n        {\\n            if(!ans.empty() and ans.back()==i)\\n                ans.pop_back();\\n            else\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161308,
                "title": "no-stack-solution-only-string-stringbuilder-c-java",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string ans = \"\";\\n        for (char ch: S) {\\n            if ( ans.size() != 0 and ans.back() == ch )\\n                ans.pop_back();\\n            else\\n                ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch: S.toCharArray()) {\\n            if ( sb.length() != 0 && sb.charAt(sb.length() - 1) == ch ) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string ans = \"\";\\n        for (char ch: S) {\\n            if ( ans.size() != 0 and ans.back() == ch )\\n                ans.pop_back();\\n            else\\n                ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch: S.toCharArray()) {\\n            if ( sb.length() != 0 && sb.charAt(sb.length() - 1) == ch ) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295517,
                "title": "python-100-stack",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for char in S:\\n            if stack and stack[-1] == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for char in S:\\n            if stack and stack[-1] == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655668,
                "title": "simple-c-approach-using-basic-strings-no-stack-with-detailed-explanation",
                "content": "\\n# Approach\\n- Create a empty string temp\\n- make a pointer i=0\\n- iterate till (i<length of string )\\n- if either the string is empty or the char is not equal to the last char at temp\\npush the current character.\\n- else\\n    pop the last character of the temp string.\\n    i++\\nreturn temp.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string temp = \"\";\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            if (temp.empty() || s[i] != temp.back()) {\\n                temp.push_back(s[i]);\\n            } else {\\n                temp.pop_back();\\n            }\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```\\n# Please upvote if you liked my approach",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string temp = \"\";\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            if (temp.empty() || s[i] != temp.back()) {\\n                temp.push_back(s[i]);\\n            } else {\\n                temp.pop_back();\\n            }\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302789,
                "title": "c-5-line-in-place-solution-o-n-time-o-1-space",
                "content": "We use the given string as a stack.\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string& s) {\\n        int i = 0;\\n        for(int j = 1; j < s.size(); ++j)\\n            if (i < 0 || s[i] != s[j]) s[++i] = s[j];\\n            else --i;\\n        return s.substr(0, i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string& s) {\\n        int i = 0;\\n        for(int j = 1; j < s.size(); ++j)\\n            if (i < 0 || s[i] != s[j]) s[++i] = s[j];\\n            else --i;\\n        return s.substr(0, i + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294930,
                "title": "c-recursive",
                "content": "```\\nstring removeDuplicates(string S) {\\n  for (auto i = 1; i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n\\t  return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1));\\n  return S;\\n}\\n```\\nA small optimization to continue from the \"cutting\" point:\\n```cpp\\nstring removeDuplicates(string S, int i = 1) {\\n  for (i = max(1, i); i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n        return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1), i - 1);\\n  return S;\\n}\\n```\\n**Complexity Analysis**\\nRuntime & Memory: O(n ^ 2). We are copying the string up to n times. With a two-pointer solution, we can achieve O(n) | O(1) complexity. This solution is slow but perhaps simpler to implement.",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicates(string S) {\\n  for (auto i = 1; i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n\\t  return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1));\\n  return S;\\n}\\n```\n```cpp\\nstring removeDuplicates(string S, int i = 1) {\\n  for (i = max(1, i); i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n        return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1), i - 1);\\n  return S;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798868,
                "title": "java-easy-solution-using-stack-faster-than-60",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length() ;i++){\\n            if(!st.isEmpty()){\\n                if(st.peek() == s.charAt(i)){\\n                    st.pop();\\n                }else{\\n                    st.push(s.charAt(i));\\n                }\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder ns = new StringBuilder(\"\");\\n        while(!st.isEmpty()){\\n            ns.append(st.pop());\\n        }\\n        return ns.reverse().toString();\\n    }\\n}\\n```\\n\\n**upvote please",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length() ;i++){\\n            if(!st.isEmpty()){\\n                if(st.peek() == s.charAt(i)){\\n                    st.pop();\\n                }else{\\n                    st.push(s.charAt(i));\\n                }\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder ns = new StringBuilder(\"\");\\n        while(!st.isEmpty()){\\n            ns.append(st.pop());\\n        }\\n        return ns.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490674,
                "title": "java-tc-o-n-sc-o-n-clean-concise-solution-using-stringbuilder-as-stack",
                "content": "```\\n/**\\n * Using StringBuilder as Stack.\\n *\\n * Time Complexity: O(N + N) = O(N) -> N for Iterating over the string. N for\\n * sb.toString()\\n *\\n * Space Complexity: O(N) -> Space used by the StringBuilder\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) {\\n            // Ask Interviewer about this base case. You can also return null here.\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < len; i++) {\\n            char curChar = s.charAt(i);\\n            int sbLen = sb.length();\\n\\n            if (sbLen > 0 && sb.charAt(sbLen - 1) == curChar) {\\n                // If last character in StringBuilder is same as the current character, then\\n                // remove the last character from StringBuilder\\n                sb.setLength(sbLen - 1);\\n            } else {\\n                sb.append(curChar);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nSolution to Part II: [1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/1490956/Java-or-TC:-O(N)-or-SC:-O(N)-or-Clean-and-Concise-solution-using-StringBuilder-and-Stack)",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Using StringBuilder as Stack.\\n *\\n * Time Complexity: O(N + N) = O(N) -> N for Iterating over the string. N for\\n * sb.toString()\\n *\\n * Space Complexity: O(N) -> Space used by the StringBuilder\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) {\\n            // Ask Interviewer about this base case. You can also return null here.\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < len; i++) {\\n            char curChar = s.charAt(i);\\n            int sbLen = sb.length();\\n\\n            if (sbLen > 0 && sb.charAt(sbLen - 1) == curChar) {\\n                // If last character in StringBuilder is same as the current character, then\\n                // remove the last character from StringBuilder\\n                sb.setLength(sbLen - 1);\\n            } else {\\n                sb.append(curChar);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294908,
                "title": "simple-solution-using-stack-c",
                "content": "Iterate through the input string.(curr is the current character)\\n\\nIf the stack is empty push curr into the stack.\\nelse if the stack top is same as curr, pop the stack once.\\nelse push curr into the stack.\\n\\nFinally the elements in the stack is the answer in reverse order.\\n\\nTry understanding with input :cabba\\n\\ncurr=c: stack=[c\\ncurr=a: stack=[ca\\ncurr=b: stack=[cab\\ncurr=b: stack=[ca\\ncurr=a: stack=[c\\n\\nans:c\\n\\n```\\nstring removeDuplicates(string a) {\\n\\tstack<char> st;\\n\\tstring ans=\"\";\\n\\tfor(auto curr:a) {\\n\\t\\tif(st.empty()) st.push(curr);\\n\\t\\telse if(st.top() == curr) st.pop();\\n\\t\\telse st.push(curr);\\n\\t}\\n\\n\\twhile(!st.empty()) {\\n\\t\\tans += st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(ans.begin(), ans.end());\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeDuplicates(string a) {\\n\\tstack<char> st;\\n\\tstring ans=\"\";\\n\\tfor(auto curr:a) {\\n\\t\\tif(st.empty()) st.push(curr);\\n\\t\\telse if(st.top() == curr) st.pop();\\n\\t\\telse st.push(curr);\\n\\t}\\n\\n\\twhile(!st.empty()) {\\n\\t\\tans += st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(ans.begin(), ans.end());\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798026,
                "title": "c-easy-detailed-explanation",
                "content": "**\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705**\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            if(ans.size() && ans.back() == s[i])\\n                ans.pop_back();\\n            else\\n                ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC : 0(n)**           **SC : O(n)**\\n\\n**Explanation :**\\n\\n\\t\\t\\t\\t\\t\\ts = \"abbaca\"\\n\\t\\t\\t\\t\\t\\t\\n1. \\t\\t\\t\\t\\t\\tans = a              s[i+1] = b\\n1. \\t\\t\\t\\t\\t\\tans = ab             s[i+1] = b\\n1. \\t\\t\\t\\t\\t\\tans = a              s[i+1] = a\\n1. \\t\\t\\t\\t\\t\\tans = c              s[i+1] = a\\n1. \\t\\t\\t\\t\\t\\tans = ca      \\n\\t\\t\\t\\t\\t\\t \\n \\t\\t\\t\\t\\t\\tFinally ans = \"ca\"        \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            if(ans.size() && ans.back() == s[i])\\n                ans.pop_back();\\n            else\\n                ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263474,
                "title": "c-2-solutions-easy-to-understand",
                "content": "* **Solution using stack.**\\n(Scroll down for more optimized solution.)\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        stack<char>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == st.top())\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        while(st.size() != 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n* **More optimized solution (faster than 96.15%)**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        string ans;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i] == ans.back())\\n            {\\n                ans.pop_back();\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        stack<char>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == st.top())\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        while(st.size() != 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        string ans;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i] == ans.back())\\n            {\\n                ans.pop_back();\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545434,
                "title": "java-easy-solution-fast-and-memory-efficient",
                "content": "```\\nchar[] ch = new char[S.length()];\\n        int i = 0;\\n        \\n        for(int j = 0; j < S.length(); j++){\\n            if(i > 0 && ch[i - 1] == S.charAt(j)){\\n                i--;\\n            }\\n            else{\\n                ch[i] = S.charAt(j);\\n                i++;\\n            }\\n        }\\n        return new String(ch, 0, i);",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nchar[] ch = new char[S.length()];\\n        int i = 0;\\n        \\n        for(int j = 0; j < S.length(); j++){\\n            if(i > 0 && ch[i - 1] == S.charAt(j)){\\n                i--;\\n            }\\n            else{\\n                ch[i] = S.charAt(j);\\n                i++;\\n            }\\n        }\\n        return new String(ch, 0, i);",
                "codeTag": "Unknown"
            },
            {
                "id": 428241,
                "title": "easy-java-stack-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        //create stack\\n        Stack<Character> stack = new Stack();\\n        \\n        //iterate thru string\\n        for (char c : S.toCharArray()) {\\n            //check if top of stack is equal to this character\\n            if (!stack.isEmpty() && stack.peek() == c) {\\n                //remove\\n                stack.pop();\\n            } else {\\n               //add to stack\\n                stack.push(c);\\n            }\\n        }\\n        \\n        //string builder for result\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //empty stack out (everything left is not an adjacent duplicate)\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        //result\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        //create stack\\n        Stack<Character> stack = new Stack();\\n        \\n        //iterate thru string\\n        for (char c : S.toCharArray()) {\\n            //check if top of stack is equal to this character\\n            if (!stack.isEmpty() && stack.peek() == c) {\\n                //remove\\n                stack.pop();\\n            } else {\\n               //add to stack\\n                stack.push(c);\\n            }\\n        }\\n        \\n        //string builder for result\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //empty stack out (everything left is not an adjacent duplicate)\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        //result\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295116,
                "title": "java-solution-using-stack",
                "content": "* If the top of the stack has the same character as the current character of String at position i, keep popping from the stack.\\n* Otherwise, push the element onto the stack.\\n* If the stack is not empty, pop all elements and store them in a StringBuilder, reverse it and return the result.\\n```\\npublic String removeDuplicates(String S) {\\n        if(S == null || S.length() == 0)\\n            return new String();\\n        Stack<Character> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            if(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                while(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                    stack.pop();\\n            else\\n                stack.push(S.charAt(i));\\n        }\\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeDuplicates(String S) {\\n        if(S == null || S.length() == 0)\\n            return new String();\\n        Stack<Character> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            if(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                while(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                    stack.pop();\\n            else\\n                stack.push(S.charAt(i));\\n        }\\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799041,
                "title": "python-c-java-rust-make-the-stack-great-again-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a stack to keep track of equal adjacent letters. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** To remove adjacent duplicates, we iteratively compare each letter with the last letter on the stack. This problem is almost identical to the November 8th\\'s daily challenge [**1544. Make The String Great**](https://leetcode.com/problems/make-the-string-great/) (check my [**solution**](https://leetcode.com/problems/make-the-string-great/discuss/2790965/PythonC%2B%2BJavaRust-Make-The-String-Great-Again-(explained))).\\n\\n**Python.**\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ss = []\\n        for c in s:\\n            if ss and ss[-1] == c : ss.pop()\\n            else                  : ss.append(c)\\n        return \"\".join(ss)\\n```\\n\\nThis solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/dekDhVK9/shared\" frameBorder=\"0\" width=\"800\" height=\"320\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ss = []\\n        for c in s:\\n            if ss and ss[-1] == c : ss.pop()\\n            else                  : ss.append(c)\\n        return \"\".join(ss)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291694,
                "title": "easy-python-solution-89-05",
                "content": "Runtime: 64 ms, faster than 89.05% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 14.9 MB, less than 21.60% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack=[s[0]]\\n        for i in range(1,len(s)):\\n            if(stack and stack[-1]==s[i]):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 64 ms, faster than 89.05% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 14.9 MB, less than 21.60% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack=[s[0]]\\n        for i in range(1,len(s)):\\n            if(stack and stack[-1]==s[i]):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1672744,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack = []\\n        for ch in s:\\n            if stack and ch == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack = []\\n        for ch in s:\\n            if stack and ch == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294942,
                "title": "javascript-stack-solution-60ms",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    let res = [];\\n    for(let i=0; i<S.length; i++){\\n        if(S[i] !== res[res.length-1]) {\\n            res.push(S[i]);\\n        } else {\\n            res.pop();\\n        }\\n    }\\n    return res.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    let res = [];\\n    for(let i=0; i<S.length; i++){\\n        if(S[i] !== res[res.length-1]) {\\n            res.push(S[i]);\\n        } else {\\n            res.pop();\\n        }\\n    }\\n    return res.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798202,
                "title": "accepted-detail-explained-stack-approach-tc-o-n",
                "content": "# Approach\\n1. Take a stack \\n2. Take a loop iterate from first to last char from given string\\n    * Check if stack is empty then push current char into stack\\n    * else check if stack top char is equal to current char then pop that form stack else push current char into stack\\n3. At the end return the reverse order of the remaining characters inside the stack.\\n\\n# Complexity\\n- Time complexity: o(N) **Reason:** We are iterating each char from string\\n\\n- Space complexity: o(N) **Reason:** Using stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(st.top()==s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(st.top()==s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302281,
                "title": "java-remove-all-adjacent-duplicates-in-string-java-simple-solution-using-stack",
                "content": "\\nclass Solution {\\n\\n\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        stack.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            char c = s.charAt(i);\\n\\t\\t\\t// if stack is empty or the top element of the stack is not current we have then push into the stack\\n            if(stack.isEmpty() || stack.peek() != c){\\n                stack.push(c);\\n            }// otherwise pop from the stack\\n\\t\\t\\telse{\\n                stack.pop();\\n            }\\n        }\\n\\t\\t// pop all the element which is left in the stack and store into the string and return;\\n        String ans=\"\";\\n        while (!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n<<<<<<<<<<<<   Please upvote.. if it is useful :)  >>>>>>>>>>>>>\\n<<<<<<<<<<<<   Happy coding :)   >>>>>>>>>>>>>>>>>>>>>>>",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        stack.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            char c = s.charAt(i);\\n\\t\\t\\t// if stack is empty or the top element of the stack is not current we have then push into the stack\\n            if(stack.isEmpty() || stack.peek() != c){\\n                stack.push(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1302187,
                "title": "python-stack-solution-explained",
                "content": "It is given in the statement of the problem that no matter in which order we remove adjacent duplicates in our string, result will always be the same. It is not obvious for my why (that is why problem marked as easy, because we can use it), so we we choose the most convinient way for us. Let us go from left to right and try to add element by element. If we see that we have repetition when we add new element, it means that we have adjacent duplicate and we pop element. In the opposite case we add element to stack. In the end we just return what we have in our stack.\\n\\n#### Complexity\\nTime and space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        stack = []\\n        for symb in s:\\n            if stack and stack[-1] == symb:\\n                stack.pop()\\n            else:\\n                stack.append(symb)\\n        return \"\".join(stack)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        stack = []\\n        for symb in s:\\n            if stack and stack[-1] == symb:\\n                stack.pop()\\n            else:\\n                stack.append(symb)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375290,
                "title": "c-solution-without-stack",
                "content": "Runtime: 20 ms, faster than 86.17% of C++ online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Remove All Adjacent Duplicates In String.\\n\\n```\\nstring removeDuplicates(string S) {\\n        \\n        string res;\\n        \\n        for(char ch : S)\\n        {\\n            if(!res.empty() && res[res.size() - 1] == ch) res.pop_back();\\n            else res += ch;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 86.17% of C++ online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Remove All Adjacent Duplicates In String.\\n\\n```\\nstring removeDuplicates(string S) {\\n        \\n        string res;\\n        \\n        for(char ch : S)\\n        {\\n            if(!res.empty() && res[res.size() - 1] == ch) res.pop_back();\\n            else res += ch;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2799023,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(!st.empty() && st.top() == s[i]) st.pop();\\n            else st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(!st.empty() && st.top() == s[i]) st.pop();\\n            else st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798255,
                "title": "fastest-solution-possibles-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563402,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef removeDuplicates(self, s: str) -> str:\\n\\ti = 0\\n\\n\\twhile i < len(s) - 1:\\n\\t\\tif i >= 0 and s[i] == s[i + 1]:\\n\\t\\t\\ts = s[:i] + s[i + 2:]\\n\\t\\t\\ti -= 1\\n\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\treturn s\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\ti = 0\\n\\n\\twhile i < len(s) - 1:\\n\\t\\tif i >= 0 and s[i] == s[i + 1]:\\n\\t\\t\\ts = s[:i] + s[i + 2:]\\n\\t\\t\\ti -= 1\\n\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\treturn s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984619,
                "title": "c-solution-o-n-time-o-1-space-complexity-100-faster",
                "content": "###   T = O(n) & S = O(n)    \\n ```\\n\\n\\n  stack<char> st;\\n\\tfor(int i = 0; i < S.size(); i++) {\\n\\t\\tif(st.empty() || S[i] != st.top()) {\\n\\t\\t\\tst.push(S[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\tstring Ans = \"\";\\n\\twhile(!st.empty()) {\\n\\t\\tAns.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(Ans.begin(), Ans.end());\\n\\treturn Ans;\\n```\\n\\n        \\n        \\n###  T = O(n) & S = O(1)\\n\\n\\t\\t\\n```\\nint stptr = -1;\\n for(int i = 0; i < S.size(); i++) {\\n\\tif(stptr == -1 || S[i] != S[stptr]) {\\n\\t\\tstptr++;\\n\\t\\tS[stptr] = S[i];\\n\\t}\\n\\telse {\\n\\t\\tstptr--;\\n\\t}\\n}\\nS.erase(stptr+1,S.size());\\n        return S;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\n  stack<char> st;\\n\\tfor(int i = 0; i < S.size(); i++) {\\n\\t\\tif(st.empty() || S[i] != st.top()) {\\n\\t\\t\\tst.push(S[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\tstring Ans = \"\";\\n\\twhile(!st.empty()) {\\n\\t\\tAns.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(Ans.begin(), Ans.end());\\n\\treturn Ans;\\n```\n```\\nint stptr = -1;\\n for(int i = 0; i < S.size(); i++) {\\n\\tif(stptr == -1 || S[i] != S[stptr]) {\\n\\t\\tstptr++;\\n\\t\\tS[stptr] = S[i];\\n\\t}\\n\\telse {\\n\\t\\tstptr--;\\n\\t}\\n}\\nS.erase(stptr+1,S.size());\\n        return S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783707,
                "title": "python-super-simple-solution-w-explanation",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        new_list = []\\n        \\n        for letter in S:\\n            new_list.append(letter)\\n            # if letter inserted is same as previous letter in list - remove both\\n            if len(new_list) > 1 and new_list[-1] == new_list[-2]: \\n                new_list.pop()\\n                new_list.pop()\\n                \\n        return \"\".join(new_list)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        new_list = []\\n        \\n        for letter in S:\\n            new_list.append(letter)\\n            # if letter inserted is same as previous letter in list - remove both\\n            if len(new_list) > 1 and new_list[-1] == new_list[-2]: \\n                new_list.pop()\\n                new_list.pop()\\n                \\n        return \"\".join(new_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799147,
                "title": "short-and-clear-solution-using-stack",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string RemoveDuplicates(string s)\\n    {\\n        Stack<char> st = new();\\n\\n        foreach (char c in s)\\n        {\\n            if (st.TryPeek(out char d) && d == c)\\n            {\\n                st.Pop();\\n                continue;\\n            }\\n\\n            st.Push(c);\\n        }\\n\\n        return string.Concat(st.Reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string RemoveDuplicates(string s)\\n    {\\n        Stack<char> st = new();\\n\\n        foreach (char c in s)\\n        {\\n            if (st.TryPeek(out char d) && d == c)\\n            {\\n                st.Pop();\\n                continue;\\n            }\\n\\n            st.Push(c);\\n        }\\n\\n        return string.Concat(st.Reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798875,
                "title": "easy-java-solution-using-stack-loop-separate-solution-easy-to-understand",
                "content": "# Using Loop\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n# Using Stack\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      Stack<Character> st=new Stack<>();\\n      for(int i=0;i<s.length();i++){\\n          char c=s.charAt(i);\\n          if(st.isEmpty()){\\n              st.push(c);\\n          }\\n          else if(st.peek()==c){\\n              st.pop();\\n          }\\n          else{\\n              st.push(c);\\n          }\\n      }\\n      String ans=new String(\"\");\\n        while(!st.isEmpty()){\\n            ans=st.pop()+ans;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      Stack<Character> st=new Stack<>();\\n      for(int i=0;i<s.length();i++){\\n          char c=s.charAt(i);\\n          if(st.isEmpty()){\\n              st.push(c);\\n          }\\n          else if(st.peek()==c){\\n              st.pop();\\n          }\\n          else{\\n              st.push(c);\\n          }\\n      }\\n      String ans=new String(\"\");\\n        while(!st.isEmpty()){\\n            ans=st.pop()+ans;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788514,
                "title": "with-diagrams-java-implictly-stack-solution-beats-99-7-time-and-97-6-space",
                "content": "For this dedup problem, first let us think about if we don\\'t use computer, just do it by hand. We will scan from left to right to see whether we need to de-duplicates. It required us to look back to previous step and check whether the character we added is the same as current character.\\n\\nThus it is easier to think out to use Stack to handle this case. Thus there will be two ways:\\n* Explicitly maintian a stack: `ArrayDeque<Character>` or `LinkedList<Character>`\\n* Implicitly simulate a stack: Two pointers or StringBuilder\\n\\nHere I will use Two Pointers to simulate a stack to be more efficient:\\n* Slow: represent the last elemetn to be returned, initialize as 0\\n* Fast: traverse the whole char array\\n```Java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        if (S == null || S.length() <= 1) {\\n            return S;\\n        }\\n        char[] chars = S.toCharArray(); // maintain as stack\\n        int slow = 0; // slow is the last element to be returned\\n        // [0, slow] will be the result after removing (inclusive)\\n        \\n        for (int fast = 1; fast < S.length(); fast++) {\\n            if (slow >= 0 && chars[slow] == chars[fast]) { // case 1: stack top has same data\\n                slow--; // stack.pop()\\n            } else { // case 2: stack top is different\\n                chars[++slow] = chars[fast]; // stack.push()\\n            }\\n        }\\n        return new String(chars, 0, slow + 1);\\n    }\\n}\\n```\\nLet\\'s use one example to see what is going on here:\\n```\\ninitially fast = 1, slow = 0\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t  f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\ta b b a c a\\n\\t  s \\u2192\\n\\t    f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t      f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n  s \\u2192\\n\\t        f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc b b a c a\\n    s \\u2192\\n\\t          f \\u2192 \\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc a b a c a\\n      s \\u2192\\n\\t            f \\u2192 \\n---------------------------------------------------\\nDone! \\'ca\\' will be returned.\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```Java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        if (S == null || S.length() <= 1) {\\n            return S;\\n        }\\n        char[] chars = S.toCharArray(); // maintain as stack\\n        int slow = 0; // slow is the last element to be returned\\n        // [0, slow] will be the result after removing (inclusive)\\n        \\n        for (int fast = 1; fast < S.length(); fast++) {\\n            if (slow >= 0 && chars[slow] == chars[fast]) { // case 1: stack top has same data\\n                slow--; // stack.pop()\\n            } else { // case 2: stack top is different\\n                chars[++slow] = chars[fast]; // stack.push()\\n            }\\n        }\\n        return new String(chars, 0, slow + 1);\\n    }\\n}\\n```\n```\\ninitially fast = 1, slow = 0\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t  f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\ta b b a c a\\n\\t  s \\u2192\\n\\t    f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t      f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n  s \\u2192\\n\\t        f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc b b a c a\\n    s \\u2192\\n\\t          f \\u2192 \\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc a b a c a\\n      s \\u2192\\n\\t            f \\u2192 \\n---------------------------------------------------\\nDone! \\'ca\\' will be returned.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798404,
                "title": "c-single-pass-solution-7-lines-code-easy-explained",
                "content": "```\\nstring removeDuplicates(string s) {\\n    string ans = \"\";\\n    for (auto &i: s) {\\n        //if current element of original string matches to last appended element of ans\\n        if (i == ans.back()){\\n            //remove that element from ans\\n            ans.pop_back();\\n        }\\n        else{\\n            //append that element to ans\\n            ans += i;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n    string ans = \"\";\\n    for (auto &i: s) {\\n        //if current element of original string matches to last appended element of ans\\n        if (i == ans.back()){\\n            //remove that element from ans\\n            ans.pop_back();\\n        }\\n        else{\\n            //append that element to ans\\n            ans += i;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798033,
                "title": "python-3-5-lines-stack-w-example-t-m-99-58",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n                                                        #   Ex: azxxzy\\n        stack = []\\n                                                        #   ch    stack      stack.pop()\\n        for ch in s:                                    #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            if stack and stack[-1]==ch: stack.pop()     #    a     [a]          \\n            else: stack.append(ch)                      #    z     [a,z]\\n                                                        #    x     [a,z,x]\\n        return \\'\\'.join(stack)                           #    x     [a,z]          x\\n                                                        #    z     [a]            z\\n                                                        #    y     [a,z]         --> \\'\\'.join([a,z]) = az\\n```\\n[https://leetcode.com/submissions/detail/637459942/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*).",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n                                                        #   Ex: azxxzy\\n        stack = []\\n                                                        #   ch    stack      stack.pop()\\n        for ch in s:                                    #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            if stack and stack[-1]==ch: stack.pop()     #    a     [a]          \\n            else: stack.append(ch)                      #    z     [a,z]\\n                                                        #    x     [a,z,x]\\n        return \\'\\'.join(stack)                           #    x     [a,z]          x\\n                                                        #    z     [a]            z\\n                                                        #    y     [a,z]         --> \\'\\'.join([a,z]) = az\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495279,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        \\n        int n = str.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(res.size() > 0 && str[i] == res.back())\\n            {\\n                res.pop_back();\\n            }\\n            else \\n            {\\n                res.push_back(str[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        \\n        int n = str.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(res.size() > 0 && str[i] == res.back())\\n            {\\n                res.pop_back();\\n            }\\n            else \\n            {\\n                res.push_back(str[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013350,
                "title": "c-solution-o-n-dry-run-included",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size(),i=0;\\n        for(int j=0;j<n;++i,++j){\\n            s[i]=s[j];\\n            if(i>0 and s[i-1]==s[i])\\n                i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n// a b b a c a , i=0,j=0\\n// a b b a c a , i=1,j=1\\n// a b b a c a , i=2,j=2 -> i-=2,j=2\\n// a a b a c a , i=0,j=3\\n// c a b a c a , i=0, j=4\\n// c a b a c a, i=1,j=4\\n// i=2,j=5 -> ans = ca\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size(),i=0;\\n        for(int j=0;j<n;++i,++j){\\n            s[i]=s[j];\\n            if(i>0 and s[i-1]==s[i])\\n                i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n// a b b a c a , i=0,j=0\\n// a b b a c a , i=1,j=1\\n// a b b a c a , i=2,j=2 -> i-=2,j=2\\n// a a b a c a , i=0,j=3\\n// c a b a c a , i=0, j=4\\n// c a b a c a, i=1,j=4\\n// i=2,j=5 -> ans = ca\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682474,
                "title": "using-stack-o-n",
                "content": "logic i used : I looped over the string and push the element in to the stack but if the top of the stack matches the next element to be pushped i poped the top.\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n    stack<char> stack;\\n        string str=\"\";\\n    \\n        for(int i=0;i<s.length();i++){\\n        \\n            if(!stack.empty() && s[i]==stack.top())\\n            {\\n                stack.pop();\\n            }\\n            else\\n            stack.push(s[i]);\\n        }\\n        while(!stack.empty()){\\n            str+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n return str; }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n    stack<char> stack;\\n        string str=\"\";\\n    \\n        for(int i=0;i<s.length();i++){\\n        \\n            if(!stack.empty() && s[i]==stack.top())\\n            {\\n                stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 560221,
                "title": "python-96-79-run-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/jackli2046/image_1585817374.png)\\n```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        if not S:\\n            return S\\n        res = [S[0]]\\n        for curr in S[1:]:            \\n            if res and curr == res[-1]:\\n                res.pop()\\n            else:\\n                res.append(curr)\\n        res = \\'\\'.join(res)                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        if not S:\\n            return S\\n        res = [S[0]]\\n        for curr in S[1:]:            \\n            if res and curr == res[-1]:\\n                res.pop()\\n            else:\\n                res.append(curr)\\n        res = \\'\\'.join(res)                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295287,
                "title": "straightforward-java-solution",
                "content": "```\\nRuntime: 192 ms, faster than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 44 MB, less than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\n```\\n```\\n\\t\\tpublic String removeDuplicates(String S) {\\n            StringBuilder sb = new StringBuilder(S);\\n            for (int i = 0; i < S.length() - 1; i++) {\\n                if (S.charAt(i) == S.charAt(i + 1)) {\\n                    return removeDuplicates(S.substring(0, i) + S.substring(i + 2));\\n                }\\n            }\\n            return sb.toString();\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nRuntime: 192 ms, faster than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 44 MB, less than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\n```\n```\\n\\t\\tpublic String removeDuplicates(String S) {\\n            StringBuilder sb = new StringBuilder(S);\\n            for (int i = 0; i < S.length() - 1; i++) {\\n                if (S.charAt(i) == S.charAt(i + 1)) {\\n                    return removeDuplicates(S.substring(0, i) + S.substring(i + 2));\\n                }\\n            }\\n            return sb.toString();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798407,
                "title": "python-super-fast-solution",
                "content": "\\tdef removeDuplicates(self, s: str) -> str:\\n\\t\\tres=[]\\n        for x in s:\\n            if len(res)>0 and res[-1]==x:\\n                res.pop()\\n            else:\\n                res.append(x)\\n        return \\'\\'.join(res)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef removeDuplicates(self, s: str) -> str:\\n\\t\\tres=[]\\n        for x in s:\\n            if len(res)>0 and res[-1]==x:\\n                res.pop()\\n            else:\\n                res.append(x)\\n        return \\'\\'.join(res)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2798135,
                "title": "most-easy-c-solution-without-stack-beginner-friendly",
                "content": "**Please Upvote if you like the Solution**\\n\\nclass Solution {\\npublic:\\n\\n    string removeDuplicates(string s) {\\n        string ans = \"\";                // String to store the Final result\\n        for(int i=0;i<s.length();i++) {\\n            if(ans.empty()) {           // if \\'ans\\' is empty then just add the current char of string \\'s\\'\\n                ans+=s[i];\\n            } else {                    // else compare the current char of string \\'s\\' with last char of \\'ans\\'\\n                                        // if they are equal then take out  last element from \\'ans\\' else put that current element in the ans\\n                if(s[i] == ans[ans.length()-1]) {\\n                    ans.pop_back();\\n                } else {\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n        return ans;                     // return the result\\n    }\\n\\t\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeDuplicates(string s) {\\n        string ans = \"\";                // String to store the Final result\\n        for(int i=0;i<s.length();i++) {\\n            if(ans.empty()) {           // if \\'ans\\' is empty then just add the current char of string \\'s\\'\\n                ans+=s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2798121,
                "title": "easy-understanding-daily-leetcode-november-10",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       int i=1;\\n        string k;\\n        k.push_back(s[0]);\\n        while(i<s.length())\\n        {\\n            if(!k.empty()&&s.length())\\n            {\\n                if(k.back()==s[i])\\n                {\\n                    k.pop_back();\\n                }\\n                else\\n                {\\n                    k.push_back(s[i]);\\n                }\\n            }\\n            else\\n                k.push_back(s[i]);\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed.\\n//Happy Coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       int i=1;\\n        string k;\\n        k.push_back(s[0]);\\n        while(i<s.length())\\n        {\\n            if(!k.empty()&&s.length())\\n            {\\n                if(k.back()==s[i])\\n                {\\n                    k.pop_back();\\n                }\\n                else\\n                {\\n                    k.push_back(s[i]);\\n                }\\n            }\\n            else\\n                k.push_back(s[i]);\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed.\\n//Happy Coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398983,
                "title": "c-stack-from-brute-force-to-optimized-well-documented",
                "content": "Brute Force time-complexity : O(N(N+M))\\nTypically O(N^2)\\n\\n```    \\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n        int i = 0;\\n        int j = 1;\\n        while(j < s.length()){\\n            if(s[i] == s[j]){\\n                s.erase(s.begin()+i);  // this function takes O(N+M) time\\n                s.erase(s.begin()+i); // N is size of the array & M is the remaining elements to be shifted\\n                i = 0;\\n                j = 1;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n\\t}\\n}\\n```\\n\\nOptimized time-complexity : O(N)\\n```\\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n\\t    string ans =\"\";\\n        stack<char> st;\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){ // initially if the stack is empty (to avoid segmentation fault)\\n                st.push(s[i]);\\n                continue; \\n            }else{\\n                if(st.top() == s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// popping out remaining elements and storing them to the string\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\t\\t\\n\\t\\t// reversing the string because stack reversed the string while popping.\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you read it till here don\\'t forget to like :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```    \\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n        int i = 0;\\n        int j = 1;\\n        while(j < s.length()){\\n            if(s[i] == s[j]){\\n                s.erase(s.begin()+i);  // this function takes O(N+M) time\\n                s.erase(s.begin()+i); // N is size of the array & M is the remaining elements to be shifted\\n                i = 0;\\n                j = 1;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n\\t    string ans =\"\";\\n        stack<char> st;\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){ // initially if the stack is empty (to avoid segmentation fault)\\n                st.push(s[i]);\\n                continue; \\n            }else{\\n                if(st.top() == s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// popping out remaining elements and storing them to the string\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\t\\t\\n\\t\\t// reversing the string because stack reversed the string while popping.\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737378,
                "title": "very-simple-java-solution-using-stack",
                "content": "** PLEASE UPVOTE IF U FIND IT USEFULL**\\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stk = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!stk.isEmpty() && stk.peek()==s.charAt(i))\\n                stk.pop();\\n            else\\n                stk.push(s.charAt(i));\\n        }\\n        \\n        for(Character c : stk)\\n            sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n** PLEASE UPVOTE IF U FIND IT USEFULL**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stk = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!stk.isEmpty() && stk.peek()==s.charAt(i))\\n                stk.pop();\\n            else\\n                stk.push(s.charAt(i));\\n        }\\n        \\n        for(Character c : stk)\\n            sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048019,
                "title": "java-no-stack-solution-o-n-single-pass",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n       StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n       for(char ch : S.toCharArray()){\\n           if(sb.length() == 0){\\n               sb.append(ch);\\n              \\n           }\\n           else{\\n               if(sb.charAt(index-1) == ch){\\n                   sb.deleteCharAt(index-1);\\n               }\\n               else{\\n                   sb.append(ch);\\n               }\\n           }\\n            index = sb.length();\\n           }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String S) {\\n       StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n       for(char ch : S.toCharArray()){\\n           if(sb.length() == 0){\\n               sb.append(ch);\\n              \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 581643,
                "title": "swift",
                "content": "```\\n    func removeDuplicates(_ S: String) -> String {\\n        var stack = [Character]()\\n        for char in S {\\n            if let last = stack.last, last == char {\\n                stack.removeLast()\\n            } else {\\n                stack.append(char)\\n            }\\n        }\\n        return String(stack)\\n    }",
                "solutionTags": [],
                "code": "```\\n    func removeDuplicates(_ S: String) -> String {\\n        var stack = [Character]()\\n        for char in S {\\n            if let last = stack.last, last == char {\\n                stack.removeLast()\\n            } else {\\n                stack.append(char)\\n            }\\n        }\\n        return String(stack)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 496072,
                "title": "c-regex-vs-stack-solution-100-time-100-space",
                "content": "I know it sucks, just wanted to play with regexes in C++ for the sake of getting familiar with them in this language as well :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    regex r = regex(\"(.)\\\\\\\\1\");\\n    \\n    string removeDuplicates(string s) {\\n        string oldS, newS = s;\\n        while (oldS != newS) {\\n            oldS = newS;\\n            newS = regex_replace(oldS, r, \"\");\\n        }\\n        return newS;\\n    }\\n};\\n```\\n\\n1.5 years later, a nicer one using the result string directly as a stack:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // support variables\\n        string res = \"\";\\n        // parsing s \\n        for (char c: s) {\\n            // case 1: c is not a duplicate\\n            if (!res.size() || res.back() != c) res.push_back(c);\\n            // case 2: c is a duplicate\\n            else res.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    regex r = regex(\"(.)\\\\\\\\1\");\\n    \\n    string removeDuplicates(string s) {\\n        string oldS, newS = s;\\n        while (oldS != newS) {\\n            oldS = newS;\\n            newS = regex_replace(oldS, r, \"\");\\n        }\\n        return newS;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // support variables\\n        string res = \"\";\\n        // parsing s \\n        for (char c: s) {\\n            // case 1: c is not a duplicate\\n            if (!res.size() || res.back() != c) res.push_back(c);\\n            // case 2: c is a duplicate\\n            else res.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878712,
                "title": "easy-two-pointer-solution",
                "content": "\\n# Approach\\nInitialize two pointers, i and j, both pointing to the first and second characters of the string s, respectively.\\n\\nUse a while loop to iterate through the string while j is within the valid index range (0 to s.length() - 1).\\n\\nCheck if the characters at indices i and j are the same. If they are, it means we have found a duplicate pair.\\n\\nWhen a duplicate pair is found, use the erase function to remove both characters from the string s. Since the erase function modifies the string in place, the characters at indices i and j will be removed.\\n\\nAdjust the pointers i and j to continue searching for adjacent duplicates:\\n\\nMove i one step back (i = max(0, i - 1)) to check if there are any duplicates before the previously deleted pair.\\nMove j one step back (j = max(1, j - 1)) to continue the search from the updated position of i.\\nIf the characters at indices i and j are different, move both pointers i and j one step forward to check the next pair of characters.\\n\\nRepeat steps 3 to 6 until all characters in the string have been checked.\\n\\nReturn the updated string after all adjacent duplicates have been removed.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s)\\n    {\\n        int i = 0;\\n        int j = 1;\\n        while (j < s.length())\\n        {\\n            if (s[i] == s[j])\\n            {\\n                s.erase(i, 2);\\n                i = max(0, i - 1);\\n                j = max(1, j - 1);\\n            } \\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s)\\n    {\\n        int i = 0;\\n        int j = 1;\\n        while (j < s.length())\\n        {\\n            if (s[i] == s[j])\\n            {\\n                s.erase(i, 2);\\n                i = max(0, i - 1);\\n                j = max(1, j - 1);\\n            } \\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800038,
                "title": "easy-explained-solution-c-with-without-stack-stl",
                "content": "## Approach without stack STL [explained in code]\\n\\nThis is a better approach than using stack STL, as the string t used here acts as a stack too.\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create another string t\\n        string t;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in string t we add the current character to t\\n            // but if the last character added to string t is same as the current character from string t\\n            // we have to remove it\\n            if (!t.empty() && t.back()==x) t.pop_back();\\n            else t.push_back(x);\\n        }\\n\\n        // and finally we return the string t\\n        return t;\\n    }\\n};\\n```\\n\\n## Approach using stack STL [explained in code]\\n\\nThis process involves using stack STL and the unnecessary extra steps to put all the characters in stack and then back in string again uses more time.\\n\\nI\\'m putting this up here for the sole sake of your understanding.\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create stack st\\n        stack<char> st;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in stack st we add the current character to st\\n            // but if the last character added to stack st is same as the current character from stack st\\n            // we have to remove it\\n            if (!st.empty() && st.top()==x) st.pop();\\n            else st.push(x);\\n        }\\n\\n        // now we\\'re going to write s from scratch so clean it up\\n        s = \"\";\\n\\n        // while stack isn\\'t empty let\\'s create string s\\n        while (!st.empty()) s=st.top()+s, st.pop();\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create another string t\\n        string t;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in string t we add the current character to t\\n            // but if the last character added to string t is same as the current character from string t\\n            // we have to remove it\\n            if (!t.empty() && t.back()==x) t.pop_back();\\n            else t.push_back(x);\\n        }\\n\\n        // and finally we return the string t\\n        return t;\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create stack st\\n        stack<char> st;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in stack st we add the current character to st\\n            // but if the last character added to stack st is same as the current character from stack st\\n            // we have to remove it\\n            if (!st.empty() && st.top()==x) st.pop();\\n            else st.push(x);\\n        }\\n\\n        // now we\\'re going to write s from scratch so clean it up\\n        s = \"\";\\n\\n        // while stack isn\\'t empty let\\'s create string s\\n        while (!st.empty()) s=st.top()+s, st.pop();\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800035,
                "title": "stack-java-easy-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\nWe compare our string character with the stack topmost element if both are same we remove the element from stack and move forward or else we just push that element too into the stack.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- N-> length of string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n-  N-> length of String\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0));\\n        for(int i = 1; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek() == s.charAt(i)){\\n                st.pop(); continue;\\n            }\\n            st.push(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return String.valueOf(sb.reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0));\\n        for(int i = 1; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek() == s.charAt(i)){\\n                st.pop(); continue;\\n            }\\n            st.push(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return String.valueOf(sb.reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741398,
                "title": "java-11-ms-faster-than-92-89",
                "content": "If you like it pls upvote\\n```\\n\\n    public String removeDuplicates(String s) {\\n        StringBuilder stb = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (stb.length() == 0) {\\n                stb.append(s.charAt(i));\\n            } else if (s.charAt(i) == stb.charAt(count)) {\\n                stb.deleteCharAt(count);\\n                if (count!=0) count--;\\n            } else {\\n                stb.append(s.charAt(i));\\n                count++;\\n            }\\n        }\\n        return stb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public String removeDuplicates(String s) {\\n        StringBuilder stb = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (stb.length() == 0) {\\n                stb.append(s.charAt(i));\\n            } else if (s.charAt(i) == stb.charAt(count)) {\\n                stb.deleteCharAt(count);\\n                if (count!=0) count--;\\n            } else {\\n                stb.append(s.charAt(i));\\n                count++;\\n            }\\n        }\\n        return stb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653948,
                "title": "java-explained-with-pictures-two-pointers-solution",
                "content": "```\\n public String removeDuplicates(String s) {\\n        //declare i outside of for loop so we can use it as upper bound for our final result\\n        int i = 0;\\n\\t\\t//conver string to array of characters\\n        char[] res = s.toCharArray();\\n       \\n        for (int j = 0; j < s.length(); ++j, ++i) {\\n\\t\\t    //this line will update array only in case if duplictae is found \\n\\t\\t\\t//otherwise i = to j so nothing will change \\n            res[i] = res[j];\\n\\t\\t\\t//check if previous value euals to current \\n            if (i > 0 && res[i - 1] == res[i]) \\n\\t\\t\\t   //reset i to the position before duplicate \\n                i -= 2;\\n        }\\n       \\n        // string from 0 - to i because rest of the array contains garbage\\n       //we moved all non-duplicate values to the begining of arr\\n        return new String(res, 0, i);\\n    }\\n```\\n\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/bfc233c8-3654-4cbe-bdb5-7a1dfc854d4a_1640752465.0941455.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String removeDuplicates(String s) {\\n        //declare i outside of for loop so we can use it as upper bound for our final result\\n        int i = 0;\\n\\t\\t//conver string to array of characters\\n        char[] res = s.toCharArray();\\n       \\n        for (int j = 0; j < s.length(); ++j, ++i) {\\n\\t\\t    //this line will update array only in case if duplictae is found \\n\\t\\t\\t//otherwise i = to j so nothing will change \\n            res[i] = res[j];\\n\\t\\t\\t//check if previous value euals to current \\n            if (i > 0 && res[i - 1] == res[i]) \\n\\t\\t\\t   //reset i to the position before duplicate \\n                i -= 2;\\n        }\\n       \\n        // string from 0 - to i because rest of the array contains garbage\\n       //we moved all non-duplicate values to the begining of arr\\n        return new String(res, 0, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562458,
                "title": "best-c-solution-5line-code-faster-than-99-users-time-o-n",
                "content": "Solution is very easy dont need and explanation. If still comment down below.\\n\\nHope you like my solution. If yes Upvote so that others can also get help.\\n\\nThanks for your time.\\n\\n    string removeDuplicates(string s) {\\n        vector<char> out;\\n        int i;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(!out.empty() && out.back()==s[i] )\\n                out.pop_back();\\n            else\\n                out.push_back(s[i]);\\n        }\\n        string ans(out.begin(),out.end());\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Solution is very easy dont need and explanation. If still comment down below.\\n\\nHope you like my solution. If yes Upvote so that others can also get help.\\n\\nThanks for your time.\\n\\n    string removeDuplicates(string s) {\\n        vector<char> out;\\n        int i;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(!out.empty() && out.back()==s[i] )\\n                out.pop_back();\\n            else\\n                out.push_back(s[i]);\\n        }\\n        string ans(out.begin(),out.end());\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1459061,
                "title": "python-using-stack-easy-to-understand",
                "content": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\tstk = []\\n\\tfor i in s:\\n\\t\\tif(len(stk) == 0):\\n\\t\\t\\tstk.append(i)\\n\\t\\telif(stk[-1] == i):\\n\\t\\t\\tstk.pop()\\n\\t\\telse:\\n\\t\\t\\tstk.append(i)\\n\\n\\treturn \"\".join(stk)\\n```\\n\\nUpvote if liked",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\tstk = []\\n\\tfor i in s:\\n\\t\\tif(len(stk) == 0):\\n\\t\\t\\tstk.append(i)\\n\\t\\telif(stk[-1] == i):\\n\\t\\t\\tstk.pop()\\n\\t\\telse:\\n\\t\\t\\tstk.append(i)\\n\\n\\treturn \"\".join(stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 977142,
                "title": "java-simple-using-stack-char-array",
                "content": "```\\npublic String removeDuplicates(String S) \\n{\\n\\tStack<Character> stackWithoutDupl = new Stack();\\n\\n\\tfor(char letter : S.toCharArray())\\n\\t{\\n\\t\\tif(stackWithoutDupl.isEmpty() || stackWithoutDupl.peek() != letter)\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.push(letter);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tchar[] result = new char[stackWithoutDupl.size()];\\n\\tfor(int i = result.length -1; i >= 0; i--)\\n\\t{\\n\\t\\tresult[i] = stackWithoutDupl.pop();\\n\\t}\\n\\n\\treturn new String(result);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeDuplicates(String S) \\n{\\n\\tStack<Character> stackWithoutDupl = new Stack();\\n\\n\\tfor(char letter : S.toCharArray())\\n\\t{\\n\\t\\tif(stackWithoutDupl.isEmpty() || stackWithoutDupl.peek() != letter)\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.push(letter);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tchar[] result = new char[stackWithoutDupl.size()];\\n\\tfor(int i = result.length -1; i >= 0; i--)\\n\\t{\\n\\t\\tresult[i] = stackWithoutDupl.pop();\\n\\t}\\n\\n\\treturn new String(result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905247,
                "title": "two-pointer-solution-clean-code",
                "content": "We can use two-pointer method to solve this problem. We can set a pointer p to point the next index of current substring:\\n**1. If there are no 2 same adjacent characters, then we move p forward along with i;\\n2. else, we move back for 1 step since we need to remove those 2 same adjacent characters!**\\n\\n```\\n    public String removeDuplicates(String S) {\\n        char[] ch = S.toCharArray();\\n        int len = S.length(), p = 0; // p as a pointer, to point the next index of current substring.\\n        for (int i=0; i<len; i++) {\\n            if (p == 0 || ch[i] != ch[p-1]) {\\n                ch[p++] = ch[i];\\n            } else {\\n                p--;\\n            }\\n        }\\n        return String.valueOf(ch).substring(0, p);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        char[] ch = S.toCharArray();\\n        int len = S.length(), p = 0; // p as a pointer, to point the next index of current substring.\\n        for (int i=0; i<len; i++) {\\n            if (p == 0 || ch[i] != ch[p-1]) {\\n                ch[p++] = ch[i];\\n            } else {\\n                p--;\\n            }\\n        }\\n        return String.valueOf(ch).substring(0, p);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378367,
                "title": "java-double-ended-queue-no-stack-explained-7ms",
                "content": "For this task we can use stack and analyse last seen char with current. But this approach has one tradeoff - added chars are in reverse order so we need to reverse it at the end. To avoid this we can use double ended queue - add chars at the end, but read it from the head for the final string.\\nThis leads to solution below.\\nO(n) time and space - read ever char 2 times when checking for duplicates and then form result string. Also we need O(n) space for the deque.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deq = new LinkedList();\\n        //iterate over the chars in string\\n        for (char ch : S.toCharArray()) {\\n            //check if the last char we checked is equal to the current one\\n            //if so - don\\'t add current and remove that previosuly added\\n            //else add char to the stack\\n            if (!deq.isEmpty() && deq.peekLast() == ch) {\\n                deq.pollLast();\\n            } else {\\n                deq.addLast(ch);\\n            }\\n        }\\n        //form the result string by polling from the stack in reversed order\\n        char[] strArr = new char[deq.size()];\\n        for (int i = 0; i < strArr.length; i++) {\\n            strArr[i] = deq.pollFirst();\\n        }  \\n        return new String(strArr);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deq = new LinkedList();\\n        //iterate over the chars in string\\n        for (char ch : S.toCharArray()) {\\n            //check if the last char we checked is equal to the current one\\n            //if so - don\\'t add current and remove that previosuly added\\n            //else add char to the stack\\n            if (!deq.isEmpty() && deq.peekLast() == ch) {\\n                deq.pollLast();\\n            } else {\\n                deq.addLast(ch);\\n            }\\n        }\\n        //form the result string by polling from the stack in reversed order\\n        char[] strArr = new char[deq.size()];\\n        for (int i = 0; i < strArr.length; i++) {\\n            strArr[i] = deq.pollFirst();\\n        }  \\n        return new String(strArr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336940,
                "title": "python-3-using-regex",
                "content": "It\\'s not the most efficient, but it\\'s pretty simple.\\n\\n```\\nimport re\\n\\nclass Solution:\\n  def removeDuplicates(self, S: str) -> str:\\n    last = None\\n    while last != S:\\n      last, S = S, re.sub(r\\'(.)\\\\1\\', \\'\\', S)\\n    return S\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\n\\nclass Solution:\\n  def removeDuplicates(self, S: str) -> str:\\n    last = None\\n    while last != S:\\n      last, S = S, re.sub(r\\'(.)\\\\1\\', \\'\\', S)\\n    return S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584200,
                "title": "easy-approach-using-stack-beginners-friendly",
                "content": "**T.C =O(N)\\nS.C =O(N) Because of stack**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==st.top()){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e93c3100-4795-4d44-a542-fc2fb2572896_1685588124.7269132.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==st.top()){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553532,
                "title": "easy-approach-c",
                "content": "# Don\\'t Feel Demotivating during watching the solution You are the _STAR_ and you can do it very well and you are able to crack every Problem in the future (INSHALLAH)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       string Result=\"\";\\n       Result=s[0];\\n       for( int i=1;i<s.size();i++){\\n         if(s[i]==Result.back()){\\n          Result.pop_back();\\n         }\\n         else {\\n           Result.push_back(s[i]);\\n         }\\n       }\\n       return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       string Result=\"\";\\n       Result=s[0];\\n       for( int i=1;i<s.size();i++){\\n         if(s[i]==Result.back()){\\n          Result.pop_back();\\n         }\\n         else {\\n           Result.push_back(s[i]);\\n         }\\n       }\\n       return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307093,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n            if(ans.length()>0&&ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n           i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n            if(ans.length()>0&&ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n           i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801475,
                "title": "c-faster-than-90-stack-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs its clearly mentioned the adjacent were to delete and if we delete any middle sequence it might be possible for the case to give another sequesnce consisting of first element so, stack was the best possible data structure I could think about.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst -- pushing the first element inti the stack,\\nsecondly-- checking if the upcomming elemnt is equal to the top of the stack if true pop() the top and move forwrd.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\nP.S : there is no need of the while loop you can ommit it and just pop() the top element. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799597,
                "title": "easy-to-understand-c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Use Of Stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<int> p;\\n        p.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!p.empty()){\\n                if(s[i]==p.top()){\\n                    p.pop();\\n                }\\n                else{\\n                    p.push(s[i]);\\n                }\\n            }\\n            else{\\n                p.push(s[i]);\\n            }\\n        }\\n        string r;\\n        while(!p.empty()){\\n            r+=p.top();\\n            p.pop();\\n        }\\n        reverse(r.begin(), r.end());\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<int> p;\\n        p.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!p.empty()){\\n                if(s[i]==p.top()){\\n                    p.pop();\\n                }\\n                else{\\n                    p.push(s[i]);\\n                }\\n            }\\n            else{\\n                p.push(s[i]);\\n            }\\n        }\\n        string r;\\n        while(!p.empty()){\\n            r+=p.top();\\n            p.pop();\\n        }\\n        reverse(r.begin(), r.end());\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798675,
                "title": "c-three-simple-solutions-with-and-without-stack",
                "content": "# Code 1 : with stack\\n# Complexity\\n- Time complexity: O(N) Traverse each char from string\\n- Space complexity: O(N) Using stack \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n\\n        for(char i: s){\\n            if(st.empty() or i != st.top()) st.push(i);\\n\\n            else\\n                st.pop();\\n        }\\n\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code 2 : without stack\\n# Complexity\\n- Time complexity: O(N) Traverse each char from string\\n- Space complexity: O(1) \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==0 or ans.back() != s[i]) \\n                ans+= s[i];\\n\\n            else if(ans.back()==s[i]) \\n                ans.pop_back();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code 3 : without stack\\n\\n# Complexity\\n- Time complexity: O(N*N) Traverse each char from string\\n             extra O(N) because of erase function.\\n- Space complexity: O(1) \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int n= s.size();\\n\\n        while(i<n){\\n            if(s[i]==s[i+1]){\\n                s.erase(s.begin()+i); \\n                s.erase(s.begin()+i);\\n\\n                if(i>0) i--;\\n\\n                n= s.size();\\n            }\\n\\n            else i++;\\n        }      \\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n\\n        for(char i: s){\\n            if(st.empty() or i != st.top()) st.push(i);\\n\\n            else\\n                st.pop();\\n        }\\n\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==0 or ans.back() != s[i]) \\n                ans+= s[i];\\n\\n            else if(ans.back()==s[i]) \\n                ans.pop_back();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int n= s.size();\\n\\n        while(i<n){\\n            if(s[i]==s[i+1]){\\n                s.erase(s.begin()+i); \\n                s.erase(s.begin()+i);\\n\\n                if(i>0) i--;\\n\\n                n= s.size();\\n            }\\n\\n            else i++;\\n        }      \\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798396,
                "title": "easy-solution-using-stack",
                "content": "this problem is similar to\\nhttps://leetcode.com/problems/make-the-string-great/solutions/2790887/daily-leetcoding-challenge-november-8-o-n-t-c/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n//if stack is empty push the element into stack\\n            if(st.empty())\\n                st.push(s[i]);\\n            else \\n//else check top element of stack is same of currunt element or not\\n//if yes pop top elemnt and ignore this element (dont push into stack)\\n                if(st.top()==s[i])\\n                    st.pop();\\n                else\\n//otherwise push into the stack\\n                   st.push(s[i]);\\n        }\\n         while(!st.empty()){\\n             ans+=st.top();\\n             st.pop();\\n         }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n//if stack is empty push the element into stack\\n            if(st.empty())\\n                st.push(s[i]);\\n            else \\n//else check top element of stack is same of currunt element or not\\n//if yes pop top elemnt and ignore this element (dont push into stack)\\n                if(st.top()==s[i])\\n                    st.pop();\\n                else\\n//otherwise push into the stack\\n                   st.push(s[i]);\\n        }\\n         while(!st.empty()){\\n             ans+=st.top();\\n             st.pop();\\n         }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798201,
                "title": "simple-c-solution-using-stack",
                "content": "```\\nstring removeDuplicates(string s)\\n    {\\n        stack<char>vishwas;\\n       for(int i=0;i<(s.size());i++)\\n       {\\n          int flag=1;\\n           while(!vishwas.empty() && vishwas.top()==s[i])\\n           {\\n              vishwas.pop();\\n               flag=0;\\n           }\\n           if(flag==1)\\n           {\\n               vishwas.push(s[i]);\\n           }\\n   \\n     \\n       }\\n                s=\"\";\\n          while(!vishwas.empty())\\n          {\\n              s+=vishwas.top();\\n              vishwas.pop();\\n          }\\n           reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nstring removeDuplicates(string s)\\n    {\\n        stack<char>vishwas;\\n       for(int i=0;i<(s.size());i++)\\n       {\\n          int flag=1;\\n           while(!vishwas.empty() && vishwas.top()==s[i])\\n           {\\n              vishwas.pop();\\n               flag=0;\\n           }\\n           if(flag==1)\\n           {\\n               vishwas.push(s[i]);\\n           }\\n   \\n     \\n       }\\n                s=\"\";\\n          while(!vishwas.empty())\\n          {\\n              s+=vishwas.top();\\n              vishwas.pop();\\n          }\\n           reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798115,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798005,
                "title": "daily-leetcoding-challenge-november-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Replace\n\n  \n**Approach 2:** Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2594691,
                "title": "easy-and-simple-java-code-using-stack-and-stringbuilder-easy-to-understand",
                "content": "```\\npublic String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2556870,
                "title": "js-with-explanation-easy-to-understand-fast",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1047-remove-all-adjacent-duplicates-in.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n   const stack = [];\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tconst cv = s[i];\\n\\t\\tconst top = stack[stack.length - 1];\\n\\n\\t\\t// if last element is same as current pop off from stack\\n\\t\\tif (cv === top) stack.pop();\\n\\t\\telse stack.push(cv); // if not equal, add to stack\\n\\t}\\n\\n\\treturn stack.join(\\'\\');\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n   const stack = [];\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tconst cv = s[i];\\n\\t\\tconst top = stack[stack.length - 1];\\n\\n\\t\\t// if last element is same as current pop off from stack\\n\\t\\tif (cv === top) stack.pop();\\n\\t\\telse stack.push(cv); // if not equal, add to stack\\n\\t}\\n\\n\\treturn stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329168,
                "title": "python-solution",
                "content": "* Runtime: 64 ms, faster than 92.95% of Python online submissions for Remove All Adjacent Duplicates In String.\\n* Memory Usage: 14.3 MB, less than 92.19% of Python online submissions for Remove All Adjacent Duplicates In String\\n\\n class Solution(object):\\n    \\n\\tdef removeDuplicates(self, s):\\n        \\n        stack =[]\\n\\n        for char in s:\\n            if stack and char == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(char)           \\n\\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python"
                ],
                "code": "* Runtime: 64 ms, faster than 92.95% of Python online submissions for Remove All Adjacent Duplicates In String.\\n* Memory Usage: 14.3 MB, less than 92.19% of Python online submissions for Remove All Adjacent Duplicates In String\\n\\n class Solution(object):\\n    \\n\\tdef removeDuplicates(self, s):\\n        \\n        stack =[]\\n\\n        for char in s:\\n            if stack and char == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(char)           \\n\\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 2303295,
                "title": "c-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        ans = ans + s[0];\\n        for (int i=1; i<s.length(); i++) {\\n            if (s[i]==ans.back()) {\\n                ans.pop_back();\\n            }\\n            else {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        ans = ans + s[0];\\n        for (int i=1; i<s.length(); i++) {\\n            if (s[i]==ans.back()) {\\n                ans.pop_back();\\n            }\\n            else {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177959,
                "title": "java-simple-logic-and-less-code",
                "content": "# Please Upvote IF You Find This Helpful\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (!st.empty() && st.peek() == s.charAt(i)) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        while (!st.empty()) ans.append(st.pop());\\n        return ans.reverse().toString();\\n    }\\n}\\n```\\n# Please Upvote IF You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (!st.empty() && st.peek() == s.charAt(i)) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        while (!st.empty()) ans.append(st.pop());\\n        return ans.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825701,
                "title": "c-easy-solution-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n     for(int i=0;i<s.length();i++)\\n     {\\n         \\n         if(s[i]==s[i+1])\\n         {\\n             s.erase(i,2);\\n             if(i==0)\\n             i=-1;\\n             else\\n             i=i-2;\\n         }\\n         \\n     }\\n        return s;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n     for(int i=0;i<s.length();i++)\\n     {\\n         \\n         if(s[i]==s[i+1])\\n         {\\n             s.erase(i,2);\\n             if(i==0)\\n             i=-1;\\n             else\\n             i=i-2;\\n         }\\n         \\n     }\\n        return s;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727513,
                "title": "simple-c-solution-one-pass-where-we-use-string-as-a-stack",
                "content": "Using string as a stack prevents the need for reversing which happens if we use a stack.\\nSince the output string is not counted in space complexity, the space complexity for the below code is O(1)\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(ans.length()==0 || ans.back()!=s[i])\\n            {\\n               ans.push_back(s[i]);\\n               continue;\\n            }\\n            while(ans.length() >0 && ans.back() == s[i])\\n            {\\n                ans.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(ans.length()==0 || ans.back()!=s[i])\\n            {\\n               ans.push_back(s[i]);\\n               continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1585958,
                "title": "python-solution-memory-usage-beats-97",
                "content": "In this code we compare the current value with the previous value .\\nFor better understanding remove the \"#\" commented part .\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        first=1\\n        last=len(s)\\n        while(first<last):\\n            if(s[first]==s[first-1]):\\n                s=s.replace(s[first-1:first+1],\"\")\\n                if(first>1):\\n                    first=first-1\\n            else:\\n                first+=1\\n            last=len(s)\\n\\t\\t\\t#print(s,first,last)\\n        return(s)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        first=1\\n        last=len(s)\\n        while(first<last):\\n            if(s[first]==s[first-1]):\\n                s=s.replace(s[first-1:first+1],\"\")\\n                if(first>1):\\n                    first=first-1\\n            else:\\n                first+=1\\n            last=len(s)\\n\\t\\t\\t#print(s,first,last)\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497407,
                "title": "deque-solution-tc-o-n",
                "content": "```\\nstring removeDuplicates(string s) {\\n        deque<char> q;\\n        string res;\\n        for(int i=0;i<s.length();i++) {\\n            if(!q.empty() && q.back()==s[i])  //when q.back is same as the current char\\n                q.pop_back();\\n            else\\n                q.push_back(s[i]);  //when q is empty or when char at q back !=s[i]\\n        }\\n\\t\\t//Concatenate chars in q from front to back\\n        while(!q.empty()){\\n            res+=q.front();\\n            q.pop_front();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n        deque<char> q;\\n        string res;\\n        for(int i=0;i<s.length();i++) {\\n            if(!q.empty() && q.back()==s[i])  //when q.back is same as the current char\\n                q.pop_back();\\n            else\\n                q.push_back(s[i]);  //when q is empty or when char at q back !=s[i]\\n        }\\n\\t\\t//Concatenate chars in q from front to back\\n        while(!q.empty()){\\n            res+=q.front();\\n            q.pop_front();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307206,
                "title": "javascript-stack-oriented-elegant-solution",
                "content": "\\tconst stack = [];\\n\\tfor(let letter of s) {\\n        let stackLastEl = stack[stack.length - 1]; //b\\n        if (letter === stackLastEl) {\\n            stack.pop();\\n            continue;\\n        }\\n\\n        stack.push(letter);\\n    }\\n\\n    return stack.join(\\'\\');",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "\\tconst stack = [];\\n\\tfor(let letter of s) {\\n        let stackLastEl = stack[stack.length - 1]; //b\\n        if (letter === stackLastEl) {\\n            stack.pop();\\n            continue;\\n        }\\n\\n        stack.push(letter);\\n    }\\n\\n    return stack.join(\\'\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1303191,
                "title": "remove-all-adjacent-duplicates-in-string-python-comments",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        arr = [i for i in s]            # Make an array of chars from the string \\'s\\'\\n        found = True                    # Initialize a var \\'found\\' to \\'True\\'\\n        \\n        while found:                    # Traverse until \\'found\\' is \\'True\\'\\n            \\n            found = False               # Change the value of \\'found\\' to \\'False\\'\\n            i = 0                       # A var to traverse the array \\'arr\\'\\n            \\n            while i < len(arr)-1:       # Traverse till the 2nd last element of \\'arr\\'\\n                \\n                if arr[i] == arr[i+1]:  # If any duplicate adjacent chars are found\\n                    del arr[i]          # Delete the ith char\\n                    del arr[i]          # Delete the i+1 th char\\n                    found = True        # Change the value of \\'found\\' to \\'True\\'\\n                    continue            # Skip the rest of the loop\\n                    \\n                i += 1                  # Else, Increase \\'i\\' to move to the next index\\n        \\n        s = \"\"                          # Take an empty string to create the resultant string\\n        for i in arr:                   # For each remaining char in the array, \\'arr\\'\\n            s += i                      # Append it to the resultant string, \\'s\\'\\n            \\n        return s                        # Finally, return the resultant string, \\'s\\'\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        arr = [i for i in s]            # Make an array of chars from the string \\'s\\'\\n        found = True                    # Initialize a var \\'found\\' to \\'True\\'\\n        \\n        while found:                    # Traverse until \\'found\\' is \\'True\\'\\n            \\n            found = False               # Change the value of \\'found\\' to \\'False\\'\\n            i = 0                       # A var to traverse the array \\'arr\\'\\n            \\n            while i < len(arr)-1:       # Traverse till the 2nd last element of \\'arr\\'\\n                \\n                if arr[i] == arr[i+1]:  # If any duplicate adjacent chars are found\\n                    del arr[i]          # Delete the ith char\\n                    del arr[i]          # Delete the i+1 th char\\n                    found = True        # Change the value of \\'found\\' to \\'True\\'\\n                    continue            # Skip the rest of the loop\\n                    \\n                i += 1                  # Else, Increase \\'i\\' to move to the next index\\n        \\n        s = \"\"                          # Take an empty string to create the resultant string\\n        for i in arr:                   # For each remaining char in the array, \\'arr\\'\\n            s += i                      # Append it to the resultant string, \\'s\\'\\n            \\n        return s                        # Finally, return the resultant string, \\'s\\'\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303019,
                "title": "rust-solution-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(s: String) -> String {\\n        s.chars()\\n            .fold(Vec::new(), |mut stack, c| {\\n                if stack.last() == Some(&c) {\\n                    stack.pop();\\n                } else {\\n                    stack.push(c);\\n                }\\n                stack\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(s: String) -> String {\\n        s.chars()\\n            .fold(Vec::new(), |mut stack, c| {\\n                if stack.last() == Some(&c) {\\n                    stack.pop();\\n                } else {\\n                    stack.push(c);\\n                }\\n                stack\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302424,
                "title": "remove-all-adjacent-duplicates-in-string-python-simple-solution",
                "content": "```\\n\\nclass Solution(object):\\n    def removeDuplicates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        for i in range(len(s)):\\n            if ans==\"\" or ans[-1] != s[i]:\\n                ans+=s[i]\\n            elif ans[-1] == s[i]:\\n                ans=ans[:-1]        \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def removeDuplicates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        for i in range(len(s)):\\n            if ans==\"\" or ans[-1] != s[i]:\\n                ans+=s[i]\\n            elif ans[-1] == s[i]:\\n                ans=ans[:-1]        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302331,
                "title": "c-without-stack-with-stack-2-approach-o-n",
                "content": "**Withou Using Stack**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(ans.size())\\n            {\\n                if(ans[ans.size()-1]==s[i])\\n                {\\n                    ans.pop_back();\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Stack Based Approach**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!st.empty())\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n*If find HelpFul then Upvote* **:)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(ans.size())\\n            {\\n                if(ans[ans.size()-1]==s[i])\\n                {\\n                    ans.pop_back();\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!st.empty())\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046953,
                "title": "python-using-stacks",
                "content": "```\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S: return s\\n        stack = []\\n        for ch in S:\\n            if stack and stack[-1]==ch: \\n                stack.pop()\\n                continue\\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S: return s\\n        stack = []\\n        for ch in S:\\n            if stack and stack[-1]==ch: \\n                stack.pop()\\n                continue\\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899822,
                "title": "python-3-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        _stack=[]                                     #initilized a new stack\\n        for s in S:                                   #looping over the characters in S\\n            if len(_stack)==0:                        #checking if the stack is empty \\n                _stack.append(s)                      #if its empty it will append the character in string S\\n            else:\\n                char=_stack[len(_stack)-1]            #top element of stack is copied to char\\n                if s==char:                           #checking if the top char is same as the current char\\n                    _stack.pop()                      # both are same the char is poped form the stack\\n                else:\\n                    _stack.append(s)                  #else will append the char to the top of the stack\\n        return \"\".join(_stack)                        #this will return the list as a string\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        _stack=[]                                     #initilized a new stack\\n        for s in S:                                   #looping over the characters in S\\n            if len(_stack)==0:                        #checking if the stack is empty \\n                _stack.append(s)                      #if its empty it will append the character in string S\\n            else:\\n                char=_stack[len(_stack)-1]            #top element of stack is copied to char\\n                if s==char:                           #checking if the top char is same as the current char\\n                    _stack.pop()                      # both are same the char is poped form the stack\\n                else:\\n                    _stack.append(s)                  #else will append the char to the top of the stack\\n        return \"\".join(_stack)                        #this will return the list as a string\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 882142,
                "title": "ruby-stack",
                "content": "```\\ndef remove_duplicates(s)\\n  stack = []\\n  s.each_char do |c|\\n    if stack[-1] == c\\n      stack.pop\\n    else\\n      stack << c\\n    end\\n  end\\n  stack.join\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef remove_duplicates(s)\\n  stack = []\\n  s.each_char do |c|\\n    if stack[-1] == c\\n      stack.pop\\n    else\\n      stack << c\\n    end\\n  end\\n  stack.join\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 813459,
                "title": "java-one-pass-stringbuilder",
                "content": "\\tclass Solution {\\n\\t\\tpublic String removeDuplicates(String S) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\t\\t\\tif(sb.length() == 0 || sb.charAt(sb.length()-1) != S.charAt(i)){\\n\\t\\t\\t\\t\\tsb.append(S.charAt(i));\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.deleteCharAt(sb.length()-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String removeDuplicates(String S) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\t\\t\\tif(sb.length() == 0 || sb.charAt(sb.length()-1) != S.charAt(i)){\\n\\t\\t\\t\\t\\tsb.append(S.charAt(i));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 757187,
                "title": "javascript-simple-recursive-solution-93-faster",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    if (S.match(/(.)\\\\1/g)) {\\n        return removeDuplicates(S.replace(/(.)\\\\1/g, \\'\\'));\\n    }\\n\\n    return S;\\n};\\n```\\n\\nStats:\\nRuntime: 80 ms, faster than 93.20% of JavaScript online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 39.4 MB, less than 100.00% of JavaScript online submissions for Remove All Adjacent Duplicates In String.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    if (S.match(/(.)\\\\1/g)) {\\n        return removeDuplicates(S.replace(/(.)\\\\1/g, \\'\\'));\\n    }\\n\\n    return S;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708930,
                "title": "c-very-simple-solution-fast-and-low-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string &S) {\\n        string s;\\n        for (char &c : S)\\n            (!s.empty() && s.back() == c)? s.pop_back() : s.push_back(c);\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string &S) {\\n        string s;\\n        for (char &c : S)\\n            (!s.empty() && s.back() == c)? s.pop_back() : s.push_back(c);\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607379,
                "title": "swift-144ms-84-21-21mb-100",
                "content": "```\\nfunc removeDuplicates(_ S: String) -> String {\\n        var result: String = \"\"\\n        \\n        for char in S {\\n            if result.isEmpty {\\n                result += String(char)\\n            }\\n            else if let peek = result.last {\\n                if char == peek {\\n                    result.removeLast()\\n                }\\n                else {\\n                    result += String(char)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc removeDuplicates(_ S: String) -> String {\\n        var result: String = \"\"\\n        \\n        for char in S {\\n            if result.isEmpty {\\n                result += String(char)\\n            }\\n            else if let peek = result.last {\\n                if char == peek {\\n                    result.removeLast()\\n                }\\n                else {\\n                    result += String(char)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459740,
                "title": "python-o-n-solution-based-on-stack-run-time-90",
                "content": "Python O( n ) solution based on stack, run time 90%+\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        \\n        char_stack = []\\n        \\n        for char  in S:\\n            \\n            if char_stack and char_stack[-1] == char:\\n                # top of stack is the same as next character\\n                # eliminate duplicates \\n                char_stack.pop()  \\n                \\n            else:\\n                # no adjacent repetition characters\\n                # push next character into stack\\n                char_stack.append( char )\\n            \\n            \\n        return \\'\\'.join(char_stack)\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        \\n        char_stack = []\\n        \\n        for char  in S:\\n            \\n            if char_stack and char_stack[-1] == char:\\n                # top of stack is the same as next character\\n                # eliminate duplicates \\n                char_stack.pop()  \\n                \\n            else:\\n                # no adjacent repetition characters\\n                # push next character into stack\\n                char_stack.append( char )\\n            \\n            \\n        return \\'\\'.join(char_stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302723,
                "title": "c-c-solution-with-stack",
                "content": "```\\nchar * removeDuplicates(char * S){\\n    int len = strlen(S);\\n    \\n    if(len <= 0){\\n        return S;\\n    }\\n    \\n    char* chars = (char *)malloc(len+1);\\n    int top = -1;\\n    \\n    for ( int i = 0; i < len ; i++ ){\\n        if(top < 0 || chars[top] != S[i] ){\\n            chars[++top] = S[i];\\n        }else{\\n            top--;\\n        }\\n    }\\n    chars[++top] = \\'\\\\0\\';\\n    return chars;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * removeDuplicates(char * S){\\n    int len = strlen(S);\\n    \\n    if(len <= 0){\\n        return S;\\n    }\\n    \\n    char* chars = (char *)malloc(len+1);\\n    int top = -1;\\n    \\n    for ( int i = 0; i < len ; i++ ){\\n        if(top < 0 || chars[top] != S[i] ){\\n            chars[++top] = S[i];\\n        }else{\\n            top--;\\n        }\\n    }\\n    chars[++top] = \\'\\\\0\\';\\n    return chars;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295088,
                "title": "c-1-line-4-lines-o-n-time",
                "content": "Build the result string in a stack way. 1 line version:\\n```\\nstring removeDuplicates(string S) {\\n    return accumulate(S.begin(), S.end(), string(), [](auto &s, char c)->auto& {return s.size() && s.back() == c ? s.pop_back() : s.push_back(c), s;});\\n}\\n```\\n4 line version:\\n```\\nstring removeDuplicates(string S) {\\n    string s;\\n    for (char c : S)\\n        s.size() && s.back() == c ? s.pop_back() : s.push_back(c);\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicates(string S) {\\n    return accumulate(S.begin(), S.end(), string(), [](auto &s, char c)->auto& {return s.size() && s.back() == c ? s.pop_back() : s.push_back(c), s;});\\n}\\n```\n```\\nstring removeDuplicates(string S) {\\n    string s;\\n    for (char c : S)\\n        s.size() && s.back() == c ? s.pop_back() : s.push_back(c);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610530,
                "title": "easy-c-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        \\n        for(auto ch:s){\\n            if(!st.empty()&&st.top()==ch)\\n            st.pop();\\n             else\\n            st.push(ch);\\n            }\\n       while(!st.empty()){\\n           ans+=st.top();\\n           st.pop();\\n       }\\n       reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        \\n        for(auto ch:s){\\n            if(!st.empty()&&st.top()==ch)\\n            st.pop();\\n             else\\n            st.push(ch);\\n            }\\n       while(!st.empty()){\\n           ans+=st.top();\\n           st.pop();\\n       }\\n       reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307088,
                "title": "easy-c-solution-beat-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n           if(ans.length()>0){\\n            if(ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n            }\\n             else\\n            ans.push_back(s[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n           if(ans.length()>0){\\n            if(ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n            }\\n             else\\n            ans.push_back(s[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102598,
                "title": "97-faster-no-stack-just-one-loop-java",
                "content": "I hope you understand it. It is just stack\\'s implementation. \\n\\n**Don\\'t forget to upvote**\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int length = s.length();\\n        int length_sb;\\n        for(int i=0;i<length;i++){\\n            length_sb = sb.length();\\n            if(length_sb!=0 && sb.charAt(length_sb-1)==s.charAt(i)){\\n                sb.deleteCharAt(length_sb-1);\\n                continue;\\n            }\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int length = s.length();\\n        int length_sb;\\n        for(int i=0;i<length;i++){\\n            length_sb = sb.length();\\n            if(length_sb!=0 && sb.charAt(length_sb-1)==s.charAt(i)){\\n                sb.deleteCharAt(length_sb-1);\\n                continue;\\n            }\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039587,
                "title": "using-string-only-0ms-code-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(ans == \"\"){\\n                ans.push_back(s[i]);\\n            }\\n            else if(ans.back()==s[i]){\\n                ans.pop_back();\\n            }\\n            else{\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(ans == \"\"){\\n                ans.push_back(s[i]);\\n            }\\n            else if(ans.back()==s[i]){\\n                ans.pop_back();\\n            }\\n            else{\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948454,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        while(s.size()>1&&i!=s.size()-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                s.erase(i,2);\\n                if(i==0)\\n                {\\n                    i=-1;\\n                }\\n                else\\n                {\\n                    i=i-2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        while(s.size()>1&&i!=s.size()-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                s.erase(i,2);\\n                if(i==0)\\n                {\\n                    i=-1;\\n                }\\n                else\\n                {\\n                    i=i-2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832310,
                "title": "easy-to-understand-c",
                "content": "**class Solution {\\npublic:**\\n\\n    string removeDuplicates(string s) {\\n        //using stack n=len of string\\n        int n=s.size();\\n        stack<char> st;\\n        //iterate over all elements\\n        for(int i=0;i<n;i++){\\n            //if stack size is greater than 0\\n            if(st.size()>0){\\n                //if current character is equal to topmost element\\n                //drop the topmost element\\n                //else push the current element in the stack\\n                char c=st.top();\\n                if(c==s[i]){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n            //if stack size is 0\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        //retrieve the char from stack\\n        string rt=\"\";\\n        while(st.size()>0){\\n            char t=st.top();\\n            rt+=t;\\n            st.pop();\\n        }\\n        //reverse the string for final ans\\n        string ans=\"\";\\n        for(int i=rt.size()-1;i>=0;i--){\\n            ans+=rt[i];\\n        }\\n        return ans;\\n    }\\n**};**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:**\\n\\n    string removeDuplicates(string s) {\\n        //using stack n=len of string\\n        int n=s.size();\\n        stack<char> st;\\n        //iterate over all elements\\n        for(int i=0;i<n;i++){\\n            //if stack size is greater than 0\\n            if(st.size()>0){\\n                //if current character is equal to topmost element\\n                //drop the topmost element\\n                //else push the current element in the stack\\n                char c=st.top();\\n                if(c==s[i]){\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2801903,
                "title": "yi",
                "content": "```\\ndef fun(s):\\n    for i in range(len(s)-1):\\n        if(s[i]==s[i+1]):\\n            s.pop(i)\\n            s.pop(i)\\n            return(fun(s))\\n    return s\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "solutionTags": [],
                "code": "```\\ndef fun(s):\\n    for i in range(len(s)-1):\\n        if(s[i]==s[i+1]):\\n            s.pop(i)\\n            s.pop(i)\\n            return(fun(s))\\n    return s\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800773,
                "title": "go-short-solution-o-n-memory-o-n",
                "content": "The main idea is to go from the end of the array and each time compare with the previous value\\n\\n```\\nfunc removeDuplicates(s string) string {\\n\\tb := []byte(s)\\n\\tfor i := len(b) - 1; i > 0; i-- {\\n\\t\\tif i != len(b) && b[i] == b[i-1] {\\n\\t\\t\\tb = append(b[:i-1], b[i+1:]...)\\n\\t\\t}\\n\\t}\\n\\treturn string(b)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(s string) string {\\n\\tb := []byte(s)\\n\\tfor i := len(b) - 1; i > 0; i-- {\\n\\t\\tif i != len(b) && b[i] == b[i-1] {\\n\\t\\t\\tb = append(b[:i-1], b[i+1:]...)\\n\\t\\t}\\n\\t}\\n\\treturn string(b)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2800524,
                "title": "java-detailed-solution-stack-two-pointers-approaches",
                "content": "Using Stack:\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && c == stack.peek()) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```\\n\\nTwo pointers:\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int slow = 0, fast = 1;\\n        while (fast < sb.length()) {\\n            if (sb.charAt(slow) == sb.charAt(fast)) {\\n                sb.deleteCharAt(slow);\\n                sb.deleteCharAt(slow);\\n                if (slow != 0) slow--;\\n                if (fast != 1) fast--;\\n            } else {\\n                slow++;\\n                fast++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && c == stack.peek()) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int slow = 0, fast = 1;\\n        while (fast < sb.length()) {\\n            if (sb.charAt(slow) == sb.charAt(fast)) {\\n                sb.deleteCharAt(slow);\\n                sb.deleteCharAt(slow);\\n                if (slow != 0) slow--;\\n                if (fast != 1) fast--;\\n            } else {\\n                slow++;\\n                fast++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800329,
                "title": "java-easy-peasy-solution",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char x : s.toCharArray()) {\\n            if (sb.length() > 0 && sb.charAt(sb.length() - 1) == x) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char x : s.toCharArray()) {\\n            if (sb.length() > 0 && sb.charAt(sb.length() - 1) == x) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799199,
                "title": "easy-solution-using-stack",
                "content": "```\\nclass Solution {\\n   public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }\\n                else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n   public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }\\n                else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799152,
                "title": "c-stack-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(st.empty()){\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(!st.empty() && st.top()==s[i]){\\n\\t\\t\\t\\t\\t\\twhile(!st.empty() && st.top()==s[i]){\\n\\t\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ti--;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\tans+=st.top(); st.pop();\\n\\t\\t\\t}\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(st.empty()){\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2798880,
                "title": "easy-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            if(st.isEmpty()){\\n            st.push(curr);\\n                }\\n            \\n            else if(st.peek() == curr){\\n                st.pop();\\n            }else{\\n                st.push(curr);\\n            }\\n           \\n        }\\n        String n = \"\";\\n        while(!st.isEmpty()){\\n            n =st.pop()+ n  ;\\n        }\\n        return n;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            if(st.isEmpty()){\\n            st.push(curr);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2798677,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(auto c: s) {\\n            if(ans.empty()) ans.push_back(c);\\n            else {\\n                if(ans.back() == c) ans.pop_back();\\n                else ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(auto c: s) {\\n            if(ans.empty()) ans.push_back(c);\\n            else {\\n                if(ans.back() == c) ans.pop_back();\\n                else ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798574,
                "title": "javascript-beats-100-solutions-in-memory",
                "content": "# Intuition\\nIt is simple. Whenever 2 adjacent characters are matching, create a window, start expanding in opposite directions. See if characters are matching or not. If not stop there, let your main counter increment\\n\\nThis solution beats 100% solutions in memory.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n    const str = [...s];\\n\\n    for(let i = 1; i < str.length; i++) {\\n        if (!str[i]) {\\n            continue;\\n        }\\n\\n        if (str[i] === str[i - 1]) {\\n            str[i] = str[i - 1] = null;\\n            let left = i - 2;\\n            let right = i + 1;\\n\\n            while (!str[left] && left >= 0) {\\n                left--;\\n            }\\n\\n            while (!str[right] && right < str.length) {\\n                right++;\\n            }\\n\\n            while(str[left] === str[right] && str[left] != null && left >= 0 && right < str.length) {\\n                str[left] = str[right] = null;\\n                left--;\\n                right++;\\n            }\\n        }\\n    }\\n\\n    return str.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n    const str = [...s];\\n\\n    for(let i = 1; i < str.length; i++) {\\n        if (!str[i]) {\\n            continue;\\n        }\\n\\n        if (str[i] === str[i - 1]) {\\n            str[i] = str[i - 1] = null;\\n            let left = i - 2;\\n            let right = i + 1;\\n\\n            while (!str[left] && left >= 0) {\\n                left--;\\n            }\\n\\n            while (!str[right] && right < str.length) {\\n                right++;\\n            }\\n\\n            while(str[left] === str[right] && str[left] != null && left >= 0 && right < str.length) {\\n                str[left] = str[right] = null;\\n                left--;\\n                right++;\\n            }\\n        }\\n    }\\n\\n    return str.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798421,
                "title": "line-by-line-explanation-easy-to-understand-stack-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Using stack to get the immediate previous character in the string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start a loop for each character in the string \\n2. Check if the stack is empty, or if the peeked element from the stack is not equals to the present character in the string, then add the element in the stack\\n3. In the else condition pop the last element in the stack becase in this case, the last element and the present character is equal to each other.\\n4. Initialize a char array of `stack.size()` length\\n5. Pop the elements if the stack while it isnt empty and insert the characters in the array in the `reverse` order.\\n6. Convert the char array to String and return it.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(stack.isEmpty() || stack.peek() != ch) stack.add(ch);\\n            else stack.pop();\\n        }\\n        char[] arr = new char[stack.size()];\\n        for(int i=stack.size(); i>0; i--) arr[i-1] = stack.pop();\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(stack.isEmpty() || stack.peek() != ch) stack.add(ch);\\n            else stack.pop();\\n        }\\n        char[] arr = new char[stack.size()];\\n        for(int i=stack.size(); i>0; i--) arr[i-1] = stack.pop();\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798308,
                "title": "stack-remove-all-adjacent-duplicates-in-string",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(char c:s.toCharArray())\\n        {\\n            if(!stack.isEmpty()&&stack.peek()==c)\\n            {\\n                stack.pop();\\n            }else{\\n                stack.push(c);\\n            }\\n        }\\n        String res=\"\";\\n        while(!stack.isEmpty()){\\n            res=stack.pop()+res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(char c:s.toCharArray())\\n        {\\n            if(!stack.isEmpty()&&stack.peek()==c)\\n            {\\n                stack.pop();\\n            }else{\\n                stack.push(c);\\n            }\\n        }\\n        String res=\"\";\\n        while(!stack.isEmpty()){\\n            res=stack.pop()+res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798236,
                "title": "c-most-easy-solution-using-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        int i=1;\\n        string ans; // stores the answer string\\n        \\n        ans.push_back(s[0]); // pushes the first char of the given string\\n        while(i<s.length())\\n        {\\n            if(ans.empty() == 0)\\n            {\\n                if(ans.back()==s[i]) // checking the char present in the ans == presenti in s\\n                {\\n                    ans.pop_back(); // removing the char\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]); // pushing the char\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if the ans is empty\\n            }\\n            i++; // incremenet \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        int i=1;\\n        string ans; // stores the answer string\\n        \\n        ans.push_back(s[0]); // pushes the first char of the given string\\n        while(i<s.length())\\n        {\\n            if(ans.empty() == 0)\\n            {\\n                if(ans.back()==s[i]) // checking the char present in the ans == presenti in s\\n                {\\n                    ans.pop_back(); // removing the char\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]); // pushing the char\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if the ans is empty\\n            }\\n            i++; // incremenet \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798020,
                "title": "easy-c-solution-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        for (int j = 0 ; j < s.size() ; j++,i++)\\n        {\\n            s[i] = s[j];\\n            if (i > 0 && s[i-1] == s[i])\\n            i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        for (int j = 0 ; j < s.size() ; j++,i++)\\n        {\\n            s[i] = s[j];\\n            if (i > 0 && s[i-1] == s[i])\\n            i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752419,
                "title": "java-efficient-solution-faster-than-96-21",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) return null;\\n\\n        char[] stack = new char[s.length()];\\n        int i = 0;\\n\\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            if (i > 0 && stack[i - 1] == c) {\\n                i--;\\n            } else {\\n                stack[i++] = c;\\n            }\\n        }\\n        return new String(stack, 0, i);       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) return null;\\n\\n        char[] stack = new char[s.length()];\\n        int i = 0;\\n\\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            if (i > 0 && stack[i - 1] == c) {\\n                i--;\\n            } else {\\n                stack[i++] = c;\\n            }\\n        }\\n        return new String(stack, 0, i);       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725400,
                "title": "python3-o-n-runtime-104-ms-beats-82-48-memory-14-7-mb-beats-86-13",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans = []\\n        i = 0\\n        for i in s:\\n            if len(ans) > 0:\\n                if i == ans[-1]:\\n                    ans.pop()\\n                else:\\n                    ans.append(i)\\n            else:\\n                ans.append(i)\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans = []\\n        i = 0\\n        for i in s:\\n            if len(ans) > 0:\\n                if i == ans[-1]:\\n                    ans.pop()\\n                else:\\n                    ans.append(i)\\n            else:\\n                ans.append(i)\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703030,
                "title": "two-solutions-o-1-extra-space-clean-code",
                "content": "**Solution 1: Using Stack**\\n```\\nvar removeDuplicates = function(str){\\n    var stack = [];\\n    for(var s of str){\\n        stack.push(s);\\n        while(stack.length > 1 && stack[stack.length-1] === stack[stack.length-2]){\\n            stack.pop();\\n            stack.pop();\\n        }\\n    }\\n    return stack.join(\\'\\');\\n}\\n```\\n**Solution 2: O(1) Space || Inplace string manipulation**\\n```\\nvar removeDuplicates = function(s) {\\n    for(var i=1; i<s.length; i++){\\n        if(s[i] === s[i-1]){\\n            s = s.slice(0, i-1) + s.slice(i+1);\\n            i-=2;\\n        }\\n    }\\n    return s;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(str){\\n    var stack = [];\\n    for(var s of str){\\n        stack.push(s);\\n        while(stack.length > 1 && stack[stack.length-1] === stack[stack.length-2]){\\n            stack.pop();\\n            stack.pop();\\n        }\\n    }\\n    return stack.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651043,
                "title": "easy-python-solution-using-if-else-with-explanation",
                "content": "Iterating an if-else loop throughout the string\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        # Initiate a blank list\\n\\t\\tstr_list = []\\n        for i in s:\\n            # Remove the element from that list only if its Non Empty and its last appended element = current element\\n\\t\\t\\tif str_list and str_list[-1] == i:\\n                str_list.pop()\\n            else:\\n\\t\\t\\t    # Else, keep appending the characters\\n                str_list.append(i)\\n        return \\'\\'.join(str_list)\\n```\\n\\n***Please upvote if you like it***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        # Initiate a blank list\\n\\t\\tstr_list = []\\n        for i in s:\\n            # Remove the element from that list only if its Non Empty and its last appended element = current element\\n\\t\\t\\tif str_list and str_list[-1] == i:\\n                str_list.pop()\\n            else:\\n\\t\\t\\t    # Else, keep appending the characters\\n                str_list.append(i)\\n        return \\'\\'.join(str_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641587,
                "title": "js-very-easy-solution-with-stack",
                "content": "```\\nvar removeDuplicates = function(s) {\\n    let output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === output[output.length - 1]) {\\n            output.pop();\\n        } else {\\n            output.push(s[i]);\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(s) {\\n    let output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === output[output.length - 1]) {\\n            output.pop();\\n        } else {\\n            output.push(s[i]);\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882377,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans{};\\n        \\n        for(char &c : s){\\n            if(ans.empty())\\n                ans.push_back(c);\\n            else{\\n                if(ans.back() == c)\\n                    ans.pop_back();\\n                else\\n                    ans.push_back(c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans{};\\n        \\n        for(char &c : s){\\n            if(ans.empty())\\n                ans.push_back(c);\\n            else{\\n                if(ans.back() == c)\\n                    ans.pop_back();\\n                else\\n                    ans.push_back(c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672467,
                "title": "c-easy-solution-stack-based",
                "content": "**Please upvote to motivate me in quest of documenting all leetcode solutions. :)**\\n```\\nThe problem is simply a use case of \"STACK\" data structure.\\nThe logic of problem is simply push the character in stack if it is empty or stack top is not same. If stack top is same\\nas the current character then pop the character from stack top. ( Easy Peasy ) :)\\n```\\n```\\nclass Solution {\\npublic:\\n    string remove_duplicate(string str, int l)\\n   {\\n          stack<char>s;\\n          for(int i=0; i<l; i++)\\n          {\\n              if(s.empty())\\n                  s.push(str[i]);\\n              else\\n             {\\n                   if(s.top()==str[i])\\n                                  s.pop();\\n                   else\\n                      s.push(str[i]);\\n             }\\n          }\\n   \\n        string sout;\\n   while(!s.empty())\\n   {\\n         sout+=s.top();\\n          s.pop();\\n   } \\n   \\n        reverse(sout.begin(),sout.end());\\n   \\n    return sout;\\n}\\n    string removeDuplicates(string str) {\\n        \\n        int l=str.length();\\n        string s=remove_duplicate(str,l);\\n    return s;\\n}\\n      \\n};\\n```\\n**Stack is best DS ;)**",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nThe problem is simply a use case of \"STACK\" data structure.\\nThe logic of problem is simply push the character in stack if it is empty or stack top is not same. If stack top is same\\nas the current character then pop the character from stack top. ( Easy Peasy ) :)\\n```\n```\\nclass Solution {\\npublic:\\n    string remove_duplicate(string str, int l)\\n   {\\n          stack<char>s;\\n          for(int i=0; i<l; i++)\\n          {\\n              if(s.empty())\\n                  s.push(str[i]);\\n              else\\n             {\\n                   if(s.top()==str[i])\\n                                  s.pop();\\n                   else\\n                      s.push(str[i]);\\n             }\\n          }\\n   \\n        string sout;\\n   while(!s.empty())\\n   {\\n         sout+=s.top();\\n          s.pop();\\n   } \\n   \\n        reverse(sout.begin(),sout.end());\\n   \\n    return sout;\\n}\\n    string removeDuplicates(string str) {\\n        \\n        int l=str.length();\\n        string s=remove_duplicate(str,l);\\n    return s;\\n}\\n      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572648,
                "title": "using-stringbuilder-as-a-stack",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i = 1; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(sb.length() > 0 && sb.charAt(sb.length()-1) == ch) {\\n                sb.setLength(sb.length()-1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i = 1; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(sb.length() > 0 && sb.charAt(sb.length()-1) == ch) {\\n                sb.setLength(sb.length()-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1569642,
                "title": "c-noob-solution-easy-to-understand-using-stack",
                "content": "If This helps you then please upvote \\uD83D\\uDE4F\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stc;\\n        string ans=\"\";\\n        for(auto x:s){\\n             if(stc.empty() || stc.top()!=x){\\n                 stc.push(x);\\n             }\\n            else if(stc.top()==x){\\n                stc.pop();\\n            }\\n        }\\n        while(!stc.empty()){\\n            ans+=stc.top();\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stc;\\n        string ans=\"\";\\n        for(auto x:s){\\n             if(stc.empty() || stc.top()!=x){\\n                 stc.push(x);\\n             }\\n            else if(stc.top()==x){\\n                stc.pop();\\n            }\\n        }\\n        while(!stc.empty()){\\n            ans+=stc.top();\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487242,
                "title": "c-easy-solution-using-stack",
                "content": "```\\nstring removeDuplicates(string s) {\\n        if(s.size()==1) return s;\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                if(s[i]==st.top()){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n        if(s.size()==1) return s;\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                if(s[i]==st.top()){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459991,
                "title": "java-sol-48ms",
                "content": "Used the same approach as done in the extension for this question. Only difference being that we don\\'t need to worry about k(frequency of character) in this question.\\n\\nreference:\\n[Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/1439667/Java-sol-or-52ms)  \\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (Character c : s.toCharArray()){\\n            if (!st.isEmpty() && st.peek() == c){\\n                st.pop();\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty())\\n            sb.append(st.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (Character c : s.toCharArray()){\\n            if (!st.isEmpty() && st.peek() == c){\\n                st.pop();\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty())\\n            sb.append(st.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457324,
                "title": "both-approach-s-in-detail-with-explanation-java-code",
                "content": "**Approach 1: Replace**\\n\\nThe idea is very simple:\\n\\nGenerate hashset of all 26 possible duplicates from aa to zz.\\n\\nIterate over that 26 duplicates and replace them all in string by empty char.\\n    \\n\\nAlgorithm\\n\\nGenerate hashset of all 26 possible duplicates from aa to zz.\\n\\nInitiate \\'one step before\\' string length by prevLength = -1.\\n\\nWhile previous length is still different from the current one prevLength != S.length()\\n\\nSet \\'one step before\\' length to be equal to the string length prevLength = S.length().\\n\\nIterate over all 26 duplicates and replace them in string by empty char.\\n\\nReturn S.\\n    \\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    // generate 26 possible duplicates\\n    HashSet<String> duplicates = new HashSet();\\n    StringBuilder sb = new StringBuilder();\\n    for(char i = \\'a\\'; i <= \\'z\\'; ++i) {\\n      sb.setLength(0);\\n      sb.append(i); sb.append(i);\\n      duplicates.add(sb.toString());\\n    }\\n\\n    int prevLength = -1;\\n    while (prevLength != S.length()) {\\n      prevLength = S.length();\\n      for (String d : duplicates) S = S.replace(d, \"\");\\n    }\\n\\n    return S;\\n  }\\n}\\n```\\nComplexity Analysis\\n\\n*Time complexity : O(N^2)\\nSpace complexity : O(N).*\\n    \\n\\n    \\n    \\n**Approach 2: Stack**\\n\\nWe could trade an extra space for speed. The idea is to use an output stack to keep track of only non duplicate characters. Here is how it works:\\n\\nCurrent string character is equal to the last element in stack? Pop that last element out of stack.\\n\\nCurrent string character is not equal to the last element in stack? Add the current character into stack.\\n\\nWhich data structure to use as the stack here?\\n    \\n    \\nSomething that is fast to convert to string for output, for example list in Python and StringBuilder in Java\\n\\nAlgorithm\\n\\nInitiate an empty output stack.\\n\\nIterate over all characters in the string.\\n\\nCurrent element is equal to the last element in stack? Pop that last element out of stack.\\n\\nCurrent element is not equal to the last element in stack? Add the current element into stack.\\n\\nConvert stack into string and return it.\\n    \\nImplementation\\n\\n\\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    StringBuilder sb = new StringBuilder();\\n    int sbLength = 0;\\n    for(char character : S.toCharArray()) {\\n      if (sbLength != 0 && character == sb.charAt(sbLength - 1))\\n        sb.deleteCharAt(sbLength-- - 1);\\n      else {\\n        sb.append(character);\\n        sbLength++;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```\\n\\nComplexity Analysis\\n\\n*Time complexity : O(N), where N is a string length.\\nSpace complexity : O(N\\u2212D) where D is a total length for all duplicates.*\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    // generate 26 possible duplicates\\n    HashSet<String> duplicates = new HashSet();\\n    StringBuilder sb = new StringBuilder();\\n    for(char i = \\'a\\'; i <= \\'z\\'; ++i) {\\n      sb.setLength(0);\\n      sb.append(i); sb.append(i);\\n      duplicates.add(sb.toString());\\n    }\\n\\n    int prevLength = -1;\\n    while (prevLength != S.length()) {\\n      prevLength = S.length();\\n      for (String d : duplicates) S = S.replace(d, \"\");\\n    }\\n\\n    return S;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    StringBuilder sb = new StringBuilder();\\n    int sbLength = 0;\\n    for(char character : S.toCharArray()) {\\n      if (sbLength != 0 && character == sb.charAt(sbLength - 1))\\n        sb.deleteCharAt(sbLength-- - 1);\\n      else {\\n        sb.append(character);\\n        sbLength++;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324665,
                "title": "python-o-n-solution-using-stack",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:        \\n        stack = deque()\\n        \\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack[-1] == c:\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n                    \\n        return \"\".join(stack)\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:        \\n        stack = deque()\\n        \\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack[-1] == c:\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n                    \\n        return \"\".join(stack)\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303758,
                "title": "remove-all-adjacent-duplicates-in-string-beginners-c-easy-to-understand",
                "content": "Upvote if You Like it ! Please leave a comment for any query or suggestion.\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n = s.length();\\n        int i=0;\\n        while(i<=n-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                i--;\\n                s.erase(s.begin()+i+2);\\n                s.erase(s.begin()+i+1);\\n                n=n-2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n            if(i<1) i=0;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n = s.length();\\n        int i=0;\\n        while(i<=n-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                i--;\\n                s.erase(s.begin()+i+2);\\n                s.erase(s.begin()+i+1);\\n                n=n-2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n            if(i<1) i=0;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208823,
                "title": "faster-than-84-of-python-solutions",
                "content": "```class Solution(object):\\n    def removeDuplicates(self, s):\\n        \\n        c = [0]\\n    \\n        for i in s:   \\n            \\n            \\n            if i != c[-1]:\\n                \\n                c.append(i)\\n            else:\\n                c.pop()\\n        c.pop(0)   \\n        return (\"\".join(c))\\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def removeDuplicates(self, s):\\n        \\n        c = [0]\\n    \\n        for i in s:   \\n            \\n            \\n            if i != c[-1]:\\n                \\n                c.append(i)\\n            else:\\n                c.pop()\\n        c.pop(0)   \\n        return (\"\".join(c))\\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1192588,
                "title": "js-o-n-solutions-using-two-pointers-and-stack-approaches-92ms",
                "content": "**Solution using Two Pointers approach**\\n```\\nvar removeDuplicates = function(S) {\\n\\t// to store the resultant string\\n    const result = [];\\n    \\n\\t// i is used to maintain the pointer at result string\\n\\t// j is used to iterate over the string S\\n    for(let i = 0, j = 0; j < S.length; ++i, ++j) {\\n        result[i] = S[j];\\n\\n\\t\\t// if the value adjacent to recently added value is same\\n        if(i > 0 && result[i] === result[i - 1]) {\\n\\n\\t\\t\\t// set both the values as empty - removing duplicate\\n\\t\\t\\t// can also pop twice - result.pop()\\n            result[i] = result[i - 1] = \\'\\';\\n\\t\\t\\t\\n\\t\\t\\t// set the value for i as the index from where to add the new value\\n\\t\\t\\t// go back 2 places since duplicates are removed\\n            i -= 2;\\n        }\\n    }\\n\\t// since result is an array, use join to convert it into a string\\n    return result.join(\\'\\');\\n}\\n```\\n\\nTime and Space Complexity: O(n)\\nn = length of the String S\\n\\n**Solution using Stack**\\n```\\nvar removeDuplicates = function(S) {\\n    const stack = [];\\n    \\n    for(let i = 0; i < S.length; ++i) {\\n\\t\\t// if stack is not empty and the stack.top() is same as the value at index i\\n        if(stack.length > 0 && stack[stack.length - 1] === S[i]) {\\n\\t\\t\\t// pop the value as it is a duplicate\\n            stack.pop();\\n        } else {\\n\\t\\t\\t// else push the value into the stack\\n            stack.push(S[i]);\\n        }\\n    }\\n\\t\\n\\t// since stack is an array, use join to convert it into a string\\n    return stack.join(\\'\\');\\n}\\n```\\n\\nTime and Space Complexity: O(n)\\nn = length of the String S",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n\\t// to store the resultant string\\n    const result = [];\\n    \\n\\t// i is used to maintain the pointer at result string\\n\\t// j is used to iterate over the string S\\n    for(let i = 0, j = 0; j < S.length; ++i, ++j) {\\n        result[i] = S[j];\\n\\n\\t\\t// if the value adjacent to recently added value is same\\n        if(i > 0 && result[i] === result[i - 1]) {\\n\\n\\t\\t\\t// set both the values as empty - removing duplicate\\n\\t\\t\\t// can also pop twice - result.pop()\\n            result[i] = result[i - 1] = \\'\\';\\n\\t\\t\\t\\n\\t\\t\\t// set the value for i as the index from where to add the new value\\n\\t\\t\\t// go back 2 places since duplicates are removed\\n            i -= 2;\\n        }\\n    }\\n\\t// since result is an array, use join to convert it into a string\\n    return result.join(\\'\\');\\n}\\n```\n```\\nvar removeDuplicates = function(S) {\\n    const stack = [];\\n    \\n    for(let i = 0; i < S.length; ++i) {\\n\\t\\t// if stack is not empty and the stack.top() is same as the value at index i\\n        if(stack.length > 0 && stack[stack.length - 1] === S[i]) {\\n\\t\\t\\t// pop the value as it is a duplicate\\n            stack.pop();\\n        } else {\\n\\t\\t\\t// else push the value into the stack\\n            stack.push(S[i]);\\n        }\\n    }\\n\\t\\n\\t// since stack is an array, use join to convert it into a string\\n    return stack.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162232,
                "title": "java-simple-and-easy-to-understand-greedy-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deque = new LinkedList();\\n        \\n        for(char c : S.toCharArray()){\\n            //if last character same as current, \\n            //then just pop last one\\n            if(!deque.isEmpty() && deque.peek() == c){\\n                deque.pop();\\n            }else{\\n                deque.push(c);\\n            }\\n        }\\n        \\n        //get all the left character\\n        StringBuilder sb = new StringBuilder();\\n        while(!deque.isEmpty()){\\n            sb.append(deque.pop());\\n        }\\n        //reverse the string\\n        sb.reverse();\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deque = new LinkedList();\\n        \\n        for(char c : S.toCharArray()){\\n            //if last character same as current, \\n            //then just pop last one\\n            if(!deque.isEmpty() && deque.peek() == c){\\n                deque.pop();\\n            }else{\\n                deque.push(c);\\n            }\\n        }\\n        \\n        //get all the left character\\n        StringBuilder sb = new StringBuilder();\\n        while(!deque.isEmpty()){\\n            sb.append(deque.pop());\\n        }\\n        //reverse the string\\n        sb.reverse();\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161162,
                "title": "easy-python-3-line-solution-no-stack-required",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        for character in s:\\n            s = s.replace (character * 2, \"\") if character * 2 in s else s\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        for character in s:\\n            s = s.replace (character * 2, \"\") if character * 2 in s else s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158365,
                "title": "python-stack-solution-95-37-faster",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        \\n        for s in S:\\n            if stack and stack[-1] == s:\\n                stack.pop()\\n            else:\\n                stack.append(s)\\n                \\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        \\n        for s in S:\\n            if stack and stack[-1] == s:\\n                stack.pop()\\n            else:\\n                stack.append(s)\\n                \\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1041434,
                "title": "python3-simple-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        st = []\\n        for i in S:\\n            if st == [] or st[-1] != i:\\n                st.append(i)\\n            else:\\n                st.pop()\\n        return \\'\\'.join(st)\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        st = []\\n        for i in S:\\n            if st == [] or st[-1] != i:\\n                st.append(i)\\n            else:\\n                st.pop()\\n        return \\'\\'.join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011120,
                "title": "python-simple-iterative-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        i = 0\\n        S = list(S)\\n        while i < len(S) - 1:\\n            if S[i] == S[i + 1]:\\n                del S[i]\\n                del S[i]\\n                if i: i -= 1\\n            else: i+= 1\\n        return \"\".join(S)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        i = 0\\n        S = list(S)\\n        while i < len(S) - 1:\\n            if S[i] == S[i + 1]:\\n                del S[i]\\n                del S[i]\\n                if i: i -= 1\\n            else: i+= 1\\n        return \"\".join(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998346,
                "title": "python-no-stack-using-slow-and-fast-pointer-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, a: str) -> str:\\n        slow=0\\n        a=list(a)\\n        for fast in range(len(a)):\\n            if slow==0 or a[slow-1]!=a[fast]:\\n                a[slow]=a[fast]\\n                slow+=1\\n            else:\\n                slow-=1\\n        return \\'\\'.join(a[:slow])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, a: str) -> str:\\n        slow=0\\n        a=list(a)\\n        for fast in range(len(a)):\\n            if slow==0 or a[slow-1]!=a[fast]:\\n                a[slow]=a[fast]\\n                slow+=1\\n            else:\\n                slow-=1\\n        return \\'\\'.join(a[:slow])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925024,
                "title": "java-solution-using-stack",
                "content": "``` \\npublic String removeDuplicates(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n\\n            //add character to the stack and append it to StringBuilder\\n            if (stack.isEmpty()) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top of stack is not equal to the current character, add it to stack and StringBuilder\\n            } else if (stack.peek() != c) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top and current character are equal, remove them from stringBuilder and stack\\n            } else {\\n                stack.pop();\\n                //remove last character in sb by reducing its length by 1\\n                sb.setLength(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "``` \\npublic String removeDuplicates(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n\\n            //add character to the stack and append it to StringBuilder\\n            if (stack.isEmpty()) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top of stack is not equal to the current character, add it to stack and StringBuilder\\n            } else if (stack.peek() != c) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top and current character are equal, remove them from stringBuilder and stack\\n            } else {\\n                stack.pop();\\n                //remove last character in sb by reducing its length by 1\\n                sb.setLength(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 619457,
                "title": "javascript",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    while(S.match(/([a-z])\\\\1/)) {\\n        S = S.replace(/([a-z])\\\\1/, \\'\\');\\n    }\\n    return S;\\n};",
                "solutionTags": [],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    while(S.match(/([a-z])\\\\1/)) {\\n        S = S.replace(/([a-z])\\\\1/, \\'\\');\\n    }\\n    return S;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 552914,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        stack<char> st;\\n        st.push(S[0]);\\n        for(int i=1;i<S.size();i++)\\n        {\\n            if(!st.empty()&&st.top()==S[i])\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(S[i]);\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp+=st.top();\\n            st.pop();\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        stack<char> st;\\n        st.push(S[0]);\\n        for(int i=1;i<S.size();i++)\\n        {\\n            if(!st.empty()&&st.top()==S[i])\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(S[i]);\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp+=st.top();\\n            st.pop();\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418388,
                "title": "o-n-o-1-space-with-two-pointers-php",
                "content": "```\\n    function removeDuplicates($s) {\\n        $len = strlen($s);\\n        if ($len <= 1) return $s;\\n        $l = 0;\\n        $r = 1;\\n        while ($r < $len) {\\n            if ($l >= 0 && $s[$l] == $s[$r]) {\\n                $l--;\\n                $r++;\\n            } else {\\n                $l++;\\n                $s[$l] = $s[$r];\\n                $r++;\\n            }\\n        }\\n        return substr($s, 0, $l + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    function removeDuplicates($s) {\\n        $len = strlen($s);\\n        if ($len <= 1) return $s;\\n        $l = 0;\\n        $r = 1;\\n        while ($r < $len) {\\n            if ($l >= 0 && $s[$l] == $s[$r]) {\\n                $l--;\\n                $r++;\\n            } else {\\n                $l++;\\n                $s[$l] = $s[$r];\\n                $r++;\\n            }\\n        }\\n        return substr($s, 0, $l + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389255,
                "title": "c-simple-easy-to-read-99-25-100",
                "content": "We create an output array the new string will be written to, we have a variable that tracks our position in the output. We loop through the chars in the input string, if the char equal that last value in the output array, then we skip the char and decrement the position variable to \\'delete\\' the last char.\\n\\n```\\npublic class Solution {\\n    public string RemoveDuplicates(string S) {\\n        \\n        char[] output = new char[S.Length];\\n        int position = -1;\\n        \\n        for (int i = 0; i < S.Length; i++){\\n            if (position >= 0 && S[i] == output[position]){\\n                position--;\\n            }\\n            else{\\n                output[++position] = S[i];\\n            }\\n        }\\n        \\n        return new string(output.Take(position + 1).ToArray());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string S) {\\n        \\n        char[] output = new char[S.Length];\\n        int position = -1;\\n        \\n        for (int i = 0; i < S.Length; i++){\\n            if (position >= 0 && S[i] == output[position]){\\n                position--;\\n            }\\n            else{\\n                output[++position] = S[i];\\n            }\\n        }\\n        \\n        return new string(output.Take(position + 1).ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352182,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 6 MB, less than 100.00% of Go online submissions for Remove All Adjacent Duplicates In String\\n\\n```go\\nfunc removeDuplicates(S string) string {\\n\\n\\tstack := []byte{}\\n\\n\\tfor i := 0; i < len(S); i++ {\\n\\t\\tif len(stack) != 0 && stack[len(stack)-1] == S[i] {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else {\\n\\t\\t\\tstack = append(stack, S[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeDuplicates(S string) string {\\n\\n\\tstack := []byte{}\\n\\n\\tfor i := 0; i < len(S); i++ {\\n\\t\\tif len(stack) != 0 && stack[len(stack)-1] == S[i] {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else {\\n\\t\\t\\tstack = append(stack, S[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338065,
                "title": "php-solution-20-ms",
                "content": "Runtime: 20 ms, faster than 93.10% of PHP online submissions\\nMemory Usage: 14.8 MB, less than 100.00% of PHP online submissions\\n\\nNo arrays; no splitting; no joining.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $S\\n     * @return String\\n     */\\n    function removeDuplicates($S)\\n    {\\n        $end = -1;\\n        for ($i = 0; $i < strlen($S); $i++)\\n            if (0 <= $end && $S[$end] === $S[$i]) $end--;\\n            else $S[++$end] = $S[$i];\\n        return substr($S, 0, $end + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $S\\n     * @return String\\n     */\\n    function removeDuplicates($S)\\n    {\\n        $end = -1;\\n        for ($i = 0; $i < strlen($S); $i++)\\n            if (0 <= $end && $S[$end] === $S[$i]) $end--;\\n            else $S[++$end] = $S[$i];\\n        return substr($S, 0, $end + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333614,
                "title": "python-stack",
                "content": "```\\ndef removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        for s in S:\\n            if not stack or s != stack[-1]:\\n                stack.append(s)\\n            else:\\n                stack.pop()\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        for s in S:\\n            if not stack or s != stack[-1]:\\n                stack.append(s)\\n            else:\\n                stack.pop()\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 306186,
                "title": "python-easy-solution-using-stack",
                "content": "```\\n# Main idea is to use a stack and keep popping the top element if it is same as the current element in the string\\n# Return my_stack as string \\n\\n# This may not be efficient but one of the approaches to solve using stack. Upvote it if you like the solution and do comment if you have a better solution.\\n\\nclass Solution(object):\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and my_stack[-1]==S[i]:\\n                my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return \\'\\'.join(my_stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Main idea is to use a stack and keep popping the top element if it is same as the current element in the string\\n# Return my_stack as string \\n\\n# This may not be efficient but one of the approaches to solve using stack. Upvote it if you like the solution and do comment if you have a better solution.\\n\\nclass Solution(object):\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and my_stack[-1]==S[i]:\\n                my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return \\'\\'.join(my_stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303366,
                "title": "c-beats-97-without-extra-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        std::string res = \"0\";\\n        for (int i = 0; i < S.size(); i++) {\\n            if (res.back() == S[i]) {\\n\\t\\t\\t\\tres.pop_back();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres.push_back(S[i]);\\n\\t\\t\\t}\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        std::string res = \"0\";\\n        for (int i = 0; i < S.size(); i++) {\\n            if (res.back() == S[i]) {\\n\\t\\t\\t\\tres.pop_back();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres.push_back(S[i]);\\n\\t\\t\\t}\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298585,
                "title": "javascript-using-regex-and-replace-52ms-36-5mb",
                "content": "I haven\\'t seen any solutions with regex and replace so I figured I would share mine. It took 52ms and used 36.5MB of memory.\\n\\n```\\nvar removeDuplicates = function(S) {\\n    const regex = /(.)\\\\1/gm;\\n    let startLength;\\n    \\n    do {\\n        startLength = S.length;\\n        S = S.replace(regex, \\'\\');\\n    } while (S.length != startLength);\\n    \\n    return S;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    const regex = /(.)\\\\1/gm;\\n    let startLength;\\n    \\n    do {\\n        startLength = S.length;\\n        S = S.replace(regex, \\'\\');\\n    } while (S.length != startLength);\\n    \\n    return S;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565616,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1568144,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678613,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1630350,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678858,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1919739,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1575390,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678476,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1675023,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794577,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1565616,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1568144,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678613,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1630350,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678858,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1919739,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1575390,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678476,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1675023,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794577,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794544,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569543,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1973014,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1776047,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574539,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572692,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2061191,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2040648,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2031753,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977159,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1951716,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1932231,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1930296,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1919713,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1876828,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1849645,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1838820,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1824934,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783619,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1760378,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1752815,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1741416,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1740932,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1736518,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1722121,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1717508,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1713040,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1702041,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1682524,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1679754,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1679219,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679128,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679090,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679027,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679026,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678974,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678932,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678913,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678908,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678898,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678849,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678786,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678741,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678708,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678610,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678580,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678546,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678540,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678500,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678472,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Three Consecutive Odds",
        "question_content": "Given an integer array <code>arr</code>, return <code>true</code>&nbsp;if there are three consecutive odd numbers in the array. Otherwise, return&nbsp;<code>false</code>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,6,4,1]\n<strong>Output:</strong> false\n<b>Explanation:</b> There are no three consecutive odds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2,34,3,4,5,7,23,12]\n<strong>Output:</strong> true\n<b>Explanation:</b> [5,7,23] are three consecutive odds.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 794167,
                "title": "java-simple-loop",
                "content": "```\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0, cnt = 0; i < arr.length; i++) {\\n            if (arr[i] % 2 == 0) cnt = 0;\\n            else if (++cnt == 3) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0, cnt = 0; i < arr.length; i++) {\\n            if (arr[i] % 2 == 0) cnt = 0;\\n            else if (++cnt == 3) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892927,
                "title": "python-beats-99-use-string",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join([str(i%2) for i in arr])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join([str(i%2) for i in arr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794125,
                "title": "c-straightforward",
                "content": "Why do we even need questions like that?\\n```cpp\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n    int odds = 0;\\n    for (auto i = 0; i < arr.size() && odds < 3; ++i)\\n        odds = arr[i] % 2 ? odds + 1 : 0;\\n    return odds == 3;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n    int odds = 0;\\n    for (auto i = 0; i < arr.size() && odds < 3; ++i)\\n        odds = arr[i] % 2 ? odds + 1 : 0;\\n    return odds == 3;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794144,
                "title": "self-explanatory-code-linear-time",
                "content": "`TC - O(N)`\\n`SC - O(1)`\\n\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i = 1; i < arr.length - 1; i++) {\\n            if(arr[i - 1] % 2 == 1 && arr[i] % 2 == 1 && arr[i + 1] % 2 == 1 )\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i = 1; i < arr.length - 1; i++) {\\n            if(arr[i - 1] % 2 == 1 && arr[i] % 2 == 1 && arr[i + 1] % 2 == 1 )\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794097,
                "title": "python3-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        \\n        for i in range(0, len(arr)):\\n            if arr[i] %2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        \\n        for i in range(0, len(arr)):\\n            if arr[i] %2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825552,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join([str(x%2) for x in arr])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join([str(x%2) for x in arr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794140,
                "title": "c-easy-to-understand",
                "content": "```\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); ++i)\\n        {\\n            if(arr[i] % 2 == 1)\\n                count++;\\n            else\\n                count = 0;\\n            if(count == 3)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); ++i)\\n        {\\n            if(arr[i] % 2 == 1)\\n                count++;\\n            else\\n                count = 0;\\n            if(count == 3)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 798856,
                "title": "1550-javascript-1-line-solution",
                "content": "> _Runtime: **72 ms**, faster than 89.54% of JavaScript online submissions_\\n> _Memory Usage: **36.8 MB**, less than 22.22% of JavaScript online submissions_\\n\\n```javascript\\nconst threeConsecutiveOdds = arr =>\\n  arr\\n    .map(n => n % 2)\\n    .join(\\'\\')\\n    .includes(\\'111\\');\\n```\\n\\nIf you prefer more inside-the-box solutions, here\\'s some bitwise shenanigans.\\n\\n> _Runtime: **64 ms**, faster than 98.69% of JavaScript online submissions_\\n> _Memory Usage: **36.5 MB**, less than 62.09% of JavaScript online submissions_\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst threeConsecutiveOdds = arr => {\\n  for (let i = 0, x = 0; i < arr.length; i++) {\\n    x = arr[i] % 2 ? x | [1, 2, 4][i % 3] : 0;\\n    if (7 === x) return true;\\n  }\\n  return false;\\n};\\n```\\n\\nAnd here\\'s basically the same idea with an array.\\n\\n>  _Runtime: **68 ms**, faster than 95.42% of JavaScript online submissions_\\n>  _Memory Usage: **37.2 MB**, less than 5.23% of JavaScript online submissions_\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst threeConsecutiveOdds = arr => {\\n  for (let i = 0, x = new Array(3); i < arr.length; i++) {\\n    x[i % 3] = arr[i] % 2;\\n    if (\\'[1,1,1]\\' === JSON.stringify(x)) return true;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```javascript\\nconst threeConsecutiveOdds = arr =>\\n  arr\\n    .map(n => n % 2)\\n    .join(\\'\\')\\n    .includes(\\'111\\');\\n```\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst threeConsecutiveOdds = arr => {\\n  for (let i = 0, x = 0; i < arr.length; i++) {\\n    x = arr[i] % 2 ? x | [1, 2, 4][i % 3] : 0;\\n    if (7 === x) return true;\\n  }\\n  return false;\\n};\\n```\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst threeConsecutiveOdds = arr => {\\n  for (let i = 0, x = new Array(3); i < arr.length; i++) {\\n    x[i % 3] = arr[i] % 2;\\n    if (\\'[1,1,1]\\' === JSON.stringify(x)) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549643,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\n\\tfor i in range(1, len(arr) - 1):\\n\\t\\tif arr[i] % 2:\\n\\t\\t\\tif arr[i - 1] % 2 and arr[i + 1] % 2:\\n\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\n\\tfor i in range(1, len(arr) - 1):\\n\\t\\tif arr[i] % 2:\\n\\t\\t\\tif arr[i - 1] % 2 and arr[i + 1] % 2:\\n\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2780281,
                "title": "3-lines-java-code-three-consecutive-odds",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=1;i<arr.length-1;i++)\\n            if(arr[i]%2!=0&&arr[i+1]%2!=0&&arr[i-1]%2!=0)return true;\\n        return false;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=1;i<arr.length-1;i++)\\n            if(arr[i]%2!=0&&arr[i+1]%2!=0&&arr[i-1]%2!=0)return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799611,
                "title": "javascript-bitwise-one-line",
                "content": "Not quite efficient though.\\n```js\\nfunction threeConsecutiveOdds(arr) {\\n  return arr.some((v, i, a) => v & a[i-1] & a[i+1] & 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction threeConsecutiveOdds(arr) {\\n  return arr.some((v, i, a) => v & a[i-1] & a[i+1] & 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352810,
                "title": "c-simple-and-short-solution-one-pass-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for (auto num : arr) {\\n            if (count == 3) return true;\\n            count = num % 2 ? count + 1 : 0;\\n        }\\n        return count == 3;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for (auto num : arr) {\\n            if (count == 3) return true;\\n            count = num % 2 ? count + 1 : 0;\\n        }\\n        return count == 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048257,
                "title": "java-faster-than-100-counter",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        var count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            count = arr[i] % 2 == 1 ? count + 1 : 0;\\n            if (count == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        var count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            count = arr[i] % 2 == 1 ? count + 1 : 0;\\n            if (count == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990828,
                "title": "c-straightforward-easy-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/ece6e55b-d459-418d-aaf6-28b2e7b1117e_1672729125.4522893.png)\\n\\n**T->O(n) [Worst Case Complexity] && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tfor(int i = 0 ; i < n - 2 ; i++){\\n\\t\\t\\t\\tif(arr[i]%2 && arr[i+1]%2 && arr[i+2]%2) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tfor(int i = 0 ; i < n - 2 ; i++){\\n\\t\\t\\t\\tif(arr[i]%2 && arr[i+1]%2 && arr[i+2]%2) return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1253518,
                "title": "100-faster-0-ms-c-simple-solution",
                "content": "Feel free to suggest ways to make this more elegant/ less lines of code.\\n\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i]%2 != 0) {\\n                count++;\\n            } else {\\n                count = 0;\\n            }\\n            if (count == 3){\\n                return true;  \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i]%2 != 0) {\\n                count++;\\n            } else {\\n                count = 0;\\n            }\\n            if (count == 3){\\n                return true;  \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799257,
                "title": "rust-linear-time-solution",
                "content": "```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        arr.windows(3)\\n            .any(|slice| is_odd(slice[0]) && is_odd(slice[1]) && is_odd(slice[2]))\\n    }\\n}\\n\\nfn is_odd(num: i32) -> bool {\\n    num % 2 == 1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        arr.windows(3)\\n            .any(|slice| is_odd(slice[0]) && is_odd(slice[1]) && is_odd(slice[2]))\\n    }\\n}\\n\\nfn is_odd(num: i32) -> bool {\\n    num % 2 == 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794518,
                "title": "java-100-speed-100-memory",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int i = 0;\\n\\t\\t// Check bounds \\n        while(i < arr.length - 2){\\n\\t\\t\\t// if current value is odd and other consecutive are odd  then return true\\n            if (arr[i]%2 == 1 && arr[i+1]%2 == 1 && arr[i+2]%2 == 1){\\n                return true;\\n            }\\n            i++;\\n        }\\n\\t\\t// else return false\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int i = 0;\\n\\t\\t// Check bounds \\n        while(i < arr.length - 2){\\n\\t\\t\\t// if current value is odd and other consecutive are odd  then return true\\n            if (arr[i]%2 == 1 && arr[i+1]%2 == 1 && arr[i+2]%2 == 1){\\n                return true;\\n            }\\n            i++;\\n        }\\n\\t\\t// else return false\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564669,
                "title": "java-100",
                "content": "```\\n\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] % 2 != 0)count++;\\n            else count=0;\\n            if(count==3)return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] % 2 != 0)count++;\\n            else count=0;\\n            if(count==3)return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1504943,
                "title": "java-simple-code",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0; i<arr.length-2; i++) {\\n            if(arr[i] % 2 != 0) {\\n                if(arr[i+1] %2 !=0  &&  arr[i+2] %2 != 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nplz upvote if found helpful :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0; i<arr.length-2; i++) {\\n            if(arr[i] % 2 != 0) {\\n                if(arr[i+1] %2 !=0  &&  arr[i+2] %2 != 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865563,
                "title": "c-straightforward-single-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        for (int i = 2; i < arr.size(); i++) {\\n            if (arr[i - 2] % 2 && arr[i - 1] % 2 && arr[i] % 2) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        for (int i = 2; i < arr.size(); i++) {\\n            if (arr[i - 2] % 2 && arr[i - 1] % 2 && arr[i] % 2) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861609,
                "title": "c-straight-forward-solution-brute-beats-98-runtime-96-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool threeConsecutiveOdds(vector<int> &arr)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); ++i)\\n        {\\n            if (arr[i] % 2 != 0)\\n                count++;\\n            else\\n            {\\n                if (count >= 3)\\n                    return true;\\n                count = 0;\\n            }\\n        }\\n        if (count >= 3)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool threeConsecutiveOdds(vector<int> &arr)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); ++i)\\n        {\\n            if (arr[i] % 2 != 0)\\n                count++;\\n            else\\n            {\\n                if (count >= 3)\\n                    return true;\\n                count = 0;\\n            }\\n        }\\n        if (count >= 3)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052639,
                "title": "no-extra-space-java-solution-please-upvote",
                "content": "# Problem Description\\n\\nYou are given an array `arr` of integers. Your task is to determine whether there exist three consecutive odd numbers in the array. If such a sequence exists, return `true`; otherwise, return `false`.\\n\\n# Intuition\\n\\nThe problem involves finding a sequence of three consecutive odd numbers in an array. The intuition here is to iterate through the array while keeping track of the parity (odd or even) of each element. By examining consecutive elements, we can identify whether three consecutive odds exist.\\n\\n# Approach\\n\\nTo solve this problem efficiently, we can follow this approach:\\n1. Check if the length of the `arr` is less than 3. If it is, return `false` because it\\'s impossible to have three consecutive odds with fewer than three elements.\\n2. Iterate through the array starting from the third element (index 2).\\n3. For each element at index `i`, convert it to its parity by taking the modulo 2 (`arr[i] = arr[i] % 2`).\\n4. Check if the sum of the current element and the two previous elements is equal to 3. If it is, return `true` because we have found three consecutive odd numbers.\\n5. If the loop completes without finding such a sequence, return `false` as there are no three consecutive odds.\\n\\n# Complexity Analysis\\n\\n- Time complexity: O(n), where `n` is the length of the `arr` array. We iterate through the array once.\\n- Space complexity: O(1), as we use only a constant amount of additional space for variables.\\n\\nThis optimized approach efficiently identifies whether there are three consecutive odd numbers in the array.\\n\\nShare this elegant solution with your fellow LeetCode enthusiasts and help them understand how to solve sequence-based problems with ease. Happy coding!\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length<3) return false;\\n        arr[0] = arr[0]%2;\\n        arr[1] = arr[1]%2;\\n        for(int i=2;i<arr.length;i++){\\n            arr[i] =arr[i]%2;\\n            if((arr[i] + arr[i-1] + arr[i-2]) == 3){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length<3) return false;\\n        arr[0] = arr[0]%2;\\n        arr[1] = arr[1]%2;\\n        for(int i=2;i<arr.length;i++){\\n            arr[i] =arr[i]%2;\\n            if((arr[i] + arr[i-1] + arr[i-2]) == 3){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640303,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr)<3:\\n            return 0\\n        window=[arr[0]%2,arr[1]%2,arr[2]%2]\\n        if window==[1,1,1]:\\n            return 1\\n        for i in range(3,len(arr)):\\n            window.pop(0)\\n            window.append(arr[i]%2)\\n            if window==[1,1,1]:\\n                return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr)<3:\\n            return 0\\n        window=[arr[0]%2,arr[1]%2,arr[2]%2]\\n        if window==[1,1,1]:\\n            return 1\\n        for i in range(3,len(arr)):\\n            window.pop(0)\\n            window.append(arr[i]%2)\\n            if window==[1,1,1]:\\n                return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486392,
                "title": "c-easy-solution-one-line-condition-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nConsecutive numbers are the numbers that continuously follow each other and odd are simply those who are not divisible by 2.if size of array is less than 3 that means it contains less than 3 digits simply return FALSE. THEN, start from third number whose index will always be 2 ,so initialize loop from 2 nd check if 3rd no. is not divisible by 2 and same for 2nd and 1st no. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<3){\\n            return false;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            if(arr[i]%2!=0 && arr[i-1]%2!=0 && arr[i-2]%2!=0){\\n                return true;\\n            }\\n        }\\n        \\n  return false;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<3){\\n            return false;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            if(arr[i]%2!=0 && arr[i-1]%2!=0 && arr[i-2]%2!=0){\\n                return true;\\n            }\\n        }\\n        \\n  return false;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418697,
                "title": "java-easy-solution-lbeginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i ++){\\n            if(arr[i] % 2 == 1){\\n                count++;\\n                if(count == 3){\\n                    return true;\\n                }\\n                continue;\\n            }\\n            count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i ++){\\n            if(arr[i] % 2 == 1){\\n                count++;\\n                if(count == 3){\\n                    return true;\\n                }\\n                continue;\\n            }\\n            count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321575,
                "title": "java-product-of-3-odds-is-odd",
                "content": "# Intuition:\\nProduct (or bitwise AND) of 3 odd numbers is always add.\\n\\n# Code:\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int n = arr.length;\\n        if (n < 3) return false;\\n\\n        for (int i = 0; i + 2 < n; i++) {\\n            // int p = arr[i] & arr[i+1] & arr[i+2];\\n            int p = arr[i] * arr[i+1] * arr[i+2];\\n            if (p % 2 == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int n = arr.length;\\n        if (n < 3) return false;\\n\\n        for (int i = 0; i + 2 < n; i++) {\\n            // int p = arr[i] & arr[i+1] & arr[i+2];\\n            int p = arr[i] * arr[i+1] * arr[i+2];\\n            if (p % 2 == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999980,
                "title": "c-easy-solution-beats-100-users",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<=2){\\n            return false;\\n        }\\n        for( int i=0 ; i<=arr.size()-3;i++){\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n                return true;\\n        }return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<=2){\\n            return false;\\n        }\\n        for( int i=0 ; i<=arr.size()-3;i++){\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n                return true;\\n        }return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716189,
                "title": "python",
                "content": "```\\nclass Solution(object):\\n    def threeConsecutiveOdds(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return any(all(map(lambda n: n%2, arr[i-3:i])) for i, _ in enumerate(arr[2:], 3))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def threeConsecutiveOdds(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return any(all(map(lambda n: n%2, arr[i-3:i])) for i, _ in enumerate(arr[2:], 3))",
                "codeTag": "Java"
            },
            {
                "id": 2710940,
                "title": "java-easiest-solution-0ms-runtime-faster-than-100-of-online-submission-o-n-complexity",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int size = arr.length;\\n        if(size <= 2){\\n            return false;\\n        }\\n        for(int i=0;i<size;i++){\\n            if(arr[i]%2 != 0){\\n                if(i+1 < size && i+2 < size){\\n                    if(arr[i+1]%2 != 0 && arr[i+2]%2 != 0)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int size = arr.length;\\n        if(size <= 2){\\n            return false;\\n        }\\n        for(int i=0;i<size;i++){\\n            if(arr[i]%2 != 0){\\n                if(i+1 < size && i+2 < size){\\n                    if(arr[i+1]%2 != 0 && arr[i+2]%2 != 0)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675339,
                "title": "python-beats-95-easy-solution",
                "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            if arr[i] % 2 != 0 and arr[i + 1] % 2 != 0 and arr[i + 2]  % 2 != 0:\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            if arr[i] % 2 != 0 and arr[i + 1] % 2 != 0 and arr[i + 2]  % 2 != 0:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2522955,
                "title": "java-simple-and-easy-solution-0ms-100-faster",
                "content": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n\\t\\n       int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if(arr[i]%2 != 0) {\\n                count++;\\n                if(count == 3) \\n                    return true;\\n                } else {\\n                    count = 0;\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n\\t\\n       int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if(arr[i]%2 != 0) {\\n                count++;\\n                if(count == 3) \\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2329183,
                "title": "simple-loop-python",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        c=0\\n        for i in arr:\\n            if i%2==0:\\n                c=0\\n            else:\\n                c+=1\\n                if c==3:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        c=0\\n        for i in arr:\\n            if i%2==0:\\n                c=0\\n            else:\\n                c+=1\\n                if c==3:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006535,
                "title": "easy-90-faster-js-solution",
                "content": "\\tvar threeConsecutiveOdds = function(arr) {\\n\\t\\tlet c = 0;\\n\\n\\t\\tfor(let val of arr){\\n\\t\\t\\tif(val % 2 === 1){\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tif(c === 3) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar threeConsecutiveOdds = function(arr) {\\n\\t\\tlet c = 0;\\n\\n\\t\\tfor(let val of arr){\\n\\t\\t\\tif(val % 2 === 1){\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tif(c === 3) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1899511,
                "title": "python-one-liners-x4",
                "content": "**Any**:\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, a):\\n        return any(True for i,x in enumerate(a) if i<len(a)-2 and a[i]%2==a[i+1]%2==a[i+2]%2==1)\\n```\\n\\n**String join**:\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return \"111\" in \"\".join(map(lambda x:str(x%2), arr))\\n```\\n\\n**Custom *accumulate* function**:\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return 3 in accumulate(arr,lambda x,y:x+y%2 if y%2 else 0, initial=0)\\n```\\n\\n**Group by**:\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return max(sum(g) for k,g in groupby(map(lambda x:x%2,arr))) >= 3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, a):\\n        return any(True for i,x in enumerate(a) if i<len(a)-2 and a[i]%2==a[i+1]%2==a[i+2]%2==1)\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return \"111\" in \"\".join(map(lambda x:str(x%2), arr))\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return 3 in accumulate(arr,lambda x,y:x+y%2 if y%2 else 0, initial=0)\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr):\\n        return max(sum(g) for k,g in groupby(map(lambda x:x%2,arr))) >= 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737817,
                "title": "javascript-simple-regex-solution",
                "content": "```javascript\\nvar threeConsecutiveOdds = function(arr) {\\n    return /\\\\d*[13579](,\\\\d*[13579]){2}/.test(arr)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar threeConsecutiveOdds = function(arr) {\\n    return /\\\\d*[13579](,\\\\d*[13579]){2}/.test(arr)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728398,
                "title": "java-very-easy-solution-runtime-0ms",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if((arr[i]&1)==1 && (arr[i+1]&1)==1 && (arr[i+2]&1)==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if((arr[i]&1)==1 && (arr[i+1]&1)==1 && (arr[i+2]&1)==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359237,
                "title": "java-0ms-clean-solution",
                "content": "\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if (arr.length < 3) return false;\\n\\n        for (int i = 0; i < arr.length - 2; i++) {\\n\\n            if ((arr[i] & arr[i + 1] & arr[i + 2] & 1) == 1) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if (arr.length < 3) return false;\\n\\n        for (int i = 0; i < arr.length - 2; i++) {\\n\\n            if ((arr[i] & arr[i + 1] & arr[i + 2] & 1) == 1) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1345336,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean threeConsecutiveOdds(int[] a) {\\n        if(a.length<3)\\n            return false;\\n        int i;\\n        for(i=0;i<a.length-2;i++)\\n        {\\n            if(a[i]%2==1&&a[i+1]%2==1&&a[i+2]%2==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean threeConsecutiveOdds(int[] a) {\\n        if(a.length<3)\\n            return false;\\n        int i;\\n        for(i=0;i<a.length-2;i++)\\n        {\\n            if(a[i]%2==1&&a[i+1]%2==1&&a[i+2]%2==1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238473,
                "title": "rust-solutions",
                "content": "Simple functional solution with windows (effective with small window):\\n```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        arr.windows(3)\\n            .map(|v| v.iter().all(|x| *x % 2 == 1))\\n            .any(|x| x)\\n    }\\n}\\n```\\n\\nMuch effective solution with simple cycle and counter (we calc remainder only once for each value in vector):\\n```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        let mut n_odds = 0;\\n        for is_odd in arr.iter().map(|x| *x % 2 == 1) {\\n            match is_odd {\\n                true => {\\n                    n_odds += 1;\\n                    if n_odds == 3 {\\n                        return true;\\n                    }\\n                }\\n                false => n_odds = 0,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        arr.windows(3)\\n            .map(|v| v.iter().all(|x| *x % 2 == 1))\\n            .any(|x| x)\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\\n        let mut n_odds = 0;\\n        for is_odd in arr.iter().map(|x| *x % 2 == 1) {\\n            match is_odd {\\n                true => {\\n                    n_odds += 1;\\n                    if n_odds == 3 {\\n                        return true;\\n                    }\\n                }\\n                false => n_odds = 0,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1193648,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr)<3:\\n            return False\\n        \\n        for i in range(len(arr)-2):\\n            odd1, odd2, odd3 = arr[i], arr[i+1], arr[i+2]\\n       \\n            if (odd1%2 !=0) and (odd2%2 !=0) and (odd3%2 !=0):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr)<3:\\n            return False\\n        \\n        for i in range(len(arr)-2):\\n            odd1, odd2, odd3 = arr[i], arr[i+1], arr[i+2]\\n       \\n            if (odd1%2 !=0) and (odd2%2 !=0) and (odd3%2 !=0):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156354,
                "title": "very-easy-java-solution-using-the-count-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int n=arr.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]%2!=0)  \\n            {\\n                count++;\\n                if(count==3) return true;\\n            }\\n            else count=0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int n=arr.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]%2!=0)  \\n            {\\n                count++;\\n                if(count==3) return true;\\n            }\\n            else count=0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072922,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return str([i & 1 for i in arr]).find(\\'1, 1, 1\\') > 0\\n```\\nExplanation:\\n* ```i & 1``` means bitwise i & 1, so if i is odd ```i & 1``` will give ```1``` and if i is even a ```0```\\n* the list comprehension gives a list with ```0```\\'s and ```1```\\'s\\n* if there are three consecutive odd numbers, ```\\'1, 1, 1\\'``` should be present in the list\\n* ```.find()``` gives the value -1 if it can\\'t find the inserted string",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return str([i & 1 for i in arr]).find(\\'1, 1, 1\\') > 0\\n```\n```i & 1```\n```i & 1```\n```1```\n```0```\n```0```\n```1```\n```\\'1, 1, 1\\'```\n```.find()```",
                "codeTag": "Java"
            },
            {
                "id": 1053233,
                "title": "python-simple-one-liner",
                "content": "By converting the modulus(item) of arr items in to str.\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join(str(num % 2) for num in arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return \"111\" in \"\".join(str(num % 2) for num in arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906400,
                "title": "python-3-solution-with-pseudocode-comments",
                "content": "Refactored based on feedback\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        #need to be 3 consecutive odd nums in the arr\\n        \\n        #variable: counter = 0\\n        counter = 0\\n        \\n        #loop thru arr\\n        for num in arr:\\n            #if num is divisible by 2 the continue\\n            if num % 2 == 0:\\n                #reset counter and continue\\n                counter = 0\\n            #else:\\n            else:\\n                #increment counter\\n                counter += 1\\n                #if counter equals 3\\n                if counter == 3:\\n                    #return true\\n                    return True\\n                \\n        #return false\\n        return False\\n```\\n\\t\\t\\nFirst Solution\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        #need to be 3 consecutive odd nums in the arr\\n        \\n        #variable: counter = 0\\n        counter = 0\\n        \\n        #loop thru arr\\n        for num in arr:\\n            #if counter equals 3:\\n            if counter == 3:\\n                #break early\\n                break\\n            #if num is divisible by 2 then\\n            elif num % 2 == 0:\\n                #reset counter and continue\\n                counter = 0\\n            #else:\\n            else:\\n                #increase counter by 1\\n                counter += 1\\n                \\n        #return true if counter equals 3 else false\\n        return True if counter == 3 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        #need to be 3 consecutive odd nums in the arr\\n        \\n        #variable: counter = 0\\n        counter = 0\\n        \\n        #loop thru arr\\n        for num in arr:\\n            #if num is divisible by 2 the continue\\n            if num % 2 == 0:\\n                #reset counter and continue\\n                counter = 0\\n            #else:\\n            else:\\n                #increment counter\\n                counter += 1\\n                #if counter equals 3\\n                if counter == 3:\\n                    #return true\\n                    return True\\n                \\n        #return false\\n        return False\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        #need to be 3 consecutive odd nums in the arr\\n        \\n        #variable: counter = 0\\n        counter = 0\\n        \\n        #loop thru arr\\n        for num in arr:\\n            #if counter equals 3:\\n            if counter == 3:\\n                #break early\\n                break\\n            #if num is divisible by 2 then\\n            elif num % 2 == 0:\\n                #reset counter and continue\\n                counter = 0\\n            #else:\\n            else:\\n                #increase counter by 1\\n                counter += 1\\n                \\n        #return true if counter equals 3 else false\\n        return True if counter == 3 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906374,
                "title": "python-solution-and-explanation",
                "content": "The idea behind the solution was to turn each index value into a boolean and then count three consecutive odds.\\nex: [1 2 3 4 5]\\n\\nIn the list comprehension we set odds to True and evens to False.\\nex: [T F T F T]\\n\\nNow looping through we can count the Ts. If we hit a False when counting we reset t_count to zero and every True we hit we increment by one.\\nex: [1 2 3 4 5]\\nex: [T F T F T]\\n\\nIn this example we do not get three consecutive odds meaning our for loop would end and return False being the last line to run in the function.\\n\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n      \\n        new_list = [True if num % 2 == 1 else False for num in arr ]\\n            \\n        t_count = 0\\n        \\n        for val in new_list:\\n            if val == False:\\n                t_count = 0\\n                \\n            if val == True:\\n                t_count += 1\\n                \\n            if t_count == 3:\\n                return True\\n                \\n\\t\\t\\t\\t\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n      \\n        new_list = [True if num % 2 == 1 else False for num in arr ]\\n            \\n        t_count = 0\\n        \\n        for val in new_list:\\n            if val == False:\\n                t_count = 0\\n                \\n            if val == True:\\n                t_count += 1\\n                \\n            if t_count == 3:\\n                return True\\n                \\n\\t\\t\\t\\t\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827437,
                "title": "easiest-python-beats-98",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        \\n        cnt = 0\\n        \\n        for i in arr:\\n            if i % 2 != 0:\\n                cnt += 1\\n                if cnt == 3:\\n                    return True\\n            else:\\n                cnt = 0\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        \\n        cnt = 0\\n        \\n        for i in arr:\\n            if i % 2 != 0:\\n                cnt += 1\\n                if cnt == 3:\\n                    return True\\n            else:\\n                cnt = 0\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794201,
                "title": "python3-self-explained",
                "content": "\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        cnt = 0\\n        for x in arr: \\n            cnt = cnt + 1 if x % 2 else 0\\n            if cnt == 3: return True\\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        cnt = 0\\n        for x in arr: \\n            cnt = cnt + 1 if x % 2 else 0\\n            if cnt == 3: return True\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 794171,
                "title": "javascript",
                "content": "Conditional check for odd num, and then break immediately if three are found.\\n```\\nvar threeConsecutiveOdds = function(arr) {\\n  for (let i = 0; i < arr.length; i++){\\n    if(arr[i] % 2 === 1 && arr[i + 1] % 2 === 1 && arr[i + 2] % 2 === 1 ){\\n      return true\\n    } \\n  }\\n  return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Conditional check for odd num, and then break immediately if three are found.\\n```\\nvar threeConsecutiveOdds = function(arr) {\\n  for (let i = 0; i < arr.length; i++){\\n    if(arr[i] % 2 === 1 && arr[i + 1] % 2 === 1 && arr[i + 2] % 2 === 1 ){\\n      return true\\n    } \\n  }\\n  return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 794153,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int oddNum=0;\\n        for(auto x:arr){\\n            if(x%2==1) oddNum++;\\n            else oddNum=0;\\n            if(oddNum==3) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int oddNum=0;\\n        for(auto x:arr){\\n            if(x%2==1) oddNum++;\\n            else oddNum=0;\\n            if(oddNum==3) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794079,
                "title": "javascript-python3-c-1-liners",
                "content": "**\"some\" solutions:**\\n\\nThanks to @vivekjain202 for suggesting this \"early exit\" optimization!\\n\\n---\\n\\n*Javascript*\\n```\\nlet threeConsecutiveOdds = A => A.some((_, i) => i < 2 ? false : A[i - 2] & A[i - 1] & A[i] & 1);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, A: List[int]) -> bool:\\n        return any([False if i < 2 else A[i - 2] & A[i - 1] & A[i] & 1 for i in range(len(A))])\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool threeConsecutiveOdds(VI& A) {\\n        return any_of(A.begin(), A.end(), [i = -1, &A](auto _) mutable {\\n            return ++i < 2 ? false : A[i - 2] & A[i - 1] & A[i] & 1;\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**\"reduce\" solutions:**\\n\\nReduce `A` with accumulator `found` initially set to `false`, return `true` if and only if a consecutive sequence of 3 odd values is `found` during this linear reduction of `A`.\\n\\n**Note:** accumulate() can be hacked into \"reduce()\" for C++ via a mutable lambda used to track the current i-th index \\uD83D\\uDC4D\\n\\n---\\n\\n**Contest 202 Screenshare:** https://www.youtube.com/watch?v=t1_lHuLvhzU&feature=youtu.be\\n\\n---\\n    \\n*Javascript*\\n```\\nlet threeConsecutiveOdds = A => A.reduce((found, _, i) => i < 2 ? found : found || A[i - 2] & A[i - 1] & A[i] & 1, false);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, A: List[int]) -> bool:\\n        return reduce(lambda found, i: found if i < 2 else found or A[i - 2] & A[i - 1] & A[i] & 1, [i for i in range(len(A))], False)\\n```\\n    \\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool threeConsecutiveOdds(VI& A) {\\n        return accumulate(A.begin(), A.end(), false, [i = -1, &A](auto found, auto _) mutable {\\n            return ++i < 2 ? found : found || A[i - 2] & A[i - 1] & A[i] & 1;\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet threeConsecutiveOdds = A => A.some((_, i) => i < 2 ? false : A[i - 2] & A[i - 1] & A[i] & 1);\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, A: List[int]) -> bool:\\n        return any([False if i < 2 else A[i - 2] & A[i - 1] & A[i] & 1 for i in range(len(A))])\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool threeConsecutiveOdds(VI& A) {\\n        return any_of(A.begin(), A.end(), [i = -1, &A](auto _) mutable {\\n            return ++i < 2 ? false : A[i - 2] & A[i - 1] & A[i] & 1;\\n        });\\n    }\\n};\\n```\n```\\nlet threeConsecutiveOdds = A => A.reduce((found, _, i) => i < 2 ? found : found || A[i - 2] & A[i - 1] & A[i] & 1, false);\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, A: List[int]) -> bool:\\n        return reduce(lambda found, i: found if i < 2 else found or A[i - 2] & A[i - 1] & A[i] & 1, [i for i in range(len(A))], False)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool threeConsecutiveOdds(VI& A) {\\n        return accumulate(A.begin(), A.end(), false, [i = -1, &A](auto found, auto _) mutable {\\n            return ++i < 2 ? found : found || A[i - 2] & A[i - 1] & A[i] & 1;\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026958,
                "title": "nothing-in-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```If arr contains consecutive odd numbers ? return true : else return false```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Just loop through given input array.\\nStep-2 -> Check if element is odd just increment count else reset count.\\nStep-3 -> Need check for 3 consecutive odd numbers if found return true.\\nStep-4 -> Else return false in the end which means not found*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i:arr){\\n            if(i%2==1) count++;\\n            else count = 0;\\n            if(count == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```If arr contains consecutive odd numbers ? return true : else return false```\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i:arr){\\n            if(i%2==1) count++;\\n            else count = 0;\\n            if(count == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980112,
                "title": "simply-3-step-explanation",
                "content": "\\n\\n# Approach\\n1) Initialize one counter variable\\n2) Make a loop and check for if the number is odd then increment the count, if number is even means make count to 0\\n3) Then finally check for if count==3(Because the problem statement is 3 consecutive odds)return true... else return false\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2!=0){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==3){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2!=0){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==3){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980053,
                "title": "3-lines-code-simplified",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Straight Forward Approach*\\n*Step-1 -> Initialise a variable count set to 0.\\nStep-2 -> Iterate through the input array arr.\\nStep-3 -> If an element is odd, increment count. If it\\'s even, reset count to 0.\\nStep-4 -> If count reaches 3, return true (three consecutive odds found).\\nStep-5 -> If the loop finishes without finding three consecutive odds, return false.*\\n# Complexity\\n*- Time complexity: O ( n )*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n*- Space complexity: O ( 1 )*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i:arr){\\n            if(i%2==0) count=0;\\n            else count++;\\n            if(count==3) return true;   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i:arr){\\n            if(i%2==0) count=0;\\n            else count++;\\n            if(count==3) return true;   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918293,
                "title": "java-100-beat-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe are just using a linear search and a variable to count the odd numbers are consecutive or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(count==0&& arr[i]%2!=0){\\n                count++;\\n            }\\n            else if(count==1&& arr[i]%2!=0){\\n                count++;\\n            }\\n            else if(count==2&& arr[i]%2!=0){\\n                return true;\\n            }\\n            else if(arr[i]%2==0){\\n                count=0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(count==0&& arr[i]%2!=0){\\n                count++;\\n            }\\n            else if(count==1&& arr[i]%2!=0){\\n                count++;\\n            }\\n            else if(count==2&& arr[i]%2!=0){\\n                return true;\\n            }\\n            else if(arr[i]%2==0){\\n                count=0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779331,
                "title": "beats-100-of-java-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(Short i=0;i<arr.length-2;i++){\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(Short i=0;i<arr.length-2;i++){\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554664,
                "title": "easy-solutions",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n\\n      int count=0;\\n      for(int  a:arr){\\n          if(a%2!=0){\\n          count++;\\n          if(count==3) return true;\\n          }\\n          else count=0;\\n      }  \\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n\\n      int count=0;\\n      for(int  a:arr){\\n          if(a%2!=0){\\n          count++;\\n          if(count==3) return true;\\n          }\\n          else count=0;\\n      }  \\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363485,
                "title": "three-consecutive-odds-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int i;\\n        if(arr.size()<3)\\n        {\\n            return false;\\n        }\\n        for(i=0 ; i<arr.size()-2 ; i++)\\n        {\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int i;\\n        if(arr.size()<3)\\n        {\\n            return false;\\n        }\\n        for(i=0 ; i<arr.size()-2 ; i++)\\n        {\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985055,
                "title": "c-easy-0ms-o-n-starightforward",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size();++i){\\n            if(arr[i]%2==1){\\n                cnt++;}\\n                else {cnt=0;}\\n             if(cnt>=3){\\n                    return true;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size();++i){\\n            if(arr[i]%2==1){\\n                cnt++;}\\n                else {cnt=0;}\\n             if(cnt>=3){\\n                    return true;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906254,
                "title": "java-o-n-1-ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0; i < arr.length - 2; i++) {\\n            boolean isOdd1 = arr[i] % 2 == 1;\\n            boolean isOdd2 = arr[i + 1] % 2 == 1;\\n            boolean isOdd3 = arr[i + 2] % 2 == 1;\\n            if (isOdd1 && isOdd2 && isOdd3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0; i < arr.length - 2; i++) {\\n            boolean isOdd1 = arr[i] % 2 == 1;\\n            boolean isOdd2 = arr[i + 1] % 2 == 1;\\n            boolean isOdd3 = arr[i + 2] % 2 == 1;\\n            if (isOdd1 && isOdd2 && isOdd3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821817,
                "title": "python-easy-to-understand",
                "content": "```\\ndef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for num in arr:\\n            if num % 2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for num in arr:\\n            if num % 2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2787116,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n    int odds = 0;\\n    for (auto i = 0; i < arr.size() && odds < 3; ++i)\\n        odds = arr[i] % 2 ? odds + 1 : 0;\\n    return odds == 3;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n    int odds = 0;\\n    for (auto i = 0; i < arr.size() && odds < 3; ++i)\\n        odds = arr[i] % 2 ? odds + 1 : 0;\\n    return odds == 3;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752131,
                "title": "1550-three-consecutive-odds",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n\\t\\t\\t\\n\\t\\t\\tint j = 0, i = 0;\\n\\t\\t\\tdeque<int> dq;\\n\\n\\t\\t\\twhile(j < arr.size()) {\\n\\n\\t\\t\\t\\tif(arr[j] % 2 != 0) {\\n\\t\\t\\t\\t\\tdq.push_back(arr[j]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(j - i + 1 == 3) {\\n\\t\\t\\t\\t\\tif(dq.size() == 3) return true;\\n\\n\\t\\t\\t\\t\\tif(!dq.empty() and arr[i] == dq.front()) dq.pop_front();\\n\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n\\t\\t\\t\\n\\t\\t\\tint j = 0, i = 0;\\n\\t\\t\\tdeque<int> dq;\\n\\n\\t\\t\\twhile(j < arr.size()) {\\n\\n\\t\\t\\t\\tif(arr[j] % 2 != 0) {\\n\\t\\t\\t\\t\\tdq.push_back(arr[j]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2702833,
                "title": "0-ms-faster-than-100-00-java",
                "content": "```\\n\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n\\n        for (int j : arr) {\\n            if (j % 2 == 1) {\\n                count++;\\n                if (count >= 3) return true;\\n            } else count = 0;\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n\\n        for (int j : arr) {\\n            if (j % 2 == 1) {\\n                count++;\\n                if (count >= 3) return true;\\n            } else count = 0;\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599465,
                "title": "swift-solution-faster-than-92",
                "content": "```\\nclass Solution {\\n    func threeConsecutiveOdds(_ arr: [Int]) -> Bool {\\n        var count = 0\\n        for num in arr {\\n            count = num % 2 != 0 ? count + 1 : 0\\n            if count == 3 { return true }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeConsecutiveOdds(_ arr: [Int]) -> Bool {\\n        var count = 0\\n        for num in arr {\\n            count = num % 2 != 0 ? count + 1 : 0\\n            if count == 3 { return true }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564629,
                "title": "java-faster-100",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int c = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] % 2 != 0) c++;\\n            else c = 0;\\n            \\n            if (c == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int c = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] % 2 != 0) c++;\\n            else c = 0;\\n            \\n            if (c == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516080,
                "title": "java-100-faster-0ms",
                "content": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i-1]%2!=0&&arr[i]%2!=0 && arr[i+1]%2!=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i-1]%2!=0&&arr[i]%2!=0 && arr[i+1]%2!=0){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2472259,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0 ; i < arr.length; i++) {\\n            if(arr[i]%2 == 1)\\n                count+=1;\\n            else\\n                count = 0;\\n            if(count == 3)\\n                return true;\\n        }\\n        \\n        if(count == 3)\\n            return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0 ; i < arr.length; i++) {\\n            if(arr[i]%2 == 1)\\n                count+=1;\\n            else\\n                count = 0;\\n            if(count == 3)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2461647,
                "title": "java-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i]%2 == 1 && arr[i + 1]%2 == 1 && arr[i + 2]%2 == 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i]%2 == 1 && arr[i + 1]%2 == 1 && arr[i + 2]%2 == 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447212,
                "title": "easy-python3-solution",
                "content": "``` \\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in arr:\\n            if i%2!=0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` \\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in arr:\\n            if i%2!=0:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425391,
                "title": "java",
                "content": "class Solution \\n{\\n    public boolean threeConsecutiveOdds(int[] arr) \\n    \\n    {\\n      if(arr.length<3)\\n        return false;\\n       for(int i=0; i<=arr.length-3; i++) \\n       {\\n         if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n         {\\n           return true;\\n         }\\n       }\\n      return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public boolean threeConsecutiveOdds(int[] arr) \\n    \\n    {\\n      if(arr.length<3)\\n        return false;\\n       for(int i=0; i<=arr.length-3; i++) \\n       {\\n         if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n         {\\n           return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2364235,
                "title": "with-explanation-comments-time-3-ms-86-60-space-8-3-mb-58-68",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        \\n        //base case: few elements\\n        if(arr.size()<=2)\\n            return false;\\n        \\n        //loop over the whole array elements until the second last one\\n        for(int i=0;i<arr.size()-2;i++)\\n            //check if the current three consecutive ones are odd or not\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                //if yes-> return true\\n                return true;\\n        \\n        //if no-> return false\\n        return false;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        \\n        //base case: few elements\\n        if(arr.size()<=2)\\n            return false;\\n        \\n        //loop over the whole array elements until the second last one\\n        for(int i=0;i<arr.size()-2;i++)\\n            //check if the current three consecutive ones are odd or not\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                //if yes-> return true\\n                return true;\\n        \\n        //if no-> return false\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2347264,
                "title": "beats-100-c-damn-simple-3-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {    \\n        for(int i=2;i<arr.size();i++)\\n            if(arr[i-2]%2 && arr[i-1]%2 && arr[i]%2) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {    \\n        for(int i=2;i<arr.size();i++)\\n            if(arr[i-2]%2 && arr[i-1]%2 && arr[i]%2) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300224,
                "title": "c-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& a) {\\n        if(a.size() < 3) {\\n            return false;\\n        }\\n        for(int i = 0; i < a.size()-2; ++i) {\\n            if(a[i] % 2 != 0 && a[i+1] % 2 != 0 && a[i+2] % 2 != 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& a) {\\n        if(a.size() < 3) {\\n            return false;\\n        }\\n        for(int i = 0; i < a.size()-2; ++i) {\\n            if(a[i] % 2 != 0 && a[i+1] % 2 != 0 && a[i+2] % 2 != 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248937,
                "title": "three-consecutive-odds",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        boolean flag=false;\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if( (arr[i]%2 != 0) && (arr[i+1]%2 != 0) && (arr[i+2]%2 != 0) )\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        if(flag==true)\\n            return true;\\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        boolean flag=false;\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if( (arr[i]%2 != 0) && (arr[i+1]%2 != 0) && (arr[i+2]%2 != 0) )\\n            {\\n                flag=true;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2224732,
                "title": "java-0ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int size = arr.length;\\n        if(arr.length<3)return false;\\n        for(int i=0;i<size-2;i++){\\n            if(arr[i]%2==1&&arr[i+1]%2==1&&arr[i+2]%2==1)return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int size = arr.length;\\n        if(arr.length<3)return false;\\n        for(int i=0;i<size-2;i++){\\n            if(arr[i]%2==1&&arr[i+1]%2==1&&arr[i+2]%2==1)return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102122,
                "title": "three-consecutive-odds",
                "content": "class Solution {\\n\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0; i<arr.length-2; i++){\\n            if((arr[i]%2 !=0) && (arr[i+1]%2 !=0) && (arr[i+2]%2 !=0))\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0; i<arr.length-2; i++){\\n            if((arr[i]%2 !=0) && (arr[i+1]%2 !=0) && (arr[i+2]%2 !=0))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2094591,
                "title": "using-list-comp",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr) - 2):\\n            sub = [n for n in arr[i:i+3] if n % 2]\\n            if len(sub) == 3:\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr) - 2):\\n            sub = [n for n in arr[i:i+3] if n % 2]\\n            if len(sub) == 3:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090623,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        odd_count = 0\\n        for num in arr:\\n            if((num % 2) != 0):\\n                odd_count += 1\\n            if((num % 2) == 0):\\n                odd_count = 0\\n            if(odd_count == 3):\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        odd_count = 0\\n        for num in arr:\\n            if((num % 2) != 0):\\n                odd_count += 1\\n            if((num % 2) == 0):\\n                odd_count = 0\\n            if(odd_count == 3):\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2018884,
                "title": "easy-approach-with-explanation-c-solution",
                "content": "```\\nEXPLANATION: \\n1) Take a variable to keep count of odd numbers.\\n2) Increase the count of variable whenever it encounters an odd number otherwise make the variable 0.\\n3) Use an if condition to check if the variable becomes 3 at any instance and if it does, then return true otherwise return false.\\n\\n\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) \\n    {\\n      int odd=0;\\n      for(int i=0;i<arr.size();i++)\\n      {\\n        if(arr[i]%2!=0)\\n            odd++;\\n        else\\n            odd=0;\\n         if(odd==3)\\n             return true;\\n          \\n      }\\n       return false; \\n        \\n        \\n    }\\n};\\n\\nNOTE: IF THIS SOLUTION WAS HELPFUL THEN DO NOT FORGET TO UPVOTE, THANKS :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) \\n    {\\n      int odd=0;\\n      for(int i=0;i<arr.size();i++)\\n      {\\n        if(arr[i]%2!=0)\\n            odd++;\\n        else\\n            odd=0;\\n         if(odd==3)\\n             return true;\\n          \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1981969,
                "title": "three-consecutive-odds",
                "content": "```\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(arr[i] % 2 == 1)\\n            {\\n                count++;\\n                if(count == 3)\\n                    break;\\n            }\\n            else\\n            {\\n                count = 0;\\n            }\\n        }\\n        if(count == 3)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(arr[i] % 2 == 1)\\n            {\\n                count++;\\n                if(count == 3)\\n                    break;\\n            }\\n            else\\n            {\\n                count = 0;\\n            }\\n        }\\n        if(count == 3)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919275,
                "title": "simple-8-line-python-code-for-beginners-single-loop-67-ms",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        for i in range(0,n-2):\\n            if arr[i]%2!=0 and arr[i+1]%2!=0 and arr[i+2]%2!=0:\\n                return True\\n                break\\n            else:\\n                pass\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        for i in range(0,n-2):\\n            if arr[i]%2!=0 and arr[i+1]%2!=0 and arr[i+2]%2!=0:\\n                return True\\n                break\\n            else:\\n                pass\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846337,
                "title": "no-fancy-simple-solution-0ms-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count=0;\\n        for(int i=0;i<size(arr);i++){\\n            if(arr[i]&1){\\n                count++;\\n                if(count==3)return 1;\\n            }\\n            else count=0;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827491,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%2!=0)\\n                c++;\\n            else\\n            {\\n                if(c>=3)\\n                return true;\\n                c=0;\\n            }\\n        }\\n        if(c>=3)\\n            return true;\\n        else\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%2!=0)\\n                c++;\\n            else\\n            {\\n                if(c>=3)\\n                return true;\\n                c=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1815636,
                "title": "python-basic-if-else-solution-runtime-40-ms",
                "content": "```\\nflag=0\\nfor i in range(0,len(arr)):\\n\\tif flag==2:\\n\\t\\tif arr[i]%2!=0:\\n\\t\\t\\treturn True\\n\\t\\telse:\\n\\t\\t\\tflag=0\\n\\telif flag==1:\\n\\t\\tif arr[i]%2!=0:\\n\\t\\t\\tflag=2\\n\\t\\telse:\\n\\t\\t\\tflag=0\\n\\telif arr[i]%2!=0:\\n\\t\\tflag=1\\nreturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nflag=0\\nfor i in range(0,len(arr)):\\n\\tif flag==2:\\n\\t\\tif arr[i]%2!=0:\\n\\t\\t\\treturn True\\n\\t\\telse:\\n\\t\\t\\tflag=0\\n\\telif flag==1:\\n\\t\\tif arr[i]%2!=0:\\n\\t\\t\\tflag=2\\n\\t\\telse:\\n\\t\\t\\tflag=0\\n\\telif arr[i]%2!=0:\\n\\t\\tflag=1\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1780992,
                "title": "c-easy-solution-2-lines-code",
                "content": "****Please upvote me  :)****\\n```\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n     \\n        int n =arr.size();\\n        \\n        for(int i=2;i<n;i++){\\n            if(arr[i]%2==1 && arr[i-1]%2==1 && arr[i-2]%2==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool threeConsecutiveOdds(vector<int>& arr) {\\n     \\n        int n =arr.size();\\n        \\n        for(int i=2;i<n;i++){\\n            if(arr[i]%2==1 && arr[i-1]%2==1 && arr[i-2]%2==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766011,
                "title": "java",
                "content": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] % 2 != 0){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n            if(count == 3)\\n                return true;\\n        }\\n        return false; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] % 2 != 0){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1758993,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in range(len(arr)):\\n            if arr[i] % 2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True \\n            else:\\n                count = 0\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in range(len(arr)):\\n            if arr[i] % 2 != 0:\\n                count += 1\\n                if count == 3:\\n                    return True \\n            else:\\n                count = 0\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705969,
                "title": "javascript-clean-code",
                "content": "```\\nvar threeConsecutiveOdds = function(arr) {\\n    function isOdd(num) {\\n        return (num%2 === 0) ? false : true\\n    }\\n\\n    for (let i = 0; i < arr.length-2; i++) {\\n        if (isOdd(arr[i]) && isOdd(arr[i+1]) && isOdd(arr[i+2])) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeConsecutiveOdds = function(arr) {\\n    function isOdd(num) {\\n        return (num%2 === 0) ? false : true\\n    }\\n\\n    for (let i = 0; i < arr.length-2; i++) {\\n        if (isOdd(arr[i]) && isOdd(arr[i+1]) && isOdd(arr[i+2])) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1700154,
                "title": "conceptual-python-code",
                "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            \\n            if((arr[i]%2 !=0) and (arr[i+1]%2 !=0) and (arr[i+2]%2 !=0)):\\n                return True\\n            \\n            else:pass\\n            \\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            \\n            if((arr[i]%2 !=0) and (arr[i+1]%2 !=0) and (arr[i+2]%2 !=0)):\\n                return True\\n            \\n            else:pass\\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1669748,
                "title": "0ms-java-simple-solution",
                "content": "no need for explanation\\n\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601317,
                "title": "java-o-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int num : arr)\\n        {\\n            //if found an odd number, increment count, if count reaches 3, return 3\\n            if(num%2 != 0)\\n            {\\n                if(++count==3) return true;\\n            }\\n            //else reset count\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int num : arr)\\n        {\\n            //if found an odd number, increment count, if count reaches 3, return 3\\n            if(num%2 != 0)\\n            {\\n                if(++count==3) return true;\\n            }\\n            //else reset count\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583799,
                "title": "easy-python-solution",
                "content": "```\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(2,len(arr)):\\n            if arr[i-2]%2==1 and arr[i-1]%2==1 and arr[i]%2==1:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(2,len(arr)):\\n            if arr[i-2]%2==1 and arr[i-1]%2==1 and arr[i]%2==1:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1583362,
                "title": "python-3-simple-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        odds = 0\\n        for num in arr:\\n            if num % 2:\\n                if odds == 2:\\n                    return True\\n                odds += 1\\n            else:\\n                odds = 0\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        odds = 0\\n        for num in arr:\\n            if num % 2:\\n                if odds == 2:\\n                    return True\\n                odds += 1\\n            else:\\n                odds = 0\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1532975,
                "title": "beats-100-easiest-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int counter = 0;\\n\\n        for (int num : arr) {\\n            if (num % 2 != 0) counter++;\\n            else counter = 0;\\n\\n            if (counter == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int counter = 0;\\n\\n        for (int num : arr) {\\n            if (num % 2 != 0) counter++;\\n            else counter = 0;\\n\\n            if (counter == 3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532793,
                "title": "java-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int counter = 0;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i-1] % 2 == 1 && arr[i] % 2 == 1) {\\n                counter++;\\n            } else {\\n                counter = 0;\\n            }\\n            \\n            if (counter > 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int counter = 0;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i-1] % 2 == 1 && arr[i] % 2 == 1) {\\n                counter++;\\n            } else {\\n                counter = 0;\\n            }\\n            \\n            if (counter > 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476839,
                "title": "python-36-ms-faster-than-98-78-14-2-mb-less-than-78-32",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n\\n        a, b, c = arr.pop(0), arr.pop(0), arr.pop(0)\\n        if all(x % 2 == 1 for x in (a, b, c)):\\n            return True\\n\\n        while arr:\\n            a, b, c = b, c, arr.pop(0)\\n            if all(x % 2 == 1 for x in (a, b, c)):\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n\\n        a, b, c = arr.pop(0), arr.pop(0), arr.pop(0)\\n        if all(x % 2 == 1 for x in (a, b, c)):\\n            return True\\n\\n        while arr:\\n            a, b, c = b, c, arr.pop(0)\\n            if all(x % 2 == 1 for x in (a, b, c)):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339814,
                "title": "simple-solution-for-three-consecutive-odds-93-86-faster",
                "content": "![image](https://assets.leetcode.com/users/images/958d0da6-e132-45ac-98c8-5ce927205b7b_1626361834.4475968.png)\\n\\n```class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 2:\\n            return False\\n        else:\\n            for i in range(len(arr)-2):\\n                if arr[i]%2 != 0 and arr[i+1]%2 != 0 and arr[i+2]%2 != 0:\\n                    return True\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/958d0da6-e132-45ac-98c8-5ce927205b7b_1626361834.4475968.png)\\n\\n```class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 2:\\n            return False\\n        else:\\n            for i in range(len(arr)-2):\\n                if arr[i]%2 != 0 and arr[i+1]%2 != 0 and arr[i+2]%2 != 0:\\n                    return True\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 1298288,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        def isOdd(n):\\n            if (n % 2) != 0:\\n                return True\\n            else: \\n                return False\\n        for i in range(len(arr) - 2):\\n            if  (isOdd(arr[i]) & isOdd(arr[i+1]) & isOdd(arr[i+2])):\\n                return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        def isOdd(n):\\n            if (n % 2) != 0:\\n                return True\\n            else: \\n                return False\\n        for i in range(len(arr) - 2):\\n            if  (isOdd(arr[i]) & isOdd(arr[i+1]) & isOdd(arr[i+2])):\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280536,
                "title": "easy-one-in-python",
                "content": "a=0\\n        for i in range(len(arr)):\\n            if(arr[i]%2!=0):\\n                a+=1\\n                if(a==3):\\n                    break\\n            else:\\n                a=0\\n        return a>2",
                "solutionTags": [],
                "code": "a=0\\n        for i in range(len(arr)):\\n            if(arr[i]%2!=0):\\n                a+=1\\n                if(a==3):\\n                    break\\n            else:\\n                a=0\\n        return a>2",
                "codeTag": "Unknown"
            },
            {
                "id": 1257825,
                "title": "very-easy-to-understand",
                "content": "Just go through every 3 numbers \\n``` \\n\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n        \\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i - 1] % 2 != 0 && arr[i] % 2 != 0 && arr[i + 1] % 2 != 0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Just go through every 3 numbers \\n``` \\n\\t\\tbool threeConsecutiveOdds(vector<int>& arr) {\\n        \\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i - 1] % 2 != 0 && arr[i] % 2 != 0 && arr[i + 1] % 2 != 0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1243409,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2==1)\\n                count++;\\n            else\\n                count=0;\\n            if(count==3)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2==1)\\n                count++;\\n            else\\n                count=0;\\n            if(count==3)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238522,
                "title": "python3-simple-o-n-solution",
                "content": "def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        \\n        for i in arr:\\n            if i % 2 != 0:\\n                count += 1\\n                \\n                if count == 3:\\n                    return True\\n                \\n            else:\\n                count = 0\\n            \\n        return False\\n    \\n    # Time complexity is O(N) and space complexity is O(1).\\n",
                "solutionTags": [],
                "code": "def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        \\n        for i in arr:\\n            if i % 2 != 0:\\n                count += 1\\n                \\n                if count == 3:\\n                    return True\\n                \\n            else:\\n                count = 0\\n            \\n        return False\\n    \\n    # Time complexity is O(N) and space complexity is O(1).\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1223885,
                "title": "easy-cpp-solution-with-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    bool odd(int n)\\n    {\\n        return n % 2 == 1;\\n    }\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int l = arr.size();\\n        if(l == 1 || l == 2)\\n            return false;\\n        for(int i = 1; i < l - 1; i++)\\n        {\\n            if(odd(arr[i - 1]) & odd(arr[i]) & odd(arr[i + 1]))\\n               return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool odd(int n)\\n    {\\n        return n % 2 == 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1196702,
                "title": "python-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return any([x[0] % 2 == 1 and x[1] % 2 == 1 and x[2] %2 == 1 for x in zip(arr, arr[1:], arr[2:])])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return any([x[0] % 2 == 1 and x[1] % 2 == 1 and x[2] %2 == 1 for x in zip(arr, arr[1:], arr[2:])])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183991,
                "title": "python-3-solution-99-73-better-runtime",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if(arr[i]%2!=0 and arr[i+1]%2!=0 and arr[i+2]%2!=0):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if(arr[i]%2!=0 and arr[i+1]%2!=0 and arr[i+2]%2!=0):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183721,
                "title": "100-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count=0;\\n        for(auto i:arr)\\n        {\\n            \\n            if(i%2!=0)\\n            {\\n                count++;\\n\\t\\t\\t\\t/* if count reach 3 then we found our answer */\\n                if(count==3)\\n                    return true;\\n                \\n            }\\n          else{\\n\\t\\t  /* if we found even number then we reset our count to 0 */\\n              count=0;\\n          }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int count=0;\\n        for(auto i:arr)\\n        {\\n            \\n            if(i%2!=0)\\n            {\\n                count++;\\n\\t\\t\\t\\t/* if count reach 3 then we found our answer */\\n                if(count==3)\\n                    return true;\\n                \\n            }\\n          else{\\n\\t\\t  /* if we found even number then we reset our count to 0 */\\n              count=0;\\n          }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173376,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int j=i+1;\\n            int k=i+2;\\n            if(k<arr.length)\\n                if(arr[i]%2!=0 && arr[j]%2!=0 && arr[k]%2!=0) return true;  \\n        }\\n        return false;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int j=i+1;\\n            int k=i+2;\\n            if(k<arr.length)\\n                if(arr[i]%2!=0 && arr[j]%2!=0 && arr[k]%2!=0) return true;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1153126,
                "title": "python-simple-and-easy-to-understand",
                "content": "```\\nodd = 0\\nfor i in arr:\\n\\tif i % 2 != 0:\\n\\t\\todd+=1\\n\\telse:\\n\\t\\todd = 0\\n\\n\\tif odd == 3:\\n\\t\\treturn True\\n\\nreturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nodd = 0\\nfor i in arr:\\n\\tif i % 2 != 0:\\n\\t\\todd+=1\\n\\telse:\\n\\t\\todd = 0\\n\\n\\tif odd == 3:\\n\\t\\treturn True\\n\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145869,
                "title": "java-simple-100",
                "content": "Actually check if three consecutive numbers are odd\\n```\\n\\tpublic boolean threeConsecutiveOdds(int[] arr) {\\n\\t\\tfor (int i = 1; i < arr.length - 1; i++) {\\n\\t\\t\\tif (isOdd(arr[i - 1])\\n\\t\\t\\t\\t\\t&& isOdd(arr[i])\\n\\t\\t\\t\\t\\t&& isOdd(arr[i + 1])) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\tprivate boolean isOdd(int number) {\\n\\t\\treturn number % 2 != 0;\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic boolean threeConsecutiveOdds(int[] arr) {\\n\\t\\tfor (int i = 1; i < arr.length - 1; i++) {\\n\\t\\t\\tif (isOdd(arr[i - 1])\\n\\t\\t\\t\\t\\t&& isOdd(arr[i])\\n\\t\\t\\t\\t\\t&& isOdd(arr[i + 1])) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\tprivate boolean isOdd(int number) {\\n\\t\\treturn number % 2 != 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1129207,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public bool ThreeConsecutiveOdds(int[] arr) {\\n        \\n        if(arr == null || arr.Length < 3)\\n            return false;\\n            \\n        int cnt = 0;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            cnt = arr[i] % 2 == 0? 0 : cnt + 1;\\n            if(cnt == 3)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ThreeConsecutiveOdds(int[] arr) {\\n        \\n        if(arr == null || arr.Length < 3)\\n            return false;\\n            \\n        int cnt = 0;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            cnt = arr[i] % 2 == 0? 0 : cnt + 1;\\n            if(cnt == 3)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122408,
                "title": "java-100-faster-simple-code",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int flag=0;\\n        for(int i=0 ; i<arr.length ; i++)\\n        {\\n            if(arr[i]%2!=0)\\n            {\\n                flag++;\\n                if(flag==3) return true;\\n            }\\n            else flag=0;\\n        }\\n        return false;            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int flag=0;\\n        for(int i=0 ; i<arr.length ; i++)\\n        {\\n            if(arr[i]%2!=0)\\n            {\\n                flag++;\\n                if(flag==3) return true;\\n            }\\n            else flag=0;\\n        }\\n        return false;            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110378,
                "title": "java-linear-time-solution-easy",
                "content": "```\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int num : arr){\\n            if(num % 2 != 0) \\n                count++;\\n            else count = 0;\\n            \\n            if(count == 3) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int num : arr){\\n            if(num % 2 != 0) \\n                count++;\\n            else count = 0;\\n            \\n            if(count == 3) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057697,
                "title": "python3-simple-solution-with-two-approaches",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in range(len(arr)):\\n            if arr[i] % 2 != 0:\\n                count += 1\\n            else:\\n                count = 0\\n            if count == 3:\\n                return True\\n        return False\\n```\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if arr[i] & 1 == 1 and arr[i+1] & 1 == 1 and arr[i+2] & 1 == 1:\\n                return True\\n        return False\\n```\\n**If you like the solution, please vote for this.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count = 0\\n        for i in range(len(arr)):\\n            if arr[i] % 2 != 0:\\n                count += 1\\n            else:\\n                count = 0\\n            if count == 3:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if arr[i] & 1 == 1 and arr[i+1] & 1 == 1 and arr[i+2] & 1 == 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040674,
                "title": "python-solution",
                "content": "\\tresult = 0\\n\\tfor num in arr:\\n\\t\\tif num % 2 == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif result == 3:\\n\\t\\t\\t\\treturn True\\n\\t\\telse:\\n\\t\\t\\tresult = 0\\n\\treturn False",
                "solutionTags": [],
                "code": "\\tresult = 0\\n\\tfor num in arr:\\n\\t\\tif num % 2 == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif result == 3:\\n\\t\\t\\t\\treturn True\\n\\t\\telse:\\n\\t\\t\\tresult = 0\\n\\treturn False",
                "codeTag": "Unknown"
            },
            {
                "id": 998672,
                "title": "kotlin-readable-solution",
                "content": "```\\nclass Solution {\\n    fun threeConsecutiveOdds(arr: IntArray) = arr.toList().windowed(3).any { \\n        it[0].isOdd() && it[1].isOdd() && it[2].isOdd()\\n    }\\n    \\n    private fun Int.isOdd() = this % 2 == 1\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun threeConsecutiveOdds(arr: IntArray) = arr.toList().windowed(3).any { \\n        it[0].isOdd() && it[1].isOdd() && it[2].isOdd()\\n    }\\n    \\n    private fun Int.isOdd() = this % 2 == 1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998566,
                "title": "java-sliding-window-approach-with-bitwise-operation-beats-100",
                "content": "The main idea is to have a sliding window of 3 elements and a sum that adds the last bit of the numbers. \\nIf a number is even, last bit is 0, if odd, last bit is 1. It is similar with having ```x % 2``` but ```x & 1``` is faster.\\nIf the sum is 3, we return true as we found 3 numbers that are odd.\\n\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        # Return false if array is null or does not have at least 3 elements\\n        if (arr == null || arr.length < 3)\\n            return false;\\n\\t\\t\\t\\n        # Compute the sum for the first 3 elements\\n        int moving_sum = last_bit(arr[0]) + last_bit(arr[1]) + last_bit(arr[2]);\\n        \\n\\t\\t# Return true if the first 3 elements are odd\\n        if (moving_sum == 3)\\n            return true;\\n        \\n\\t\\t# Search for 3 consecutive odd numbers - sliding window\\n        for (int i = 3; i < arr.length; i++) {\\n            moving_sum -= last_bit(arr[i-3]);\\n            moving_sum += last_bit(arr[i]);\\n            if (moving_sum == 3)\\n                return true;\\n        }\\n\\t\\t\\n\\t\\t# If no such elements, return false\\n        return false;\\n    }\\n    \\n\\t# Return the last bit of the number\\n\\t# Similar with : x % 2\\n    private int last_bit(int x) {\\n        return x & 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```x % 2```\n```x & 1```\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        # Return false if array is null or does not have at least 3 elements\\n        if (arr == null || arr.length < 3)\\n            return false;\\n\\t\\t\\t\\n        # Compute the sum for the first 3 elements\\n        int moving_sum = last_bit(arr[0]) + last_bit(arr[1]) + last_bit(arr[2]);\\n        \\n\\t\\t# Return true if the first 3 elements are odd\\n        if (moving_sum == 3)\\n            return true;\\n        \\n\\t\\t# Search for 3 consecutive odd numbers - sliding window\\n        for (int i = 3; i < arr.length; i++) {\\n            moving_sum -= last_bit(arr[i-3]);\\n            moving_sum += last_bit(arr[i]);\\n            if (moving_sum == 3)\\n                return true;\\n        }\\n\\t\\t\\n\\t\\t# If no such elements, return false\\n        return false;\\n    }\\n    \\n\\t# Return the last bit of the number\\n\\t# Similar with : x % 2\\n    private int last_bit(int x) {\\n        return x & 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983752,
                "title": "easy-solution-4ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int sum=0;\\n        if(arr.size()<3)return false;\\n        for(int i=0;i<arr.size()-2;i++){\\n            //if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)return true;\\n            if(arr[i]%2==1){\\n                if(arr[i+1]%2==1){\\n                    if(arr[i+2]%2==1)return true;\\n                    else i=i+2;\\n                }else i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int sum=0;\\n        if(arr.size()<3)return false;\\n        for(int i=0;i<arr.size()-2;i++){\\n            //if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)return true;\\n            if(arr[i]%2==1){\\n                if(arr[i+1]%2==1){\\n                    if(arr[i+2]%2==1)return true;\\n                    else i=i+2;\\n                }else i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963501,
                "title": "python-one-liner-any",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return any(arr[i]%2 and arr[i+1]%2 and arr[i+2]%2 for i in range(len(arr)-2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        return any(arr[i]%2 and arr[i+1]%2 and arr[i+2]%2 for i in range(len(arr)-2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963301,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if arr[i]%2 and arr[i+1]%2 and arr[i+2]%2:\\n                return 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)-2):\\n            if arr[i]%2 and arr[i+1]%2 and arr[i+2]%2:\\n                return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954927,
                "title": "java-solution-100-faster",
                "content": "\\n```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 2; i++) {\\n\\t\\tif (arr[i]%2 == 1 && arr[i+1]%2 == 1 && arr[i+2]%2 == 1){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 2; i++) {\\n\\t\\tif (arr[i]%2 == 1 && arr[i+1]%2 == 1 && arr[i+2]%2 == 1){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935876,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        res,tmp=[x%2 for x in arr],0 \\n        for x in res:\\n            if x==1:\\n                tmp+=1\\n                if tmp==3:\\n                    return True\\n            else:  \\n                tmp=0\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        res,tmp=[x%2 for x in arr],0 \\n        for x in res:\\n            if x==1:\\n                tmp+=1\\n                if tmp==3:\\n                    return True\\n            else:  \\n                tmp=0\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925199,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        boolean res  = false;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] % 2 != 0){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n            if(count == 3){\\n                res = true;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        boolean res  = false;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] % 2 != 0){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n            if(count == 3){\\n                res = true;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924854,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\t\\n        f=0\\n        for i in range(0,len(arr)-2):\\n            if arr[i]%2==1 and arr[i+1]%2==1 and arr[i+2]%2==1:        #check for 3 consecutive odd numbers\\n                f=8                   #changing the flag value\\n        return (f==8)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\t\\n        f=0\\n        for i in range(0,len(arr)-2):\\n            if arr[i]%2==1 and arr[i+1]%2==1 and arr[i+2]%2==1:        #check for 3 consecutive odd numbers\\n                f=8                   #changing the flag value\\n        return (f==8)",
                "codeTag": "Java"
            },
            {
                "id": 916449,
                "title": "simplest-java-solution-100",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if(arr[i]%2==1 && arr[i+1]%2==1 && arr[i+2]%2==1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 882246,
                "title": "c-solution",
                "content": "```\\nbool threeConsecutiveOdds(int* arr, int arrSize){\\n    int count = 0;\\n    if(arrSize<3) return false;\\n    for (int i=0;i<arrSize;i++){\\n        if(arr[i]%2 == 0)\\n            count = 0;\\n        else\\n            if(++count == 3) return true;\\n    }\\n    return false;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool threeConsecutiveOdds(int* arr, int arrSize){\\n    int count = 0;\\n    if(arrSize<3) return false;\\n    for (int i=0;i<arrSize;i++){\\n        if(arr[i]%2 == 0)\\n            count = 0;\\n        else\\n            if(++count == 3) return true;\\n    }\\n    return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 869384,
                "title": "easy-and-understandable-java-solution-faster-than-100-in-0ms",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866137,
                "title": "javascript",
                "content": "```\\nconst threeConsecutiveOdds = (arr) => {\\n    let count = 0;\\n    for(const num of arr) {\\n        if(num % 2 === 1) {\\n            count++;\\n            if(count === 3) return true;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst threeConsecutiveOdds = (arr) => {\\n    let count = 0;\\n    for(const num of arr) {\\n        if(num % 2 === 1) {\\n            count++;\\n            if(count === 3) return true;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858585,
                "title": "easy-c-solution",
                "content": "**Runtime: 4 ms, faster than 98.73% of C++ online submissions for Three Consecutive Odds.\\nMemory Usage: 8.5 MB, less than 9.37% of C++ online submissions for Three Consecutive Odds.**\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<=2)\\n            return false;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            if(arr[i]&1&&arr[i+1]&1&&arr[i+2]&1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size()<=2)\\n            return false;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            if(arr[i]&1&&arr[i+1]&1&&arr[i+2]&1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 847349,
                "title": "python-solution",
                "content": "\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            a=arr[i:i+3]\\n            a=list(map(lambda x : x%2!=0,a))\\n            if all(a):\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)-2):\\n            a=arr[i:i+3]\\n            a=list(map(lambda x : x%2!=0,a))\\n            if all(a):\\n                return True\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 839325,
                "title": "quick-solution-o-n-96-faster",
                "content": "Simply check if three odd numbers are there\\n```\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n        for i in range(0, len(arr) - 2):\\n            if arr[i] % 2 == 1 and arr[i+1] % 2 == 1 and arr[i+2] % 2 == 1:\\n                return True\\n        return False\\n```\\n\\nif you like the solution do upvote it, comment if you think any optimizationcan be done",
                "solutionTags": [],
                "code": "```\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n        for i in range(0, len(arr) - 2):\\n            if arr[i] % 2 == 1 and arr[i+1] % 2 == 1 and arr[i+2] % 2 == 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 837090,
                "title": "java-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        boolean flag = false;\\n        if(arr.length>2){\\n            for(int i=0;i<arr.length-2;i++){\\n                if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        boolean flag = false;\\n        if(arr.length>2){\\n            for(int i=0;i<arr.length-2;i++){\\n                if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835703,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 1; i < arr.length - 1; ++i) {\\n            if (arr[i-1] % 2 == 1 & arr[i] % 2 == 1 & arr[i+1] % 2 == 1) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 1; i < arr.length - 1; ++i) {\\n            if (arr[i-1] % 2 == 1 & arr[i] % 2 == 1 & arr[i+1] % 2 == 1) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831066,
                "title": "36-ms-faster-than-99",
                "content": "```\\n\\n```class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count =0\\n        for i in range(0,len(arr)):\\n            if arr[i]%2!=0:\\n                count+=1\\n                if count==3:\\n                    return True\\n            else:\\n                count=0\\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818275,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar threeConsecutiveOdds = function(arr) {\\n    for (let i = 2; i < arr.length; i++) {\\n        if (arr[i] & 1 && arr[i - 1] & 1 && arr[i - 2] & 1) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar threeConsecutiveOdds = function(arr) {\\n    for (let i = 2; i < arr.length; i++) {\\n        if (arr[i] & 1 && arr[i - 1] & 1 && arr[i - 2] & 1) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807944,
                "title": "faster-than-100-memory-less-than-100",
                "content": "```\\nint count = 0;\\n\\t\\tfor (int i : arr) {\\n\\t\\t\\tif(i % 2 == 0) count = 0;\\n\\t\\t\\telse if (++count == 3) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n```",
                "solutionTags": [],
                "code": "```\\nint count = 0;\\n\\t\\tfor (int i : arr) {\\n\\t\\t\\tif(i % 2 == 0) count = 0;\\n\\t\\t\\telse if (++count == 3) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 803462,
                "title": "c-easy-solutions-4ms-faster-than-98-76-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size() < 2){\\n            return false;\\n        }\\n        for(int i=0;i<arr.size()-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size() < 2){\\n            return false;\\n        }\\n        for(int i=0;i<arr.size()-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796897,
                "title": "python-o-n-by-itertaion-w-comment",
                "content": "Python O(n) by itertaion\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        \\n        size = len(arr)\\n        \\n        is_odd = lambda x: (x % 2 == 1)\\n        \\n        if size < 3:\\n            # Quick rejection for small array which is impossible to have three consecutive odds\\n            return False\\n        \\n        else:\\n            \\n            for i in range( 1, size-1):\\n                \\n                if all( map(is_odd, arr[i-1:i+2] ) ):\\n\\t\\t\\t\\t\\t# check if we have three consecutive odds\\n                    return True\\n                \\n            return False\\n            \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python built-in function all( ... )](https://docs.python.org/3/library/functions.html?highlight=all#all)\\n\\n[2] [Python built-in function map( ... )](https://docs.python.org/3/library/functions.html?highlight=all#map)\\n\\n[3] [Python docs about lambda expression](https://docs.python.org/3/howto/functional.html?highlight=lambda#small-functions-and-the-lambda-expression)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        \\n        size = len(arr)\\n        \\n        is_odd = lambda x: (x % 2 == 1)\\n        \\n        if size < 3:\\n            # Quick rejection for small array which is impossible to have three consecutive odds\\n            return False\\n        \\n        else:\\n            \\n            for i in range( 1, size-1):\\n                \\n                if all( map(is_odd, arr[i-1:i+2] ) ):\\n\\t\\t\\t\\t\\t# check if we have three consecutive odds\\n                    return True\\n                \\n            return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 796875,
                "title": "scala-fp-one-line",
                "content": "```\\nobject Solution {\\n    def threeConsecutiveOdds(arr: Array[Int]): Boolean = {\\n        arr.sliding(3,1).filter(x=> x.map(_%2).filter(_==1).size==3).size > 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def threeConsecutiveOdds(arr: Array[Int]): Boolean = {\\n        arr.sliding(3,1).filter(x=> x.map(_%2).filter(_==1).size==3).size > 0\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 795375,
                "title": "solution-python-o-n",
                "content": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n       # initialize the count variable for odd values\\n\\t   oddCount = 0\\n\\t   \\n\\t   # iterate over the given array\\n        for x  in arr:\\n\\t\\t    # check if the number is odd and increment the odd counter\\n            if x % 2 != 0:\\n                oddCount += 1\\n            else:\\n\\t\\t\\t    # reset the counter if we get an even value\\n                oddCount = 0\\n\\t\\t\\t# check the odd counter value, if it is 3 return True \\n            if oddCount == 3:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t# return False if there are no three consecutive odds\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n       # initialize the count variable for odd values\\n\\t   oddCount = 0\\n\\t   \\n\\t   # iterate over the given array\\n        for x  in arr:\\n\\t\\t    # check if the number is odd and increment the odd counter\\n            if x % 2 != 0:\\n                oddCount += 1\\n            else:\\n\\t\\t\\t    # reset the counter if we get an even value\\n                oddCount = 0\\n\\t\\t\\t# check the odd counter value, if it is 3 return True \\n            if oddCount == 3:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t# return False if there are no three consecutive odds\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794992,
                "title": "go-solution",
                "content": "```go\\nfunc threeConsecutiveOdds(arr []int) bool {\\n    sz := len(arr)\\n    \\n    if sz < 3 {return false}\\n    \\n    for i, _ := range arr {\\n        if i + 2 < sz {\\n            if arr[i] % 2 != 0 && arr[i + 1] % 2 != 0 && arr[i + 2] % 2 != 0 {\\n                return true\\n            }\\n        }        \\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc threeConsecutiveOdds(arr []int) bool {\\n    sz := len(arr)\\n    \\n    if sz < 3 {return false}\\n    \\n    for i, _ := range arr {\\n        if i + 2 < sz {\\n            if arr[i] % 2 != 0 && arr[i + 1] % 2 != 0 && arr[i + 2] % 2 != 0 {\\n                return true\\n            }\\n        }        \\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794978,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size() < 3) return false;\\n        \\n        for(int i = 0; i < arr.size(); ++i) {\\n            if((i + 2) < arr.size()) {\\n                if(arr[i] % 2 != 0 && arr[i + 1] % 2 != 0 && arr[i + 2] % 2 != 0)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        if(arr.size() < 3) return false;\\n        \\n        for(int i = 0; i < arr.size(); ++i) {\\n            if((i + 2) < arr.size()) {\\n                if(arr[i] % 2 != 0 && arr[i + 1] % 2 != 0 && arr[i + 2] % 2 != 0)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794954,
                "title": "python-100-time-and-100-memory-efficient-noob-solution",
                "content": "A noob way of coding it, but sometimes thats ok.\\n![image](https://assets.leetcode.com/users/images/56bbd9a0-709f-4860-a8aa-afa0812de0d9_1597579013.073011.png)\\n\\n```python\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n        i = 0\\n        while i < len(arr)-2:\\n            j, k = i+1, i+2\\n            if arr[i] % 2 != 0 and arr[j] % 2 != 0 and arr[k] % 2 != 0:\\n                return True\\n            elif arr[k] % 2 == 0:\\n                i += 3\\n            elif arr[j] % 2 == 0:\\n                i += 2\\n            elif arr[i] % 2 == 0:\\n                i += 1\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "A noob way of coding it, but sometimes thats ok.\\n![image](https://assets.leetcode.com/users/images/56bbd9a0-709f-4860-a8aa-afa0812de0d9_1597579013.073011.png)\\n\\n```python\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        if len(arr) < 3:\\n            return False\\n        i = 0\\n        while i < len(arr)-2:\\n            j, k = i+1, i+2\\n            if arr[i] % 2 != 0 and arr[j] % 2 != 0 and arr[k] % 2 != 0:\\n                return True\\n            elif arr[k] % 2 == 0:\\n                i += 3\\n            elif arr[j] % 2 == 0:\\n                i += 2\\n            elif arr[i] % 2 == 0:\\n                i += 1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 794696,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if (arr.length < 3) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i] % 2 == 1 && arr[i+1] % 2 == 1  && arr[i+2] % 2 == 1) {\\n                return true;\\n            }    \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if (arr.length < 3) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < arr.length - 2; i++) {\\n            if (arr[i] % 2 == 1 && arr[i+1] % 2 == 1  && arr[i+2] % 2 == 1) {\\n                return true;\\n            }    \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794347,
                "title": "java-straighforward",
                "content": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length < 3)\\n            return false;\\n        for(int i=0;i<arr.length-2;i++ ){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length < 3)\\n            return false;\\n        for(int i=0;i<arr.length-2;i++ ){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794286,
                "title": "python-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif i % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tif cnt == 3:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif i % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tif cnt == 3:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 794248,
                "title": "java-easy-to-understand-o-n",
                "content": "```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794242,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int so_far, curr;\\n        for(int i = 0; i < arr.size(); i++) {\\n            if(arr[i] % 2 == 1) {\\n                curr += 1;\\n                if(curr == 3) return true;\\n            } else {\\n                curr = 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool threeConsecutiveOdds(vector<int>& arr) {\\n        int so_far, curr;\\n        for(int i = 0; i < arr.size(); i++) {\\n            if(arr[i] % 2 == 1) {\\n                curr += 1;\\n                if(curr == 3) return true;\\n            } else {\\n                curr = 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794208,
                "title": "java-solution",
                "content": "```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i] %2 !=0 && arr[i+1] %2 !=0 && arr[i+2] %2 !=0)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean threeConsecutiveOdds(int[] arr) {\\n        \\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i] %2 !=0 && arr[i+1] %2 !=0 && arr[i+2] %2 !=0)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4106879,
                "title": "python-o-n-time-and-o-1-space-solution",
                "content": "# Intuition\\nKeep a count that represents how many numbers at the index before the current one is odd. If two numbers before the current number is odd AND the current number is odd, we will return True. \\n\\nWe must reset our count every time we encounter a 0.\\n\\n# Approach\\nI used n & 1 to calculate whether it is odd, but also just use n % 2 == 1 instead. \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        lastSeen = 0\\n\\n        for n in arr: \\n            if not n & 1: #is not odd \\n                lastSeen = 0\\n                continue\\n            if lastSeen == 2:\\n                return True\\n            lastSeen += 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        lastSeen = 0\\n\\n        for n in arr: \\n            if not n & 1: #is not odd \\n                lastSeen = 0\\n                continue\\n            if lastSeen == 2:\\n                return True\\n            lastSeen += 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104999,
                "title": "simple-solutions-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length>=3){\\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        if(arr.length>=3){\\n        for(int i=0;i<arr.length-2;i++){\\n            if(arr[i]%2!=0 && arr[i+1]%2!=0 && arr[i+2]%2!=0){\\n                return true;\\n            }\\n        }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1673217,
                "content": [
                    {
                        "username": "narwar_veer",
                        "content": "why it is giving TLE using this method\\n if (arr[i]%2 !=0 && arr[i+1]%2 !=0 && arr[i+2]%2 !=0 ) ?????\\n           "
                    },
                    {
                        "username": "Har_2818",
                        "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count= 0\\n        for i in arr:\\n            if(i%2!=0):\\n                count+=1\\n                if(count==3):\\n                    return True\\n            else:\\n                count=0\\n        return False    \\n                \\ntry this "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean threeConsecutiveOdds(int[] arr) {\\n        int odd = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2==0){\\n                odd=0;\\n            }else{\\n                odd++;\\n            }\\n            if(odd==3){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1860532,
                "content": [
                    {
                        "username": "narwar_veer",
                        "content": "why it is giving TLE using this method\\n if (arr[i]%2 !=0 && arr[i+1]%2 !=0 && arr[i+2]%2 !=0 ) ?????\\n           "
                    },
                    {
                        "username": "Har_2818",
                        "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count= 0\\n        for i in arr:\\n            if(i%2!=0):\\n                count+=1\\n                if(count==3):\\n                    return True\\n            else:\\n                count=0\\n        return False    \\n                \\ntry this "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean threeConsecutiveOdds(int[] arr) {\\n        int odd = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2==0){\\n                odd=0;\\n            }else{\\n                odd++;\\n            }\\n            if(odd==3){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1882172,
                "content": [
                    {
                        "username": "narwar_veer",
                        "content": "why it is giving TLE using this method\\n if (arr[i]%2 !=0 && arr[i+1]%2 !=0 && arr[i+2]%2 !=0 ) ?????\\n           "
                    },
                    {
                        "username": "Har_2818",
                        "content": "class Solution:\\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\\n        count= 0\\n        for i in arr:\\n            if(i%2!=0):\\n                count+=1\\n                if(count==3):\\n                    return True\\n            else:\\n                count=0\\n        return False    \\n                \\ntry this "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean threeConsecutiveOdds(int[] arr) {\\n        int odd = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2==0){\\n                odd=0;\\n            }else{\\n                odd++;\\n            }\\n            if(odd==3){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Egg Drop With 2 Eggs and N Floors",
        "question_content": "<p>You are given <strong>two identical</strong> eggs and you have access to a building with <code>n</code> floors labeled from <code>1</code> to <code>n</code>.</p>\n\n<p>You know that there exists a floor <code>f</code> where <code>0 &lt;= f &lt;= n</code> such that any egg dropped at a floor <strong>higher</strong> than <code>f</code> will <strong>break</strong>, and any egg dropped <strong>at or below</strong> floor <code>f</code> will <strong>not break</strong>.</p>\n\n<p>In each move, you may take an <strong>unbroken</strong> egg and drop it from any floor <code>x</code> (where <code>1 &lt;= x &lt;= n</code>). If the egg breaks, you can no longer use it. However, if the egg does not break, you may <strong>reuse</strong> it in future moves.</p>\n\n<p>Return <em>the <strong>minimum number of moves</strong> that you need to determine <strong>with certainty</strong> what the value of </em><code>f</code> is.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn&#39;t, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 100\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1248069,
                "title": "recursive-iterative-generic",
                "content": "It may take you a while to come up with an efficient math-based solution. So, for an interview, I would start with a simple recursion - at least you will have something. It can help you see a pattern, and it will be easiser to develop an intuition for an improved solution. \\n\\nIf you follow-up with an improved solution, and also generalize it for `k` eggs ([887. Super Egg Drop](https://leetcode.com/problems/super-egg-drop/)) - it would be a home run. This is how this progression might look like.\\n\\n> Fun fact: this problem is decribed in the Wikipedia\\'s article for [Dynamic Programming](https://en.wikipedia.org/w/index.php?title=Dynamic_programming).\\n\\n#### Simple Recursion\\nIn the solution below, we drop an egg from each floor and find the number of throws for these two cases:\\n- We lost an egg but we reduced the number of floors to `i`.\\n\\t- Since we only have one egg left, we can just return `i - 1` to check all floors.\\n- The egg did not break, and we reduced the number of floors to `n - i`.\\n\\t- Solve this recursively to get the number of throws for `n - i` floors.\\n\\nThis way, we find a floor for which the number of throws - maximum from these two cases - is minimal.\\n\\n**C++**\\n```cpp\\nint dp[1001] = {};\\nclass Solution {\\npublic:\\nint twoEggDrop(int n) {\\n\\tif (dp[n] == 0)\\n\\t\\tfor (int i = 1; i <= n; ++i)\\n\\t\\t\\tdp[n] = min(dp[n] == 0 ? n : dp[n], 1 + max(i - 1, twoEggDrop(n - i)));\\n\\treturn dp[n];\\n}\\n};\\n```\\n**Java**\\n```java\\nstatic int[] dp = new int[1001];\\npublic int twoEggDrop(int n) {\\n    if (dp[n] == 0)\\n        for (int i = 1; i <= n; ++i)\\n            dp[n] = Math.min(dp[n] == 0 ? n : dp[n], 1 + Math.max(i - 1, twoEggDrop(n - i)));\\n    return dp[n];\\n}\\n```\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    @cache\\n    def twoEggDrop(self, n: int) -> int:\\n        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)\\n```\\n#### Iterative Computation\\nLet\\'s take a look at the results from the first solution for different `n`:\\n```\\n1: 1\\n2: 2\\n4: 3\\n7: 4\\n11: 5\\n16: 6\\n22: 7\\n29: 8\\n37: 9\\n46: 10\\n```\\nAs you see, with `m` drops, we can test up to 1 + 2 + ... + m floors. \\n\\n**C++**\\n```cpp\\nint twoEggDrop(int n) {\\n    int res = 1;\\n    while (n - res > 0)\\n        n -= res++;\\n    return res;    \\n}\\n```\\n... or, using a formula:\\n\\n**C++**\\n```cpp\\nint twoEggDrop(int n) {\\n    int m = 1;\\n    while (m * (m + 1) / 2 < n)\\n        ++m;\\n    return m;    \\n}  \\n```\\n\\n#### Inversion and Generic Solution\\nWith the help of the iterative solution above, we see that it\\'s easier to solve an inverse problem: given `m` total drops, and `k` eggs, how high can we go?\\n\\nSo with one egg and `m` drops, we can only test `m` floors.\\n\\nWith two eggs and `m` drops:\\n1. We drop one egg to test one floor.\\n2. We add the number of floors we can test with `m - 1` drops and 2 eggs (the egg did not break).\\n3. And we add `m - 1 ` floors we can test with the last egg (the egg broke).\\n\\nThus, the formula is:\\n```\\ndp[m] = 1 + dp[m - 1] + m - 1;\\n```\\n... which is in-line with the observation we made for the iterative solution above!\\n\\nThis can be easily generalized for `k` eggs:\\n\\n```\\ndp[m][k] = 1 + dp[m - 1][k] + dp[m - 1][k - 1];\\n```\\n\\n**C++**\\n```cpp\\nint dp[1001][3] = {};\\nclass Solution {\\npublic:\\nint twoEggDrop(int n, int k = 2) {\\n    int m = 0;\\n    while (dp[m][k] < n) {\\n        ++m;\\n        for (int j = 1; j <= k; ++j)\\n            dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1;\\n    }\\n    return m;  \\n}\\n};\\n```\\nAs we only look one step back, we can reduce the memory ussage to O(k): \\n\\n**C++**\\n```cpp\\nint twoEggDrop(int n, int k = 2) {\\n    int dp[3] = {};\\n    int m = 0;\\n    while (dp[k] < n) {\\n        ++m;\\n        for (int j = k; j > 0; --j)\\n            dp[j] += dp[j - 1] + 1;\\n    }\\n    return m;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint dp[1001] = {};\\nclass Solution {\\npublic:\\nint twoEggDrop(int n) {\\n\\tif (dp[n] == 0)\\n\\t\\tfor (int i = 1; i <= n; ++i)\\n\\t\\t\\tdp[n] = min(dp[n] == 0 ? n : dp[n], 1 + max(i - 1, twoEggDrop(n - i)));\\n\\treturn dp[n];\\n}\\n};\\n```\n```java\\nstatic int[] dp = new int[1001];\\npublic int twoEggDrop(int n) {\\n    if (dp[n] == 0)\\n        for (int i = 1; i <= n; ++i)\\n            dp[n] = Math.min(dp[n] == 0 ? n : dp[n], 1 + Math.max(i - 1, twoEggDrop(n - i)));\\n    return dp[n];\\n}\\n```\n```python\\nclass Solution:\\n    @cache\\n    def twoEggDrop(self, n: int) -> int:\\n        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)\\n```\n```\\n1: 1\\n2: 2\\n4: 3\\n7: 4\\n11: 5\\n16: 6\\n22: 7\\n29: 8\\n37: 9\\n46: 10\\n```\n```cpp\\nint twoEggDrop(int n) {\\n    int res = 1;\\n    while (n - res > 0)\\n        n -= res++;\\n    return res;    \\n}\\n```\n```cpp\\nint twoEggDrop(int n) {\\n    int m = 1;\\n    while (m * (m + 1) / 2 < n)\\n        ++m;\\n    return m;    \\n}  \\n```\n```\\ndp[m] = 1 + dp[m - 1] + m - 1;\\n```\n```\\ndp[m][k] = 1 + dp[m - 1][k] + dp[m - 1][k - 1];\\n```\n```cpp\\nint dp[1001][3] = {};\\nclass Solution {\\npublic:\\nint twoEggDrop(int n, int k = 2) {\\n    int m = 0;\\n    while (dp[m][k] < n) {\\n        ++m;\\n        for (int j = 1; j <= k; ++j)\\n            dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1;\\n    }\\n    return m;  \\n}\\n};\\n```\n```cpp\\nint twoEggDrop(int n, int k = 2) {\\n    int dp[3] = {};\\n    int m = 0;\\n    while (dp[k] < n) {\\n        ++m;\\n        for (int j = k; j > 0; --j)\\n            dp[j] += dp[j - 1] + 1;\\n    }\\n    return m;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246123,
                "title": "java-dp-solution-for-n-floors-and-x-eggs-if-you-could-not-come-up-with-the-math-solution",
                "content": "This is a classic problem. You can read about it or watch it on youtube. Just google egg dropping problem. The solution comes down to solving x + (x - 1) + (x - 2) + ... + 2 + 1 >= n equation (when you have two eggs)\\n```java\\n public int twoEggDrop(int n) {\\n     return (int) Math.ceil((Math.sqrt(1 + 8 * n) - 1) / 2);\\n }\\n ```\\n You can also solve this problem using recursion. Let\\'s consider a more general problem when we have `x` eggs and `n` floors. If you drop an egg from `i` floor (`1<=i<=n`), then\\n 1. If the egg breaks, the problem is reduced to `x-1` eggs and `i - 1` floors\\n 2. If the eggs does not break, the problem is reduced to `x` eggs and `n-i` floors\\n\\n```java\\n public int twoEggDrop(int n) {\\n        int eggs = 2;\\n        return drop(n, eggs, new int[n + 1][eggs + 1]);\\n    }\\n\\n    int drop(int floors, int eggs, int[][] dp) {\\n        if (eggs == 1 || floors <= 1)\\n            return floors;\\n        if (dp[floors][eggs] > 0)\\n            return dp[floors][eggs];\\n        int min = Integer.MAX_VALUE;\\n        for (int f = 1; f <= floors; f++)\\n            min = Math.min(min, 1 + Math.max(drop(f - 1, eggs - 1, dp), drop(floors - f, eggs, dp)));\\n        dp[floors][eggs] = min;\\n        return min;\\n    }",
                "solutionTags": [],
                "code": "```java\\n public int twoEggDrop(int n) {\\n     return (int) Math.ceil((Math.sqrt(1 + 8 * n) - 1) / 2);\\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248560,
                "title": "simple-math-problem-with-intuition-explained-o-1-time-o-1-space-python",
                "content": "Honestly this problem initially seemed similar to [Guess Number Higher or Lower II](http://leetcode.com/problems/guess-number-higher-or-lower-ii/) *until I checked the test case with n = 100.*\\n\\nSince we have 2 eggs and **need to preserve at least one egg at the end**, we can safely sacrifice one egg before we find f.\\n\\nThis is a form of minimax problem, where we need to minimize the maximum number of moves possible to find out f.\\n\\nSuppose optimally minimum number of moves needed to find f is x.\\n**That means the first number that we have chosen cannot exceed x. Why?**\\n\\nSuppose we choose x + 1 as 1st guess and the first egg breaks, then we can no longer guess the 2nd number blindly - it needs to start from 1 to x - leading to  **x + 1** total moves, which is the contradiction.\\n\\nSo, it is clear that if x is our minimum number of moves, x is the greatest possible 1st guess.\\nIn case the 1st egg breaks, we need to linearly move from 1 to x - 1, as any other method risks the second egg.\\nIn case 1st egg is safe, what should be our 2nd guess? \\nit should be x + (x - 1) for the similar explanation as above.\\nThus, we use linear search in case 1st egg breaks at any time, and jump up by x - i where i is the number of moves done until now.\\n\\nhere is an example :\\nIf n = 105, let our minimum moves be x.\\nThen our guesses would be : x , x + (x - 1), x + (x - 1) + (x - 2), and so on until we reach n.\\n\\nThere are two points to be noted :\\n\\t\\n\\t1. The increments vary from x to 1.\\n\\t2. The increments can continue until we have reached f, or n, whichever first.\\n\\t\\nUsing the two points above, **in worst case**, we have :\\n\\n\\tSum of all increments >= n\\n\\tor, x + (x - 1) + (x - 2)...1 >= n\\n\\tor, x * (x + 1)/2 >= n\\n\\tor, x^2 + x - 2n >= 0\\n\\t\\nNow it is a simple quadratic equation whose positive root is to be solved by sridharacharya method.\\n\\nFor example, if n = 105, using the above equation, our x would be 14.\\nThe increments possible would be 14, 13...1\\nConsquently, the guesses would be 14, 27...105.\\n\\n**One important point here is that x must be a non-negative integer. If x calculated is a decimal, that means number of moves needed is more than floor(x), floor(x) + 1 to be precise.**\\n\\nSo, our answer would be :\\n\\t\\n\\tx if x is an integer\\n\\tceil(x) or floor(x) + 1 if x is a decimal.\\n\\nHere is the code: \\n\\n```\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        a = 1\\n        b = 1\\n        c = - 2 * n\\n    \\n        x = (-b + (b * b - 4 * a * c)**0.5) / 2.0\\n        \\n        if x - int(x) == 0 :\\n            return int(x)\\n        return int(x) + 1\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        a = 1\\n        b = 1\\n        c = - 2 * n\\n    \\n        x = (-b + (b * b - 4 * a * c)**0.5) / 2.0\\n        \\n        if x - int(x) == 0 :\\n            return int(x)\\n        return int(x) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1246621,
                "title": "java-o-1-intuition-and-detailed-reasoning-100-time-100-space",
                "content": "### TLDR\\nThe solution is pretty simple\\n```\\nreturn (int) Math.ceil((-1.0 + Math.sqrt(1 + 8 * n))/2.0);        \\n```\\n\\nNow let\\'s go about solving this. Let\\'s assume that we have 100 floors.\\n\\n### __Approach 1: Simple Binary Search__\\n\\nYou can fail at most once. So you start right in the middle - 50<sup>th</sup> floor. Two possibilities open up:\\n1. Break at 50: Scan floors 1..49 to arrive at the answer.\\n2. Survive 50: Test for floors 51..100, with recursion.\\n\\nThe worst case for this approach comes at floor 49 - You break at 50<sup>th</sup>, then you drop the remaining egg from floors 1-49 to find that it doesn\\'t break. You have exhausted 50 tries, and a hell lot of time you\\'ll never get back :(\\n\\n### __Approach 2: Partitioning__\\n\\nThe worst case for the approach #1 comes from the fact that each partition of the original sample space only gets halved after a test where the first egg doesn\\'t break. How about we partition better ? The immediate approach will be to think in terms of exponents instead of factors - instead of dividing the sample space\\'s size by a factor of 2, we reduce it by an exponent of 2.\\n\\nFor 100 floors, divide the sample space in ```Math.sqrt(100) = 10``` partitions of size 10 each. Here are the partitions:\\n\\n```[1,10], [11,20], [21,30].....[91,100]```\\n\\nNow, start testing from the highest floor of the bottom-most partition - 10<sup>th</sup> floor. If the egg breaks at p<sup>th</sup> partition, you have exhausted `p` tries, and then you need to test at most 9 more floors in this partition to arrive at the answer.\\n\\nThe worst case comes for floor 99 - you break the first egg at the 10<sup>th</sup> try, and then spend 9 more tries - for a total of 19. We have done better than approach #1 :)\\n\\n### __Approach 3: Smarter Partitioning__\\n\\nApproach #2 gives us a lot of insights into the nature of the problem. We have fixed-size partitions, and the number of partitions left to explore after the first egg breaks is constant. If we break at the p<sup>th</sup> partition, we need to explore ``c`` floors, for a total of ``p+c`` tries, and if we break at the (p+1)<sup>th</sup> partition, we get ``p+1+c`` tries in all.\\n\\n__How about we make the ``(p+1)`` partition smaller by 1 unit, so that we are left with just ``c-1`` floors to explore after the first egg breaks at the (p+1)<sup>th</sup> partition, for a total of ``(p + 1) + (c - 1) = p + c`` tries ?__\\n\\nLet\\'s try to set our first partition at floor 13<sup>th</sup>. \\n1. If the first egg breaks here, we need to explore only 12 more floors - total 13 tries.\\n2. If the egg doesn\\'t break, we next try from the ``13 + (13 - 1) = 25th`` floor. If the egg breaks at 25<sup>th</sup>, you need to explore the floors 14-24 - giving a total of ``1 (25th floor) + 1 (13th floor) + 11 (14-24 floors) = 13`` tries.\\n\\nThere\\'s the logic!\\n\\nBut how do we decide the size of the first partition ? Starting with 13 as the first partition size will only lead us upto 91st floor - ``13 + 12 + 11 ...... 3 + 2 + 1``. To be able to exhaust all ``n`` available floors, we need to find the smallest number k such that \\n\\n```\\n(k * (k + 1) / 2) >= n\\n```\\n\\nWhy smallest ? Because if the partition size is larger, you\\'ll have to do more work per partition (start with 17 as the first partition size - you now need 17 moves to solve the problem).\\n\\nSolving the quadratic for k (only positive solution is acceptable, and only 1 positive solution is possible), you get the first partition size - which is also the maximum number of moves required (each partition gives the same number of moves, and it would take k moves if the first broke at the first partition itself).\\n\\nLiked the solution ? Upvote!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nreturn (int) Math.ceil((-1.0 + Math.sqrt(1 + 8 * n))/2.0);        \\n```\n```Math.sqrt(100) = 10```\n```[1,10], [11,20], [21,30].....[91,100]```\n```\\n(k * (k + 1) / 2) >= n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265931,
                "title": "that-math-solution-is-too-fancy-to-come-up-with-let-s-just-try-dp-with-step-by-step-explanations",
                "content": "Yeah I know that Math solution is great but as a normal person with a normal brain I don\\'t think i can ever come up with that solution in time limited interviews. So let\\'s just try DP\\n\\n1. Naive thoughts\\n\\nSo we want to find this floor F. At first glance i really thought this is a binary search problem: you drop your first egg at middle floor, if break drop another at lower levels, otherwise higher levels. However, we only have 2 eggs! So when you have lost your first egg at level M, you HAVE TO use the only left egg and try from floor 1 all the way to floor M - 1 to get your answer. With limited supply of eggs, binary search won\\'t work.\\n\\nThen i thought: ok screw this, don\\'t try to be a smart ass. Let\\'s try to solve this in the brute force way. What is it? You want to know the floor F? OK then i will calculate the result on EVERY SINGLE FLOOR. That is, i am going to calculate how many steps i need to decide floor F if I drop my first egg at 1st floor, how many steps i need to decide floor F if I drop my first egg at 2nd floor, how many steps i need to decide floor F if I drop my first egg at 3rd floor... etc. This sounds like a bulky solution, but this is brute force. Let me work this out then try to optimize it.\\n\\n2. Implement the brute force\\n\\nSo apparently we need an 2D DP array for this. With each column being the number of floors of the building, and each row being the floor i am gonna drop my first egg. That is `dp[row][col] = the minimum steps i need to take to decide the floor F we are trying to find, if this building has [col] floors, and if I drop my first egg at floor [row]`\\nAlso let\\'s have another array `bests`, where `best[i] = the minimum steps to determine floor F on a building with i floors`. `bests[10] = the minimum steps to determine floor F on a building with 10 floors`\\n(if you cannot understand why we need `bests`, keep reading. I didn\\'t think we need `bests` in the first place either, but as I proceed with this approach, it occurs to me we need `bests`)\\nWith that determined, for each `dp[row][col]` there are 2 conditions we need to calculate: \\n1. what if I drop my first egg at floor row and it breaks (ah oh)\\n2. what if I drop my first egg at floor row and it survived?\\n\\nFor first case, you will lose your first egg and you only have 1 egg left. Then you will need to drop your last egg from floor 1, then floor 2, then floor 3 all the way to floor row - 1 -- you don\\'t have other choices!\\nSo for case 1, the unlucky case, we need (for the worst case) `1(the initial drop) + (row - 1) (number of drops for your last egg)` .\\nFor second case, nice you didn\\'t lose your first egg. Then the problem evolves from \"find floor F on this building with [col] floors\" to \"find floor F on this building with [col - row] floors\". That is, because on floor [row] your egg didn\\'t break, so you don\\'t even need to look at floors below [row]th floor any more -  your egg definitely won\\'t break on these floors. So with this building only has [col - row] floors and 2 eggs in your pocket, we can determine floor F in `bests[col - row]` steps (recall `bests` is `bests[i] = the minimum steps to determine floor F on a building with i floors`, and now, `i` is `col - row`).\\n\\nOk, for case 1, we have\\n`int steps_case_1 = 1 + row - 1 // first egg broke at first drop`\\nfor case 2 we have\\n`int steps_case_2 = 1 + bests[col - row] // first egg didn\\'t break`\\nYou need to consider both cases, so\\n`dp[row][col] = max(steps_case_1, steps_case_2)`\\n\\nThen we keep adding row and col until we fill all spots in our `dp` matrix.\\n\\nThe answer would be `bests[n]`\\n\\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int twoEggDrop(int n) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<int> bests(n + 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<int> oneRow(n + 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>> dp(n + 1, oneRow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[1][1] = 1; // a building with 1 floor, and i drop at 1st floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[1][2] = 2; // a building with 2 floors, and i drop at 1st floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[2][2] = 2; // a building with 2 floors, and i drop at 2nd floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[0] = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[1] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[2] = 2;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int col = 3; col <= n; ++col) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int bestThisCol = n; // the mini steps needed to determine floor F if this building has col floors\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int row = 1; row <= col; ++row) { // I drop at each floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // row is which floor we drop\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // col is the number of floors of this building\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // if we have col floors and we drop at rowth floor and it broke\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int breaks = 1 + row - 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // if we have col floors and we drop at rowth floor and it survived\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int survive = 1 + bests[col - row];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[row][col] = max(breaks, survive);\\n\\t\\t\\t\\t// with all the floors you can drop your first egg, of cource you will choose the floor so that you can determine F with minimum steps, so this is min() here\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bestThisCol = min(bestThisCol, dp[row][col]);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[col] = bestThisCol;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return bests[n];\\n\\xA0\\xA0\\xA0 }\\n};\\n\\n```\\n\\n3. Optimize\\nWell if you look at above code, you will directly notice we don\\'t need `dp` at all!\\n```\\ndp[row][col] = max(breaks, survive);\\nbestThisCol = min(bestThisCol, dp[row][col]);\\n```\\ncan be rewriitten as \\n```\\nbestThisCol = min(bestThisCol, max(breaks, survive));\\n```\\nSo uhhhh, let\\'s dump that `dp`\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<int> bests(n + 1);\\n        \\n        bests[0] = 0;\\n        bests[1] = 1;\\n        bests[2] = 2;\\n        \\n        for (int col = 3; col <= n; ++col) {\\n            int bestThisCol = n;\\n            for (int row = 1; row <= col; ++row) {\\n                // row is which floor we drop\\n                // col is the number of floors\\n                \\n                // if we have col floors and we drop at rowth floor and it broke\\n                int breaks = 1 + row - 1;\\n                // if we have col floors and we drop at rowth floor and it survived\\n                int survive = 1 + bests[col - row];\\n                bestThisCol = min(bestThisCol, max(breaks, survive));\\n            }\\n            bests[col] = bestThisCol;\\n        }\\n        \\n        return bests[n];\\n    }\\n};\\n```\\nDone. This answer is faster than ~50% of submissions.\\nEven though this is O(N^2) time and O(N) space, i think this might be an acceptable answer for an interview. Please add more if you can further optimize based on my thoughts.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int twoEggDrop(int n) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<int> bests(n + 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<int> oneRow(n + 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>> dp(n + 1, oneRow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[1][1] = 1; // a building with 1 floor, and i drop at 1st floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[1][2] = 2; // a building with 2 floors, and i drop at 1st floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[2][2] = 2; // a building with 2 floors, and i drop at 2nd floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[0] = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[1] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[2] = 2;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int col = 3; col <= n; ++col) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int bestThisCol = n; // the mini steps needed to determine floor F if this building has col floors\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int row = 1; row <= col; ++row) { // I drop at each floor\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // row is which floor we drop\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // col is the number of floors of this building\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // if we have col floors and we drop at rowth floor and it broke\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int breaks = 1 + row - 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // if we have col floors and we drop at rowth floor and it survived\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int survive = 1 + bests[col - row];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dp[row][col] = max(breaks, survive);\\n\\t\\t\\t\\t// with all the floors you can drop your first egg, of cource you will choose the floor so that you can determine F with minimum steps, so this is min() here\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bestThisCol = min(bestThisCol, dp[row][col]);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 bests[col] = bestThisCol;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return bests[n];\\n\\xA0\\xA0\\xA0 }\\n};\\n\\n```\n```\\ndp[row][col] = max(breaks, survive);\\nbestThisCol = min(bestThisCol, dp[row][col]);\\n```\n```\\nbestThisCol = min(bestThisCol, max(breaks, survive));\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<int> bests(n + 1);\\n        \\n        bests[0] = 0;\\n        bests[1] = 1;\\n        bests[2] = 2;\\n        \\n        for (int col = 3; col <= n; ++col) {\\n            int bestThisCol = n;\\n            for (int row = 1; row <= col; ++row) {\\n                // row is which floor we drop\\n                // col is the number of floors\\n                \\n                // if we have col floors and we drop at rowth floor and it broke\\n                int breaks = 1 + row - 1;\\n                // if we have col floors and we drop at rowth floor and it survived\\n                int survive = 1 + bests[col - row];\\n                bestThisCol = min(bestThisCol, max(breaks, survive));\\n            }\\n            bests[col] = bestThisCol;\\n        }\\n        \\n        return bests[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251343,
                "title": "3-solutions",
                "content": "## Solution 1\\n**Dynamic programming**\\n**time `O(N^2)`; space `O(N)`**\\n\\nConsider dropping the first egg from the `1st`, `2nd`, `3rd` ... `ith` floor. Say we drop an egg from the `j`-th floor. It either breaks or doesn\\'t.\\n* if it breaks then you know that the \"breaking floor\" must be below (or equal to `j`). So you have to use the only \"egg life\" left to test `j-1` floors below (with indices `1...j-1`)\\n* if it doesn\\'t break, then the \"breaking floor\" must be above (or there could be no \"breaking floor\" at all). Fortunately you still have two eggs, thus you can solve the same problem but for `i-j` floors (indices `j+1...i`). Thus to solve problem for `i` we need to know solutions for the same problem for `1,2,3,..,i-1`. That\\'s dynamic programming, baby...\\n\\n![image](https://assets.leetcode.com/users/images/782cb54a-d083-4000-ae23-46e652dd4dd6_1622906015.1339016.png)\\n\\n\\nFor each `j` consider both \"egg breaks\" and \"egg survives\" alternatives, calculate `max` of them and add `1` (as you have used one of the throws already).\\nYou should take minimum of the values calculated for all possible `j \\u2208 [1, i]`.\\nIf you store solutions in the vector and start from `1` and proceed for larger `n` then you\\'ll get the following solution.\\n\\n```\\nint twoEggDrop(int n)\\n{\\n\\tvector m{0};\\n\\tfor(auto i{1}; i<=n; ++i) \\n\\t{\\n\\t\\tint out{INT_MAX};\\n\\t\\tfor(auto j{1}; j<=i; ++j)              \\n\\t\\t\\tout = min(out, 1+max(m[i-j], j-1));\\n\\t\\tm.push_back(out);\\n\\t}\\n\\treturn m.back();    \\n}\\n```\\nIf you change variables `j=i-j` you can get arguably simpler formula\\n```\\nint twoEggDrop(int n)\\n{\\n\\tvector m{0};\\n\\tfor(auto i{1}; i<=n; ++i) \\n\\t{\\n\\t\\tint out{INT_MAX};\\n\\t\\tfor(auto j{0}; j<i; ++j)              \\n\\t\\t\\tout = min(out, 1+max(m[j], i-j-1));  \\n\\t\\tm.push_back(out);\\n\\t}\\n\\treturn m.back();    \\n}\\n```\\nThis reminds me algorithm for Catalan\\'s numbers generation in [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/discuss/1190656/solutions-and-pictures) (or in [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)).\\n\\n<details>\\n<summary>\\nHere\\'s is the recursive up-bottom variation.\\n</summary>\\n\\n**Dynamic programming, bottom up recursion with memoization**\\n**time `O(N^2)`; space `O(N)`**\\n```\\nint twoEggDrop(int n)\\n{\\n    static unordered_map<int, int> m{{0,0}};\\n    if(m.count(n)) return m[n];\\n  \\tint out{INT_MAX};\\n    for(auto j{0}; j<n; ++j)              \\n\\t    out = min(out, 1+max(twoEggDrop(j), n-j-1));\\n\\treturn m[n]=out;    \\n}\\n```\\n</details>\\n\\n**Analysis**\\n\\nLet\\'s talk about this part of the solution \\n```\\n\\tint out{INT_MAX};\\n\\tfor(auto j{0}; j<i; ++j)              \\n\\t\\tout = min(out, 1+max(m[j], i-j-1));\\n\\tm.push_back(out);\\n```\\nTo calculate `m[i]` it considers a line `l(j)=i-j-1` and a function `m[j]` in the range `j \\u2208 [1, i-1]`.\\nIt takes `max(l(j), m(j))`, finds it\\'s minimum by linear search, adds `1` to it and assigns it to `m[i]`.\\n\\nIt\\'s like this\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/ef8cccae-8d95-4a6b-858c-8cbee305a001_1622839980.4860308.png)\\n\\n<br>\\nonly for discrete case.\\n\\nIf you draw some more pictures (\\uD83D\\uDE42) you can come up with the \"graphical algo\":\\n* to calculate `m[i]` draw line with slope `-1` that crosses `x` axis at point `i-1`.\\n* if it passes through one of the red points then `m[i]=m[i-1]`. If it doesn\\'t then `m[i]=m[i-1]+1`\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/669afb4b-8e9e-49ba-b598-70195ad68a58_1622924206.974553.png)\\n\\n![image](https://assets.leetcode.com/users/images/4989aa23-fb62-4ec3-ae88-a7091e7b6ab0_1622924223.070747.png)\\n\\n<br>\\n\\nPictures help to realize that the `m[i]` is very tightly connected to `m[i-1]`: it\\'s either `m[i-1]` or `m[i-1]+1`. Moreover the function is **highly regular and predictable**: `1,2,2,3,3,3,4,4,4,4...`.\\n\\n## Solution 2\\n\\n**time `O(N)`; space `O(1)`**\\n\\nSo as we have seen we just want to replicate the following sequence\\n<br>\\n![image](https://assets.leetcode.com/users/images/3d6aba52-7182-4756-845c-3777b6eb0e94_1622923226.2858493.png)\\n\\nOne `1`, two `2`s, three `3`s and so on.\\nYou can generate it with the help of linear algorithm (you\\'ll need two extra variables: a counter `i` and a current output variable `out`)\\n<br>\\n![image](https://assets.leetcode.com/users/images/e26b2c0c-6147-42a6-8781-19807ff8e4b5_1622923545.035664.png)\\n\\nlike this \\n```\\nint twoEggDrop(int n)\\n{\\n\\tint out{};\\n\\tfor(int i{}; n--; ++i>out ? out=i, i=1 : 0);           \\n\\treturn out;    \\n}\\n```\\nor maybe like this\\n```\\nint twoEggDrop(int n)\\n{\\n\\tint out{};\\n\\tfor(int i{}; n; --n)\\n\\t\\tif(++i>out) out=i, i=1;\\n\\treturn out;    \\n}\\n```\\n## Solution 3\\n\\n**time `O(1)`; space `O(1)`**\\n\\nUsing some math magic you can come up with the formula to solve the problem in `O(1)`.\\nThe key is to derive integer inverse function of the triangular numbers **trinv(n)** and to shift it by `1`.\\n<br>\\n![image](https://assets.leetcode.com/users/images/0db66a56-f16d-47f8-82f8-4f27ac06b6f7_1622829604.721454.png)\\n\\n```\\nint twoEggDrop(int n)\\n{\\n\\treturn (1+sqrt(8.0*n-7))/2;    \\n}\\n```\\nalso you can use this formula\\n```\\nint twoEggDrop(int n)\\n{\\n\\treturn floor(sqrt(2.0*n) + 0.5);    \\n}\\n```\\n**What is this sequence ?**\\n\\nI\\'ve looked this sequence up, and [that\\'s](https://oeis.org/A002024) what I\\'ve found.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a635652a-7fe9-4d88-a48a-0bb627a734ec_1622925867.822566.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint twoEggDrop(int n)\\n{\\n\\tvector m{0};\\n\\tfor(auto i{1}; i<=n; ++i) \\n\\t{\\n\\t\\tint out{INT_MAX};\\n\\t\\tfor(auto j{1}; j<=i; ++j)              \\n\\t\\t\\tout = min(out, 1+max(m[i-j], j-1));\\n\\t\\tm.push_back(out);\\n\\t}\\n\\treturn m.back();    \\n}\\n```\n```\\nint twoEggDrop(int n)\\n{\\n\\tvector m{0};\\n\\tfor(auto i{1}; i<=n; ++i) \\n\\t{\\n\\t\\tint out{INT_MAX};\\n\\t\\tfor(auto j{0}; j<i; ++j)              \\n\\t\\t\\tout = min(out, 1+max(m[j], i-j-1));  \\n\\t\\tm.push_back(out);\\n\\t}\\n\\treturn m.back();    \\n}\\n```\n```\\nint twoEggDrop(int n)\\n{\\n    static unordered_map<int, int> m{{0,0}};\\n    if(m.count(n)) return m[n];\\n  \\tint out{INT_MAX};\\n    for(auto j{0}; j<n; ++j)              \\n\\t    out = min(out, 1+max(twoEggDrop(j), n-j-1));\\n\\treturn m[n]=out;    \\n}\\n```\n```\\n\\tint out{INT_MAX};\\n\\tfor(auto j{0}; j<i; ++j)              \\n\\t\\tout = min(out, 1+max(m[j], i-j-1));\\n\\tm.push_back(out);\\n```\n```\\nint twoEggDrop(int n)\\n{\\n\\tint out{};\\n\\tfor(int i{}; n--; ++i>out ? out=i, i=1 : 0);           \\n\\treturn out;    \\n}\\n```\n```\\nint twoEggDrop(int n)\\n{\\n\\tint out{};\\n\\tfor(int i{}; n; --n)\\n\\t\\tif(++i>out) out=i, i=1;\\n\\treturn out;    \\n}\\n```\n```\\nint twoEggDrop(int n)\\n{\\n\\treturn (1+sqrt(8.0*n-7))/2;    \\n}\\n```\n```\\nint twoEggDrop(int n)\\n{\\n\\treturn floor(sqrt(2.0*n) + 0.5);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246338,
                "title": "python-dp",
                "content": "Credits to [@climberig](https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/discuss/1246123/Java-dp-solution-for-n-floors-and-x-eggs-(if-you-could-not-come-up-with-the-math-solution)).\\n\\nRewrite @climberig Java code in Python 3 and add some comments.\\nLet\\'s consider a more general problem when we have x eggs and n floors. If you drop an egg from i floor (1<=i<=n), then\\nIf the egg breaks, the problem is reduced to x-1 eggs and i - 1 floors\\nIf the eggs does not break, the problem is reduced to x eggs and n - i floors\\n\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(m, eggs):\\n            if eggs == 1 or m <= 1: return m # eggs = 1, you need to try the floors one by one\\n            res = float(\\'inf\\')       \\n            for f in range(1, m + 1): # we do not know at which floor the egg will break\\n                res = min(res, 1 + max(dp(f - 1, eggs - 1), dp(m - f, eggs))) # min-max\\n            return res \\n            \\n        return dp(n, 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(m, eggs):\\n            if eggs == 1 or m <= 1: return m # eggs = 1, you need to try the floors one by one\\n            res = float(\\'inf\\')       \\n            for f in range(1, m + 1): # we do not know at which floor the egg will break\\n                res = min(res, 1 + max(dp(f - 1, eggs - 1), dp(m - f, eggs))) # min-max\\n            return res \\n            \\n        return dp(n, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249918,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThe key to this problem statement is \"to determine with certainty\" the `n`<sup>th</sup> floor.  This can be done with one egg `k = 1` if and only if the egg is *not* broken until we have determined the `n`<sup>th</sup> floor.  The only way to safely perform drops with one egg is from the bottom-up, one floor at a time.  So whenever we have one egg, the \"penalty\" or \"cost\" is all `n` floors (the worst case to safely determine when this last egg will break).\\n\\nThus we consider all `i`<sup>th</sup> floor possibilities from `i = 1..n` inclusive to find the minimum worst case scenario of 2 use cases to consider for each `k`<sup>th</sup> egg:\\n\\n1. the egg breaks on the `i`<sup>th</sup> floor drop, then we have `n - i` floors left to explore with `k - 1` eggs\\n2. the egg does *not* break on the `i`<sup>th</sup> floor drop, then we have `i - 1` floors left to explore with `k` eggs\\n\\nWe return the maximum of these 2 use cases to absorb the worst case penalty for each possibility under consideration in order to \"to determine with certainty\" the `n`<sup>th</sup> floor.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        fun go(n: Int = N, k: Int = K): Int {\\n            if (n <= 2 || k == 1)\\n                return n\\n            var best = INF\\n            for (i in 1..n)\\n                best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(n: Int = N, k: Int = K): Int {\\n            if (n <= 2 || k == 1)\\n                return n\\n            var key = \"$n,$k\"\\n            if (m.contains(key))\\n                return m[key]!!\\n            var best = INF\\n            for (i in 1..n)\\n                best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)))\\n            m[key] = best\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var dp = Array(N + 1) { IntArray(K + 1) { INF } }\\n        for (n in 1..2)\\n            for (k in 2..K)\\n                dp[n][k] = n\\n        for (n in 1..N)\\n            dp[n][1] = n\\n        for (n in 1..N)\\n            for (i in 1..n)\\n                for (k in 2..K)\\n                    dp[n][k] = Math.min(dp[n][k], 1 + Math.max(dp[n - i][k - 1], dp[i - 1][k]))\\n        return dp[N][K]\\n    }\\n}\\n```\\n\\n4. Memory Optimization, ie. formulate each current solution with `k` eggs from each previous solution with `k - 1` eggs.  Thus we replace `dp[x][k]` with `cur[x]` and replace `dp[n - i][k - 1]` with `pre[n - i]`.\\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = Array(N + 1) { it }\\n        for (k in 2..K) {\\n            var cur = Array(N + 1) { INF }\\n            for (n in 1..N)\\n                for (i in 1..n)\\n                    cur[n] = Math.min(cur[n], 1 + (if (cur[i - 1] < INF) Math.max(pre[n - i], cur[i - 1]) else pre[n - i]))\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet twoEggDrop = (N, K = 2) => {\\n    let go = (n = N, k = K) => {\\n        if (n <= 2 || k == 1)\\n            return n;\\n        let best = Infinity;\\n        for (let i = 1; i <= n; ++i)\\n            best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)));\\n        return best;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let go = (n = N, k = K) => {\\n        if (n <= 2 || k == 1)\\n            return n;\\n        let key = `${n},${k}`;\\n        if (m.has(key))\\n            return m.get(key);\\n        let best = Infinity;\\n        for (let i = 1; i <= n; ++i)\\n            best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)));\\n        return m.set(key, best)\\n                .get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let dp = [...Array(N + 1)].map(_ => Array(K + 1).fill(Infinity));\\n    for (let n = 1; n <= 2; ++n)\\n        for (let k = 1; k <= K; ++k)\\n            dp[n][k] = n;\\n    for (let n = 1; n <= N; ++n)\\n        dp[n][1] = n;\\n    for (let n = 1; n <= N; ++n)\\n        for (let i = 1; i <= n; ++i)\\n            for (let k = 2; k <= K; ++k)\\n                dp[n][k] = Math.min(dp[n][k], 1 + Math.max(dp[n - i][k - 1], dp[i - 1][k]));\\n    return dp[N][K];\\n};\\n```\\n\\n4. Memory Optimization, ie. formulate each current solution with `k` eggs from each previous solution with `k - 1` eggs.  Thus we replace `dp[x][k]` with `cur[x]` and replace `dp[n - i][k - 1]` with `pre[n - i]`.\\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let pre = [...Array(N + 1)].map((_, n) => n);\\n    for (let k = 2; k <= K; ++k) {\\n        let cur = Array(N + 1).fill(Infinity);\\n        for (let n = 1; n <= N; ++n)\\n            for (let i = 1; i <= n; ++i)\\n                cur[n] = Math.min(cur[n], 1 + (cur[i - 1] < Infinity ? Math.max(pre[n - i], cur[i - 1]) : pre[n - i]));\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        def go(n = N, k = K):\\n            if n <= 2 or k == 1:\\n                return n\\n            best = float(\\'inf\\');\\n            for i in range(1, n + 1):\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        @cache\\n        def go(n = N, k = K):\\n            if n <= 2 or k == 1:\\n                return n\\n            best = float(\\'inf\\');\\n            for i in range(1, n + 1):\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        dp = [[float(\\'inf\\')] * (K + 1) for _ in range(N + 1)]\\n        for n in range(K + 1):\\n            for k in range(K + 1):\\n                dp[n][k] = n\\n        for n in range(N + 1):\\n            dp[n][1] = n\\n        for n in range(1, N + 1):\\n            for i in range(1, n + 1):\\n                for k in range(2, K + 1):\\n                    dp[n][k] = min(dp[n][k], 1 + max(dp[n - i][k - 1], dp[i - 1][k]))\\n        return dp[N][K]\\n```\\n\\n4. Memory Optimization, ie. formulate each current solution with `k` eggs from each previous solution with `k - 1` eggs.  Thus we replace `dp[x][k]` with `cur[x]` and replace `dp[n - i][k - 1]` with `pre[n - i]`.\\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        pre = [i for i in range(N + 1)]\\n        for k in range(2, K + 1):\\n            cur = [float(\\'inf\\') for _ in range(N + 1)]\\n            for n in range(1, N + 1):\\n                for i in range(1, n + 1):\\n                    cur[n] = min(cur[n], 1 + (max(pre[n - i], cur[i - 1]) if cur[i - 1] < float(\\'inf\\') else pre[n - i]))\\n            pre, cur = cur, pre\\n        return pre[N]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        fun go = [&](auto n, auto k) {\\n            if (n <= 2 || k == 1)\\n                return n;\\n            auto best = INF;\\n            for (auto i{ 1 }; i <= n; ++i)\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)));\\n            return best;\\n        };\\n        return go(N, K);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7, Map m = {}) {\\n        fun go = [&](auto n, auto k) {\\n            if (n <= 2 || k == 1)\\n                return n;\\n            stringstream key; key << n << \",\" << k;\\n            if (m.find(key.str()) != m.end())\\n                return m[key.str()];\\n            auto best = INF;\\n            for (auto i{ 1 }; i <= n; ++i)\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)));\\n            return m[key.str()] = best;\\n        };\\n        return go(N, K);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        VVI dp(N + 1, VI(K + 1, INF));\\n        for (auto n{ 0 }; n <= K; ++n)\\n            for (auto k{ 1 }; k <= K; ++k)\\n                dp[n][k] = n;\\n        for (auto n{ 1 }; n <= N; ++n)\\n            dp[n][1] = n;\\n        for (auto n{ 1 }; n <= N; ++n)\\n            for (auto i{ 1 }; i <= n; ++i)\\n                for (auto k{ 2 }; k <= K; ++k)\\n                    dp[n][k] = min(dp[n][k], 1 + max(dp[n - i][k - 1], dp[i - 1][k]));\\n        return dp[N][K];\\n    }\\n};\\n```\\n\\n4. Memory Optimization, ie. formulate each current solution with `k` eggs from each previous solution with `k - 1` eggs.  Thus we replace `dp[x][k]` with `cur[x]` and replace `dp[n - i][k - 1]` with `pre[n - i]`.\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        VI pre(N + 1); iota(pre.begin(), pre.end(), 0);\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            VI cur(N + 1, INF);\\n            for (auto n{ 1 }; n <= N; ++n)\\n                for (auto i{ 1 }; i <= n; ++i)\\n                    cur[n] = min(cur[n], 1 + (cur[i - 1] < INF ? max(pre[n - i], cur[i - 1]) : pre[n - i]));\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```\\n\\n---\\n\\n**Sum of Series:**\\n\\nUse the sum-of-series to find the appropriate `i`<sup>th</sup> bucket for the input `N`\\n\\n---\\n\\nNote: these solutions are based on ancedotal evidence from **Example 2** input `N = 100`, ie. we can see the sum-of-series in reverse via adjacent differences of `i`<sup>th</sup> drop candidates.  As calculated below, the 13<sup>th</sup> bucket doesn\\'t reach `200`, ie. 13<sup>2</sup> + 13 = 182.  However the 14<sup>th</sup> bucket reaches `200`, ie. 14<sup>2</sup> + 14 = 210.  [ Note: there\\'s a typo in my calculation below, I wrote 220, but it\\'s actually 210 ]\\n\\n![image](https://assets.leetcode.com/users/images/a535cd12-ff22-463d-95c1-a3cbe6045ad4_1622758735.0634835.jpeg)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int): Int {\\n        var f = { n: Int -> n * (n + 1) / 2 }\\n        for (i in 1..45)\\n            if (N <= f(i))\\n                return i\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet twoEggDrop = N => {\\n    let f = n => n * (n + 1) / 2;\\n    for (let i = 1; i <= 45; ++i)\\n        if (N <= f(i))\\n            return i;\\n    return -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int) -> int:\\n        f = lambda n: n * (n + 1) // 2\\n        for i in range(1, 45 + 1):\\n            if N <= f(i):\\n                return i\\n        return -1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int N) {\\n        auto f = [](auto n) { return n * (n + 1) / 2; };\\n        for (auto i{ 1 }; i <= 45; ++i)\\n            if (N <= f(i))\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        fun go(n: Int = N, k: Int = K): Int {\\n            if (n <= 2 || k == 1)\\n                return n\\n            var best = INF\\n            for (i in 1..n)\\n                best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(n: Int = N, k: Int = K): Int {\\n            if (n <= 2 || k == 1)\\n                return n\\n            var key = \"$n,$k\"\\n            if (m.contains(key))\\n                return m[key]!!\\n            var best = INF\\n            for (i in 1..n)\\n                best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)))\\n            m[key] = best\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var dp = Array(N + 1) { IntArray(K + 1) { INF } }\\n        for (n in 1..2)\\n            for (k in 2..K)\\n                dp[n][k] = n\\n        for (n in 1..N)\\n            dp[n][1] = n\\n        for (n in 1..N)\\n            for (i in 1..n)\\n                for (k in 2..K)\\n                    dp[n][k] = Math.min(dp[n][k], 1 + Math.max(dp[n - i][k - 1], dp[i - 1][k]))\\n        return dp[N][K]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int, K: Int = 2, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = Array(N + 1) { it }\\n        for (k in 2..K) {\\n            var cur = Array(N + 1) { INF }\\n            for (n in 1..N)\\n                for (i in 1..n)\\n                    cur[n] = Math.min(cur[n], 1 + (if (cur[i - 1] < INF) Math.max(pre[n - i], cur[i - 1]) else pre[n - i]))\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N]\\n    }\\n}\\n```\n```\\nlet twoEggDrop = (N, K = 2) => {\\n    let go = (n = N, k = K) => {\\n        if (n <= 2 || k == 1)\\n            return n;\\n        let best = Infinity;\\n        for (let i = 1; i <= n; ++i)\\n            best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)));\\n        return best;\\n    };\\n    return go();\\n};\\n```\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let go = (n = N, k = K) => {\\n        if (n <= 2 || k == 1)\\n            return n;\\n        let key = `${n},${k}`;\\n        if (m.has(key))\\n            return m.get(key);\\n        let best = Infinity;\\n        for (let i = 1; i <= n; ++i)\\n            best = Math.min(best, 1 + Math.max(go(n - i, k - 1), go(i - 1, k)));\\n        return m.set(key, best)\\n                .get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let dp = [...Array(N + 1)].map(_ => Array(K + 1).fill(Infinity));\\n    for (let n = 1; n <= 2; ++n)\\n        for (let k = 1; k <= K; ++k)\\n            dp[n][k] = n;\\n    for (let n = 1; n <= N; ++n)\\n        dp[n][1] = n;\\n    for (let n = 1; n <= N; ++n)\\n        for (let i = 1; i <= n; ++i)\\n            for (let k = 2; k <= K; ++k)\\n                dp[n][k] = Math.min(dp[n][k], 1 + Math.max(dp[n - i][k - 1], dp[i - 1][k]));\\n    return dp[N][K];\\n};\\n```\n```\\nlet twoEggDrop = (N, K = 2, m = new Map()) => {\\n    let pre = [...Array(N + 1)].map((_, n) => n);\\n    for (let k = 2; k <= K; ++k) {\\n        let cur = Array(N + 1).fill(Infinity);\\n        for (let n = 1; n <= N; ++n)\\n            for (let i = 1; i <= n; ++i)\\n                cur[n] = Math.min(cur[n], 1 + (cur[i - 1] < Infinity ? Math.max(pre[n - i], cur[i - 1]) : pre[n - i]));\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N];\\n};\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        def go(n = N, k = K):\\n            if n <= 2 or k == 1:\\n                return n\\n            best = float(\\'inf\\');\\n            for i in range(1, n + 1):\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        return go()\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        @cache\\n        def go(n = N, k = K):\\n            if n <= 2 or k == 1:\\n                return n\\n            best = float(\\'inf\\');\\n            for i in range(1, n + 1):\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)))\\n            return best\\n        return go()\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        dp = [[float(\\'inf\\')] * (K + 1) for _ in range(N + 1)]\\n        for n in range(K + 1):\\n            for k in range(K + 1):\\n                dp[n][k] = n\\n        for n in range(N + 1):\\n            dp[n][1] = n\\n        for n in range(1, N + 1):\\n            for i in range(1, n + 1):\\n                for k in range(2, K + 1):\\n                    dp[n][k] = min(dp[n][k], 1 + max(dp[n - i][k - 1], dp[i - 1][k]))\\n        return dp[N][K]\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int, K = 2) -> int:\\n        pre = [i for i in range(N + 1)]\\n        for k in range(2, K + 1):\\n            cur = [float(\\'inf\\') for _ in range(N + 1)]\\n            for n in range(1, N + 1):\\n                for i in range(1, n + 1):\\n                    cur[n] = min(cur[n], 1 + (max(pre[n - i], cur[i - 1]) if cur[i - 1] < float(\\'inf\\') else pre[n - i]))\\n            pre, cur = cur, pre\\n        return pre[N]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        fun go = [&](auto n, auto k) {\\n            if (n <= 2 || k == 1)\\n                return n;\\n            auto best = INF;\\n            for (auto i{ 1 }; i <= n; ++i)\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)));\\n            return best;\\n        };\\n        return go(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7, Map m = {}) {\\n        fun go = [&](auto n, auto k) {\\n            if (n <= 2 || k == 1)\\n                return n;\\n            stringstream key; key << n << \",\" << k;\\n            if (m.find(key.str()) != m.end())\\n                return m[key.str()];\\n            auto best = INF;\\n            for (auto i{ 1 }; i <= n; ++i)\\n                best = min(best, 1 + max(go(n - i, k - 1), go(i - 1, k)));\\n            return m[key.str()] = best;\\n        };\\n        return go(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        VVI dp(N + 1, VI(K + 1, INF));\\n        for (auto n{ 0 }; n <= K; ++n)\\n            for (auto k{ 1 }; k <= K; ++k)\\n                dp[n][k] = n;\\n        for (auto n{ 1 }; n <= N; ++n)\\n            dp[n][1] = n;\\n        for (auto n{ 1 }; n <= N; ++n)\\n            for (auto i{ 1 }; i <= n; ++i)\\n                for (auto k{ 2 }; k <= K; ++k)\\n                    dp[n][k] = min(dp[n][k], 1 + max(dp[n - i][k - 1], dp[i - 1][k]));\\n        return dp[N][K];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int twoEggDrop(int N, int K = 2, int INF = 1e9 + 7) {\\n        VI pre(N + 1); iota(pre.begin(), pre.end(), 0);\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            VI cur(N + 1, INF);\\n            for (auto n{ 1 }; n <= N; ++n)\\n                for (auto i{ 1 }; i <= n; ++i)\\n                    cur[n] = min(cur[n], 1 + (cur[i - 1] < INF ? max(pre[n - i], cur[i - 1]) : pre[n - i]));\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun twoEggDrop(N: Int): Int {\\n        var f = { n: Int -> n * (n + 1) / 2 }\\n        for (i in 1..45)\\n            if (N <= f(i))\\n                return i\\n        return -1\\n    }\\n}\\n```\n```\\nlet twoEggDrop = N => {\\n    let f = n => n * (n + 1) / 2;\\n    for (let i = 1; i <= 45; ++i)\\n        if (N <= f(i))\\n            return i;\\n    return -1;\\n};\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, N: int) -> int:\\n        f = lambda n: n * (n + 1) // 2\\n        for i in range(1, 45 + 1):\\n            if N <= f(i):\\n                return i\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int N) {\\n        auto f = [](auto n) { return n * (n + 1) / 2; };\\n        for (auto i{ 1 }; i <= 45; ++i)\\n            if (N <= f(i))\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422722,
                "title": "egg-drop-dp-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[3][1001];\\n    \\n    int solve(int e , int f){\\n        if(f==0 or f == 1) {\\n            return f; \\n        }\\n        \\n       if( e == 1 ){\\n           return f;\\n       }\\n        \\n        if(dp[e][f] != -1){\\n            return dp[e][f];\\n        }\\n        int mn = INT_MAX;\\n        for(int k = 1 ; k<= f; k++){\\n            int temp = 1+ max(solve(e-1,k-1), solve(e, f-k)); \\n            mn = min(mn, temp);\\n        }\\n        \\n        return dp[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(2,n); \\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[3][1001];\\n    \\n    int solve(int e , int f){\\n        if(f==0 or f == 1) {\\n            return f; \\n        }\\n        \\n       if( e == 1 ){\\n           return f;\\n       }\\n        \\n        if(dp[e][f] != -1){\\n            return dp[e][f];\\n        }\\n        int mn = INT_MAX;\\n        for(int k = 1 ; k<= f; k++){\\n            int temp = 1+ max(solve(e-1,k-1), solve(e, f-k)); \\n            mn = min(mn, temp);\\n        }\\n        \\n        return dp[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(2,n); \\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291262,
                "title": "recursion-memoization-dp-java-solution",
                "content": "# Recursion\\n- Find the recurrence relation and take care of base cases\\n- Here the base cases would be if number of floors are 0 or 1 then number of moves are equals to number of floors\\n- Second  base condition if you are left with one egg you cannot drop the egg from any random floor you must start from 0th floor and increase the floor to find threshold floor\\n```\\n- Time Complexity : exponential (Consists of repeated sub problems)\\n- Space Complexity : O(1)\\n```\\n# Recursive Solution\\n```\\nclass Solution {\\n    \\n    public int f(int eggs,int floors) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors;\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i <= floors;i++) {\\n            int min = Math.max( f(eggs-1,i-1) , f(eggs,floors - i));\\n            if(min < ans) ans = min;\\n        }\\n        return ans + 1;\\n    }\\n    public int twoEggDrop(int n) {\\n       int floors = n;\\n       int eggs = 2;\\n       return f(eggs,floors);\\n    }\\n}\\n```\\n# Memoization\\n\\n- The recursive solution we will encounter with the sub problems which are already solved in recurrsive tree.It is the reason the time complexity is exponential in recursive solution\\n- So we use the datastructure to store the already solved sub problems solution and it use it when we encounter the same sub problem \\n```\\n- Time Complexity : O( N * (K^2) )\\n- Space Complexity : O(N*K)\\n```\\n# Memoized Solution\\n\\n```\\nclass Solution {\\n    public int f(int eggs,int floors,int[][] memo) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors; \\n\\n        int ans = Integer.MAX_VALUE;\\n        if(memo[eggs][floors] != -1) return memo[eggs][floors];\\n\\n        for(int i = 1;i<=floors;i++) {\\n            int min = Math.max(f(eggs-1,i-1,memo),f(eggs,floors-i,memo));\\n            if(min < ans) ans = min;\\n        }\\n\\n        return memo[eggs][floors] = ans+1;\\n    }\\n    public int twoEggDrop(int n) {\\n        int floors = n;\\n        int eggs = 2;\\n        int[][] memo = new int[eggs+1][floors+1];\\n        for(int[] arr: memo) Arrays.fill(arr,-1);\\n        return f(eggs,floors,memo);\\n    }\\n}\\n```\\n# DP One Row Optimization\\n- If we observed carefullly we are actually using the previous value to get the current value \\n- In this case we can optimize it further by using 1-D array\\n```\\n- Time Complexity : O(N * logK)\\n- Space Complexity : O(N)\\n```\\n# DP Code\\n```\\nclass Solution {\\n    \\n    public int twoEggDrop(int n) {\\n        int floors = n;\\n        int eggs = 2;\\n        int[] dp = new int[eggs+1];\\n        int moves = 0;\\n        for(moves = 0;dp[eggs] < floors;moves++) {\\n            for(int i = eggs;i>0;i--) {\\n                dp[i] += dp[i-1] + 1;\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n- Time Complexity : exponential (Consists of repeated sub problems)\\n- Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    \\n    public int f(int eggs,int floors) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors;\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i <= floors;i++) {\\n            int min = Math.max( f(eggs-1,i-1) , f(eggs,floors - i));\\n            if(min < ans) ans = min;\\n        }\\n        return ans + 1;\\n    }\\n    public int twoEggDrop(int n) {\\n       int floors = n;\\n       int eggs = 2;\\n       return f(eggs,floors);\\n    }\\n}\\n```\n```\\n- Time Complexity : O( N * (K^2) )\\n- Space Complexity : O(N*K)\\n```\n```\\nclass Solution {\\n    public int f(int eggs,int floors,int[][] memo) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors; \\n\\n        int ans = Integer.MAX_VALUE;\\n        if(memo[eggs][floors] != -1) return memo[eggs][floors];\\n\\n        for(int i = 1;i<=floors;i++) {\\n            int min = Math.max(f(eggs-1,i-1,memo),f(eggs,floors-i,memo));\\n            if(min < ans) ans = min;\\n        }\\n\\n        return memo[eggs][floors] = ans+1;\\n    }\\n    public int twoEggDrop(int n) {\\n        int floors = n;\\n        int eggs = 2;\\n        int[][] memo = new int[eggs+1][floors+1];\\n        for(int[] arr: memo) Arrays.fill(arr,-1);\\n        return f(eggs,floors,memo);\\n    }\\n}\\n```\n```\\n- Time Complexity : O(N * logK)\\n- Space Complexity : O(N)\\n```\n```\\nclass Solution {\\n    \\n    public int twoEggDrop(int n) {\\n        int floors = n;\\n        int eggs = 2;\\n        int[] dp = new int[eggs+1];\\n        int moves = 0;\\n        for(moves = 0;dp[eggs] < floors;moves++) {\\n            for(int i = eggs;i>0;i--) {\\n                dp[i] += dp[i-1] + 1;\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255086,
                "title": "c-generalised-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int util(int f, int e, vector<vector<int>> dp) {\\n       for(int i=1;i<=f;i++) {\\n           dp[1][i]=i;                    //Case: 1 egg and f floors - Number of moves will be equal to the floor since we will have to try from 1st floor and then move iteratively upwards\\n       }\\n        for(int i=1;i<=e;i++) {\\n            dp[i][1]=1;                //Case: i egg and 1 floor - Number of moves will be 1 since using 1 egg we will know.\\n        }\\n        for(int i=2;i<=e;i++) {\\n            for(int j=2;j<=f;j++) {\\n                int res=INT_MAX;\\n                for(int x=1;x<=j;x++) {\\n                    res=min(res,1+max(dp[i-1][x-1],dp[i][j-x]));      //dp[i-1][x-1]: egg will break so we will be left with only 1 egg less and since it broke from \\'x\\' floor, so we will have remaining x-1 floors to check.\\n\\t\\t\\t\\t\\t//dp[i][j-x]: egg did not break from \\'x\\' floor, so remaining options left to check will be j-x(upwards from x)\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[e][f];\\n    }\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,0));      //dp[egg+1][floor+1] : depicting dp[i][j] i.e minimum number of moves required with i eggs and j floor.\\n        return util(n,2,dp);\\n    }\\n};\\n```\\n\\nTime Complexity: O(EF^2)          ``` //E: number of eggs, F: number of floors```\\nSpace Complexity: O(EF)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(int f, int e, vector<vector<int>> dp) {\\n       for(int i=1;i<=f;i++) {\\n           dp[1][i]=i;                    //Case: 1 egg and f floors - Number of moves will be equal to the floor since we will have to try from 1st floor and then move iteratively upwards\\n       }\\n        for(int i=1;i<=e;i++) {\\n            dp[i][1]=1;                //Case: i egg and 1 floor - Number of moves will be 1 since using 1 egg we will know.\\n        }\\n        for(int i=2;i<=e;i++) {\\n            for(int j=2;j<=f;j++) {\\n                int res=INT_MAX;\\n                for(int x=1;x<=j;x++) {\\n                    res=min(res,1+max(dp[i-1][x-1],dp[i][j-x]));      //dp[i-1][x-1]: egg will break so we will be left with only 1 egg less and since it broke from \\'x\\' floor, so we will have remaining x-1 floors to check.\\n\\t\\t\\t\\t\\t//dp[i][j-x]: egg did not break from \\'x\\' floor, so remaining options left to check will be j-x(upwards from x)\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[e][f];\\n    }\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,0));      //dp[egg+1][floor+1] : depicting dp[i][j] i.e minimum number of moves required with i eggs and j floor.\\n        return util(n,2,dp);\\n    }\\n};\\n```\n``` //E: number of eggs, F: number of floors```",
                "codeTag": "Java"
            },
            {
                "id": 1246061,
                "title": "c-o-1-1-liner-math-solution-beats-100-with-explanation",
                "content": "Idea:\\n1. It\\'s a well known problem, the result is the minimum of x such that 1+2+......+x>=n,\\n2. The user drops at x floor at first\\na. if breaks, then at most x-1 tries left (don\\'t need to drop at the last floor)\\nb. if it doesn\\'t break, then try x-1 floor (1+twoEggDrop(x-1))=x-1 tries left (see 3.)\\n3. The user drops at x-1 floor\\na. if breaks, then at most x-2 tries left\\nb. if it doesn\\'t break, then try x-2 floor (1+twoEggDrop(x-2))=x-2 tries left\\nand so on......\\nso in every case, there is at most x tries to determine the egg for n floors\\n\\nthe formula comes from x * (x+1) / 2 >=n\\n\\u2192 x>=(-1+sqrt(1+8n))/2\\n```\\nint twoEggDrop(int n) \\n{\\n\\treturn (int)ceil((-1.+sqrt(1+8*n))/2.);    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint twoEggDrop(int n) \\n{\\n\\treturn (int)ceil((-1.+sqrt(1+8*n))/2.);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249773,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int floors) {\\n        int eggs = 2;\\n        int dp[][] = new int[eggs+1][floors+1];\\n        int c =0;\\n        \\n        for(int i=0; i <= floors; i++){\\n            dp[1][i] = i;\\n        }\\n        \\n        for(int f = 1; f <=floors; f++){\\n            dp[2][f] = Integer.MAX_VALUE;\\n                for(int k = 1; k <=f ; k++){\\n                    c = 1 + Math.max(dp[1][k-1], dp[2][f-k]); //the egg breaks on current floor or the egg dosen\\'t break on the current floor. Take the worst case\\n                    if(c < dp[2][f])\\n                        dp[2][f] = c;\\n                }\\n            }\\n        return dp[eggs][floors];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int floors) {\\n        int eggs = 2;\\n        int dp[][] = new int[eggs+1][floors+1];\\n        int c =0;\\n        \\n        for(int i=0; i <= floors; i++){\\n            dp[1][i] = i;\\n        }\\n        \\n        for(int f = 1; f <=floors; f++){\\n            dp[2][f] = Integer.MAX_VALUE;\\n                for(int k = 1; k <=f ; k++){\\n                    c = 1 + Math.max(dp[1][k-1], dp[2][f-k]); //the egg breaks on current floor or the egg dosen\\'t break on the current floor. Take the worst case\\n                    if(c < dp[2][f])\\n                        dp[2][f] = c;\\n                }\\n            }\\n        return dp[eggs][floors];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191540,
                "title": "easy-c-dp-recursive-memoization-striver-s-approach",
                "content": "# Intuition\\nTo solve this problem we can use Striver\\'s pick and non-pick concept.\\nans will be maximum of pick and not-pick as we need to assure that the answer we are getting will definately count the F.\\n\\n# Approach\\nAt each step we have two options as we have discussed.\\n\\n```\\nint break= minMove(egg-1,i-1)\\nint not_break=minMove(egg,f-i)\\nint ans=1+max(break,not_brerak)\\n```\\nHere i is the index between 1 and n. we have to check at each i to get the minimum result.\\n\\nTo memoize this solution we will use 2-D dp. i.e. dp[egg][f].\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMove(int egg,int f,vector<vector<int>> &dp){\\n        if(egg==1){\\n            return f;\\n        }\\n\\n        if(f==0 || f==1) return f;\\n\\n        if(dp[egg][f]!=-1) return dp[egg][f];\\n\\n        int mi=INT_MAX;\\n        for(int i=1;i<f;++i){\\n            int Break=minMove(egg-1,i-1,dp);\\n            int notBreak=minMove(egg,f-i,dp);\\n            int move=1+max(Break,notBreak);\\n            mi=min(mi,move);\\n        }\\n\\n        return dp[egg][f]=mi;\\n    }\\n\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,-1));\\n        return minMove(2,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint break= minMove(egg-1,i-1)\\nint not_break=minMove(egg,f-i)\\nint ans=1+max(break,not_brerak)\\n```\n```\\nclass Solution {\\npublic:\\n    int minMove(int egg,int f,vector<vector<int>> &dp){\\n        if(egg==1){\\n            return f;\\n        }\\n\\n        if(f==0 || f==1) return f;\\n\\n        if(dp[egg][f]!=-1) return dp[egg][f];\\n\\n        int mi=INT_MAX;\\n        for(int i=1;i<f;++i){\\n            int Break=minMove(egg-1,i-1,dp);\\n            int notBreak=minMove(egg,f-i,dp);\\n            int move=1+max(Break,notBreak);\\n            mi=min(mi,move);\\n        }\\n\\n        return dp[egg][f]=mi;\\n    }\\n\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,-1));\\n        return minMove(2,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767634,
                "title": "simple-java-dp-solution-for-n-floor-k-egg",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int egg = 2; // hard coded to 2 eggs for this problem\\n        int[][] dp = new int[n+1][egg+1];\\n        return eggDrop(n, egg, dp);\\n    }\\n    \\n    int eggDrop(int n, int egg, int[][] dp) {\\n        if(n <= 2 || egg == 1) return n;\\n        if(dp[n][egg] != 0) return dp[n][egg];\\n        int min = n; // when you drop at each floor starting from 1\\n        for(int i = 1; i < n; i++) {\\n            int eggBreak = 1 + eggDrop(i-1, egg-1, dp); // drops needed if egg breaks at this floor\\n            int noEggBreak = 1 + eggDrop(n-i, egg, dp); // drops needed if egg does not break at this floor\\n            int moves = Math.max(eggBreak, noEggBreak); // since we want certain moves for n floor take max\\n            min = Math.min(min, moves);\\n        }\\n        dp[n][egg] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int egg = 2; // hard coded to 2 eggs for this problem\\n        int[][] dp = new int[n+1][egg+1];\\n        return eggDrop(n, egg, dp);\\n    }\\n    \\n    int eggDrop(int n, int egg, int[][] dp) {\\n        if(n <= 2 || egg == 1) return n;\\n        if(dp[n][egg] != 0) return dp[n][egg];\\n        int min = n; // when you drop at each floor starting from 1\\n        for(int i = 1; i < n; i++) {\\n            int eggBreak = 1 + eggDrop(i-1, egg-1, dp); // drops needed if egg breaks at this floor\\n            int noEggBreak = 1 + eggDrop(n-i, egg, dp); // drops needed if egg does not break at this floor\\n            int moves = Math.max(eggBreak, noEggBreak); // since we want certain moves for n floor take max\\n            min = Math.min(min, moves);\\n        }\\n        dp[n][egg] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572001,
                "title": "python-keep-it-simple-5-lines-o-n-time",
                "content": "I found the example case `n=100` to be very helpful. Used the idea of drawing out examples and finding the pattern (as taught in Cracking the Coding Interview book).\\n\\nSee, when n = 100, in their example case:\\n```\\ndropAtFloors = [9,22,34,45,55,64,72,79,85,90,94,97,99,100]\\n\\t\\t\\t   ^ ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\\n(gap)\\t\\t   8 13 12 11 10 9  8  7  6  5  4  3  2  1 \\n```\\n\\nNotice the pattern? Now implement.\\n        \\n```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        iterable = n\\n        while iterable > 0:\\n            count += 1\\n            iterable -= count\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndropAtFloors = [9,22,34,45,55,64,72,79,85,90,94,97,99,100]\\n\\t\\t\\t   ^ ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\\n(gap)\\t\\t   8 13 12 11 10 9  8  7  6  5  4  3  2  1 \\n```\n```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        iterable = n\\n        while iterable > 0:\\n            count += 1\\n            iterable -= count\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373814,
                "title": "simple-c-math-problem-0-ms-soln-with-nearly-o-1-time-o-1-space-without-dp",
                "content": "\\'\\'\\'\\n* If u clearly observe the pattern with increasing numbers from 1 it would be 1 times 1,2 times 2,3 times 3 ,and so on...\\n* 1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6......\\n* for example n=7,then return the 7th value in above sequence which is 4.\\n**this will take time complexty of root(N) **.\\n\\n\\ncode for this is as follows\\n\\nclass Solution {\\npublic:\\n\\n int twoEggDrop(int n) {\\n        int k=1,i ;      \\n    for(i=1;i<=k;i++)\\n    {    k+=i;         \\n        if(k>n)  break;      \\n    }\\n        return i ;\\n\\t\\t**by using quadratic equations we can get two roots in which one root is negative and other is  x=(-1+sqrt(1-4*2*n))/2\\n    x=-1+sqrt(1-8*n)/2;**\\n\\ttime complexity is o(1)\\n\\t*code for this is*\\n\\t\\n\\t**return (int)ceil((-1.+sqrt(1+8*n))/2.);    **\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n int twoEggDrop(int n) {\\n        int k=1,i ;      \\n    for(i=1;i<=k;i++)\\n    {    k+=i;         \\n        if(k>n)  break;      \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1247673,
                "title": "python3-egg-dropping-problem",
                "content": "\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        @cache\\n        def fn(n, k): \\n            \"\"\"Return min moves for n floors and k eggs.\"\"\"\\n            if k == 1: return n \\n            if n == 0: return 0 \\n            ans = inf \\n            for x in range(1, n+1): \\n                ans = min(ans, 1 + max(fn(x-1, k-1), fn(n-x, k)))\\n            return ans \\n        \\n        return fn(n, 2)\\n```\\n\\nOf course, analytical formula exists for the case of `k=2`\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        return ceil((sqrt(1 + 8*n)-1)/2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        @cache\\n        def fn(n, k): \\n            \"\"\"Return min moves for n floors and k eggs.\"\"\"\\n            if k == 1: return n \\n            if n == 0: return 0 \\n            ans = inf \\n            for x in range(1, n+1): \\n                ans = min(ans, 1 + max(fn(x-1, k-1), fn(n-x, k)))\\n            return ans \\n        \\n        return fn(n, 2)\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        return ceil((sqrt(1 + 8*n)-1)/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697189,
                "title": "python-math-solution",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # 1. set up an interval as 1\\n        interval = 1\\n        \\n        # 2. count down from n until it\\'s <= 0, reducing by the interval, and increasing the interval each time\\n        while n > 0:\\n            n -= interval\\n            interval += 1\\n        \\n        # 3. return interval - 1\\n        return interval - 1\\n```\\n\\nLogic:\\nlet\\'s use 100 floors for this example. You need to keep the egg + 1 distribution throughout the search for the optimal solution\\n\\negg, floor\\n1, 1\\n2, 3\\n3, 6\\n4, 10\\n5, 15\\n6, 21\\n7, 28\\n8, 36\\n9, 45\\n10, 55\\n11, 66\\n12, 78\\n13, 91\\n14, 105 -> over 100, so the answer is 14",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # 1. set up an interval as 1\\n        interval = 1\\n        \\n        # 2. count down from n until it\\'s <= 0, reducing by the interval, and increasing the interval each time\\n        while n > 0:\\n            n -= interval\\n            interval += 1\\n        \\n        # 3. return interval - 1\\n        return interval - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295268,
                "title": "c-2-solutions-0ms-dp-math-explained-with-diagrams",
                "content": "**Math:**\\n\\n* let\\'s say minimum number of moves needed to find f is x\\n\\t* now we can\\'t drop the egg from floor>x\\n\\t* proof?\\n\\t\\t* let\\'s say we drop from x+1\\n\\t\\t* it breaks so now we have only 1 egg left and so we have to lineary drop it from 1 to x to check if it breaks or not\\n\\t\\t\\t* i.e. total no of moves = x+1\\n\\t\\t\\t* but we said min moves is x\\n\\t\\t\\t* hence contradiction\\n\\t* **So, it is clear that if x is our minimum number of moves, x is the greatest possible 1st guess**\\n\\t* now,\\n\\t* Case 1: 1st egg breaks:\\n\\t\\t* we have only 1 egg left and so we have to lineary drop it from 1 to x -1\\n\\t* Case 2: 1st egg doesn\\'t break\\n\\t\\t* so now from where should we throw the second egg\\n\\t\\t* it should be from x+(x-1) \\n\\t\\t\\t*  same explanation as above: \\n\\t\\t\\t*  because now we have x-1 moves left and we are at xth floor so x+(x-1)\\n\\t* Thus, we use linear search in case 1st egg breaks at any time, and jump up by x - i where i is the number of moves done until now.\\n* Note that:\\n\\t*  The increments vary from x to 1. \\n\\t*  The increments can continue until we have reached f, or n, whichever first.\\n* In the worst case:\\n\\t* ```sum of all the increments>=n```\\n\\t*![image](https://assets.leetcode.com/users/images/58645f31-7fd1-4050-aeac-e98b46f5a221_1658061550.9221926.jpeg)\\n\\n* **x must not be a non-integer, hence if x is in decimal then we increase it by 1**\\n```\\nclass Solution\\n{\\npublic:\\n    int twoEggDrop(int n)\\n    {\\n        double ans = (sqrt(1 + 8 * n) - 1) / 2;\\n        return (ans - int(ans) == 0) ? ans : ans + 1;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n**DP:**\\n\\n* ```dp[i][j] = minimum number of trials needed to determine the threshold floor for i number of eggs and j number of floors```\\n* Let\\u2019s say we drop the egg from the xth floor\\n    * It breaks\\n        * Now we need to check for (x-1) floors only and we have (e-1) eggs left\\n        * So call``` solve(e-1,x-1)```\\n    * Doesn\\u2019t break:\\n        * Now we need to check for (n-x) floors and we have (e) eggs remaining\\n        * So call ```solve(e,n-x)```\\n* We need to consider the worst case so we take the max of above two cases\\n* Now we can drop it from any floor from 0 to n\\n    * So we calculate the number of trials needed if we drop from xth floor where x goes from 0 to n\\n    * And as we want minimum number of trials so we take the minimum of all these values\\n    * I.e. ```ans = min(ans, 1+ max(solve(e-1,x-1), solve(e,n-x) ))```\\n        * +1 because we already drop a egg\\n![image](https://assets.leetcode.com/users/images/53151635-c079-410c-98f6-f15b10b555f8_1658061542.7045417.jpeg)\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int dp[3][1001];\\n    int solve(int e, int f)\\n    {\\n        if (f <= 1 || e == 1)\\n            return f;\\n        if (dp[e][f] != -1)\\n            return dp[e][f];\\n        int mn = INT_MAX;\\n        for (int i = 1; i <= f; i++)\\n            mn = min(mn, 1 + max(solve(e - 1, i - 1), solve(e, f - i)));\\n        dp[e][f] = mn;\\n        return mn;\\n    }\\n    int twoEggDrop(int n)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```sum of all the increments>=n```\n```\\nclass Solution\\n{\\npublic:\\n    int twoEggDrop(int n)\\n    {\\n        double ans = (sqrt(1 + 8 * n) - 1) / 2;\\n        return (ans - int(ans) == 0) ? ans : ans + 1;\\n    }\\n};\\n```\n```dp[i][j] = minimum number of trials needed to determine the threshold floor for i number of eggs and j number of floors```\n``` solve(e-1,x-1)```\n```solve(e,n-x)```\n```ans = min(ans, 1+ max(solve(e-1,x-1), solve(e,n-x) ))```\n```\\nclass Solution\\n{\\npublic:\\n    int dp[3][1001];\\n    int solve(int e, int f)\\n    {\\n        if (f <= 1 || e == 1)\\n            return f;\\n        if (dp[e][f] != -1)\\n            return dp[e][f];\\n        int mn = INT_MAX;\\n        for (int i = 1; i <= f; i++)\\n            mn = min(mn, 1 + max(solve(e - 1, i - 1), solve(e, f - i)));\\n        dp[e][f] = mn;\\n        return mn;\\n    }\\n    int twoEggDrop(int n)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206621,
                "title": "memoization-tabulation-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int solve(int f,int e,int[][] dp)\\n    {\\n        if(f<=2 || e==1) return f;\\n        if(dp[f][e]!=-1) return dp[f][e];\\n        \\n        int min=f;\\n        \\n        for(int i=1;i<=f;++i)\\n        {\\n            int Break=solve(i-1,e-1,dp);\\n            int notBreak=solve(f-i,e,dp);\\n            int worstCase=1+Math.max(Break,notBreak);\\n            min=Math.min(min,worstCase);\\n        }\\n        \\n        return dp[f][e]=min;\\n    }\\n    public int twoEggDrop(int n) \\n    {\\n        int eggs=2;\\n        int[][] dp=new int[n+1][3];\\n        /*for(int[] row : dp)\\n            Arrays.fill(row,-1);\\n        \\n        return solve(n,2,dp);\\n        */\\n        for(int f=1;f<=n;++f)\\n        {\\n            for(int e=1;e<=2;++e)\\n            {\\n                if(f<=2 || e==1)\\n                {\\n                    dp[f][e]=f;\\n                    continue;\\n                }\\n                int min=(int)Math.pow(10,9);\\n        \\n                for(int i=1;i<f;++i)\\n                {\\n                    int Break=dp[i-1][e-1];\\n                    int notBreak=dp[f-i][e];\\n                    int worstCase=1+Math.max(Break,notBreak);\\n                    min=Math.min(min,worstCase);\\n                }\\n        \\n                dp[f][e]=min;\\n            }\\n        }\\n        return dp[n][2];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution \\n{\\n    public int solve(int f,int e,int[][] dp)\\n    {\\n        if(f<=2 || e==1) return f;\\n        if(dp[f][e]!=-1) return dp[f][e];\\n        \\n        int min=f;\\n        \\n        for(int i=1;i<=f;++i)\\n        {\\n            int Break=solve(i-1,e-1,dp);\\n            int notBreak=solve(f-i,e,dp);\\n            int worstCase=1+Math.max(Break,notBreak);\\n            min=Math.min(min,worstCase);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1928279,
                "title": "simple-c-solution-very-easy",
                "content": "\\tint dp[1005][3];\\n\\t\\tint solve(int n, int eggs){\\n        \\n        if(dp[n][eggs]!=-1)\\n            return dp[n][eggs];\\n        if(n<=1 || eggs==1)\\n            return n;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1;i<n;i++)\\n            mini = min(mini, max(solve(i-1, eggs-1), solve(n-i, eggs))+1);\\n    \\n        return dp[n][eggs] = mini;\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 2);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\tint dp[1005][3];\\n\\t\\tint solve(int n, int eggs){\\n        \\n        if(dp[n][eggs]!=-1)\\n            return dp[n][eggs];\\n        if(n<=1 || eggs==1)\\n            return n;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1;i<n;i++)\\n            mini = min(mini, max(solve(i-1, eggs-1), solve(n-i, eggs))+1);\\n    \\n        return dp[n][eggs] = mini;\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1901519,
                "title": "c-dynamic-programming-easy-to-understand",
                "content": "```\\nint twoEggDrop(int n) {\\n        vector<vector<int>> dp(2,vector<int>(n+1,INT_MAX-1));\\n        dp[0][0]=dp[1][0]=0;\\n        //BASE CASE \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i]=i;\\n        }   \\n        // STATE : dp[i][j] means the when we have i egg and j floor what is the minimum no of moves:\\n        \\n        for(int at=1;at<=n;at++){\\n            for(int choose= 1;choose<=at;choose++){\\n        //TRANSACTION : when we are (at) we through egg it either break or didnt break so\\n        // if break go to egg-1 if didnt break keep go down  \\n                dp[1][at]=min(max(dp[0][choose-1],dp[1][at-choose])+1,dp[1][at]);\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint twoEggDrop(int n) {\\n        vector<vector<int>> dp(2,vector<int>(n+1,INT_MAX-1));\\n        dp[0][0]=dp[1][0]=0;\\n        //BASE CASE \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i]=i;\\n        }   \\n        // STATE : dp[i][j] means the when we have i egg and j floor what is the minimum no of moves:\\n        \\n        for(int at=1;at<=n;at++){\\n            for(int choose= 1;choose<=at;choose++){\\n        //TRANSACTION : when we are (at) we through egg it either break or didnt break so\\n        // if break go to egg-1 if didnt break keep go down  \\n                dp[1][at]=min(max(dp[0][choose-1],dp[1][at-choose])+1,dp[1][at]);\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463019,
                "title": "simple-mathematics-soln-pattern",
                "content": "better than dp soln..\\n just see the case of n=100 , every time we are decresing no. with increasing value \\neg.\\n100 -1=99\\n99 -2 =97\\n97 -3= 94\\n and so on  \\n the answer will be the decrement value when it reaches negative value\\n ,,,\\n class Solution {\\n     \\npublic:\\n    \\n    int twoEggDrop(int n) {\\n       \\n       int i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n        }\\n        i--;\\n        return i;\\n        \\n    }\\n};\\n,,,\\n**DON\\'T FORGET TO UPVOTE ,ONLY IF YOU LIKE IT :))**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n     \\npublic:\\n    \\n    int twoEggDrop(int n) {\\n       \\n       int i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428699,
                "title": "i-think-the-explain-in-example-2-is-wrong",
                "content": "In the example 2, it explains that \\n```\\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting\\n  from floor 1 and going up one at a time to find f within 7 more drops. Total drops is 1 + 7 = 8.\\n```\\nbut actually, if first egg breaks in floor 9, it takes 8 more steps to find the answer in worst case where the 8th floor is the answer. so total drops in this case is 1 + 8 = 9.",
                "solutionTags": [],
                "code": "```\\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting\\n  from floor 1 and going up one at a time to find f within 7 more drops. Total drops is 1 + 7 = 8.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250399,
                "title": "accepted-python-recursion-memoization-with-comments",
                "content": "```class Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        def helper(numFloors, eggs):\\n            if (numFloors, eggs) in memo:\\n                return memo[(numFloors, eggs)]\\n            #print (n, eggs)\\n            # For 0 floors, we need no more moves.\\n            # For 1 floor, we try to throw an egg from floor 1. Depending on the result, we know if f == 0 or f == 1. So number of moves needed is 1.\\n            if numFloors <= 1:\\n                memo[(numFloors, eggs)] = numFloors\\n                return numFloors\\n            \\n            # If only 1 egg is available, we need to try from every floor starting at 1 to find the correct f value. Hence, in the worst case, we would need numFloors moves to know the value of f for certain.\\n            if eggs == 1:\\n                memo[(numFloors, eggs)] = numFloors\\n                return numFloors\\n            \\n            result = inf\\n            for floor in range(1, numFloors+1):\\n                # Try from every floor\\n                # If the egg breaks, we have 1 less egg and we have to find the answer from floor - 1. Every floor from floor to n will see the egg break.\\n                # If the egg does not break, we know floors 1 to floor are safe, so we need to find the answer from floor+1 to numFloors. But the answer from floor+1 to numFloors would be the same as the answer from 1 to numFloors-floor.\\n                # In floor+1 to numFloors, if an egg breaks at some point (say x), we would generally need to try throwing eggs from floor 1 to floor x in the worst case. But here, we already know that all floors till \\'floor\\' are safe, so we actually only need to try x - floor, which is the same as trying to find the answer from 1 to numFloors - floor.\\n                result = min(result, max(helper(floor-1, eggs-1), helper(numFloors-floor, eggs)))   \\n                memo[(numFloors, eggs)] = result+1\\n            \\n            return result+1   \\n        \\n        if n == 1:\\n            return 1\\n        \\n        eggs = 2\\n        memo = {}\\n        return helper(n, eggs)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        def helper(numFloors, eggs):\\n            if (numFloors, eggs) in memo:\\n                return memo[(numFloors, eggs)]\\n            #print (n, eggs)\\n            # For 0 floors, we need no more moves.\\n            # For 1 floor, we try to throw an egg from floor 1. Depending on the result, we know if f == 0 or f == 1. So number of moves needed is 1.\\n            if numFloors <= 1:\\n                memo[(numFloors, eggs)] = numFloors\\n                return numFloors\\n            \\n            # If only 1 egg is available, we need to try from every floor starting at 1 to find the correct f value. Hence, in the worst case, we would need numFloors moves to know the value of f for certain.\\n            if eggs == 1:\\n                memo[(numFloors, eggs)] = numFloors\\n                return numFloors\\n            \\n            result = inf\\n            for floor in range(1, numFloors+1):\\n                # Try from every floor\\n                # If the egg breaks, we have 1 less egg and we have to find the answer from floor - 1. Every floor from floor to n will see the egg break.\\n                # If the egg does not break, we know floors 1 to floor are safe, so we need to find the answer from floor+1 to numFloors. But the answer from floor+1 to numFloors would be the same as the answer from 1 to numFloors-floor.\\n                # In floor+1 to numFloors, if an egg breaks at some point (say x), we would generally need to try throwing eggs from floor 1 to floor x in the worst case. But here, we already know that all floors till \\'floor\\' are safe, so we actually only need to try x - floor, which is the same as trying to find the answer from 1 to numFloors - floor.\\n                result = min(result, max(helper(floor-1, eggs-1), helper(numFloors-floor, eggs)))   \\n                memo[(numFloors, eggs)] = result+1\\n            \\n            return result+1   \\n        \\n        if n == 1:\\n            return 1\\n        \\n        eggs = 2\\n        memo = {}\\n        return helper(n, eggs)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2683695,
                "title": "math-o-1-solution-clear-and-easy-explanation",
                "content": "Let the building have n floors and the 1st egg be dropped from floor number x. \\nWe now have two situations:\\n1. If 1st egg breaks when dropped from floor x, we will have to linearly search for the first floor where the egg breaks from the bottom. i.e, search floors 1,2,3,..., x -1. In the worst case we would have searched x-1 floors + the first egg drop from the floor x. A total of x searches or moves.\\n\\t`C(n) = x` if first egg breaks on first drop.\\n2. If the 1st egg doesn\\'t break, we now have two eggs and (n-x) floors to search. This problem is same as original problem with a different number of floors to search. However, we used up one extra search in checking the first egg drop.\\n\\t`C(n) = 1 + C(n-x)` if first egg doesn\\'t break on first drop.\\n\\nIn essence, the number of searches we need to make to discover the target floor with certainty is the maximum of 1. and 2. \\n\\ni.e, `C(n) = max(x, 1 + C(n-x))`  equation #1\\n\\nNote that if we set x to a lower floor, x decreases. But C(n-x) increases, because it would have to search more floors. Similarly if we increase x, C(n-x) decreases as it has to search through fewer floors, but increase in x causes the first parameter to increase.\\n\\nThus we need to balance the first and second parameter in equation #1. So we set the two parameters to be equal.\\n\\n`x = 1 +  C(n-x)` equation #2\\n\\nFrom equation #1, using the equality above, we get `C(n) = x = 1 + C(n-x)`\\n\\nSimilarly, for the next search we branch into: \\n\\n`C(n-x) = max(y, 1 + C(n-x-y))`\\n\\nBalancing the two branches: `C(n-x) = y = 1 + C(n-x-y)` equation #3\\n\\nSubstituting the above in equation #2, we get `x = 1 + y` or `y = x - 1`\\n\\nContinuing the search from C(n-x-y) we get `C(n-x-y) = z = 1 + C(n-x-y-z)`\\n\\nSubstituting the above in equation #3, we get `y = 1 + z` or `z = y - 1` or `z = x - 2`\\n\\nAs we can see from the above, the searches split into 2 parts at each stage depending upon the egg being dropped breaks or not. Moreover, at each stage we go through two parts of search. One which linearly searches from the first floor in the search range till the floor where the first egg dropped breaks. The other search goes through the remaining portion in a sort of recursive way. The first search goes through x searches, the second one through x-1 searches, third through x-2 searches and so on..\\n\\nAt the end of the search we are guaranteed to have searched through the n floors. Therefore, `x + (x-1) +  (x-2) + (x-3) + .... + (x-x) = n` at the least.\\n\\nThe summation is nothing but the sum of first x natural numbers : \\n```\\nx + (x-1) + (x-1) +..... + 3 + 2 + 1 = n\\nx*(x+1)/2 = n\\nx^2 + x - 2n = 0\\n```\\n\\nUsing the quadratic formula, we can solve the above as `x = (-b + sqrt(b^2 - 4ac)) / 2a` or `x = (-1 + sqrt(1 + 8*n))/2`\\n\\nWe choose the positive square root because we want a positive number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        double res = (-1.0 + sqrt(1+8*n))/2.0;\\n        return ceil(res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nx + (x-1) + (x-1) +..... + 3 + 2 + 1 = n\\nx*(x+1)/2 = n\\nx^2 + x - 2n = 0\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        double res = (-1.0 + sqrt(1+8*n))/2.0;\\n        return ceil(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119678,
                "title": "dp-with-binary-search-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][3];\\n    int solve(int floor, int egg) {\\n        if(floor == 0 || floor == 1) return floor;\\n        if(egg == 1) return floor;\\n        if(dp[floor][egg] != -1) return dp[floor][egg];\\n        int mi = INT_MAX, l = 1, r = floor;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            \\n            int left = solve(mid - 1, egg - 1); //egg broken check for down floors of mid.\\n            \\n            int right = solve(floor - mid, egg); // not broken check for up floors of mid.\\n            \\n            if(left >= right) {   //left >= right so we will go downward\\n                r = mid;\\n            } else { //since right is more than left and we need more in worst case \\n                l = mid + 1;  // so l=mid+1 to gain more  for worst case : upward\\n            }\\n            mi = min(mi, 1+max(left, right)); //store minimum attempts of (max of both left, right )\\n        }\\n        return dp[floor][egg] = mi;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][3];\\n    int solve(int floor, int egg) {\\n        if(floor == 0 || floor == 1) return floor;\\n        if(egg == 1) return floor;\\n        if(dp[floor][egg] != -1) return dp[floor][egg];\\n        int mi = INT_MAX, l = 1, r = floor;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            \\n            int left = solve(mid - 1, egg - 1); //egg broken check for down floors of mid.\\n            \\n            int right = solve(floor - mid, egg); // not broken check for up floors of mid.\\n            \\n            if(left >= right) {   //left >= right so we will go downward\\n                r = mid;\\n            } else { //since right is more than left and we need more in worst case \\n                l = mid + 1;  // so l=mid+1 to gain more  for worst case : upward\\n            }\\n            mi = min(mi, 1+max(left, right)); //store minimum attempts of (max of both left, right )\\n        }\\n        return dp[floor][egg] = mi;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876518,
                "title": "c-faster-than-100-for-beginners-with-explanation",
                "content": "If we look at how the answer is for various inputs, it is\\n1 \\n2 2\\n3 3 3\\n4 4 4 4\\n5 5 5 5 5 \\n6 6 6 6 6 6\\n7 7 7 7 7 7 7\\n8 8 8 8 8 8 8 8\\n9 9 9 9 9 9 9 9 9\\n10 10 10 10 10 10 10 10 10 10\\n11 11 11 11 11 11 11 11 11 11 11\\n12 12 12 12 12 12 12 12 12 12 12 12\\n13 13 13 13 13 13 13 13 13 13 13 13 13\\n14 14 14 14 14 14 14 14 14 14 14 14 14 14\\n(where each number denotes the input n)\\n\\nwhich is 4 times 4, 5 times 5, 10 times 10 and so on.\\nHence, for n = 7, answer will be 4 and also for n = 10, answer will be 4.\\nSo, with the help of these ranges for the inputs, we have a pattern and we can code accordingly.\\n\\n**Planning the code:**\\n\\t\\tWe need two for loops, outer one will keep on incrementing and the inner will take help of outer for maintaining the range (4 times 4, 5 times 5 and so on)....\\n\\t\\tUsing the inner loop, we also keep the track of steps, and outer loop runs ```temp < n``` times.\\n\\n**Analysis:**\\n\\t\\tComplexity: O(n\\xB2)\\n)\\n\\nThe code is as follows: \\n```\\nint twoEggDrop(int n) {\\n    int ans = 1, temp = 0;\\n    for (int i = 0; i < n && temp < n; i++)    //temp < n, loop ends.\\n    {\\n        for (int j = 0; j <= i; j++)    //maintains range\\n        {\\n            temp++;    //it keeps a track of how many moves are done.\\n            ans = j;    //storing answer using answer variable.\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\nPlease upvote and comment if you liked the solution !!\\n\\n![image](https://assets.leetcode.com/users/images/02755fa6-c100-4326-903c-aa50e6d34287_1648043711.1681225.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```temp < n```\n```\\nint twoEggDrop(int n) {\\n    int ans = 1, temp = 0;\\n    for (int i = 0; i < n && temp < n; i++)    //temp < n, loop ends.\\n    {\\n        for (int j = 0; j <= i; j++)    //maintains range\\n        {\\n            temp++;    //it keeps a track of how many moves are done.\\n            ans = j;    //storing answer using answer variable.\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639441,
                "title": "mathematical-o-1-easiest-explanation",
                "content": "From example 2 you will get the strategy to solve the problem \\n\\nExplanation:\\nIt is evident from the problem that we will need to hit the eggs on the floor linearly to catch the exact floor it breaks once we lose the first egg.\\n\\nlet us consider the Example 2: 100 floors.\\n\\n1. assume the n=1, all we need is one move to hit 1 and check if the f is 1 or none.\\n2. assume n=2, all we need is 2 moves for the worst case i.e `2->1`.\\n3. assume n=3, again we need 2 moves for worst case i.e `2->1` or `2->3`.\\n4. assume n=4, all we need is 3 moves to check for worst case i.e `3->1->2`.\\n5. assume n=5, again we need is 3 moves to check for the worst case i.e `3->1->2` or `3->5->4`.\\n6. if n=6-10, all we need is 4 moves i.e `4->1->2->3` or `4->7->5->6` or `4->7->9->8` or `4->7->9->10`.\\n\\n| n | moves |\\n| - | - |\\n| 1 | 1 |\\n| 2 | 2 |\\n| 3 | 2 |\\n| 4 | 3 |\\n| 5 | 3 |\\n| 6 | 4 |\\n| 7 | 4 |\\n| 8 | 4 |\\n| 9 | 4 |\\n\\nIf you see the pattern here for a given amount of moves you can handle a certain amount of floors. where the pattern boils down to sum of n.\\n\\nMathematically, SumOfN <= n(n+1)/2, where we need to find n and SumOfN is given so lets consider it as x.\\n```\\nx <= n(n+1)/2\\n2x <= n^2 + n \\nn^2 + n -2x >= 0\\n```\\nthis is a quadriatic equaltion, we can use `n=b^2 + sqrt(4ac) / 2a` formula.\\nhere a=1, b=1, c=2x\\n```\\nn = 1 + sqrt( 4 * 1 * 2x ) / 2\\nn = sqrt( 8 * x ) + 1 / 2\\n```\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ((sqrt((float)n*8)+1)/2);\\n    }\\n};\\n```\\nor\\n```\\n ( sqrt( n << 3 ) + 1 ) >> 2;\\n```\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nx <= n(n+1)/2\\n2x <= n^2 + n \\nn^2 + n -2x >= 0\\n```\n```\\nn = 1 + sqrt( 4 * 1 * 2x ) / 2\\nn = sqrt( 8 * x ) + 1 / 2\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ((sqrt((float)n*8)+1)/2);\\n    }\\n};\\n```\n```\\n ( sqrt( n << 3 ) + 1 ) >> 2;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487889,
                "title": "c-simple-solution-based-on-the-pattern-described-in-the-examples",
                "content": "Start with a difference of \\'1\\', incrementing it everytime after substracting it from the \\'n\\' untill \\'n\\' becomes negative\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) \\n    {\\n        int diff = 1;\\n        while(n>0)\\n        {\\n            n-=diff;//Subtract the diff. from the  \\'n\\'\\n            diff++; //keep incrementing the difference\\n        }\\n        \\n        return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) \\n    {\\n        int diff = 1;\\n        while(n>0)\\n        {\\n            n-=diff;//Subtract the diff. from the  \\'n\\'\\n            diff++; //keep incrementing the difference\\n        }\\n        \\n        return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473777,
                "title": "c-easy-to-understand-fast-using-dynamic-programming",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,0));\\n        for(int i=1;i<=2;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=j;\\n                }\\n                else if(j==1)\\n                {\\n                    dp[i][j]=1;\\n                }\\n                else\\n                {\\n                    int mini=INT_MAX;\\n                    for(int mj=j-1,pj=0;mj>=0;mj--,pj++)\\n                    {\\n                        int v1=dp[i][mj];\\n                        int v2=dp[i-1][pj];\\n                        int val=max(v1,v2);\\n                        mini=min(mini,val);\\n                    }\\n                    dp[i][j]=mini+1;\\n                }\\n            }\\n        }\\n        return dp[2][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3,vector<int>(n+1,0));\\n        for(int i=1;i<=2;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=j;\\n                }\\n                else if(j==1)\\n                {\\n                    dp[i][j]=1;\\n                }\\n                else\\n                {\\n                    int mini=INT_MAX;\\n                    for(int mj=j-1,pj=0;mj>=0;mj--,pj++)\\n                    {\\n                        int v1=dp[i][mj];\\n                        int v2=dp[i-1][pj];\\n                        int val=max(v1,v2);\\n                        mini=min(mini,val);\\n                    }\\n                    dp[i][j]=mini+1;\\n                }\\n            }\\n        }\\n        return dp[2][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392853,
                "title": "easy-java-commented-code",
                "content": "**Please Upvote if you liked the post**\\n\\n```\\nclass Solution {\\n    public int twoEggDrop(int floors) {\\n        \\n        int [][] dp = new int [3][floors + 1];\\n        \\n        for(int egg = 1;egg<3;egg++){\\n            for(int floor = 1;floor<=floors;floor++){\\n            \\n                if(egg == 1){ // if there is 1 egg then guaranteed min\\n\\t\\t\\t\\t\\t//attempts at any floor will be equal to floor num\\n                    dp[egg][floor] = floor;\\n                }else if(floor == 1){//we will get result in one throw\\n                    dp[egg][floor] = 1;\\n                }else{\\n                    \\n                    int min = Integer.MAX_VALUE;\\n                    for(int mj = floor - 1,pj = 0;mj >= 0;mj--,pj++){\\n                        \\n                        int survive = dp[egg][mj] ;//egg survives\\n                        int breaks  = dp[egg - 1][pj]; //egg breaks\\n                        \\n                        int max = Math.max(survive,breaks);//assuming worst of luck\\n                        min = Math.min(min,max);//doing best what is in our hands\\n                    }\\n                    \\n                    dp[egg][floor] = min + 1; //this is guaranteed best ans \\n                    // update the ans with\\n                    //best of the worst results , so that we can give a guaranteed Plan \\n\\t\\t\\t\\t\\twhich will work regardless of the position of critical floor\\n                }\\n            }\\n        }\\n        return dp[2][floors];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int floors) {\\n        \\n        int [][] dp = new int [3][floors + 1];\\n        \\n        for(int egg = 1;egg<3;egg++){\\n            for(int floor = 1;floor<=floors;floor++){\\n            \\n                if(egg == 1){ // if there is 1 egg then guaranteed min\\n\\t\\t\\t\\t\\t//attempts at any floor will be equal to floor num\\n                    dp[egg][floor] = floor;\\n                }else if(floor == 1){//we will get result in one throw\\n                    dp[egg][floor] = 1;\\n                }else{\\n                    \\n                    int min = Integer.MAX_VALUE;\\n                    for(int mj = floor - 1,pj = 0;mj >= 0;mj--,pj++){\\n                        \\n                        int survive = dp[egg][mj] ;//egg survives\\n                        int breaks  = dp[egg - 1][pj]; //egg breaks\\n                        \\n                        int max = Math.max(survive,breaks);//assuming worst of luck\\n                        min = Math.min(min,max);//doing best what is in our hands\\n                    }\\n                    \\n                    dp[egg][floor] = min + 1; //this is guaranteed best ans \\n                    // update the ans with\\n                    //best of the worst results , so that we can give a guaranteed Plan \\n\\t\\t\\t\\t\\twhich will work regardless of the position of critical floor\\n                }\\n            }\\n        }\\n        return dp[2][floors];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371690,
                "title": "easy-java-and-c-solution-similar-as-super-egg-drop-using-dp",
                "content": "This question is same as question **Super Egg Drop** instead of k identical egg we have given 2 identical eggs.\\nFor every floor there will be two cases :\\n*  Egg will break between 1-st to n-th floor, let say k-th floor.\\n*  Egg will break after k-th floor, means between (n-k)th to n-th floor.\\n\\nWe will take maximum of these two cases for every floor and store the minimum possible value among these maximum values in dp.\\n\\n**Java Implementation**\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2 ; i<dp.length ; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            int max = Integer.MIN_VALUE;\\n            for(int k=1 ; k<=i ; k++){\\n\\t\\t\\t//Taking max between two possible cases.\\n                max = 1 + Math.max(k-1, dp[i - k]);\\n                if(max < dp[i]){\\n\\t\\t\\t\\t//Taking minimum of all max values\\n                    dp[i] = max;\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\n**C++ Implementation**\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2 ; i<n+1 ; i++){\\n            dp[i] = INT_MAX;\\n            int val = INT_MIN;\\n            for(int k=1 ; k<=i ; k++){\\n\\t\\t\\t//Taking max between two possible cases.\\n                val = 1 + max(k-1, dp[i - k]);\\n                if(val < dp[i]){\\n\\t\\t\\t\\t//Taking minimum of all max values\\n                    dp[i] = val;\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n**Time Complexity : O(n^2)\\nSpace Complexity : O(n).**\\n\\n**Please upvote if you like the implementation it helps a lot.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2 ; i<dp.length ; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            int max = Integer.MIN_VALUE;\\n            for(int k=1 ; k<=i ; k++){\\n\\t\\t\\t//Taking max between two possible cases.\\n                max = 1 + Math.max(k-1, dp[i - k]);\\n                if(max < dp[i]){\\n\\t\\t\\t\\t//Taking minimum of all max values\\n                    dp[i] = max;\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i=2 ; i<n+1 ; i++){\\n            dp[i] = INT_MAX;\\n            int val = INT_MIN;\\n            for(int k=1 ; k<=i ; k++){\\n\\t\\t\\t//Taking max between two possible cases.\\n                val = 1 + max(k-1, dp[i - k]);\\n                if(val < dp[i]){\\n\\t\\t\\t\\t//Taking minimum of all max values\\n                    dp[i] = val;\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356707,
                "title": "one-line-solution-for-any-language",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1 + sqrt(1 + 8*n))/2);\\n    }\\n};\\n```\\n**Don\\'t forget to upvote : )**\\n\\n**Explaination :**\\n\\n\\t There are some results which I found out by observation, \\n        n=1, res=1\\n        n=2, res=2\\n        n=3, res=2\\n        n=4, res=3\\n        n=5, res=3\\n        n=6, res=3\\n        n=7, res=4\\n        n=8, res=4\\n        n=9, res=4\\n        n=10, res=4\\n\\t\\tn=11, res=5... so on\\n        \\n        So as we can see it\\'s making an AP\\n        1 times+ 2 times + 3 times + 4 times + 5 times+....\\n        and the result of our AP would be equal or greater or equal to total floors.\\n        \\n        so we know sum formula of AP i.e x*(x+1) / 2\\n        so by equating this formula with n\\n        x*(x+1)/2 = n\\n        this results to\\n        x^2 + x = 2*n\\n        x^2+x-2*n=0;--------(1)\\n        \\n        By Sridharacharya method \\n        \\n        if coefficients are a,b,c\\n        so,\\n\\t\\tx = (-b+sqrt(b^2-4*a*c))/2*a--------(2) \\n\\t\\tor \\n\\t\\tx = (-b-sqrt(b^2-4*a*c))/2*a;(this one is not possible)\\n        \\n        as second one is not possible as our result can\\'t be negative\\n        so, now putting values of a,b,c from our equation (1) to equation (2)\\n        a=1,b=1,c=-2*n\\n        \\n        so x=(-1+sqrt(1-4*2*n))/2\\n        x=-1+sqrt(1-8*n)/2;\\n\\t\\t\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1 + sqrt(1 + 8*n))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254508,
                "title": "one-liner-o-sqrt-n-o-log-n-clear-explanation-c",
                "content": "```\\nPlease comment if you have a doubt in the approach, I have added an example in the end\\n```\\nI was able to form an **arithmetic progression**. \\nLet\\'s say you select the floors in such a way that you\\'re always able to get the correct floor in at max **m** steps.\\nTotal floors = **N**. \\n\\n---\\n\\nKey Idea : \\n---\\n```\\nTest floors in gaps such that if egg breaks at floor i, then you always end up getting the right floor in at most m steps.\\nThe gap at which you  test floors depends on all the chances you have already used\\n```\\n\\nSolution : \\n---\\n\\n`\\nIf you drop the first egg at floor m and it breaks, then you need to check all the floors from 1 to m-1 incrementally. \\n`\\n \\nIf it doesn\\'t then you already have used 1 chance, so you should leave a gap of m - 2 and then check at floor m+(m-2)+1 i.e  floor (2 * m - 1). \\n\\n\\nIf it breaks at floor 2 * m - 1, then you check all floors from m+1 to 2 * m - 2 incrementally. \\nYou still will take m moves at most because,\\n`1 (floor m) + 1(floor 2 * m - 1) + m-2(all between m and 2 * m - 1) = m.`\\n \\nIf it doesn\\'t break (you\\'ve used  2 moves already), then leave a gap of m-3 and check at floor \\n`(2 * m - 1) + (m - 3)  + 1`  i.e `3 * m - 3` and so on....\\n\\nIf you observe, \\nFloor for 1st move = m,         .........................................................(gap of m-1)\\nFloor for 2nd move = m + m - 1,..................................................(gap of m-2)\\nFloor for 3rd move  = m + m - 1 + m - 2 ..................................(gap of m-3)\\n\\n**For the optimal solution, we should reach floor N in the mth move.**  \\nFloor from mth move = m + m - 1 + m - 2 + ........ + m - ( m - 2 ) + m - ( m - 1 ) = N. \\n\\nCan also be written as,\\n1 + 2 + 3 + ....... m = N. \\nThis is arithmetic progression which evaluates to **` m * (  m + 1 ) / 2 = N. `**\\nWe need to find first m such that, m * ( m + 1 ) >= 2 * N\\n\\n***Please look at the end for example***\\n\\n---\\nCode :\\n----\\n \\n` O(sqrt(N)) solution `\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        for(int i=1;i<50;i++){\\n            if(i*(i+1) >= 2*n){\\n                return i; \\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\n\\n---\\n` O(log(N)) one liner  solution `\\nUse the [quatratic formula](https://en.wikipedia.org/wiki/Quadratic_formula) on equation m * m + m - 2 * n > = 0\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1.0 +sqrt(1 + 8 * n))/2) ; \\n    }\\n};\\n```\\n\\n---\\nExample : \\n----\\n```\\nSuppose there are 20 floors, \\nFloors to check with egg 1 : 6 , 11, 15, 18, 20. \\n\\nIf the egg-break floor is between 1 and 6 inclusive, \\nMax chances = 1(6th floor) + 5(1st to 5th floor incrementally) = 6.\\n\\nIf the egg-break floor is between 6 and 11 inclusive, \\nMax chances = 1(6th floor) + 1(11th floor) + 4(7 to 10th floor incrementally) = 6\\n\\nIf the egg-break floor is between 11 and 15 inclusive, \\nMax chances = 1(6th floor) + 1(11th floor) + 1(15th floor)  +3(12 to 14th floor incrementally) \\n= 6.\\n\\nHence we are always reaching the egg-break floor in at most 6 moves. \\n```\\n\\n`\\nPlease do upvote if you like the approach \\uD83D\\uDE03\\n`\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nPlease comment if you have a doubt in the approach, I have added an example in the end\\n```\n```\\nTest floors in gaps such that if egg breaks at floor i, then you always end up getting the right floor in at most m steps.\\nThe gap at which you  test floors depends on all the chances you have already used\\n```\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        for(int i=1;i<50;i++){\\n            if(i*(i+1) >= 2*n){\\n                return i; \\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1.0 +sqrt(1 + 8 * n))/2) ; \\n    }\\n};\\n```\n```\\nSuppose there are 20 floors, \\nFloors to check with egg 1 : 6 , 11, 15, 18, 20. \\n\\nIf the egg-break floor is between 1 and 6 inclusive, \\nMax chances = 1(6th floor) + 5(1st to 5th floor incrementally) = 6.\\n\\nIf the egg-break floor is between 6 and 11 inclusive, \\nMax chances = 1(6th floor) + 1(11th floor) + 4(7 to 10th floor incrementally) = 6\\n\\nIf the egg-break floor is between 11 and 15 inclusive, \\nMax chances = 1(6th floor) + 1(11th floor) + 1(15th floor)  +3(12 to 14th floor incrementally) \\n= 6.\\n\\nHence we are always reaching the egg-break floor in at most 6 moves. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250141,
                "title": "two-lines-of-code-c-faster-than-100-online-submissions",
                "content": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        \\n        float temp= sqrt(2*n);\\n        int res=  ceil(n/temp+ (temp-1)/2);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        \\n        float temp= sqrt(2*n);\\n        int res=  ceil(n/temp+ (temp-1)/2);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3675246,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck problem example two, it is a hint. if you want to add to n, the base line is sqrt(n), There is no way you can test out less that sqrt(n).  res>sqrt(n)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets start from sqrt(n), because each time when you drop the egg and the egg is not broken, you have to drop again(the big interval, assume sqrt(n) because sqrt(n)* sqrt(n) = n for each phase you try sqrt(n), and you try sqrt(n) times) by rasing certain amount of floors. To reach optimal solution, we\\'d like each big interval be the same length. beause why not? the length between each interval doesnt make any difference.\\n\\nTake 100 as example, sqrt(100) = 10. lets try if we can finish in 10 times. \\nfist we start at 10, if lucky, we have two eggs still. If we are lucky enough, the egg doesnt broke until it hit 99. we need to try 1*10+9 = 19 times. (1 for each 10 floors, 1 egg broke at 100, so we try 9 time to find 99)\\nthat doesnt seem to work so we add 1 to ourt basedline and try again, until we hit 14 for our base line. \\n14+13+12....+1 = 105 > 100, we have tested all the floors and we only used 14 steps max!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) (i dont have math proof but it should around O(1) unless we have a enormous n in that case it still less that log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = ceil(sqrt(n));\\n        while((i+1)*i/2<n){\\n            i++;\\n        }\\n\\n        return i;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = ceil(sqrt(n));\\n        while((i+1)*i/2<n){\\n            i++;\\n        }\\n\\n        return i;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530731,
                "title": "egg-drop-with-2-eggs-and-n-floors-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            ans++;\\n            n -= ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/ff0c0a25-45a4-483b-8d15-bb6dad8602da_1684239538.5164714.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            ans++;\\n            n -= ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383678,
                "title": "easy-solution-in-python-run-time-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/1be472e3-f6d1-403c-bf3a-98d9c73c1e1b_1680711655.9163277.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i=1\\n        steps=0\\n        while n>0:\\n            n-=i\\n            i+=1\\n            steps+=1\\n        return steps\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i=1\\n        steps=0\\n        while n>0:\\n            n-=i\\n            i+=1\\n            steps+=1\\n        return steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627765,
                "title": "made-easy-2-ways-o-1-sc-o-n-tc-single-loop-iterative-python-solution",
                "content": "**Approach 1:** Observation is key to this approach. Take a closer look at the second example:\\n9, 22, 34, 45 ,..., 97, 99, 100\\neach time we are decreasing by a certain amount in decreasing order. \\n22 - 9 = **13**\\n34 - 22 = **12**\\n45 - 34 = **11**\\nand so on...\\n\\nIf we reverse this, we will increase by a certain amount in an increasing order:\\n1 (base)\\n1 + **1** = 2\\n2 + **2** = 4\\n4 + **3** = 7\\n7 + **4** = 11\\n11 + **5** = 16\\nand so on until we cross n, we count the number of steps we take during the process. \\n\\nThis is my analogy to the real world: At start Im afraid that the egg might break so I take the smallest step. If the egg doesn\\'t break I grow in confidence and take a larger next step. If it breaks I only take smaller steps since can\\'t afford to lose the second egg without finding the answer. Maximum steps taken during the process is the answer. Reverse is also true!\\n\\n**Upvote if you like the answer :)**\\n\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        c = 0\\n        x = i = 1\\n        \\n        while x <= n:\\n            c += 1\\n            x += i\\n            i += 1\\n        \\n        return c\\n```\\n\\n**Approach 2:** Using dp, useful for any number of eggs:\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int, e = 2, dp = {}) -> int:\\n        if e <= 1:\\n            return e\\n        if n <= 1:\\n            return n\\n        if (n, e) in dp:\\n            return dp[(n, e)]\\n        \\n        ans = n # worst possible value is n\\n        \\n\\t\\t# try throwing at every floor\\n\\t\\t# egg breaks at kth floor: reduce egg count and check for remaining eggs in the floors below kth floor\\n\\t\\t# egg doesnt break at kth floor: check for remaining floors above kth floor with same number of eggs\\n\\t\\t# take the worst possible using max at kth floor, but the overall best possible value using min\\n        for k in range(1, n):\\n            ans = min(ans, 1 + max(self.twoEggDrop(k - 1, e - 1, dp), self.twoEggDrop(n - k, e, dp)))\\n        \\n        dp[(n, e)] = ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        c = 0\\n        x = i = 1\\n        \\n        while x <= n:\\n            c += 1\\n            x += i\\n            i += 1\\n        \\n        return c\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int, e = 2, dp = {}) -> int:\\n        if e <= 1:\\n            return e\\n        if n <= 1:\\n            return n\\n        if (n, e) in dp:\\n            return dp[(n, e)]\\n        \\n        ans = n # worst possible value is n\\n        \\n\\t\\t# try throwing at every floor\\n\\t\\t# egg breaks at kth floor: reduce egg count and check for remaining eggs in the floors below kth floor\\n\\t\\t# egg doesnt break at kth floor: check for remaining floors above kth floor with same number of eggs\\n\\t\\t# take the worst possible using max at kth floor, but the overall best possible value using min\\n        for k in range(1, n):\\n            ans = min(ans, 1 + max(self.twoEggDrop(k - 1, e - 1, dp), self.twoEggDrop(n - k, e, dp)))\\n        \\n        dp[(n, e)] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435929,
                "title": "simple-5-line-python-solution-most-unique-and-smallest-solution-without-any-in-built-function",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        count = 1\\n        i = 2\\n        while(n-count > 0):\\n            count+=i\\n            i+=1\\n        return i-1\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        count = 1\\n        i = 2\\n        while(n-count > 0):\\n            count+=i\\n            i+=1\\n        return i-1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392769,
                "title": "simple-mathematical-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n         int x = 2 * n;\\n\\t\\tint ans= pow(x,0.5);\\n\\t\\tint res = (ans * (ans + 1)) / 2;   \\n\\t\\treturn res >= n ? ans : ans + 1;\\n    }\\n};\\n```\\n\\nHere I have used formula of sum of n integer numbers, and approximated it with int ans= pow(x,0.5); And after that checked it\\'s sum again for 1 digit difference. \\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n         int x = 2 * n;\\n\\t\\tint ans= pow(x,0.5);\\n\\t\\tint res = (ans * (ans + 1)) / 2;   \\n\\t\\treturn res >= n ? ans : ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217940,
                "title": "c-mcm-aditya-verma-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int k, int n, int dp[3][1001])\\n    {\\n        if(k==1 || n==0 || n==1)\\n        return n;\\n        if(dp[k][n] != -1)\\n        return dp[k][n];\\n        int mn = INT_MAX, low, high;\\n        for(int k1=1; k1<=n; k1++)\\n        {\\n            if(dp[k-1][k1-1] != -1)\\n            low = dp[k-1][k1-1];\\n            else\\n            {\\n                low = solve(k-1, k1-1, dp);\\n                dp[k-1][k1-1] = low;\\n            }\\n            if(dp[k][n-k1] != -1)\\n            high = dp[k][n-k1];\\n            else\\n            {\\n                high = solve(k, n-k1, dp);\\n                dp[k][n-k1] = high;\\n            }\\n            int temp = 1 + max(low, high);\\n            mn = min(mn, temp);\\n        }\\n        return dp[k][n] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        int dp[3][1001];\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int k, int n, int dp[3][1001])\\n    {\\n        if(k==1 || n==0 || n==1)\\n        return n;\\n        if(dp[k][n] != -1)\\n        return dp[k][n];\\n        int mn = INT_MAX, low, high;\\n        for(int k1=1; k1<=n; k1++)\\n        {\\n            if(dp[k-1][k1-1] != -1)\\n            low = dp[k-1][k1-1];\\n            else\\n            {\\n                low = solve(k-1, k1-1, dp);\\n                dp[k-1][k1-1] = low;\\n            }\\n            if(dp[k][n-k1] != -1)\\n            high = dp[k][n-k1];\\n            else\\n            {\\n                high = solve(k, n-k1, dp);\\n                dp[k][n-k1] = high;\\n            }\\n            int temp = 1 + max(low, high);\\n            mn = min(mn, temp);\\n        }\\n        return dp[k][n] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        int dp[3][1001];\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217302,
                "title": "python-dynamic-programming-faster-than-90",
                "content": "It is better to think this problem from a reverse angle. The problem wants us to work out how many steps we have to take to figure out the largest floor the egg can tolerate. We can try to solve that with n steps/attempts what is the largest floor we can figure out. \\n* \\tWith 0 attempt, we can figure out nothing, then record[0]=0.\\n* \\tWith 1 attempt, we can figure out whether the egg can withstand 1 floor high, then record[1]=1.\\n* \\tWith 2 attempts , we can figure out 3 floor. The strategy is to drop the first egg at second floor, if it breaks, we can now focus our search window within 1 floor with the only one left egg, if it doesn\\'t break, we can also try the third floor, so record[2]=3.\\nNow on and on , we can draw the conclusion that the best strategy is as follows:\\nif we have i attempts to allocate, use the first attempt at the (record[i-1]+1) floor, if we have 3 attempts, the first try must be the 4th floor, so that if it breaks, we can use the 2 left attempts to figure out another 3 floors, and that is 7 floors in total; if it doesn\\'t break, we can use the 2 left attempts to figure out the first to third floor.\\nThe conclusion is :\\n```\\nrecord[i]=record[i-1]+i\\n```\\nThe code can be  :\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n<=2: return n\\n        record=[-1 for _ in range(n+1)]\\n        record[0]=0\\n        record[1]=1\\n        record[2]=3\\n        for i in range(3,n+1):\\n            record[i]=record[i-1]+i\\n            if record[i]>=n:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nrecord[i]=record[i-1]+i\\n```\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n<=2: return n\\n        record=[-1 for _ in range(n+1)]\\n        record[0]=0\\n        record[1]=1\\n        record[2]=3\\n        for i in range(3,n+1):\\n            record[i]=record[i-1]+i\\n            if record[i]>=n:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098753,
                "title": "after-months-of-struggling-i-finally-solved-it-in-python",
                "content": "Figured it out on my own.\\n\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int: \\n        M = [None] * (n + 1)\\n        M[0] = 0\\n        M[1] = 1      \\n        \\n        for i in range(2, n + 1):\\n            M[i] = min([1 + max(j - 1, M[i - j]) for j in range(1, i + 1)])\\n        \\n        return M[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int: \\n        M = [None] * (n + 1)\\n        M[0] = 0\\n        M[1] = 1      \\n        \\n        for i in range(2, n + 1):\\n            M[i] = min([1 + max(j - 1, M[i - j]) for j in range(1, i + 1)])\\n        \\n        return M[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060503,
                "title": "i-came-up-with-a-math-solution-for-the-first-time",
                "content": "For the first time, I have figured out a soluiton that I can tag MATH\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        count = 1\\n        while n > count:\\n            n -= count\\n            count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        \\n        count = 1\\n        while n > count:\\n            n -= count\\n            count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019593,
                "title": "java-linear-dp-solution-with-comments-tc-o-n-sc-o-1",
                "content": "Inspired by @lee215\\'s solution on k eggs, n floors, we can think in different way that given 2 eggs, we want to find the maximum floors we can test. If it is more than required n, we can return the moves.\\nTC: O(n) SC: O(n)\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {   \\n        // given x steps, the maximum floors I can test with two eggs\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            // move is i, previous move is i - 1,\\n            // we put egg on floor i, if egg breaks, we can check i - 1 floors with i - 1 moves\\n            // if egg does not break, we can check dp[i-1] floors having two eggs to with i - 1 moves\\n            dp[i] = 1 + i - 1 + dp[i - 1];\\n            if (dp[i] >= n) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\nIf we reduce dimension to 1, we can have SC O(1)\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {   \\n        // give x steps, the maximum floors I can test with two eggs\\n        int dp = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // move is i, previous move is i - 1,\\n            // we put egg on floor i, if egg breaks, we can check i - 1 floors with i - 1 moves\\n            // if egg not break, we can check dp[i-1] floors having two eggs to with i - 1 moves            \\n\\t\\t\\tdp += i; // dp = 1 + i - 1 + dp;\\n            if (dp >= n) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {   \\n        // given x steps, the maximum floors I can test with two eggs\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            // move is i, previous move is i - 1,\\n            // we put egg on floor i, if egg breaks, we can check i - 1 floors with i - 1 moves\\n            // if egg does not break, we can check dp[i-1] floors having two eggs to with i - 1 moves\\n            dp[i] = 1 + i - 1 + dp[i - 1];\\n            if (dp[i] >= n) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {   \\n        // give x steps, the maximum floors I can test with two eggs\\n        int dp = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // move is i, previous move is i - 1,\\n            // we put egg on floor i, if egg breaks, we can check i - 1 floors with i - 1 moves\\n            // if egg not break, we can check dp[i-1] floors having two eggs to with i - 1 moves            \\n\\t\\t\\tdp += i; // dp = 1 + i - 1 + dp;\\n            if (dp >= n) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988423,
                "title": "java-top-down-dp-with-memoization",
                "content": "If we drop the egg on floor i, there are 2 scenarios:\\n- the egg broke, then we continue with `floor[0...i-1]` with `(k - 1)` eggs\\n- the egg does not break, we continue with `floor[i...n-1]` with k eggs\\n\\n`dp(i, k)` means  the worst scenario to determine centain f by dropping k eggs with i floors\\n\\n```\\ndp(i, k) = MAX(dp(i - 1, k - 1),  if egg breaks\\n                dp(n - i, k))     if egg does not break\\n```\\nTake the minimum of trying all the possible floor i to start dropping.\\n\\nBase Case:\\n- `k == 1`, then we need to test all remaining floors\\n- `n == 0`, no more floors\\n\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int twoEggDrop(int n) {\\n        int k = 2;\\n        memo = new Integer[n + 1][k + 1];\\n        return helper(n, k);\\n    }\\n\\n    private int helper(int n, int k){\\n        if(n == 0) return 0;\\n        if(k == 1) return n;\\n        if(memo[n][k] != null) return memo[n][k];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 1; i <= n; i++){\\n            res = Math.min(res, 1 + Math.max(helper(i - 1, k - 1), helper(n - i, k)));\\n        }\\n        return memo[n][k] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp(i, k) = MAX(dp(i - 1, k - 1),  if egg breaks\\n                dp(n - i, k))     if egg does not break\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int twoEggDrop(int n) {\\n        int k = 2;\\n        memo = new Integer[n + 1][k + 1];\\n        return helper(n, k);\\n    }\\n\\n    private int helper(int n, int k){\\n        if(n == 0) return 0;\\n        if(k == 1) return n;\\n        if(memo[n][k] != null) return memo[n][k];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 1; i <= n; i++){\\n            res = Math.min(res, 1 + Math.max(helper(i - 1, k - 1), helper(n - i, k)));\\n        }\\n        return memo[n][k] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940893,
                "title": "java-four-line-100-0ms-solution-with-explanation",
                "content": "Scan backwards. \\n\\nFirst, I noticed this pattern!\\nAdding:  13  12  11  10   9    8    7     6    5     4     3    2    1\\nTo get:  9, 22, 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, 100\\n\\nAssuming every solution might converge to n such as this pattern does, if we start at the end (n = 100), we can exhaust the arithmetic sequence by counting up starting at 1. \\n\\nOnce we exhaust the sequence, the final value is our answer.\\nHope this makes sense.\\n\\n```\\npublic int twoEggDrop(int n) {\\n\\tint count=1;\\n\\tfor(int i=n-1; i>0; i-=count)\\n\\t\\tcount++;\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int twoEggDrop(int n) {\\n\\tint count=1;\\n\\tfor(int i=n-1; i>0; i-=count)\\n\\t\\tcount++;\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903638,
                "title": "c-binary-search-memoization",
                "content": "# **INTUITION :- \\n###  First of all lets see the edge cases , if egg==1 && we have to check multiple floors (f), so we need f no. of trials in worst case . As we have to take \\n### maximum no of trials , so we will look into worst case . \\n\\n### if floor value i.e f==0 || f==1 then no of trials will be (0 and 1 respectively ) .\\n\\n#### Now starting from lo=1 to h= f , we find mid  and if at mid it breaks \\n###  calls func( mid-1 ) as it surely breaks above mid.\\n###  if it not breaks calls to remaining floors ( f - mid) above mid \\n\\n### Now we call both as we dont know which takes maximum no of trials \\n### and then find out which is taking max trials i.e temp = 1+ max(below_mid , above_mid) \\n### Makes next call such that through that it takes max no of trials\\n\\n#### if(below_mid > above_mid) we will call below mid , i.e h=mid \\n#### else lo = mid+1\\n\\n## If still u find it difficult to understand  , I will suggest u to solve 887 no. problem first , reads multiple solutions in thread bcoz its a typical DP interview Question.\\n\\n### If u find helpful , plz upvote bcoz its motivating to contribute more & more .\\n\\n```\\n int dp[1003][4];\\n    // Binary search instead of linear search \\n    \\n    int func(int f , int e)\\n    {\\n          if(f==0 || f==1)\\n        {\\n            return f;\\n        }\\n        \\n        if(e==1)\\n        {\\n            return f;\\n        }\\n        \\n         if(dp[f][e]!=-1)\\n         {\\n             return dp[f][e];\\n         }\\n        int ans=INT_MAX;\\n        \\n        int lo=1 , h=f;\\n        \\n        while(lo<h)\\n        {\\n            int mid= (lo + (h-lo)/2);\\n            // if breaks at mid\\n            int val1 = func(mid-1 , e-1 );\\n            int val2 = func(f-mid , e);\\n            \\n            int temp= 1 + max(val1 , val2);\\n            \\n            if(val1>val2)\\n            {\\n                h=mid;\\n            }\\n            else\\n            {\\n                lo=mid+1;\\n            }\\n            \\n            ans = min( ans , temp);\\n            \\n            \\n        }\\n        \\n        return dp[f][e]=ans;\\n        \\n        \\n        \\n    }\\n    int twoEggDrop(int n) {\\n        int e=2;\\n        int f=n;\\n        \\n        memset(dp , -1 , sizeof(dp));\\n        return func(f , e);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n int dp[1003][4];\\n    // Binary search instead of linear search \\n    \\n    int func(int f , int e)\\n    {\\n          if(f==0 || f==1)\\n        {\\n            return f;\\n        }\\n        \\n        if(e==1)\\n        {\\n            return f;\\n        }\\n        \\n         if(dp[f][e]!=-1)\\n         {\\n             return dp[f][e];\\n         }\\n        int ans=INT_MAX;\\n        \\n        int lo=1 , h=f;\\n        \\n        while(lo<h)\\n        {\\n            int mid= (lo + (h-lo)/2);\\n            // if breaks at mid\\n            int val1 = func(mid-1 , e-1 );\\n            int val2 = func(f-mid , e);\\n            \\n            int temp= 1 + max(val1 , val2);\\n            \\n            if(val1>val2)\\n            {\\n                h=mid;\\n            }\\n            else\\n            {\\n                lo=mid+1;\\n            }\\n            \\n            ans = min( ans , temp);\\n            \\n            \\n        }\\n        \\n        return dp[f][e]=ans;\\n        \\n        \\n        \\n    }\\n    int twoEggDrop(int n) {\\n        int e=2;\\n        int f=n;\\n        \\n        memset(dp , -1 , sizeof(dp));\\n        return func(f , e);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799251,
                "title": "binary-search-python-o-logn-time-and-o-1-space",
                "content": "I. Intuition:\\nThere are 2 conditions I always look out for to see if a binary search solution is applicable here:\\n\\t(a) there are a range of choices and a target.\\n\\t(b) there is monotonicity of some kind. For example: In the example of n = 100, I notice that if we drop the egg at most 100 times, we will definitely find the `f`. If we decrease the egg dropping by 1, dropping the egg at most 99 times, we would still be able to find the `f`. And so on, until we find the min number of drop that is no longer possible.\\nII. Similar questions:\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/split-array-largest-sum/\\nIII. The code:\\n```class Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n == 1: return 1\\n        \\n        \\n        i_min, i_max = 2, n//2 + 1\\n        while i_min < i_max:\\n            mid = i_min + (i_max - i_min)//2\\n            isPossible = ((mid+1)*(mid))/2\\n \\n            if isPossible >= n:\\n                i_max = mid\\n            elif isPossible < n:\\n                i_min = mid + 1\\n                \\n            \\n            \\n        return i_min\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "I. Intuition:\\nThere are 2 conditions I always look out for to see if a binary search solution is applicable here:\\n\\t(a) there are a range of choices and a target.\\n\\t(b) there is monotonicity of some kind. For example: In the example of n = 100, I notice that if we drop the egg at most 100 times, we will definitely find the `f`. If we decrease the egg dropping by 1, dropping the egg at most 99 times, we would still be able to find the `f`. And so on, until we find the min number of drop that is no longer possible.\\nII. Similar questions:\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/split-array-largest-sum/\\nIII. The code:\\n```class Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n == 1: return 1\\n        \\n        \\n        i_min, i_max = 2, n//2 + 1\\n        while i_min < i_max:\\n            mid = i_min + (i_max - i_min)//2\\n            isPossible = ((mid+1)*(mid))/2\\n \\n            if isPossible >= n:\\n                i_max = mid\\n            elif isPossible < n:\\n                i_min = mid + 1\\n                \\n            \\n            \\n        return i_min\\n",
                "codeTag": "Java"
            },
            {
                "id": 1775461,
                "title": "c-0ms-dp-solution-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<int> dp(n+1,0);\\n\\t\\t// base case\\n        dp[1]=1;\\n        for(int j=2;j<=n;j++){\\n            int l=1,r=j-1;\\n            int res=0;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n\\t\\t\\t\\t// If egg break, search for break point in (0,m-1) floors\\n                int left=m-1;\\n\\t\\t\\t\\t//If egg didn\\'t break, search for the break point in (m,j-m)\\n                int right=dp[j-m];\\n\\t\\t\\t\\t//max (break, didn\\'t break)\\n                res=max(left,right);\\n                if(left==right) break;\\n                if(left<right) l=m+1;\\n                else r=m-1;\\n            }\\n            dp[j]=1+res;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Please upvote : )**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        vector<int> dp(n+1,0);\\n\\t\\t// base case\\n        dp[1]=1;\\n        for(int j=2;j<=n;j++){\\n            int l=1,r=j-1;\\n            int res=0;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n\\t\\t\\t\\t// If egg break, search for break point in (0,m-1) floors\\n                int left=m-1;\\n\\t\\t\\t\\t//If egg didn\\'t break, search for the break point in (m,j-m)\\n                int right=dp[j-m];\\n\\t\\t\\t\\t//max (break, didn\\'t break)\\n                res=max(left,right);\\n                if(left==right) break;\\n                if(left<right) l=m+1;\\n                else r=m-1;\\n            }\\n            dp[j]=1+res;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772479,
                "title": "c-simple-solution-0-ms-faster-than-100-00-memory-usage-less-than-64-68",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i=n,r=0;\\n        while(i>0){\\n            r++;\\n            i-=r;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i=n,r=0;\\n        while(i>0){\\n            r++;\\n            i-=r;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722031,
                "title": "c-dynamic-programming-with-binary-search",
                "content": "**Time Complexity : O(N^2)\\nSpace Complexity : O(N^2)**\\n```\\nint dp[1001][1001];\\nclass Solution {\\npublic:\\n    int solve(int e, int f){\\n        if(f == 0 || f == 1){\\n            return f;\\n        }\\n        if(e == 1){\\n            return f;\\n        }\\n        if(dp[e][f] != -1) return dp[e][f];\\n        int mn = INT_MAX;\\n        int left = 1, right = f;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            int left_result = solve(e-1,mid-1);\\n            int right_result = solve(e,f-mid);\\n            mn = min(mn,1+max(left_result, right_result));\\n            if(left_result<right_result)\\n                left = mid+1;\\n            else\\n                right = mid-1;\\n        }\\n        return dp[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nint dp[1001][1001];\\nclass Solution {\\npublic:\\n    int solve(int e, int f){\\n        if(f == 0 || f == 1){\\n            return f;\\n        }\\n        if(e == 1){\\n            return f;\\n        }\\n        if(dp[e][f] != -1) return dp[e][f];\\n        int mn = INT_MAX;\\n        int left = 1, right = f;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            int left_result = solve(e-1,mid-1);\\n            int right_result = solve(e,f-mid);\\n            mn = min(mn,1+max(left_result, right_result));\\n            if(left_result<right_result)\\n                left = mid+1;\\n            else\\n                right = mid-1;\\n        }\\n        return dp[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633217,
                "title": "swift-1-liner-100-faster-with-o-1",
                "content": "```\\nclass Solution {\\n    func twoEggDrop(_ n: Int) -> Int {\\n        Int(round(sqrt(Double(n*2))))\\n    }\\n}\\n```\\n\\nJust tried to find some logic and correlation. I belived what key is \"sqrt\".\\nAnd found what sqrt(200) = 14.142... Int(14) is correct answer for 100\\nsqrt(400) = 20 is correct answer for 200\\nBut for 500 sqrt(1000) = 31.622 corret answer is 32 not 31!\\nSo we need a \"round\" function used this default rule:\\n\\n```\\nvar x = 5.2\\nx.round() // x == 5.0\\n\\nvar y = 5.5\\ny.round() // y == 6.0\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func twoEggDrop(_ n: Int) -> Int {\\n        Int(round(sqrt(Double(n*2))))\\n    }\\n}\\n```\n```\\nvar x = 5.2\\nx.round() // x == 5.0\\n\\nvar y = 5.5\\ny.round() // y == 6.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621594,
                "title": "c-0ms-4-line-solution",
                "content": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {             \\n        int i;\\n        for(i=1; i<n; i++){\\n            //int k=(i*(i+1))/2;\\n            if((i*(i+1))/2>=n) break;\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {             \\n        int i;\\n        for(i=1; i<n; i++){\\n            //int k=(i*(i+1))/2;\\n            if((i*(i+1))/2>=n) break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1533740,
                "title": "simple-one-liner-python-math-solution-solving-quadratic-equation",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # [0, a_1, a_2, a_3, a_4...., n]\\n        # max(a_1-1, a_2-a_1-1,a_3-a_2-1,.....n-a_n-1)\\n        # (1+k)k/2 = n --> k^2+k-2n = 0\\n        return math.ceil((-1+math.sqrt(1+8*n))/2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # [0, a_1, a_2, a_3, a_4...., n]\\n        # max(a_1-1, a_2-a_1-1,a_3-a_2-1,.....n-a_n-1)\\n        # (1+k)k/2 = n --> k^2+k-2n = 0\\n        return math.ceil((-1+math.sqrt(1+8*n))/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396584,
                "title": "one-equation-faster-than-100",
                "content": "ans * (ans -1 ) / 2  <= n\\nthen\\nans ^ 2 - ans - 2 * n <= 0 \\nthen \\nans = ( 1 + sqrt (8 * n )  ) / 2    or  ( 1 - sqrt (8 * n )  ) /2\\nbut we only care about the postiove answer \\nthen  ans = ( 1 + sqrt (8 * n )  ) / 2 \\n\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return (1 + sqrt(8 * n)) / 2 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return (1 + sqrt(8 * n)) / 2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389144,
                "title": "simple-python-solution-using-dp-easy-to-understand",
                "content": "**I have two solutions to discuss**\\n\\n*At first we look at itterative solution*\\n\\nif there is only one floor, then its obvious we make one move. if it\\'s two or three floors then we make two moves. or else if it is four or five or six then we will have 3 moves and so on. we should observe the pattern present here. the pattern present here is,\\n\\n**1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6**\\n\\nand thus we observe that 1 is repeated once, 2 is repeated twice, 3 is repeated thrice and so on.\\n\\nThus our code has\\n**Time complexity  : O(n)\\nSpace complexity   : O(n)\\n**\\n\\n```\\ndef twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [1]\\n        i = 2\\n        elem = 2\\n        while i < n+1:\\n            for j in range(elem):\\n                dp.append(elem)\\n            i += elem\\n            #print(\\'i value\\',i)\\n            elem += 1\\n        #print(dp)\\n        return dp.pop()\\n```\\n\\n\\n**the second is to make use of formula**\\n\\nwe just assume that we drop a egg from kth floor, if it doesn\\'t break, then we drop it from k-1 th floor and so on till first floor.\\n\\nthus moves is k + (k -1) + (k - 2) + .... + 1\\nwhich is (k * (k + 1)) / 2 = no of floors\\nthus we solve the equation of k^2 + k - (2 * no of floors) = 0\\nthe ceil value of positive root of the equation gives the answer.\\n\\n\\n**Time complexity  : O(1)\\nSpace complexity  : O(n)**\\n\\n```\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        new_n = 2 * n\\n        coeff = [1,1,-new_n]\\n        res = numpy.roots(coeff)\\n        #print(res)\\n        ans = 0\\n        for elem in res:\\n            if elem > 0:\\n                ans = math.ceil(elem)\\n        return int(ans)\\n```\\n\\n\\n\\n**If you have any queries, then comment below. Upvote to show your support.**",
                "solutionTags": [],
                "code": "```\\ndef twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [1]\\n        i = 2\\n        elem = 2\\n        while i < n+1:\\n            for j in range(elem):\\n                dp.append(elem)\\n            i += elem\\n            #print(\\'i value\\',i)\\n            elem += 1\\n        #print(dp)\\n        return dp.pop()\\n```\n```\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        new_n = 2 * n\\n        coeff = [1,1,-new_n]\\n        res = numpy.roots(coeff)\\n        #print(res)\\n        ans = 0\\n        for elem in res:\\n            if elem > 0:\\n                ans = math.ceil(elem)\\n        return int(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1387690,
                "title": "c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[3][n+1];\\n        for(int i = 0; i <= n; i++) dp[0][i] = INT_MAX;\\n        for(int i = 0; i <= n; i++) dp[1][i] = i;\\n        for(int i = 0; i <= 2; i++) dp[i][0] = 0;\\n        for(int i = 0; i <= 2; i++) dp[i][1] = 1;\\n    \\n            for(int j = 2; j <= n; j++){\\n                int curr_ans = INT_MAX;\\n                int l = 0, r = j-1;\\n                while(l < j && r >= 0){\\n                    curr_ans = min(curr_ans, max(dp[1][l], dp[2][r]));\\n                    l++; r--;\\n                }\\n              dp[2][j] = curr_ans+1;\\n            }\\n        return dp[2][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[3][n+1];\\n        for(int i = 0; i <= n; i++) dp[0][i] = INT_MAX;\\n        for(int i = 0; i <= n; i++) dp[1][i] = i;\\n        for(int i = 0; i <= 2; i++) dp[i][0] = 0;\\n        for(int i = 0; i <= 2; i++) dp[i][1] = 1;\\n    \\n            for(int j = 2; j <= n; j++){\\n                int curr_ans = INT_MAX;\\n                int l = 0, r = j-1;\\n                while(l < j && r >= 0){\\n                    curr_ans = min(curr_ans, max(dp[1][l], dp[2][r]));\\n                    l++; r--;\\n                }\\n              dp[2][j] = curr_ans+1;\\n            }\\n        return dp[2][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380058,
                "title": "c-bottom-up-approach",
                "content": "```\\n/*\\nBase case 1: drop(E,0) -- 0\\nBase case 2: drop(E,1) -- 1\\nBase case 1: drop(1,N) -- N\\n\\nDroping from a floor f has two outcomes\\n    1: Egg may break ---> have to move one floor down with one less egg. (There is no point in  trying                      from higher floors. So the num of remaining floors from where trying make sense is                      f-1.)\\n    2: Egg may not break ---> have to move one floor up with one less egg (Num of floors left would be \\n            N-f as there is no point in  trying from lower floors. So the num of remaining floors from               where trying make sense is N-f.)\\n            \\n    Maximum of 1 and 2 is outcome for trying out drop from all floor OTHER THEN f.\\n    \\nThe final out come of drop(E,N) is 1 + min(trying drop of E eggs from all floors 0 to N, except f). That \\'1\\' is the count for the current trial from current floor.\\n*/\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return bottomUp(n);\\n    }\\n    int bottomUp(int n){\\n        int e = 2;\\n        vector<vector<int>>DP(e+1,vector<int>(n+1,-1));\\n        for(int i = 0; i<n+1; ++i){\\n            DP[0][i] = 0;\\n        }\\n        for(int i = 0; i<e+1; ++i){\\n            DP[i][0] = 0;\\n        }\\n        for(int i = 0; i<n+1; ++i){\\n            DP[1][i] = i;\\n        }\\n        \\n        for(int floor = 1; floor<= n ; ++floor){\\n            int xx = floor;\\n            // One egg is base case. So start with 2. (Starting with one and trying to create\\n            // base case here ,, messes it up)\\n            for(int egg = 2; egg<= e ; ++egg){\\n                for(int drop = 1; drop<=floor ; ++drop){\\n                    xx = min(xx, max(DP[egg-1][drop-1], DP[egg][floor-drop]));\\n                }\\n                DP[egg][floor] = 1 + xx;\\n            }\\n        }        \\n        return DP[e][n];\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBase case 1: drop(E,0) -- 0\\nBase case 2: drop(E,1) -- 1\\nBase case 1: drop(1,N) -- N\\n\\nDroping from a floor f has two outcomes\\n    1: Egg may break ---> have to move one floor down with one less egg. (There is no point in  trying                      from higher floors. So the num of remaining floors from where trying make sense is                      f-1.)\\n    2: Egg may not break ---> have to move one floor up with one less egg (Num of floors left would be \\n            N-f as there is no point in  trying from lower floors. So the num of remaining floors from               where trying make sense is N-f.)\\n            \\n    Maximum of 1 and 2 is outcome for trying out drop from all floor OTHER THEN f.\\n    \\nThe final out come of drop(E,N) is 1 + min(trying drop of E eggs from all floors 0 to N, except f). That \\'1\\' is the count for the current trial from current floor.\\n*/\\n\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return bottomUp(n);\\n    }\\n    int bottomUp(int n){\\n        int e = 2;\\n        vector<vector<int>>DP(e+1,vector<int>(n+1,-1));\\n        for(int i = 0; i<n+1; ++i){\\n            DP[0][i] = 0;\\n        }\\n        for(int i = 0; i<e+1; ++i){\\n            DP[i][0] = 0;\\n        }\\n        for(int i = 0; i<n+1; ++i){\\n            DP[1][i] = i;\\n        }\\n        \\n        for(int floor = 1; floor<= n ; ++floor){\\n            int xx = floor;\\n            // One egg is base case. So start with 2. (Starting with one and trying to create\\n            // base case here ,, messes it up)\\n            for(int egg = 2; egg<= e ; ++egg){\\n                for(int drop = 1; drop<=floor ; ++drop){\\n                    xx = min(xx, max(DP[egg-1][drop-1], DP[egg][floor-drop]));\\n                }\\n                DP[egg][floor] = 1 + xx;\\n            }\\n        }        \\n        return DP[e][n];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337676,
                "title": "faster-than-100-without-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int e=1+4*1*2*n;\\n        float f=sqrt(e);\\n        // cout<<f<<endl;\\n        f=ceil(f);\\n        f-=1;\\n        f=f/2;\\n        f=ceil(f);\\n        return f;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int e=1+4*1*2*n;\\n        float f=sqrt(e);\\n        // cout<<f<<endl;\\n        f=ceil(f);\\n        f-=1;\\n        f=f/2;\\n        f=ceil(f);\\n        return f;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1311619,
                "title": "c-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = 1; \\n        vector<int >dp(n+1,0); \\n        int t = 1; \\n        int temp = t; \\n\\t\\t// there is a simple pattern in this question \\n\\t\\t// for n  = 1 ans = 1  | n = 2,3 ans = 2 | n=4,5,6 ans = 3 |n=7,8,9,10 ans = 4 ans so on... \\n        while(i<=n){ \\n            \\n         while(t>0 && i<=n){ \\n            dp[i] = temp; \\n              t--; \\n              i++; \\n          }\\n            if(t==0) {temp++; t = temp; } \\n             \\n        }\\n         return dp[n]; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = 1; \\n        vector<int >dp(n+1,0); \\n        int t = 1; \\n        int temp = t; \\n\\t\\t// there is a simple pattern in this question \\n\\t\\t// for n  = 1 ans = 1  | n = 2,3 ans = 2 | n=4,5,6 ans = 3 |n=7,8,9,10 ans = 4 ans so on... \\n        while(i<=n){ \\n            \\n         while(t>0 && i<=n){ \\n            dp[i] = temp; \\n              t--; \\n              i++; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1279535,
                "title": "1884-java-0ms-35-5-mb",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int result = 1;\\n        while(n > 0){\\n            n-=result;\\n            result++;\\n        }\\n        return result-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int result = 1;\\n        while(n > 0){\\n            n-=result;\\n            result++;\\n        }\\n        return result-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263487,
                "title": "simple-solution-using-memorization-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[3][1001];\\n\\t\\tint check(int e,int f)\\n\\t\\t{\\n\\t\\t\\tif(f==0||f==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn f;\\n\\t\\t\\t}\\n\\t\\t\\tif(e==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn f;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[e][f]!=-1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn dp[e][f];\\n\\t\\t\\t}\\n\\t\\t\\tint mn=INT_MAX;\\n\\t\\t\\tfor(int k=1;k<=f;k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp=1+max(check(e-1,k-1),check(e,f-k));\\n\\t\\t\\t\\tmn=min(mn,temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[e][f]=mn;\\n\\n\\t\\t}\\n\\t\\tint twoEggDrop(int n) {\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\treturn check(2,n);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[3][1001];\\n\\t\\tint check(int e,int f)\\n\\t\\t{\\n\\t\\t\\tif(f==0||f==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn f;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1260236,
                "title": "python-dp-solution-with-explanation-and-complexity-analysis-discussion",
                "content": "Reasoning is derived from the examples given in the question.\\n\\nCase 1:  If we drop the egg from floor X and it brakes, then we need to check from floor 0 till floor X with the second X. This will result in X total moves.\\nCase 2: If we drop the egg from floor X and it Does not break, then we need to recursively check the number of moves possible for n - X floors. Since we dropped the egg on this floor, need to add 1 to the outcome of this case.\\n\\nWe will consider the max out of case 1 and 2 because we need to consider the worst case. \\n\\nThis is for one floor X. When we need to find the answer for n floors, we will start from floor 1 and go up to n and find the answer for both the cases listed above, for each value between 1 and n. There will be repeated subproblems in this case that we will memoize.\\n\\n\\n```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return self.min_moves_with_memo(n, {})\\n    \\n    def min_moves_with_memo(self, n, memo):\\n        if n in memo:\\n            return memo[n]\\n        if n == 0: return 0\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        min_moves = n\\n        for i in range(1, n):            \\n            min_moves = min(min_moves, max(i, 1 + self.min_moves_with_memo(n - i, memo)))\\n        memo[n] = min_moves\\n        return min_moves        \\n```\\n\\nComplexity Analysis without Memoization:\\n\\nFor n floors, starting at nth floor, we will check case 1 and 2 for n - 1 floors. So the branching factor for every subproblem of size n will be n - 1.\\nSo if we think of our call patten as a tree, there will be n - 1 children for every root and the depth of the tree will be n. so runtime complexity will be O(n ^ n)\\n\\nSpace complexity will be O(n) = depth of the tree.\\n\\n\\nComplexity Analysis with Memoization:\\n\\nSince we will avoid solving duplicate subproblems and memoize the result, the runtime complexity analysis will be O(n ^ 2) \\nSpace complexity will still be O(n) as depth of the tree is still n and we will be storing at the most n keys in our memo object.\\n\\n****\\n\\nWould love to hear your thoughts on complexity analysis and the solution overall. I am still learning how to solve DP problems and come up with the runtime complexity so if you can spot any mistakes in the above, I would love to learn from you.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoEggDrop(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return self.min_moves_with_memo(n, {})\\n    \\n    def min_moves_with_memo(self, n, memo):\\n        if n in memo:\\n            return memo[n]\\n        if n == 0: return 0\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        min_moves = n\\n        for i in range(1, n):            \\n            min_moves = min(min_moves, max(i, 1 + self.min_moves_with_memo(n - i, memo)))\\n        memo[n] = min_moves\\n        return min_moves        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253415,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func twoEggDrop(_ n: Int) -> Int {\\n        var step = 0, drops = 0\\n        while drops < n {\\n            step += 1\\n            drops += step\\n        }\\n        return step\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func twoEggDrop(_ n: Int) -> Int {\\n        var step = 0, drops = 0\\n        while drops < n {\\n            step += 1\\n            drops += step\\n        }\\n        return step\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251673,
                "title": "java-easy-pattern-analysis-with-comments",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) { //1 to n floor\\n            \\t/* n-> answer\\n    \\t * 1->1\\n\\t    \\t * 2->2\\n\\t\\t\\t\\t3->2\\n\\t\\t\\t\\t4->3\\n\\t\\t\\t\\t5->3\\n\\t\\t\\t\\t6->3\\n\\t\\t\\t\\t7->4\\n\\t\\t\\t\\t8->4\\n\\t\\t\\t\\t9->4\\n\\t\\t\\t\\t10->4\\n\\t\\t\\t\\t11->5\\n\\t\\t\\t\\t12->5\\n\\t\\t\\t\\t13->5\\n\\t\\t\\t\\t14->5\\n\\t\\t\\t\\t15->5\\n\\t\\t\\t\\t16->6\\n\\t\\t\\t\\t17->6\\n    \\t * \\n    \\t */\\n        //pattern identified \\n        int c=1;\\n        int dp[]=new int[n+1]; //dp[i] min number of attempts to find the pivot floor\\n        dp[0]=0;\\n        boolean flag=true;\\n        for(int i=1;i<=n;i++) {\\n        \\tfor(int j=1;j<=i;j++) {\\n        \\t\\tif(c>n) {\\n        \\t\\t\\tflag=false;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tdp[c]=i;\\n        \\t\\tc++;\\n        \\t}\\n        \\tif(!flag)\\n        \\t\\tbreak;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) { //1 to n floor\\n            \\t/* n-> answer\\n    \\t * 1->1\\n\\t    \\t * 2->2\\n\\t\\t\\t\\t3->2\\n\\t\\t\\t\\t4->3\\n\\t\\t\\t\\t5->3\\n\\t\\t\\t\\t6->3\\n\\t\\t\\t\\t7->4\\n\\t\\t\\t\\t8->4\\n\\t\\t\\t\\t9->4\\n\\t\\t\\t\\t10->4\\n\\t\\t\\t\\t11->5\\n\\t\\t\\t\\t12->5\\n\\t\\t\\t\\t13->5\\n\\t\\t\\t\\t14->5\\n\\t\\t\\t\\t15->5\\n\\t\\t\\t\\t16->6\\n\\t\\t\\t\\t17->6\\n    \\t * \\n    \\t */\\n        //pattern identified \\n        int c=1;\\n        int dp[]=new int[n+1]; //dp[i] min number of attempts to find the pivot floor\\n        dp[0]=0;\\n        boolean flag=true;\\n        for(int i=1;i<=n;i++) {\\n        \\tfor(int j=1;j<=i;j++) {\\n        \\t\\tif(c>n) {\\n        \\t\\t\\tflag=false;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tdp[c]=i;\\n        \\t\\tc++;\\n        \\t}\\n        \\tif(!flag)\\n        \\t\\tbreak;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246594,
                "title": "verbose-intuition",
                "content": "Let us assume you have only ONE egg and N floors to test. You could drop the egg from each floor starting from bottom to top. When the egg breaks on dropping, you know which floor you are on. So that way our answer is always ONE egg but ..... in the worst case, you would test the egg on each level from 1 to N.\\n\\nIn the above solution to test Floor-X you would move 2X levels,\\n1. you would move-up X floors and drop the egg\\n2. move-down X floors to pick the egg if unbroken, so you can test next floor\\n\\nIn total, you would move 2(1+2+3+....+N) that is **O(N^2) moves**\\n\\nTo understand how we reduce the moves, let us look at an example with **100 floors**. To build the best solution, we are working backwards so bear with me..\\n\\n*Floor 100 - you must ideally have only ONE egg. You drop the egg, it breaks and voila.. don\\'t care if the egg doesn\\'t break. Either ways you are done testing all floors.*\\n\\n*Floor 99 - you must ideally have TWO eggs because you would test 99th floor with the first egg. If the egg doesn\\'t break, use the remaining ONE egg to test Floor-100. If the first egg breaks, use the remaining ONE egg to test Floor-98.*\\n\\n*Floor 97 - you must ideally have THREE eggs because you would test 97th floor with the first egg. If the egg doesn\\'t break, use the remaining TWO eggs at Floor-99. If the first egg breaks, use the remaining TWO eggs to test Floor-96 and Floor-95.*\\n\\n*Floor 94 - you must ideally have FOUR eggs because you would test 94th floor with the first egg. If the egg doesn\\'t break, use the remaining THREE eggs at Floor-97. If the first egg breaks, use the remaining THREE eggs to test Floor-93, Floor-92 and Floor-91.*\\n\\n*Floor 90 - you must ideally have FIVE eggs because you would test 90th floor with the first egg. If the egg doesn\\'t break, use the remaining FOUR eggs at Floor-94. If the first egg breaks, use the remaining FOUR eggs to test Floor-89, Floor-88 and Floor-87.*\\n\\nWait a second, while working backwards you can observe that \\n\\n*At Floor-100 you had ONE egg. Before that you were at Floor-99 which is 100-ONE\\nAt Floor-99 you had TWO eggs. Before that you were at Floor-97 which is 99-TWO\\nAt Floor-97 you had THREE eggs. Before that you were at Floor-94 which is 97-THREE\\nAt Floor-94 you had FOUR eggs. Before that you were at Floor-90 which is 94-FOUR\\nAt Floor-90 you had FIVE eggs. So where should you have been before? Floor-85 as it is 90-FIVE*\\n\\nHence the backward sequence of (Floor, Eggs) is (100, 1) > (99, 2) > (97, 3) > (94, 4) > (90, 5) > (85, 6) > (79, 7) > (72, 8) > (64, 9) > (55, 10) > (45, 11) > (34, 12) > (22, 13) > (9, 14) > and stop because at Floor-9 you have **14 eggs** and only 8 floors below to test.\\n\\nYou can test 9th floor with the first egg. If the egg doesn\\'t break, use the remaining 13 eggs at Floor-22. If the first egg breaks, use the remaining 13 eggs to test Floor-8 to Floor-1.\\n\\nSo to generalize for N floors, you start with Floor-N with ONE egg and work your way backwards and stop at the floor where you have enough eggs to test all the floors below. \\n\\nYou would move up N floors only once. In case an egg breaks, you would move #EGGS floors lower. In total, you would move only **O(N) moves**\\n\\n**Java - O(n) time & O(1) space**\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs = 1;\\n        while(eggs < n)\\n        {\\n            n -= eggs;\\n            eggs++;\\n        }\\n\\n        return eggs;\\n    }\\n}\\n```\\n\\n**Java - O(1) time & O(1) space**\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs = (int) Math.sqrt( 2 * n );\\n        return eggs * (eggs + 1) >= 2 * n ? eggs : eggs+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs = 1;\\n        while(eggs < n)\\n        {\\n            n -= eggs;\\n            eggs++;\\n        }\\n\\n        return eggs;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs = (int) Math.sqrt( 2 * n );\\n        return eggs * (eggs + 1) >= 2 * n ? eggs : eggs+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091756,
                "title": "recursion-memoization-tabulation",
                "content": "____________________________________________\\n\\n**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n____________________________________________\\n# Recursion *TLE*\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        return f(n,2);\\n    }\\n    public int f(int n, int e){\\n        if(n==0 || n==1){\\n            return n;\\n        }\\n        if(e==1){\\n            return n;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1; i<=n ; i++){\\n            int willBreak=f(i-1,e-1);\\n            int notBreak=f(n-i,e);\\n            ans=Math.min(ans,Math.max(willBreak,notBreak));\\n        }\\n        return ans+1;\\n    }\\n}\\n```\\n____________________________________________\\n# Memoization\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int twoEggDrop(int n) {\\n        memo=new Integer[n+1][3];\\n        return f(n,2);\\n    }\\n    public int f(int n, int e){\\n        if(n==0 || n==1){\\n            return n;\\n        }\\n        if(e==1){\\n            return n;\\n        }\\n        if(memo[n][e]!=null){\\n            return memo[n][e];\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1; i<=n ; i++){\\n            int willBreak=f(i-1,e-1);\\n            int notBreak=f(n-i,e);\\n            ans=Math.min(ans,Math.max(willBreak,notBreak));\\n        }\\n        return memo[n][e]=ans+1;\\n    }\\n}\\n```\\n____________________________________________\\n\\n# Tabulation\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[][] dp=new int[3][n+1];\\n        for(int i=1; i<=2; i++){\\n            for(int j=1; j<=n; j++){\\n                if(i==1){ //only one egg\\n                    dp[i][j]=j;\\n                }else if(j==1){  // only one floor\\n                    dp[i][j]=1;\\n                }else{\\n                    int min=Integer.MAX_VALUE;\\n                    for(int myCol=j-1,prevCol=0; myCol>=0; myCol--,prevCol++){\\n                        int max=Math.max(dp[i][myCol],dp[i-1][prevCol]);\\n                        min=Math.min(min,max);\\n                    }\\n                    dp[i][j]=min+1;\\n                }\\n            }\\n        }\\n        return dp[2][n];\\n    }\\n}\\n```\\n____________________________________________\\n\\n**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n____________________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        return f(n,2);\\n    }\\n    public int f(int n, int e){\\n        if(n==0 || n==1){\\n            return n;\\n        }\\n        if(e==1){\\n            return n;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1; i<=n ; i++){\\n            int willBreak=f(i-1,e-1);\\n            int notBreak=f(n-i,e);\\n            ans=Math.min(ans,Math.max(willBreak,notBreak));\\n        }\\n        return ans+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int twoEggDrop(int n) {\\n        memo=new Integer[n+1][3];\\n        return f(n,2);\\n    }\\n    public int f(int n, int e){\\n        if(n==0 || n==1){\\n            return n;\\n        }\\n        if(e==1){\\n            return n;\\n        }\\n        if(memo[n][e]!=null){\\n            return memo[n][e];\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1; i<=n ; i++){\\n            int willBreak=f(i-1,e-1);\\n            int notBreak=f(n-i,e);\\n            ans=Math.min(ans,Math.max(willBreak,notBreak));\\n        }\\n        return memo[n][e]=ans+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[][] dp=new int[3][n+1];\\n        for(int i=1; i<=2; i++){\\n            for(int j=1; j<=n; j++){\\n                if(i==1){ //only one egg\\n                    dp[i][j]=j;\\n                }else if(j==1){  // only one floor\\n                    dp[i][j]=1;\\n                }else{\\n                    int min=Integer.MAX_VALUE;\\n                    for(int myCol=j-1,prevCol=0; myCol>=0; myCol--,prevCol++){\\n                        int max=Math.max(dp[i][myCol],dp[i-1][prevCol]);\\n                        min=Math.min(min,max);\\n                    }\\n                    dp[i][j]=min+1;\\n                }\\n            }\\n        }\\n        return dp[2][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068403,
                "title": "simple-o-n-time-compexity-for-begineers-and-advance-observer-coders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think of n(n+1)/2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust think of summation of every number from index 0 and when the summation become greater than n just return the index.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int a=0,sum=0;\\n        for(int i=0;i<=n;i++){\\n            sum+=i;\\n            if(sum>=n){\\n                a=i;\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int a=0,sum=0;\\n        for(int i=0;i<=n;i++){\\n            sum+=i;\\n            if(sum>=n){\\n                a=i;\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874492,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs=2;\\n        int[][] dp=new int[n+1][3];\\n        for(int[] row : dp)\\n            Arrays.fill(row,-1);\\n        \\n        return solve(n,2,dp);\\n    }\\n      public int solve(int f,int e,int[][] dp)\\n    {\\n    if(f<=2 || e==1) return f;\\n        if(dp[f][e]!=-1) return dp[f][e];\\n        \\n        int min=f;\\n        \\n        for(int i=1;i<=f;++i)\\n        {\\n            int Break=solve(i-1,e-1,dp);\\n            int notBreak=solve(f-i,e,dp);\\n          //  System.out.print(\"1.\"+Break+\"2.\"+notBreak+\"-->\");\\n            int worstCase=1+Math.max(Break,notBreak);\\n\\n            min=Math.min(min,worstCase);\\n         //   System.out.print (worstCase+\"--\"+min+\"==\");\\n        }\\n       // System.out.println(f+\"f\"+e+\"e\"+min+\"min\");\\n        return dp[f][e]=min;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int eggs=2;\\n        int[][] dp=new int[n+1][3];\\n        for(int[] row : dp)\\n            Arrays.fill(row,-1);\\n        \\n        return solve(n,2,dp);\\n    }\\n      public int solve(int f,int e,int[][] dp)\\n    {\\n    if(f<=2 || e==1) return f;\\n        if(dp[f][e]!=-1) return dp[f][e];\\n        \\n        int min=f;\\n        \\n        for(int i=1;i<=f;++i)\\n        {\\n            int Break=solve(i-1,e-1,dp);\\n            int notBreak=solve(f-i,e,dp);\\n          //  System.out.print(\"1.\"+Break+\"2.\"+notBreak+\"-->\");\\n            int worstCase=1+Math.max(Break,notBreak);\\n\\n            min=Math.min(min,worstCase);\\n         //   System.out.print (worstCase+\"--\"+min+\"==\");\\n        }\\n       // System.out.println(f+\"f\"+e+\"e\"+min+\"min\");\\n        return dp[f][e]=min;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770176,
                "title": "c-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int TwoEggDrop(int n) {\\n        return (int)Math.Ceiling(Math.Sqrt(2 * n + 0.25) - 0.5);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TwoEggDrop(int n) {\\n        return (int)Math.Ceiling(Math.Sqrt(2 * n + 0.25) - 0.5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383673,
                "title": "easy-c-solution-runtime-0ms-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/618df341-7dc8-4da2-bd73-cf5f26afc785_1680711701.8926115.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i=1,steps=0;\\n        while(n>0){\\n            n-=i;\\n            i++;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i=1,steps=0;\\n        while(n>0){\\n            n-=i;\\n            i++;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359802,
                "title": "dp-bottom-up-approach-math-solution-using-while-loop-and-o-1-one-liner-solution",
                "content": "# Using Dp bottom up approach\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[n+1][2];\\n        dp[0][0]=0;dp[0][1]=0;\\n        dp[1][0]=1;dp[1][1]=1;\\n        for(int i=2;i<=n;i++){dp[i][0]=i;}\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i][1]=INT_MAX;\\n            for(int x=1;x<=i;x++)\\n            {\\n                dp[i][1]=min({dp[i][1],1+max(dp[x-1][0],dp[i-x][1])});\\n            }\\n        }\\n        return dp[n][1];\\n    }\\n};\\n```\\n# Using while loop\\n# Complexity\\n- Time Complexity-O(sqrt(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int curr=1;\\n        int temp=0;\\n        while(n>0)\\n        {\\n            n-=curr;\\n            temp++;\\n            curr++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```\\n# Better optimized math code using formula\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1 + sqrt(1 + 8*n))/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int dp[n+1][2];\\n        dp[0][0]=0;dp[0][1]=0;\\n        dp[1][0]=1;dp[1][1]=1;\\n        for(int i=2;i<=n;i++){dp[i][0]=i;}\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i][1]=INT_MAX;\\n            for(int x=1;x<=i;x++)\\n            {\\n                dp[i][1]=min({dp[i][1],1+max(dp[x-1][0],dp[i-x][1])});\\n            }\\n        }\\n        return dp[n][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int curr=1;\\n        int temp=0;\\n        while(n>0)\\n        {\\n            n-=curr;\\n            temp++;\\n            curr++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1 + sqrt(1 + 8*n))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172868,
                "title": "c-aditya-verma-s-approach-easy-to-understand-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int t[3][1001];          //matrix for memoization\\n\\n    int solve(int e,int f)\\n    {\\n        if(f == 0 || f==1)  //base conditon\\n        {\\n            return f;\\n        }\\n        if(e==1)\\n        {\\n            return f;\\n        }\\n\\n        if(t[e][f] !=-1)          //if element present in matrix, get from it\\n        {\\n            return t[e][f];\\n        }\\n\\n        int mn = INT_MAX;          //for answer return \\n        int low,high ;\\n\\n        for(int k=1;k<=f;k++)        //floor 1 to Nth floor\\n        {\\n            if(t[e-1][k-1] != -1)           //upto that floor egg will break\\n            {\\n                 low = t[e-1][k-1];\\n            }\\n            else\\n            {\\n                low = solve(e-1,k-1);\\n                t[e-1][k-1] = low;\\n            }\\n\\n            if(t[e][f-k] != -1)        //above the floors from the egg will break\\n            {\\n                 high = t[e][f-k];\\n            }\\n            else\\n            {\\n                high = solve(e,f-k);\\n                t[e][f-k] = high;\\n            }\\n\\n            int temp = 1 + max(low,high);       // max for worst case \\n            \\n            mn = min(mn,temp);      //return the minimun ans;\\n        }\\n        \\n        return t[e][f] = mn;\\n    }\\n    int twoEggDrop(int f) {\\n        memset(t,-1,sizeof(t));\\n\\n        return solve(2,f);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[3][1001];          //matrix for memoization\\n\\n    int solve(int e,int f)\\n    {\\n        if(f == 0 || f==1)  //base conditon\\n        {\\n            return f;\\n        }\\n        if(e==1)\\n        {\\n            return f;\\n        }\\n\\n        if(t[e][f] !=-1)          //if element present in matrix, get from it\\n        {\\n            return t[e][f];\\n        }\\n\\n        int mn = INT_MAX;          //for answer return \\n        int low,high ;\\n\\n        for(int k=1;k<=f;k++)        //floor 1 to Nth floor\\n        {\\n            if(t[e-1][k-1] != -1)           //upto that floor egg will break\\n            {\\n                 low = t[e-1][k-1];\\n            }\\n            else\\n            {\\n                low = solve(e-1,k-1);\\n                t[e-1][k-1] = low;\\n            }\\n\\n            if(t[e][f-k] != -1)        //above the floors from the egg will break\\n            {\\n                 high = t[e][f-k];\\n            }\\n            else\\n            {\\n                high = solve(e,f-k);\\n                t[e][f-k] = high;\\n            }\\n\\n            int temp = 1 + max(low,high);       // max for worst case \\n            \\n            mn = min(mn,temp);      //return the minimun ans;\\n        }\\n        \\n        return t[e][f] = mn;\\n    }\\n    int twoEggDrop(int f) {\\n        memset(t,-1,sizeof(t));\\n\\n        return solve(2,f);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975058,
                "title": "c-dp-intuitive-soltion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            int mini=INT_MAX;\\n            for(int j=1;j<=i;j++){\\n                mini=min(mini,max(j,dp[i-j]+1));\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            int mini=INT_MAX;\\n            for(int j=1;j<=i;j++){\\n                mini=min(mini,max(j,dp[i-j]+1));\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859189,
                "title": "java-runtime-0-ms-faster-than-100-00",
                "content": "UPVOTE IF YOU FIND THIS HELPFUL\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) \\n    {\\n       int s=0,i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n            s++;\\n        }\\n        return s;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) \\n    {\\n       int s=0,i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n            s++;\\n        }\\n        return s;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772344,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int solve(int k, int n, int dp[3][1001])\\n    {\\n        if(k==1 || n==0 || n==1)\\n        return n;\\n        if(dp[k][n] != -1)\\n        return dp[k][n];\\n        int mn = INT_MAX, low, high;\\n        for(int k1=1; k1<=n; k1++)\\n        {\\n            if(dp[k-1][k1-1] != -1)\\n            low = dp[k-1][k1-1];\\n            else\\n            {\\n                low = solve(k-1, k1-1, dp);\\n                dp[k-1][k1-1] = low;\\n            }\\n            if(dp[k][n-k1] != -1)\\n            high = dp[k][n-k1];\\n            else\\n            {\\n                high = solve(k, n-k1, dp);\\n                dp[k][n-k1] = high;\\n            }\\n            int temp = 1 + max(low, high);\\n            mn = min(mn, temp);\\n        }\\n        return dp[k][n] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        int dp[3][1001];\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(int k, int n, int dp[3][1001])\\n    {\\n        if(k==1 || n==0 || n==1)\\n        return n;\\n        if(dp[k][n] != -1)\\n        return dp[k][n];\\n        int mn = INT_MAX, low, high;\\n        for(int k1=1; k1<=n; k1++)\\n        {\\n            if(dp[k-1][k1-1] != -1)\\n            low = dp[k-1][k1-1];\\n            else\\n            {\\n                low = solve(k-1, k1-1, dp);\\n                dp[k-1][k1-1] = low;\\n            }\\n            if(dp[k][n-k1] != -1)\\n            high = dp[k][n-k1];\\n            else\\n            {\\n                high = solve(k, n-k1, dp);\\n                dp[k][n-k1] = high;\\n            }\\n            int temp = 1 + max(low, high);\\n            mn = min(mn, temp);\\n        }\\n        return dp[k][n] = mn;\\n    }\\n    int twoEggDrop(int n) {\\n        int dp[3][1001];\\n        memset(dp, -1, sizeof(dp));\\n        return solve(2, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697675,
                "title": "java-solution-math-0ms-runtime-faster-than-100",
                "content": "```java \\nclass Solution {\\n    public int twoEggDrop(int n) {\\n       int c=0;\\n        while(n>0)\\n            n-=++c;\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int twoEggDrop(int n) {\\n       int c=0;\\n        while(n>0)\\n            n-=++c;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2600314,
                "title": "python-one-line-constant-time-space",
                "content": "```\\n    def twoEggDrop(self, n: int) -> int:\\n        return ((-1+math.sqrt(1+8*n))/2).__ceil__()\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n    def twoEggDrop(self, n: int) -> int:\\n        return ((-1+math.sqrt(1+8*n))/2).__ceil__()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2553142,
                "title": "1884-python",
                "content": "\\tclass Solution:\\n\\t\\tdef twoEggDrop(self, n: int) -> int:\\n\\n\\t\\t\\tdp = [math.inf]* (n+1)\\n\\t\\t\\tdp[0] = 0\\n\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tfor j in range(1,i+1):\\n\\t\\t\\t\\t\\tdp[i] = min(dp[i],max(dp[i-j]+1,j))\\n\\n\\t\\t\\treturn dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef twoEggDrop(self, n: int) -> int:\\n\\n\\t\\t\\tdp = [math.inf]* (n+1)\\n\\t\\t\\tdp[0] = 0\\n\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tfor j in range(1,i+1):\\n\\t\\t\\t\\t\\tdp[i] = min(dp[i],max(dp[i-j]+1,j))\\n\\n\\t\\t\\treturn dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2552677,
                "title": "python-dp-solution-with-explanation",
                "content": "the basic idea is that\\nif we only have ```1``` egg, the finding critical layer ```f``` approach is drop the egg floor by floor.\\nif we have ```2``` eggs, and we is to find the minimum moves of ```n``` floors,\\nand we pick a floor ```k``` from ```[1, n]```,\\nif the first egg is broken after we drop it from ```k```th floor, and we can use ```1``` egg approach to find ```f```\\nif not, ```f``` is in the floor ```[k+1, n]```, and ```[k+1, n]``` has ```n-k``` floors, so ```n``` change to ```n-k```, and we can try this method again to find ```f```\\n```dp[i, 0]``` is minimum move to find ```f``` when we only have ```1``` egg and total floor is ```i```\\n```dp[i, 1]``` is minimum move to find ```f``` when we have ```2``` eggs  and total floor is ```i```\\n\\n\\n```\\ndp[i, 0] = i\\ndp[i, 1] = min(dp[i, 1], max(dp[k-1, 0], dp[i-k, 1]) + 1) for k in [1, i+1]\\n```\\n\\n### iteration\\nTLE, tc is ```O(n^2)```, sc is the same as tc\\n\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = [[0,0] for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = i\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i][1] == 0:\\n                    dp[i][1] = max(dp[j-1][0], dp[i-j][1]) + 1\\n                else:\\n                    dp[i][1] = min(dp[i][1], max(dp[j-1][0], dp[i-j][1]) + 1)\\n        return dp[n][1]\\n```\\nac, tc is ```O(n^2)```, sc is ```O(N)```\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i] == 0:\\n                    dp[i] = max(j-1, dp[i-j]) + 1\\n                else:\\n                    dp[i] = min(dp[i], max(j-1, dp[i-j]) + 1)\\n        return dp[n]   \\n```\\n### dfs\\ntc is ```O(n^2)```, sc is the same as tc\\n```\\nINT_MAX = 2**32 - 1\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == 1: return 1\\n            if j==0: return i\\n            sub = INT_MAX\\n            for k in range(1, i+1):\\n                sub = min(sub, max(dfs(k-1, 0), dfs(i-k, 1))+1)\\n            return sub\\n        return dfs(n, 1)\\n```\\n\\n### intuition\\na simple approach is to find ```f``` with equal-width intervals.\\neg. interval\\'s width is ```10```, ```n=100```\\ndrop the first egg drop from ```10, 20, 30 ,..., 100```, then use the second egg to find exact ```f```\\nbut if ```f=100```, total move is ```20```, first egg is broken at ```100```, and the second is too.\\n\\nif we make the each interval\\'s width is not the same, e.g., first interval\\'s width is ```m```, the second is ```m-1``` and so on, the last is ```1```\\nso total interval length is ```100```, \\n```\\nm+m-1+...+1 = 100\\nm(m+1)/2=100\\nm = 13.67 -> 14\\n```\\nif ```f``` and ```n``` are ```100```, the minimum move is ```14```\\nthis is tc and sc ```O(1)``` approach.\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```1```\n```f```\n```2```\n```n```\n```k```\n```[1, n]```\n```k```\n```1```\n```f```\n```f```\n```[k+1, n]```\n```[k+1, n]```\n```n-k```\n```n```\n```n-k```\n```f```\n```dp[i, 0]```\n```f```\n```1```\n```i```\n```dp[i, 1]```\n```f```\n```2```\n```i```\n```\\ndp[i, 0] = i\\ndp[i, 1] = min(dp[i, 1], max(dp[k-1, 0], dp[i-k, 1]) + 1) for k in [1, i+1]\\n```\n```O(n^2)```\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = [[0,0] for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = i\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i][1] == 0:\\n                    dp[i][1] = max(dp[j-1][0], dp[i-j][1]) + 1\\n                else:\\n                    dp[i][1] = min(dp[i][1], max(dp[j-1][0], dp[i-j][1]) + 1)\\n        return dp[n][1]\\n```\n```O(n^2)```\n```O(N)```\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i] == 0:\\n                    dp[i] = max(j-1, dp[i-j]) + 1\\n                else:\\n                    dp[i] = min(dp[i], max(j-1, dp[i-j]) + 1)\\n        return dp[n]   \\n```\n```O(n^2)```\n```\\nINT_MAX = 2**32 - 1\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == 1: return 1\\n            if j==0: return i\\n            sub = INT_MAX\\n            for k in range(1, i+1):\\n                sub = min(sub, max(dfs(k-1, 0), dfs(i-k, 1))+1)\\n            return sub\\n        return dfs(n, 1)\\n```\n```f```\n```10```\n```n=100```\n```10, 20, 30 ,..., 100```\n```f```\n```f=100```\n```20```\n```100```\n```m```\n```m-1```\n```1```\n```100```\n```\\nm+m-1+...+1 = 100\\nm(m+1)/2=100\\nm = 13.67 -> 14\\n```\n```f```\n```n```\n```100```\n```14```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 2544431,
                "title": "c-one-line-no-dp-linear-solution",
                "content": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1+sqrt(1 + 8 * n))/2.);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1+sqrt(1 + 8 * n))/2.);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2509643,
                "title": "easy-to-understand-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[3][1001];\\n    int solve(int e,int f)\\n    {\\n        if(f==0||f==1)\\n            return f;\\n        if(e==1)\\n            return f;\\n        if(t[e][f]!=-1)\\n            return t[e][f];\\n        int mn=INT_MAX;\\n        for(int k=1;k<=f;k++)\\n        {\\n            int temp=1+max(solve(e-1,k-1),solve(e,f-k));\\n            mn=min(mn,temp);        \\n    }\\n        return t[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) \\n    {\\n         memset(t,-1,sizeof(t));\\n        return solve(2,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[3][1001];\\n    int solve(int e,int f)\\n    {\\n        if(f==0||f==1)\\n            return f;\\n        if(e==1)\\n            return f;\\n        if(t[e][f]!=-1)\\n            return t[e][f];\\n        int mn=INT_MAX;\\n        for(int k=1;k<=f;k++)\\n        {\\n            int temp=1+max(solve(e-1,k-1),solve(e,f-k));\\n            mn=min(mn,temp);        \\n    }\\n        return t[e][f] = mn;\\n    }\\n    int twoEggDrop(int n) \\n    {\\n         memset(t,-1,sizeof(t));\\n        return solve(2,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475183,
                "title": "python-math-solution-with-explanation",
                "content": "```\\ndef twoEggDrop(self, n: int) -> int:\\n        # The ceiling of the square root should find the ideal \"skip length\".\\n        # Ex: n= 110, we can move in increments of 11.\\n        # However, we have to factor in the steps added for testing the 1st egg. For example:\\n        #   Step 11: We test the first egg, then in a worst case, test floors 1-10\\n        #   Step 22: We test the first egg, then in a worst case, test floors 12-21. However we\\'ve still used the move from the above step!\\n        \\n        # So incorporating each additional step, our ideal equation is:\\n        # x + (x-1) + (x-2) + ... 1 >= n\\n        # => (X**2 +x)/2 >= n\\n        # We just iterate from the square root to find the first X where this is satisfied\\n        x = math.ceil(math.sqrt(n))\\n        while ((x**2 + x)/2 < n):\\n            x += 1\\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\ndef twoEggDrop(self, n: int) -> int:\\n        # The ceiling of the square root should find the ideal \"skip length\".\\n        # Ex: n= 110, we can move in increments of 11.\\n        # However, we have to factor in the steps added for testing the 1st egg. For example:\\n        #   Step 11: We test the first egg, then in a worst case, test floors 1-10\\n        #   Step 22: We test the first egg, then in a worst case, test floors 12-21. However we\\'ve still used the move from the above step!\\n        \\n        # So incorporating each additional step, our ideal equation is:\\n        # x + (x-1) + (x-2) + ... 1 >= n\\n        # => (X**2 +x)/2 >= n\\n        # We just iterate from the square root to find the first X where this is satisfied\\n        x = math.ceil(math.sqrt(n))\\n        while ((x**2 + x)/2 < n):\\n            x += 1\\n        return x\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2394987,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int count=0;\\n        int x=1;\\n        while(n>0)\\n        {\\n            count++;\\n            n-=x++;\\n            // x++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int count=0;\\n        int x=1;\\n        while(n>0)\\n        {\\n            count++;\\n            n-=x++;\\n            // x++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356989,
                "title": "c-dp-recursion-memoization",
                "content": "I have made a generalised solution for N floors and K eggs.\\nThe main idea is we go to every floor and check the condition of egg after throwing it(break or not break).\\n\\nIf it breaks we check for remaining floors with one egg less.\\nOtherwise we check for remaining upper floors with the same no of eggs.\\n\\nLet\\'s assume mid=20;\\nif egg breaks->we check for 1 to 19 floors.\\nOtherwise->we check for 21 to N floors.\\n\\n```\\nclass Solution {\\npublic:\\n    // GENERALISED SOLUTION FOR N FLOORS AND K EGGS\\n    \\n    int fun(int n,int e,vector<vector<int>>&dp)\\n    {\\n        if(e==1 || n<2)return n;\\n        \\n        if(dp[n][e]!=-1)return dp[n][e];\\n        \\n        int l=1;\\n        int h=n;\\n        int minm=INT_MAX;\\n        \\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            int egg_break=fun(mid-1,e-1,dp);          // no of eggs reduces by one and we check for remaining                                                          (mid-1) floors.\\n            int egg_not_break=fun(n-mid,e,dp);        //  we check for remaining n-mid floors.   \\n            \\n            if(egg_break<egg_not_break)\\n                l=mid+1;\\n            else\\n                h=mid-1;\\n            \\n            int temp=1+max(egg_break,egg_not_break);    // we take max because we have to find minm attempts\\n            minm=min(minm,temp);                        // in the worst case scenario.\\n        }\\n        \\n        return dp[n][e]=minm;\\n    }\\n    int twoEggDrop(int n) {\\n        int k=2;\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return fun(n,2,dp);\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE THE SOLUTION!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // GENERALISED SOLUTION FOR N FLOORS AND K EGGS\\n    \\n    int fun(int n,int e,vector<vector<int>>&dp)\\n    {\\n        if(e==1 || n<2)return n;\\n        \\n        if(dp[n][e]!=-1)return dp[n][e];\\n        \\n        int l=1;\\n        int h=n;\\n        int minm=INT_MAX;\\n        \\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            int egg_break=fun(mid-1,e-1,dp);          // no of eggs reduces by one and we check for remaining                                                          (mid-1) floors.\\n            int egg_not_break=fun(n-mid,e,dp);        //  we check for remaining n-mid floors.   \\n            \\n            if(egg_break<egg_not_break)\\n                l=mid+1;\\n            else\\n                h=mid-1;\\n            \\n            int temp=1+max(egg_break,egg_not_break);    // we take max because we have to find minm attempts\\n            minm=min(minm,temp);                        // in the worst case scenario.\\n        }\\n        \\n        return dp[n][e]=minm;\\n    }\\n    int twoEggDrop(int n) {\\n        int k=2;\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return fun(n,2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336636,
                "title": "idk-just-saw-a-pattern-in-test-case-lmao-not-recommended",
                "content": "If you observe the answer  you would notice  a pattern. its\\n1 2 2 3 3 3 4 4 4 4 5 5 5 5 5..........................\\ni repeats i times and hence the pattern \\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n       int i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n        }\\n        return i-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n       int i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            i++;\\n        }\\n        return i-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309144,
                "title": "c-formula-solution-o-1-tc-o-1-sc",
                "content": "\\tint twoEggDrop(int n) {\\n        int z = (sqrt(8*n+1)-1)/2;\\n        if((z*(z+1))/2==n) return z;\\n        else return z+1;\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "\\tint twoEggDrop(int n) {\\n        int z = (sqrt(8*n+1)-1)/2;\\n        if((z*(z+1))/2==n) return z;\\n        else return z+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2295392,
                "title": "c-clean-code-easy-to-understand",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int counter = 0;\\n        for(int i = 1; i <= n; ++i){\\n            counter = counter + i;\\n            if(counter >= n){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Output**\\n```\\nRuntime: 2 ms, faster than 83.14% of C++ online submissions for Egg Drop With 2 Eggs and N Floors.\\nMemory Usage: 5.8 MB, less than 90.50% of C++ online submissions for Egg Drop With 2 Eggs and N Floors.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int counter = 0;\\n        for(int i = 1; i <= n; ++i){\\n            counter = counter + i;\\n            if(counter >= n){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nRuntime: 2 ms, faster than 83.14% of C++ online submissions for Egg Drop With 2 Eggs and N Floors.\\nMemory Usage: 5.8 MB, less than 90.50% of C++ online submissions for Egg Drop With 2 Eggs and N Floors.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247426,
                "title": "c-dp-memoization-clean-code",
                "content": "```\\nvector<int> dp(1001, 0);\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        \\n        if(dp[n])\\n            return dp[n];\\n        \\n        int i, res;\\n        for(i=1;i<=n;i++)\\n        {\\n            res = 1 + max(i-1, twoEggDrop(n-i));\\n            dp[n] = min(dp[n] == 0 ? n : dp[n], res);\\n        } \\n        return dp[n]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<int> dp(1001, 0);\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        \\n        if(dp[n])\\n            return dp[n];\\n        \\n        int i, res;\\n        for(i=1;i<=n;i++)\\n        {\\n            res = 1 + max(i-1, twoEggDrop(n-i));\\n            dp[n] = min(dp[n] == 0 ? n : dp[n], res);\\n        } \\n        return dp[n]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173892,
                "title": "c-aditya-verma-binary-search-dp",
                "content": "just watch this video by aditya verma sir  : https://www.youtube.com/watch?v=S49zeUjeUL0&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=42\\n\\nand we willl just apply binary search instead of linear traversal because   linear traversal is giving us TLE\\n```\\nclass Solution {\\npublic:\\n    int t[3][1001];\\n    int util(int e, int f){\\n        if(e<=1 || f<=1)\\n            return f;\\n            \\n        if(t[e][f]!=-1)\\n           return t[e][f];\\n       \\n        int count=INT32_MAX;\\n        int l=1,r=f;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            int left = util(e-1,mid-1);\\n            int right = util(e,f-mid);\\n            int temp = 1 + max(left,right);\\n            if(left<right)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            count = min(count,temp);\\n        }\\n        return t[e][f] = count;\\n        \\n      \\n    }\\n    int twoEggDrop(int n) {\\n        memset(t,-1,sizeof(t));\\n        return util(2,n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int t[3][1001];\\n    int util(int e, int f){\\n        if(e<=1 || f<=1)\\n            return f;\\n            \\n        if(t[e][f]!=-1)\\n           return t[e][f];\\n       \\n        int count=INT32_MAX;\\n        int l=1,r=f;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            int left = util(e-1,mid-1);\\n            int right = util(e,f-mid);\\n            int temp = 1 + max(left,right);\\n            if(left<right)\\n            {\\n                l=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2122007,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = n, ans = 0;\\n        while(i > 0) {\\n            ans++;\\n            i -= ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i = n, ans = 0;\\n        while(i > 0) {\\n            ans++;\\n            i -= ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111208,
                "title": "cheat-code-very-easy-java",
                "content": "Try to figure it out by your own ;) \\n\\nHint: Refer Example 2 explanation\\n\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int ans = 0;\\n        for(int i = n;i> 0;i = i- ans)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int ans = 0;\\n        for(int i = n;i> 0;i = i- ans)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068566,
                "title": "clean-math-one-liner-c",
                "content": "The general relationship is k + k-1 + k-2 + ... +1 <= n.  So k(k+1)/2<=n,  which is a simple quadratic equation that we can solve for k:\\n   ```\\n   int twoEggDrop(int n) {\\n        return ceil((sqrt(8.0*n+1)-1)/2);\\n    }",
                "solutionTags": [],
                "code": "The general relationship is k + k-1 + k-2 + ... +1 <= n.  So k(k+1)/2<=n,  which is a simple quadratic equation that we can solve for k:\\n   ```\\n   int twoEggDrop(int n) {\\n        return ceil((sqrt(8.0*n+1)-1)/2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1991796,
                "title": "c-mathematical-solution-explaination-o-1-time-and-space",
                "content": "Since there are a only 2 eggs the use of a binary search to locate the floor is not optimal (as once the first egg breaks a linear search through the remainder would be required).\\n\\nTherefore the optimal strategy to find the floor at which an egg breaks at will be using some sort of interval between throws (leading to O(\\u221An) time to find the floor).\\nOne option for the interval size would be a fixed interval of size \\u221An (optimal, can be proved with calculus but not relevant here) however this results in a generally larger number of throws towards the top of the building because of the fixed interval so a using variable interval can balance this to get a more even distribution.\\nIf this variable interval starts at x and decrements by 1 after each throw then the sum of the throws before the 1st egg breaks + the worst number of throws for the 2nd egg breaks (which is the interval size - 1) will be constant so the number of throws to reach the end of each interval will all be the worst case and equal rather than a larger worst case per interval towards the top of the building.\\n\\nHowever most of the computation of this strategy is NOT required as this problem wants to find the minimum number of moves (with certainty), which in this will be the worst case (as a function of n) of the above strategy.\\n\\nlet i = the number of throws before while the 1st egg does not break\\nlet x(i) = the interval\\nso the worst case for the number of throws of the second egg if the 1st egg broke at i would be x(i) - 1\\n\\ntherefore: i + x(i) - 1 = k where k is a constant\\nso as i increments to maintain a constant value x(i) decrements as explained above: x(i + 1) = x(i) - 1\\nAdditionally in the intial case that i = 1, x(1) = k; therefore the initial interval size will be the minimum number of moves\\n\\nNow all that needs to be done is find the minimum initial value of x which still has a positive or 0 interval size by the time it reaches the top floor (to ensure that all floors can be checked).\\n\\nAs an example for n = 20 choosing x(1) = 5 would drop the first egg at intervals:\\n5, 9, 12, 14, 15, 15, 15 ...\\nAs you can see this doesn\\'t ever reach the top floor 20\\nbut for x(1) = 6:\\n\\n6, 11, 15, 18, 20, (stops early but would reach up to a maximum of floor 21 in 6 throws as expected)\\nAs you can see the maximum floor that a given interval x(1) can reach is equivalent to the x(1)th triangular number (otherwise known as the sum of r between r = 1 and r = x(1), which makes sense as this is just the sum of all the interval sizes until it reaches 0)\\n\\nTherefore a final solvable expression is (substituting x(1) = k):\\n\\n![image](https://assets.leetcode.com/users/images/fb44222d-01cd-4efb-80fd-94f64c39ea1b_1651237910.6004503.gif)\\n\\n![image](https://assets.leetcode.com/users/images/820d9c70-3e07-417a-a6b3-c9091aabaee7_1651238241.6981032.gif)\\n\\n![image](https://assets.leetcode.com/users/images/0a0deed3-4478-46ab-b351-16d6b0e61233_1651238574.0006733.gif)\\n\\n![image](https://assets.leetcode.com/users/images/f659b686-0345-48e4-8908-ff0b7cf2ada9_1651242161.5300543.gif)\\n\\nImplementing this final line as code is easy (note integer division does the floor automatically):\\n\\n```\\npublic int TwoEggDrop(int n) {\\n\\treturn (int)Math.Ceiling(Math.Sqrt(8*n + 1))/2;\\n}\\n```\\n\\nAlternatively converting an integer square root function (floor of the root) into the ceiling of the root could offer better performance in some cases.\\nHere is an implementation of this finding the integer square root using Newton\\'s method:\\n```\\npublic int TwoEggDrop(int n) {\\n        int s = isqrt(8*n + 1);\\n        return (s*s == 8*n + 1 ? s : s + 1)/2; //convert to Ceiling(s)/2\\n    }\\n\\n    \\n    public static int isqrt(int num) //Integer square root Newton\\n    {\\n        if (0 == num) { return 0; }\\n            int n = (num / 2) + 1;       // Initial guess\\n            int n1 = (n + (num / n)) / 2;\\n            while (n1 < n) {\\n                n = n1;\\n                n1 = (n + (num / n)) / 2;\\n            }\\n            return n;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\npublic int TwoEggDrop(int n) {\\n\\treturn (int)Math.Ceiling(Math.Sqrt(8*n + 1))/2;\\n}\\n```\n```\\npublic int TwoEggDrop(int n) {\\n        int s = isqrt(8*n + 1);\\n        return (s*s == 8*n + 1 ? s : s + 1)/2; //convert to Ceiling(s)/2\\n    }\\n\\n    \\n    public static int isqrt(int num) //Integer square root Newton\\n    {\\n        if (0 == num) { return 0; }\\n            int n = (num / 2) + 1;       // Initial guess\\n            int n1 = (n + (num / n)) / 2;\\n            while (n1 < n) {\\n                n = n1;\\n                n1 = (n + (num / n)) / 2;\\n            }\\n            return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984066,
                "title": "egg-drop-with-2-eggs-and-n-floors",
                "content": "```\\nint twoEggDrop(int n) {\\n        int count = 0;\\n        for(int i = n; i > 0; i -= count)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint twoEggDrop(int n) {\\n        int count = 0;\\n        for(int i = n; i > 0; i -= count)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903924,
                "title": "c-1-line-solution-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1+sqrt(1+8*n))/2);\\n    }\\n};\\n```\\n\\nObjective: Find the roots of  x^2+x-2*n = 0 and take the ceiling of the greater root.\\nLogic:\\n1\\n2 2\\n3 3 3 \\n4 4 4 4\\n...\\nTo find the n th element in this pattern!!\\nx(x+1)/2 = n \\nx^2+x-2*n = 0\\nThen, apply Shridhar Acharya\\'s Theorem!!",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil((-1+sqrt(1+8*n))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901286,
                "title": "gadit-math-java-easy-pattern",
                "content": "\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int ans[]=new int[1000001];\\n        ans[0]=0;\\n        ans[1]=1;\\n        int mul=2;\\n        int ind=2;  \\n        while(mul <= n){\\n          for(int i=0;i<mul;i++)ans[ind++]=mul;\\n          mul++;\\n        }\\n        return ans[n];\\n    }\\n}\\n```\\nPattern I saw ->\\nfor N ->\\n1 -> 1\\n2 -> 2\\n3 -> 2\\n4 -> 3\\n5 -> 3\\n6 -> 3\\n7 -> 4\\n8 -> 4\\n9 -> 4\\n10 ->  4\\n... and so onn\\ni.e. evern digits repeat Digit times",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int ans[]=new int[1000001];\\n        ans[0]=0;\\n        ans[1]=1;\\n        int mul=2;\\n        int ind=2;  \\n        while(mul <= n){\\n          for(int i=0;i<mul;i++)ans[ind++]=mul;\\n          mul++;\\n        }\\n        return ans[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858303,
                "title": "c-very-easy-solution-optimized-one",
                "content": "```\\nint twoEggDrop(int n) {\\n        int s = (sqrt((8*n) + 1));\\n        if(s*s == 8*n + 1)\\n            s = sqrt(8*n);\\n        return floor((1 + s)/2);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint twoEggDrop(int n) {\\n        int s = (sqrt((8*n) + 1));\\n        if(s*s == 8*n + 1)\\n            s = sqrt(8*n);\\n        return floor((1 + s)/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858295,
                "title": "0-ms-o-log-n-easy-c",
                "content": "```\\nint twoEggDrop(int n) {\\n        int res = 0;\\n        int count = 0;\\n        int i;\\n        for(i=1;i<=n;i+=res){\\n            count++;\\n            res++;\\n        }\\n        if(i<n)\\n            return count+1;\\n        return count;\\n\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint twoEggDrop(int n) {\\n        int res = 0;\\n        int count = 0;\\n        int i;\\n        for(i=1;i<=n;i+=res){\\n            count++;\\n            res++;\\n        }\\n        if(i<n)\\n            return count+1;\\n        return count;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733765,
                "title": "java-solution-with-explanation",
                "content": "There is a pattern in this problem:\\n1 -> 1\\n2 -> 2\\n3 -> 2\\n4 -> 3\\n5 -> 3\\n6 -> 3\\n7 -> 4\\n8 -> 4\\n9 -> 4\\n10 -> 4\\n11 -> 5\\n\\nAccording to that the Solution:\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int res = 0;\\n        \\n        for(int i=0;i<=n;i++) {\\n            res = res + i;\\n            if(res >= n)\\n                return i;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int twoEggDrop(int n) {\\n        int res = 0;\\n        \\n        for(int i=0;i<=n;i++) {\\n            res = res + i;\\n            if(res >= n)\\n                return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1729639,
                "title": "most-simple-code-c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int count=0;\\n        int i=1;\\n        while(n>0){\\n            n-=i;\\n            i++;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int count=0;\\n        int i=1;\\n        while(n>0){\\n            n-=i;\\n            i++;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705643,
                "title": "javascript-easy-dp-76ms",
                "content": "solutions: come from 887 https://leetcode.com/problems/super-egg-drop/discuss/1705642/javascript-easy-dp-123ms when k = 2\\n\\n```\\nconst twoEggDrop = (n) => {\\n    let k = 2, dp = Array(k + 1).fill(0), res = 0;\\n    while (dp[k] < n) {\\n        for (let i = k; i > 0; i--) {\\n            dp[i] = dp[i] + dp[i - 1] + 1;\\n        }\\n        res++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst twoEggDrop = (n) => {\\n    let k = 2, dp = Array(k + 1).fill(0), res = 0;\\n    while (dp[k] < n) {\\n        for (let i = k; i > 0; i--) {\\n            dp[i] = dp[i] + dp[i - 1] + 1;\\n        }\\n        res++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634803,
                "title": "python-o-1-with-explaination",
                "content": "Think the problem in Binary Search sense:\\n\\nCan we find an algorithm to tell us whether it\\'s possible to find out the floor with only K tries?\\nThen I just realized how to resolve this problem:\\n\\nWe try it out greedly, in the first try, we take K-th floor because if we fail, we have (K - 1) tries remaining and it\\'s just enough for covering (k-1) floors below the K-th floor.\\nThen if it didn\\'t break, we used one of our chance and we are forced to take (K + K - 1)-th floor otherwise we don\\'t have enough chances / retries to cover the floor in between the 1st try and 2nd try.\\n\\nThen the problem becomes solving a mathematic equation:\\n```\\ny + (1 + 2 + ... + y - 1) >= n\\n\\n=>\\n\\ny >= sqrt(2 * N - 0.25) - 0.5\\n```\\n\\n```\\n    def twoEggDrop(self, n: int) -> int:\\n        return math.ceil(math.sqrt(2 * n - 0.25) - 0.5)\\n```",
                "solutionTags": [],
                "code": "```\\ny + (1 + 2 + ... + y - 1) >= n\\n\\n=>\\n\\ny >= sqrt(2 * N - 0.25) - 0.5\\n```\n```\\n    def twoEggDrop(self, n: int) -> int:\\n        return math.ceil(math.sqrt(2 * n - 0.25) - 0.5)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1582941,
                "title": "memoization-based-java-solution",
                "content": "```\\nclass Solution {\\n    int[][] dp;\\n    public int twoEggDrop(int n) {\\n        dp = new int[n+1][3];\\n        return helper(n , 2);\\n    }\\n    public int helper(int f , int e){\\n        if(f == 0 || f == 1)\\n            return f;\\n        \\n        if(e == 1)\\n            return f;\\n        if(dp[f][e] != 0)\\n            return dp[f][e];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int k = 1; k<f ;k++){\\n            int tmp = 1 + Math.max(helper( k - 1 , e - 1) , helper(f - k , e) );\\n            \\n            ans = Math.min( ans , tmp );\\n        }\\n        return dp[f][e] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public int twoEggDrop(int n) {\\n        dp = new int[n+1][3];\\n        return helper(n , 2);\\n    }\\n    public int helper(int f , int e){\\n        if(f == 0 || f == 1)\\n            return f;\\n        \\n        if(e == 1)\\n            return f;\\n        if(dp[f][e] != 0)\\n            return dp[f][e];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int k = 1; k<f ;k++){\\n            int tmp = 1 + Math.max(helper( k - 1 , e - 1) , helper(f - k , e) );\\n            \\n            ans = Math.min( ans , tmp );\\n        }\\n        return dp[f][e] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576196,
                "title": "java-easy-solution-100-0ms",
                "content": "class Solution {\\n    public int twoEggDrop(int n) {\\n        if(n<3)\\n            return n;\\n        for(int i=0;i<n;i++){\\n            if(i*(i+1)/2>=n)\\n                return i;\\n        }\\n        return 12345678;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int twoEggDrop(int n) {\\n        if(n<3)\\n            return n;\\n        for(int i=0;i<n;i++){\\n            if(i*(i+1)/2>=n)\\n                return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1568050,
                "title": "python3-solution-1-line-answer",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        return math.ceil((2*math.sqrt(2*n)-1)/2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        return math.ceil((2*math.sqrt(2*n)-1)/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562360,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    int findMinimumDrop(int floors, int eggs, vector<vector<int>>& dp){\\n       \\n        for(int f=1; f<=floors; ++f){ // only 1 egg\\n            dp[1][f] = f;\\n        }\\n     \\n        for(int e=1; e<=eggs; ++e){ // only 1 floor\\n            dp[e][1] = 1;\\n        }\\n        \\n        for(int e= 2; e<=eggs; ++e){\\n            for(int f=2; f<=floors; ++f){ \\n                int result = INT_MAX;\\n                                         // (e,f) --> (e, f),(e,f-1),...(e,1)\\n                for(int x=1; x<=f; ++x){\\n                    result = min(result, 1+max(dp[e-1][x-1] , dp[e][f-x]));\\n                }\\n                \\n                dp[e][f] = result;\\n            }\\n        }\\n        return dp[eggs][floors];\\n    }\\n    \\npublic:\\n    int twoEggDrop(int n) {\\n        vector<vector<int>> dp(3, vector<int>(n+1, 0));\\n        int eggs = 2;\\n        return findMinimumDrop(n, eggs, dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int findMinimumDrop(int floors, int eggs, vector<vector<int>>& dp){\\n       \\n        for(int f=1; f<=floors; ++f){ // only 1 egg\\n            dp[1][f] = f;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1538460,
                "title": "not-generic-simple-1d-dp-solution-explained",
                "content": "There are generic solutions for this problem which can account for more than 2 eggs, but this solution is greedy at implementation and does it in 1 dimensional DP.\\nLet\\'s start off with recursive solution and then proceed to DP.\\nIntution :\\nLet\\'s consider a sequence of moves, and let this sequence give the minimum no. of moves to find the target floor.\\nNow this sequence may start from any level between 1 to N. So, to find the first floor of sequence we loop for every floor while considering two cases :\\n1. Egg breaks at level i, this means we have only one egg left, so we can find floor f in no less than i-1 moves. \\n2. Egg doesn\\'t break at level i, this means we need to search for solution in N-i levels. \\n\\nWe take maximum of the two cases (we need to consider worst case) at every iteration of loop.\\nFinally we take the minimum of all the moves that start from 1 to N.\\n\\nBase cases : \\nIf there is only one floor, minimum moves is 1 as we need only one egg to find target floor.\\nIf there is no floor, minimum moves is 0.\\n\\nRecursive Solution :\\n\\n\\t\\t\\tint twoEggDrop(int n) {\\n\\t\\t\\t\\tif(n == 1 || n == 0) return n;\\n\\t\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint max_moves = 1 + max(i-1, twoEggDrop(n-i));\\n\\t\\t\\t\\t\\tans = min(ans, max_moves);\\n\\t\\t\\t\\t}       \\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}        \\n\\t\\t\\t\\t\\nThe complexity is exponential, therefore we move forward to the DP solution.\\n\\nNow we can store the recurring computation of minimum moves for finding f floor in total i floors. For this we take 1 dimensional array memo, such that memo[i] represents the minumum moves to find target floor in total i floors.\\nDP formula :\\n\\n\\t\\t\\t\\t\\tmemo[ i ] = INT_MAX\\n\\t\\t\\t\\t\\tmemo[ i ] = for( j = 1 to i ) { min( memo[ i ], 1 + max( j - 1, memo[ i - j ] ) ) }\\n\\nDP solution :\\n\\n\\t\\tint twoEggDrop(int n) {\\n        vector<int> memo(n+1, INT_MAX);\\n        memo[1] = 1, memo[0] = 0;\\n        for(int i = 2; i <= n; i++)\\n            for(int j = 1; j <= i; j++)\\n            {\\n                int max_moves = 1 + max(j-1, memo[i-j]);\\n                memo[i] = min(memo[i], max_moves);        \\n            }\\n        return memo[n];\\n    }\\n\\nTime complexity : O(n^2)",
                "solutionTags": [],
                "code": "There are generic solutions for this problem which can account for more than 2 eggs, but this solution is greedy at implementation and does it in 1 dimensional DP.\\nLet\\'s start off with recursive solution and then proceed to DP.\\nIntution :\\nLet\\'s consider a sequence of moves, and let this sequence give the minimum no. of moves to find the target floor.\\nNow this sequence may start from any level between 1 to N. So, to find the first floor of sequence we loop for every floor while considering two cases :\\n1. Egg breaks at level i, this means we have only one egg left, so we can find floor f in no less than i-1 moves. \\n2. Egg doesn\\'t break at level i, this means we need to search for solution in N-i levels. \\n\\nWe take maximum of the two cases (we need to consider worst case) at every iteration of loop.\\nFinally we take the minimum of all the moves that start from 1 to N.\\n\\nBase cases : \\nIf there is only one floor, minimum moves is 1 as we need only one egg to find target floor.\\nIf there is no floor, minimum moves is 0.\\n\\nRecursive Solution :\\n\\n\\t\\t\\tint twoEggDrop(int n) {\\n\\t\\t\\t\\tif(n == 1 || n == 0) return n;\\n\\t\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint max_moves = 1 + max(i-1, twoEggDrop(n-i));\\n\\t\\t\\t\\t\\tans = min(ans, max_moves);\\n\\t\\t\\t\\t}       \\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}        \\n\\t\\t\\t\\t\\nThe complexity is exponential, therefore we move forward to the DP solution.\\n\\nNow we can store the recurring computation of minimum moves for finding f floor in total i floors. For this we take 1 dimensional array memo, such that memo[i] represents the minumum moves to find target floor in total i floors.\\nDP formula :\\n\\n\\t\\t\\t\\t\\tmemo[ i ] = INT_MAX\\n\\t\\t\\t\\t\\tmemo[ i ] = for( j = 1 to i ) { min( memo[ i ], 1 + max( j - 1, memo[ i - j ] ) ) }\\n\\nDP solution :\\n\\n\\t\\tint twoEggDrop(int n) {\\n        vector<int> memo(n+1, INT_MAX);\\n        memo[1] = 1, memo[0] = 0;\\n        for(int i = 2; i <= n; i++)\\n            for(int j = 1; j <= i; j++)\\n            {\\n                int max_moves = 1 + max(j-1, memo[i-j]);\\n                memo[i] = min(memo[i], max_moves);        \\n            }\\n        return memo[n];\\n    }\\n\\nTime complexity : O(n^2)",
                "codeTag": "Unknown"
            },
            {
                "id": 1526495,
                "title": "c-using-memoization",
                "content": "**Please Upvote if you like the Solution!**\\n   \\n    class Solution {\\n    public:\\n    int mem[3][1001];\\n    int solve(int e,int f)\\n    {\\n        if(f==0 || f==1)//when their is floor value 0 and 1\\n            return f;\\n        if(e==1)//when their is only one egg\\n            return f;\\n        \\n        if(mem[e][f]!=-1)\\n            return mem[e][f];\\n        \\n        int mn=INT_MAX;\\n        \\n        for(int k=1;k<=f;k++)\\n        {\\n            //Here max value of temp is finding because we are calculating number of attempts in worst case\\n            int temp=1+max(solve(e-1,k-1),solve(e,f-k));// here first case is when egg breaks and second case is when egg doesn\\'t breaks\\n            \\n            mn=min(mn,temp);//finding minimum number of attempts\\n        }\\n        return mem[e][f]=mn;\\n    }\\n    int twoEggDrop(int n) \\n    { \\n        memset(mem,-1,sizeof(mem));\\n        \\n        return solve(2,n);//2 eggs the given\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public:\\n    int mem[3][1001];\\n    int solve(int e,int f)\\n    {\\n        if(f==0 || f==1)//when their is floor value 0 and 1\\n            return f;\\n        if(e==1)//when their is only one egg\\n            return f;\\n        \\n        if(mem[e][f]!=-1)\\n            return mem[e][f];\\n        \\n        int mn=INT_MAX;\\n        \\n        for(int k=1;k<=f;k++)\\n        {\\n            //Here max value of temp is finding because we are calculating number of attempts in worst case\\n            int temp=1+max(solve(e-1,k-1),solve(e,f-k));// here first case is when egg breaks and second case is when egg doesn\\'t breaks\\n            \\n            mn=min(mn,temp);//finding minimum number of attempts\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1504213,
                "title": "python-concise-dp-solution",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # For checking floor n, we can compute base off of previous floor drops.\\n        # Try all previous floors as the first floor drop and handle both their cases:\\n        # For floor i 1, n-1\\n        # Case 1. Egg Breaks -> i - 1 floors to check\\n        # Case 2. Egg doesn\\'t break -> same problem again for n - i floors\\n        # We need to handle the worst case, so take the max of this.\\n        # For all floors, take the min of this operation\\n        \\n        dp = [float(inf)] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                dp[i] = min(dp[i], 1 + max(j - 1, dp[i - j]))\\n                \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        # For checking floor n, we can compute base off of previous floor drops.\\n        # Try all previous floors as the first floor drop and handle both their cases:\\n        # For floor i 1, n-1\\n        # Case 1. Egg Breaks -> i - 1 floors to check\\n        # Case 2. Egg doesn\\'t break -> same problem again for n - i floors\\n        # We need to handle the worst case, so take the max of this.\\n        # For all floors, take the min of this operation\\n        \\n        dp = [float(inf)] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                dp[i] = min(dp[i], 1 + max(j - 1, dp[i - j]))\\n                \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447235,
                "title": "0ms-faster-than-100-simple-4-line-math-solution-in-c",
                "content": "int twoEggDrop(int n) {\\n        int i=0;\\n        for(i=0;;i++)\\n        if((i*(i+1))/2>=n){\\n            break;\\n        }\\n        return i;\\n    }",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "int twoEggDrop(int n) {\\n        int i=0;\\n        for(i=0;;i++)\\n        if((i*(i+1))/2>=n){\\n            break;\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1446208,
                "title": "c-100-2-line-code-0ms-egg-drop",
                "content": "There is a pattern between n and output ,I just cracked that\\nThis solution is just a short cut\\nI suggest you guys to solve it using DP for practice.\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int temp=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            temp+=i;\\n            if(temp>=n)return i;\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int temp=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            temp+=i;\\n            if(temp>=n)return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1444622,
                "title": "cpp-0ms-binary-search",
                "content": "\\tint twoEggDrop(int n) {\\n        \\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right)\\n        {\\n            int mid = (left+right)/2;\\n            \\n            if(mid*(mid+1) >= 2*n  && (mid-1)*mid < 2*n)\\n                return mid;\\n            \\n            if(mid*(mid+1) < 2*n)\\n                left = mid+1;\\n            else\\n                right = mid-1;\\n        }\\n        return left;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "\\tint twoEggDrop(int n) {\\n        \\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right)\\n        {\\n            int mid = (left+right)/2;\\n            \\n            if(mid*(mid+1) >= 2*n  && (mid-1)*mid < 2*n)\\n                return mid;\\n            \\n            if(mid*(mid+1) < 2*n)\\n                left = mid+1;\\n            else\\n                right = mid-1;\\n        }\\n        return left;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1411347,
                "title": "java-very-simple-math-solution",
                "content": "class Solution {\\n    public int twoEggDrop(int n) {\\n        \\n        int sum = 0;\\n        int count = 0;\\n        while(sum < n){\\n            ++count;\\n            sum+=count;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int twoEggDrop(int n) {\\n        \\n        int sum = 0;\\n        int count = 0;\\n        while(sum < n){\\n            ++count;\\n            sum+=count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405216,
                "title": "asked-in-my-recent-interview-see-more",
                "content": "Variant of this was asked in my recent interview with Agoda. Checkout out my detailed interview experience.\\nhttps://freezefrancis.medium.com/agoda-interview-experience-de6abc2c7347",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1401544,
                "title": "javascript-clean-code",
                "content": "```\\nvar twoEggDrop = function(n) {\\n  const eggs = 2;\\n  const memo = new Array(n+1).fill(0).map(() => new Array(eggs + 1).fill(-1));\\n\\n  function solve(n, eggs) {\\n    if (memo[n][eggs] !== -1) return memo[n][eggs];\\n    if (n <= 1 || eggs === 1) return n;  \\n    let min = Infinity;\\n    for (let i = 1; i <= n; i++) {\\n      // if egg breaks on ith floor solve for (i - 1, eggs - 1) and if eggs doesn\\'t break on the ith floor\\n      // solve for (n - i, eggs)\\n      \\n      // Why choose max - because we need to consider the worst case\\n      const cur = Math.max(solve(i - 1, eggs - 1), solve(n - i, eggs)) + 1;\\n      min = Math.min(cur, min);\\n    }\\n    \\n    memo[n][eggs] =  min\\n    return memo[n][eggs];\\n  }\\n  \\n  return solve(n, eggs);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoEggDrop = function(n) {\\n  const eggs = 2;\\n  const memo = new Array(n+1).fill(0).map(() => new Array(eggs + 1).fill(-1));\\n\\n  function solve(n, eggs) {\\n    if (memo[n][eggs] !== -1) return memo[n][eggs];\\n    if (n <= 1 || eggs === 1) return n;  \\n    let min = Infinity;\\n    for (let i = 1; i <= n; i++) {\\n      // if egg breaks on ith floor solve for (i - 1, eggs - 1) and if eggs doesn\\'t break on the ith floor\\n      // solve for (n - i, eggs)\\n      \\n      // Why choose max - because we need to consider the worst case\\n      const cur = Math.max(solve(i - 1, eggs - 1), solve(n - i, eggs)) + 1;\\n      min = Math.min(cur, min);\\n    }\\n    \\n    memo[n][eggs] =  min\\n    return memo[n][eggs];\\n  }\\n  \\n  return solve(n, eggs);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354633,
                "title": "c-decrement-no-dp",
                "content": "```\\npublic class Solution\\n{\\n  public int TwoEggDrop(int n)\\n  {\\n    var ans = 0;\\n    var inc = 1;\\n\\n    while (n > 0)\\n    {\\n      n -= inc;\\n      ans++;\\n      inc++;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public int TwoEggDrop(int n)\\n  {\\n    var ans = 0;\\n    var inc = 1;\\n\\n    while (n > 0)\\n    {\\n      n -= inc;\\n      ans++;\\n      inc++;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323212,
                "title": "dp-approach-with-neat-explanation-python",
                "content": "```\\nclass Solution:\\n    def solve(self, e, f, dp):\\n        # base condition\\n        if f == 0 or f == 1:\\n            # if floor is not given or only one floor is available, then we simply return f as a min no of attempts\\n            return f\\n        if e == 1:\\n            # in worst case egg is suppose not broken, to check it we need to throw egg from each floor,\\n            # so min no of attempts will be f\\n            return f\\n\\n        if (e, f) in dp:\\n            return dp[(e, f)]\\n\\n        min_attempts = 1001\\n        for i in range(1, f + 1):\\n            # if egg is broken at particular floor, then we need to go downside for further checking by egg having e-1\\n            low = self.solve(e - 1, i - 1, dp)\\n            # if egg is not broken, then we can move up on the floor and can reuse egg\\n            high = self.solve(e, f - i, dp)\\n            # to determine the min attempt by using all eggs efficiently, we need to check worst case possibility\\n            # that\\'s why for eac attempt we need to calculate for max\\n            attempts = 1 + max(low, high)\\n            if min_attempts > attempts:\\n                min_attempts = attempts\\n        dp[(e, f)] = min_attempts\\n        return dp[(e, f)]\\n\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = {}\\n        return self.solve(2, n, dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solve(self, e, f, dp):\\n        # base condition\\n        if f == 0 or f == 1:\\n            # if floor is not given or only one floor is available, then we simply return f as a min no of attempts\\n            return f\\n        if e == 1:\\n            # in worst case egg is suppose not broken, to check it we need to throw egg from each floor,\\n            # so min no of attempts will be f\\n            return f\\n\\n        if (e, f) in dp:\\n            return dp[(e, f)]\\n\\n        min_attempts = 1001\\n        for i in range(1, f + 1):\\n            # if egg is broken at particular floor, then we need to go downside for further checking by egg having e-1\\n            low = self.solve(e - 1, i - 1, dp)\\n            # if egg is not broken, then we can move up on the floor and can reuse egg\\n            high = self.solve(e, f - i, dp)\\n            # to determine the min attempt by using all eggs efficiently, we need to check worst case possibility\\n            # that\\'s why for eac attempt we need to calculate for max\\n            attempts = 1 + max(low, high)\\n            if min_attempts > attempts:\\n                min_attempts = attempts\\n        dp[(e, f)] = min_attempts\\n        return dp[(e, f)]\\n\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = {}\\n        return self.solve(2, n, dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306744,
                "title": "c-recursion-memoization-valid-for-n-floors-and-n-eggs-with-comments",
                "content": "```\\n//valid for n floors and k eggs\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    //being vegetarian dealing with eggs is difficult....    ;)\\n    int recurs(int n,int egg)\\n    {\\n  \\n        if(n<=0)\\n            return 0;\\n        if(n<=2)  //base case\\n            return n;\\n        \\n        if(egg==1)\\n            return n;//if only one egg left we need to test for each floor\\n\\n\\n        if(dp[n][egg]!=-1)\\n            return dp[n][egg];\\n        \\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int a=max(recurs(i-1,egg-1),recurs(n-i,egg));//max since -> worse case that can occur while choosing f=i \\n            res=min(res,a);\\n        }\\n        return dp[n][egg]=res+1;// 1 since egg is dropped for this n for a trial\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        dp.resize(n+1,vector<int>(4,-1));\\n        return recurs(n,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//valid for n floors and k eggs\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    //being vegetarian dealing with eggs is difficult....    ;)\\n    int recurs(int n,int egg)\\n    {\\n  \\n        if(n<=0)\\n            return 0;\\n        if(n<=2)  //base case\\n            return n;\\n        \\n        if(egg==1)\\n            return n;//if only one egg left we need to test for each floor\\n\\n\\n        if(dp[n][egg]!=-1)\\n            return dp[n][egg];\\n        \\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int a=max(recurs(i-1,egg-1),recurs(n-i,egg));//max since -> worse case that can occur while choosing f=i \\n            res=min(res,a);\\n        }\\n        return dp[n][egg]=res+1;// 1 since egg is dropped for this n for a trial\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        dp.resize(n+1,vector<int>(4,-1));\\n        return recurs(n,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294505,
                "title": "python-solution-beats-99-75-python-submissions",
                "content": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        i = 1\\n        counter = 0\\n        sm = 0\\n        while sm<n:\\n            sm+=i\\n            i+=1\\n            counter+=1\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        i = 1\\n        counter = 0\\n        sm = 0\\n        while sm<n:\\n            sm+=i\\n            i+=1\\n            counter+=1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294243,
                "title": "recursion-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int res = 1e9;\\n    int dp[1001][3];\\n    int solve(int n , int eggs)\\n    {\\n        // base case\\n        // if no.of floors left is 1 or 0 we need to take n moves\\n        if(n<=1)\\n         return n;\\n        // suppose 1st egg broke at mth floor then we need to take atleat m-1 try \\' s\\n        if(eggs == 1)\\n            return n;\\n        \\n        if(dp[n][eggs]!=-1)\\n            return dp[n][eggs];\\n        \\n        int ans = 1e8;\\n        //at the ith floor either the eg will break or survive \\n        // 1. if it break at ith floor we need to try for i-1 foors in worst case\\n        // 2. 1st do not break at i th then we need to search for n-i left floors\\n        for(int  i = 1 ; i < n ;i++)\\n        {\\n            ans = min(ans , max(solve(i-1,eggs-1) , solve(n-i , eggs)) + 1);\\n        }\\n        return dp[n][eggs] = ans;\\n    }\\n    int twoEggDrop(int n) {\\n        if(n <= 1)\\n            return n;\\n        int eggs = 2 ;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(n,eggs);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int res = 1e9;\\n    int dp[1001][3];\\n    int solve(int n , int eggs)\\n    {\\n        // base case\\n        // if no.of floors left is 1 or 0 we need to take n moves\\n        if(n<=1)\\n         return n;\\n        // suppose 1st egg broke at mth floor then we need to take atleat m-1 try \\' s\\n        if(eggs == 1)\\n            return n;\\n        \\n        if(dp[n][eggs]!=-1)\\n            return dp[n][eggs];\\n        \\n        int ans = 1e8;\\n        //at the ith floor either the eg will break or survive \\n        // 1. if it break at ith floor we need to try for i-1 foors in worst case\\n        // 2. 1st do not break at i th then we need to search for n-i left floors\\n        for(int  i = 1 ; i < n ;i++)\\n        {\\n            ans = min(ans , max(solve(i-1,eggs-1) , solve(n-i , eggs)) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290724,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int twoEggDrop(int n) {\\n        int i=2;\\n        int sum=1; \\n        while(sum<n){\\n            sum+=i;\\n            i++;\\n        }\\n        return i-1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int twoEggDrop(int n) {\\n        int i=2;\\n        int sum=1; \\n        while(sum<n){\\n            sum+=i;\\n            i++;\\n        }\\n        return i-1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272074,
                "title": "o-1-solution-formula-easy-quadratic-equation-explained",
                "content": "Idea: Until the first egg is not broken: At each iteration, we have to be at a floor such that if the egg drop breaks from there, we have to iterate the remainng floor one by one.\\n\\ne.g. if start from floor = 5 and drop first egg and it breaks. We will have to go in the order 1 -> 2 -> 3 -> 4 to determine f. This means a worst case total of 5 moves if we start from floor = 5. We will try optimizing such that this worst case of 5 floors remains contant.\\n\\n\\nNow if the egg does not break from floor = 5, we have 4 shots left to fit the optimal 5 chances scenario. Again, we have to be careful that if the egg breaks on chance 2, we will have to iterate all the way up from floor = 6 using the second egg one by one. So we only go to floor = 9 such that the worst case of 5 shots is maintained. That is, if the egg breaks from floor = 9, we iterate back as 6 -> 7 -> 8 to determine f giving total of 5 shots.\\n\\nSimilarly, if egg does not break from floor = 9,  we go up by 3 floors to 12th floor on 3rd move (to give worst case of 5 shots as 10 -> 11 -> 12)\\n\\nThus the maximum floors we can cover starting from floor m is (m) + (m-1) + ... + 1 = m(m + 1) /2 i.e. sum of first m natural numbers. \\n\\nIn the problem, this sum is given as n and we need to compute m.\\n\\nm(m+1)/2 = n (Here n is given in the problem, the total number of floor)\\n\\nQuadratic equation solution:\\n\\nm(m+1) = 2n\\n\\nm^2 + m - 2n = 0\\n\\nm = (-1 + sqrt(1 + 8n))/2\\n\\nWe take math.ceil of this m to round up and return as the answer.\\n\\n```\\ndef twoEggDrop(self, n: int) -> int:\\n        \\n        return math.ceil((-1+math.sqrt(1+8*n))/2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef twoEggDrop(self, n: int) -> int:\\n        \\n        return math.ceil((-1+math.sqrt(1+8*n))/2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1270399,
                "title": "java-dp",
                "content": "```\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j = 1; j < i; j++) {\\n                int v1 = j;//first egg broken : 1 + (j -1)\\n                int v2 = 1 + dp[i-j];//first egg not broken\\n                dp[i] = Math.min(dp[i], Math.max(v1, v2));\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j = 1; j < i; j++) {\\n                int v1 = j;//first egg broken : 1 + (j -1)\\n                int v2 = 1 + dp[i-j];//first egg not broken\\n                dp[i] = Math.min(dp[i], Math.max(v1, v2));\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266367,
                "title": "java-5-lines-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int i = 1;\\n        \\n        while(n > 0){\\n            n -= i;\\n            i++;\\n        }\\n        \\n        return --i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int i = 1;\\n        \\n        while(n > 0){\\n            n -= i;\\n            i++;\\n        }\\n        \\n        return --i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253762,
                "title": "explained-in-comments-kotlin-classic-bottom-up",
                "content": "```\\n    fun twoEggDrop(n: Int): Int {\\n        val k = 2\\n        val dp = Array(k + 1) { IntArray(n + 1) } // <eggs, floors>\\n        for (i in 1..k) // i eggs, 1 floor\\n            dp[i][1] = 1 // we only need 1 move\\n        for (j in 1..n) // 1 egg, j floors\\n            dp[1][j] = j // we need \\'j\\' (or floor number) moves, play conservatively\\n\\t\\t\\t\\n        for (i in 2..k) { // eggs\\n            for (j in 2..n) { // floor\\n                var ans = Int.MAX_VALUE // need min moves in the end\\n                for (x in 1 until j) { // x is simulation floor, means try dropping it from bottom till top(j\\'th) floor\\n                    val eggBreaks = dp[i - 1][x - 1] // one less egg and move down\\n                    val eggNotBreak = dp[i][j - x] // same eggs, number of floors left is total(j) - simulation/droppped floor(x) = j - x\\n                    ans = minOf(ans, 1 + maxOf(eggBreaks, eggNotBreak)) // added one - this constitutes to one move\\n                }\\n                dp[i][j] = ans\\n            }\\n        }\\n        return dp[k][n]\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun twoEggDrop(n: Int): Int {\\n        val k = 2\\n        val dp = Array(k + 1) { IntArray(n + 1) } // <eggs, floors>\\n        for (i in 1..k) // i eggs, 1 floor\\n            dp[i][1] = 1 // we only need 1 move\\n        for (j in 1..n) // 1 egg, j floors\\n            dp[1][j] = j // we need \\'j\\' (or floor number) moves, play conservatively\\n\\t\\t\\t\\n        for (i in 2..k) { // eggs\\n            for (j in 2..n) { // floor\\n                var ans = Int.MAX_VALUE // need min moves in the end\\n                for (x in 1 until j) { // x is simulation floor, means try dropping it from bottom till top(j\\'th) floor\\n                    val eggBreaks = dp[i - 1][x - 1] // one less egg and move down\\n                    val eggNotBreak = dp[i][j - x] // same eggs, number of floors left is total(j) - simulation/droppped floor(x) = j - x\\n                    ans = minOf(ans, 1 + maxOf(eggBreaks, eggNotBreak)) // added one - this constitutes to one move\\n                }\\n                dp[i][j] = ans\\n            }\\n        }\\n        return dp[k][n]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250171,
                "title": "python-simple-binary-search-solution",
                "content": "```python\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        l = 1\\n        r = n - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid*(mid + 1)/2 < n:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        l = 1\\n        r = n - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid*(mid + 1)/2 < n:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249670,
                "title": "easy-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i*(i+1)>=2*n)return i;\\n        }\\n        return 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i*(i+1)>=2*n)return i;\\n        }\\n        return 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248497,
                "title": "python-algebraic-progression",
                "content": "```Python\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        step = 0\\n        while n > 0:\\n            step += 1\\n            n -= step\\n        return step\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```Python\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        step = 0\\n        while n > 0:\\n            step += 1\\n            n -= step\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247577,
                "title": "c-generalized-super-egg-drop-20-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    std::unordered_map<int, int> memo;\\n    int drop(int K, int N) {\\n\\t\\t// No floors left\\n        if (N == 0) return 0;\\n\\t\\t// Only one egg left, test all floors\\n        if (K == 1) return N;\\n        \\n        const int key = (N << 2) + K;\\n        if (memo.count(key)) return memo[key];\\n            \\n        int res = std::numeric_limits<int>::max();\\n        int lo = 1, hi = N;\\n        while (lo <= hi) {\\n            int n = lo + (hi - lo) / 2;\\n            \\n\\t\\t\\t// count0 increases with n, count1 decreases\\n            int count0 = drop(K, n - 1);\\n            int count1 = drop(K - 1, N - n);\\n            res = std::min(res, 1 + std::max(count0, count1));\\n            (count0 > count1) ? hi = n - 1 : lo = n + 1;\\n        }\\n        \\n        return memo[key] = res;\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        return drop(2, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::unordered_map<int, int> memo;\\n    int drop(int K, int N) {\\n\\t\\t// No floors left\\n        if (N == 0) return 0;\\n\\t\\t// Only one egg left, test all floors\\n        if (K == 1) return N;\\n        \\n        const int key = (N << 2) + K;\\n        if (memo.count(key)) return memo[key];\\n            \\n        int res = std::numeric_limits<int>::max();\\n        int lo = 1, hi = N;\\n        while (lo <= hi) {\\n            int n = lo + (hi - lo) / 2;\\n            \\n\\t\\t\\t// count0 increases with n, count1 decreases\\n            int count0 = drop(K, n - 1);\\n            int count1 = drop(K - 1, N - n);\\n            res = std::min(res, 1 + std::max(count0, count1));\\n            (count0 > count1) ? hi = n - 1 : lo = n + 1;\\n        }\\n        \\n        return memo[key] = res;\\n    }\\n    \\n    int twoEggDrop(int n) {\\n        return drop(2, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247129,
                "title": "python3-bottom-up-dp",
                "content": "DP[e][f] is the answer for e eggs and f floors.\\n\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        DP = { e:[None for _ in range(n+1)] for e in {1,2} }\\n        DP[1][0] = DP[2][0] = 0\\n        DP[1][1] = DP[2][1] = 1\\n        for k in range(2,n+1):\\n            DP[1][k] = DP[1][k-1]+1\\n            best = None\\n            for j in range(1,k+1):\\n                # test floor j with first egg\\n                # if it breaks, we have (j-1) floors and one egg left\\n                # if it doesn\\'t, we have (k-j) floors and two eggs\\n                cand = 1+max(DP[1][j-1],DP[2][k-j])\\n                if (best is None) or (best>cand):\\n                    best = cand\\n            DP[2][k] = best\\n        return min(DP[1][n],DP[2][n])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        DP = { e:[None for _ in range(n+1)] for e in {1,2} }\\n        DP[1][0] = DP[2][0] = 0\\n        DP[1][1] = DP[2][1] = 1\\n        for k in range(2,n+1):\\n            DP[1][k] = DP[1][k-1]+1\\n            best = None\\n            for j in range(1,k+1):\\n                # test floor j with first egg\\n                # if it breaks, we have (j-1) floors and one egg left\\n                # if it doesn\\'t, we have (k-j) floors and two eggs\\n                cand = 1+max(DP[1][j-1],DP[2][k-j])\\n                if (best is None) or (best>cand):\\n                    best = cand\\n            DP[2][k] = best\\n        return min(DP[1][n],DP[2][n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246763,
                "title": "javascript-o-1-one-liner",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar twoEggDrop = function(n) {\\n    return Math.ceil((Math.sqrt(8 * n + 1) - 1) / 2)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar twoEggDrop = function(n) {\\n    return Math.ceil((Math.sqrt(8 * n + 1) - 1) / 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078909,
                "title": "egg-drop-with-2-egg-o-1-space-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nobserve the pattern of substraction.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->observe the substraction pattern starting from last floor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int f=1;\\n        while(n>0){\\n         n=n-f;\\n         f++;\\n        }\\n        return f-1;\\n    }\\n};\\n```**Bold**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int f=1;\\n        while(n>0){\\n         n=n-f;\\n         f++;\\n        }\\n        return f-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067128,
                "title": "optimize-solution-using-binary-search-counting-theory-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int cnt(int n){\\n        int count=1;\\n        int res =1;\\n        while(count < n){\\n            res++;\\n            count+=res;\\n        }\\n        return res;\\n    }\\n\\n    public int twoEggDrop(int n) {/*\\n        int left = 0, right = n;\\n        int res = n;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(mid*(mid+1) >= 2*n){\\n                res = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n*/\\n        return cnt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int cnt(int n){\\n        int count=1;\\n        int res =1;\\n        while(count < n){\\n            res++;\\n            count+=res;\\n        }\\n        return res;\\n    }\\n\\n    public int twoEggDrop(int n) {/*\\n        int left = 0, right = n;\\n        int res = n;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(mid*(mid+1) >= 2*n){\\n                res = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n*/\\n        return cnt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066660,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int floors,int eggs){\\n        if(floors <= 1 || eggs == 1)\\n            return floors;\\n        if(dp[floors][eggs] != -1)\\n            return dp[floors][eggs];\\n        int ans = INT_MAX;\\n        for(int i = 1;i <= floors;i++){\\n            int a = max(solve(i-1,eggs-1),solve(floors-i,eggs))+1;\\n            ans = min(ans,a);\\n        }\\n        return dp[floors][eggs] = ans;\\n    }\\n    int twoEggDrop(int n) {\\n        dp = vector<vector<int>>(n+1,vector<int>(3,-1));\\n        return solve(n,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int floors,int eggs){\\n        if(floors <= 1 || eggs == 1)\\n            return floors;\\n        if(dp[floors][eggs] != -1)\\n            return dp[floors][eggs];\\n        int ans = INT_MAX;\\n        for(int i = 1;i <= floors;i++){\\n            int a = max(solve(i-1,eggs-1),solve(floors-i,eggs))+1;\\n            ans = min(ans,a);\\n        }\\n        return dp[floors][eggs] = ans;\\n    }\\n    int twoEggDrop(int n) {\\n        dp = vector<vector<int>>(n+1,vector<int>(3,-1));\\n        return solve(n,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056904,
                "title": "c-5-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int k=0;\\n        int ans=0;\\n        while(ans<n){\\n            k = k+1;\\n            ans += k;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int k=0;\\n        int ans=0;\\n        while(ans<n){\\n            k = k+1;\\n            ans += k;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044585,
                "title": "shortest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(0)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        n*=2;\\n        for(int i=1;i<50;i++){\\n            if(i*(i+1)>=n)return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        n*=2;\\n        for(int i=1;i<50;i++){\\n            if(i*(i+1)>=n)return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042316,
                "title": "java-simple-and-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n/k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int i = 0;\\n\\n        while(i * (i+1) < 2 * n)\\n           i++;\\n        \\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int i = 0;\\n\\n        while(i * (i+1) < 2 * n)\\n           i++;\\n        \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026838,
                "title": "dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n];\\n        int sub = 1;\\n        dp[n-1] = 1;\\n        int index = 0;\\n\\n        for(int i = n-2; i >= 0; ) {\\n            dp[i] = dp[i+sub] +1;\\n            sub = sub + 1;\\n            int k = i;\\n            i = i - sub;\\n            if(i < 0)\\n                index = k;\\n        }\\n\\n        return dp[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int[] dp = new int[n];\\n        int sub = 1;\\n        dp[n-1] = 1;\\n        int index = 0;\\n\\n        for(int i = n-2; i >= 0; ) {\\n            dp[i] = dp[i+sub] +1;\\n            sub = sub + 1;\\n            int k = i;\\n            i = i - sub;\\n            if(i < 0)\\n                index = k;\\n        }\\n\\n        return dp[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014224,
                "title": "c-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n\\n    int f(int n){\\n        if(n==1)return 1;\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int l=1,r=n,ans=1e7,temp=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            int down = mid-1;  // egg broke\\n            int up = f(n-mid); // egg didnt break;\\n            temp=1+max(up,down);\\n            if(down>up){\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n\\n            ans=min(ans,temp);\\n        }\\n        return dp[n] = ans;\\n    }\\n\\n    int twoEggDrop(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n\\n    int f(int n){\\n        if(n==1)return 1;\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int l=1,r=n,ans=1e7,temp=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            int down = mid-1;  // egg broke\\n            int up = f(n-mid); // egg didnt break;\\n            temp=1+max(up,down);\\n            if(down>up){\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n\\n            ans=min(ans,temp);\\n        }\\n        return dp[n] = ans;\\n    }\\n\\n    int twoEggDrop(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012766,
                "title": "sridharacharya-to-the-rescue-1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you want to find out no. of steps from a floor lets say k then check the no. of steps it is going to take from k - 1<sup>th</sup> floor. Because if you need you need lets say m steps from k<sup>th</sup> floor then you\\'ll need atleast (m) steps or atmost (m + 1).steps. \\n> This is because 1 step to go from k<sup>th</sup> floor to (k - 1)<sup>th</sup> floor & then m steps from there.\\n\\nNow, if you go since it is going to take (m + 1) steps at most try to go back m steps back (from k<sup>th</sup> index) to see if you can do it in lesser amount. If you do this you\\'ll see a pattern emerging. I\\'ll leave that for you to find out.\\n\\n# Approach\\n- Once you see the pattern. You can see that 1 comes 1 time, 2 comes 2 times, 3 comes 3 times, & so on. \\n- Each no. n will end at the value which is equal to the sum of first n natural numbers.\\n- This sum can be respresented by (n * (n + 1)) / 2.\\n- Which can give us a quadratic equation and which I know you can solve.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        return ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010447,
                "title": "rust-easy-100-speed-100-space",
                "content": "![image.png](https://assets.leetcode.com/users/images/004af69d-d253-48e4-af1c-7c7eedb039c0_1694014481.515003.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn two_egg_drop(mut n: i32) -> i32 {\\n        let mut i = 1;\\n        loop{\\n            n -= i;\\n            if n < 1 { return i; }\\n            i += 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn two_egg_drop(mut n: i32) -> i32 {\\n        let mut i = 1;\\n        loop{\\n            n -= i;\\n            if n < 1 { return i; }\\n            i += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998121,
                "title": "easy-python-code-using-naive-approach",
                "content": "# Intuition\\nnumber of floors       -   minimum number of moves\\n    1                  -   1\\n    2                  -   2\\n    3                  -   2\\n    4                  -   3\\n    5                  -   3\\n    6                  -   3\\n    7                  -   4\\n    8                  -   4\\n    9                  -   4\\n    10                 -   4\\n    11                 -   5\\n    12                 -   5\\n    13                 -   5\\n    14                 -   5\\n    15                 -   5\\n\\n\\nObserve the pattern carefully\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        c=1\\n        ans=1\\n        while c!=n:\\n            i=0\\n            while c!=n and i<ans+1:\\n                c+=1;i+=1\\n            ans+=1\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        c=1\\n        ans=1\\n        while c!=n:\\n            i=0\\n            while c!=n and i<ans+1:\\n                c+=1;i+=1\\n            ans+=1\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981706,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int twoEggDrop(int n) {\\n    return superEggDrop(2, n);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int superEggDrop(int k, int N) {\\n    // dp[k][n] := min # of moves to know F with k eggs and n floors\\n    dp.resize(k + 1, vector<int>(N + 1, -1));\\n    return drop(k, N);\\n  }\\n\\n  int drop(int k, int n) {\\n    if (k == 0)  // No eggs -> done\\n      return 0;\\n    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor\\n      return n;\\n    if (n == 0)  // No floor -> done\\n      return 0;\\n    if (n == 1)  // One floor -> drop from that floor\\n      return 1;\\n    if (dp[k][n] != -1)\\n      return dp[k][n];\\n\\n    //   broken[i] := drop(k - 1, i - 1) is increasing w/ i\\n    // unbroken[i] := drop(k,     n - i) is decreasing w/ i\\n    // dp[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n\\n    // Find the first index i s.t broken[i] >= unbroken[i],\\n    // Which minimizes max(broken[i], unbroken[i])\\n\\n    int l = 1;\\n    int r = n + 1;\\n\\n    while (l < r) {\\n      const int m = (l + r) / 2;\\n      const int broken = drop(k - 1, m - 1);\\n      const int unbroken = drop(k, n - m);\\n      if (broken >= unbroken)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return dp[k][n] = 1 + drop(k - 1, l - 1);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int twoEggDrop(int n) {\\n    return superEggDrop(2, n);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int superEggDrop(int k, int N) {\\n    // dp[k][n] := min # of moves to know F with k eggs and n floors\\n    dp.resize(k + 1, vector<int>(N + 1, -1));\\n    return drop(k, N);\\n  }\\n\\n  int drop(int k, int n) {\\n    if (k == 0)  // No eggs -> done\\n      return 0;\\n    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor\\n      return n;\\n    if (n == 0)  // No floor -> done\\n      return 0;\\n    if (n == 1)  // One floor -> drop from that floor\\n      return 1;\\n    if (dp[k][n] != -1)\\n      return dp[k][n];\\n\\n    //   broken[i] := drop(k - 1, i - 1) is increasing w/ i\\n    // unbroken[i] := drop(k,     n - i) is decreasing w/ i\\n    // dp[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n\\n    // Find the first index i s.t broken[i] >= unbroken[i],\\n    // Which minimizes max(broken[i], unbroken[i])\\n\\n    int l = 1;\\n    int r = n + 1;\\n\\n    while (l < r) {\\n      const int m = (l + r) / 2;\\n      const int broken = drop(k - 1, m - 1);\\n      const int unbroken = drop(k, n - m);\\n      if (broken >= unbroken)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return dp[k][n] = 1 + drop(k - 1, l - 1);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978093,
                "title": "single-while-condition-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar twoEggDrop = function(n) {\\n    let count = 1;\\n    while(n>0){\\n        n -= count;\\n        count++\\n    }\\n    return count-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar twoEggDrop = function(n) {\\n    let count = 1;\\n    while(n>0){\\n        n -= count;\\n        count++\\n    }\\n    return count-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970730,
                "title": "java-solution-100-fast-o-1-space-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Problem is a series question where dropping an egg takes place from flores with difference of 1,2,3,4,....upto the 1st floor.\\n\\nsay n=100\\nHere 100 are there , so dropping of an egg takes place from 100, 99, 97, 94,.....9\\n\\nupon close looking 100, 99, 97, 94, 90, 85,.....\\nthe diiference in floor numbers is 1,2,3,4,5,....\\n\\nSo the maximum drops possible is counting of floor numbers till f>=1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare a var c for counting of floors.\\niterate a loop with i=1.\\n    substract the i from n till n>0 and the no of times the loop iterated.\\n        if(n>0)\\n            n=n-i\\n            c=c+1;\\nreturn c value.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int n1=n,c=0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        for(int i=1;i<n1;i++){\\n            if(n>0){\\n                n=n-i;\\n                c=c+1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int twoEggDrop(int n) {\\n        int n1=n,c=0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        for(int i=1;i<n1;i++){\\n            if(n>0){\\n                n=n-i;\\n                c=c+1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1783405,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1717006,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1566393,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1788997,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1810004,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2051064,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2047413,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2029403,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1955456,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1948392,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1783405,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1717006,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1566393,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1788997,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1810004,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2051064,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2047413,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 2029403,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1955456,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            },
            {
                "id": 1948392,
                "content": [
                    {
                        "username": "rohit__27",
                        "content": "My brain has become an omelette.."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Watch this video by Ted-ed for insights.\n\n[Can you solve the egg drop riddle? - Yossi Elran\n](https://www.youtube.com/watch?v=NGtt7GJ1uiM)"
                    },
                    {
                        "username": "leet_eight",
                        "content": "int twoEggDrop(int n) {\\n       int i=1;while((i*(i+1))/2<n)i++;return i;\\n    }"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "They are asking min # drops but then they are saying we are given 2 eggs. Also, how do I know if the egg broke or not?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "How are you supposed to know if the egg breaks or not?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You have to account for both options. So you have to consider the worst case scenario. After how many attempts will you always know at which floor the egg breaks. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "The problem may initially appear unclear, so here are a couple more examples from me:\n\n**Input**: n = 10\n**Output**: 4\n**Explanation**:\nWe have only 2 eggs, so we can safely lose the first egg. The second egg is only used to check floors within a certain range. If we don't check every floor with the second egg, we won't be certain about the floor `f`. With 10 floors, let's try throwing an egg from the 4th floor. If it breaks, we know that `f` is less than 4, and we need to check at most floors 1-3 (inclusive). Otherwise, it's in floors 5-10 (inclusive). We don't need to know if it breaks or not; we need to calculate the length of the longest one path.\nWith the first throw at the 4th floor, the result is 7, as the longest way is 4,5,6,7,8,9,10. But wait, in the second scenario, our egg is not broken, and we can safely throw it again, skipping some floors. Let's say, level 7. If it breaks, we check the range 5-6; if it doesn't, we safely throw it at 9. If it breaks at 9, we check 8; otherwise, we check 10. Let's look at all the options we have:\n1: 4,1,2,3\n2: 4,7,5,6\n3: 4,7,9,8\n4: 4,7,9,10\nIndeed, regardless of the `f` value, we have only 4 scenarios, and the longest one is 4 steps long. In this case, they are all of the same length (but it is not always like that). There is no shorter way to determine ***with certainty*** which floor is the `f` floor, so the result is 4 steps.\n\n**Input**: n = 20\n**Output**: 6\n**Explanation**: Let's examine all the paths for this case:\n1: 5,1,2,3,4 (length = 5)\n2: 5,10,6,7,8,9 (length = 6)\n3: 5,10,14,11,12,13 (length = 6)\n4: 5,10,14,17,15,16 (length = 6)\n5: 5,10,14,17,19,18 (length = 6)\n6: 5,10,14,17,19,20 (length = 6)\nYou don't need to find all the paths, but you need to determine the most optimal way to find the longest path with the least possible number of steps."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Sridharacharya to the rescue.\\n\\nreturn ceil(ceil(-1 + sqrt(1 + 8 * n)) / 2.0);"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How\\'d u get that man?"
                    },
                    {
                        "username": "_numeroUno",
                        "content": " Hint 1: Time complexity is O(n^1/2)\\n Hint 2: After each throw increase the difference b/w previous floor and \\n            current floor by 1"
                    },
                    {
                        "username": "bfay",
                        "content": "complexity is O(1)"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for n=100 how it is 14. Why it can't be 100, Drop the 1st from 100th floor. if first egg breaks then second egg will break between 1-99 floor"
                    },
                    {
                        "username": "Stasinos",
                        "content": "14 is working fine(check the explanation) and is smaller than 100. Example 2 is actually pretty helpful for solving the problem. Check if there\\'s rule applied on the sequence, starting from 100 and moving down to 1."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "This question doesn\\'t make any sense to me"
                    }
                ]
            }
        ]
    }
]