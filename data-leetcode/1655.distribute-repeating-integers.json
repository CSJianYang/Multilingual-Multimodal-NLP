[
    {
        "title": "Defuse the Bomb",
        "question_content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code&nbsp;of length of n&nbsp;and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\n\tIf k > 0, replace the ith number with the sum of the next k numbers.\n\tIf k < 0, replace the ith number with the sum of the previous k numbers.\n\tIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n&nbsp;\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n&nbsp;\nConstraints:\n\n\tn == code.length\n\t1 <= n&nbsp;<= 100\n\t1 <= code[i] <= 100\n\t-(n - 1) <= k <= n - 1",
        "solutions": [
            {
                "id": 935398,
                "title": "java-o-n-100-time-and-space-short-concise-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948726,
                "title": "c-sliding-window-linear-time-and-constant-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935444,
                "title": "clean-python-3-prefix-sum-o-n",
                "content": "Use the prefix sum trick to get range sum in O(1)\\nTime: `O(N)`\\nSpace: `O(N)`\\nThanks @WangQiuc\\'s suggestion.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\\n\\nOne pass\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936749,
                "title": "pyhton3-beats-100-double-the-code-array",
                "content": "Double the ```code``` array so that it\\'s easy to iterate.\\n```class Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k==0: return [0 for i in code]\\n        temp = code\\n        code = code*2\\n        for i in range(len(temp)):\\n            if k>0:\\n                temp[i] = sum(code[i+1:i+k+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        return temp",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code```",
                "codeTag": "Unknown"
            },
            {
                "id": 935478,
                "title": "python-3-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```\\n\\n- for negative k: reverse params and result\\n- calculate sum of k element, then iteratively add new element and remove oldest one.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935457,
                "title": "my-short-easy-to-understand-solution",
                "content": "To deal with this kind of problem, we need to play with the index wisely and carefully, just like defusing a bomb (lol). There are 3 points we need to notice:\\n\\n0. We need to return the result directly if k == 0 based on the problem statement. (I will handle this case specifically, to make it more readable and slightly faster :) )\\n1. We need to do ***%*** to make sure the index is always in-bound when k > 0;\\n2. We need to do ***+code.length*** to make sure it is alway > 0, and ***%*** to make sure the index is always in-bound when k < 0.\\n\\nHere is my code: \\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```\\n\\nPlease upvote if you find this is helpful! :)",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942580,
                "title": "c-easy-solution-brute-force",
                "content": "if you don\\'t know how this code works,you could comment below.\\nI will try my best to answer your question! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218554,
                "title": "very-easy-solution-explained-with-sample-implementation-break-the-cycle-prefix-suffix-sum",
                "content": "*------Please **upvote** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n**Prerequisites -** *Prefix Sum* and *Suffix Sum* of an Array.\\n\\nFirst, we **simplify** the problem by **breaking the cycle.** \\n\\n*****How?*****  Just append the array to itself and the cycle will be broken into a linear array.\\n\\nTake the sample input array **code** as: **[5, 7, 1, 4]**\\nAppending it to itself, we get our new array **arr** as: **[5, 7, 1, 4, 5, 7, 1, 4]**.  We will now use this array for calculation.\\n\\n1. If **k = 0**: Just change all array elements of **code** to **0** and return **code**.\\n\\n2. If **k > 0**:  We calculate the **prefix** sum array **pre** of **arr** and our result for every index **i** would be **pre [i + k] - pre [i]**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**pre:** `[5, 12, 13, 17, 22, 29, 30, 34]`\\n\\n**k = 2**\\n\\nNow, for every index **i**: **code [i]** will become **pre [i + 2] - pre [i]**.\\n\\n**i = 0**: `code [0]` = `pre [0 + 2] - pre [0]` = `pre [2] - pre [0]` = **8**\\n**i = 1**: `code [1]` = `pre [1 + 2] - pre [1]` = `pre [3] - pre [1]` = **5**\\n**i = 2**: `code [2]` = `pre [2 + 2] - pre [2]` = `pre [4] - pre [2]` = **9**\\n**i = 3**: `code [3]` = `pre [3 + 2] - pre [3]` = `pre [5] - pre [3]` = **12**\\n\\nReturn **code** as **`[8, 5, 9, 12]`**\\n\\n3. If **k < 0**:  We calculate the **suffix** sum array **suf** of **arr** and our result for every index **i** would be **suf [i + n - k] - suf [i + n]** where **`n = length (code)`**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**suf:** `[34, 29, 22, 21, 17, 12, 5, 4]`\\n\\n**k = -2**\\n\\nHere, we will proceed in the reverse order (right - to - left) because the suffix sum is calculated from the right - to - left direction.\\n\\nNow, for every index **i**: **code [i]** will become **suf [i + 4 - 2] - suf [i + 4]**.\\n\\n**i = 3**: `code [3]` = `suf [3 + 4 - 2] - suf [3 + 4]` = `suf [5] - suf [7]` = **8**\\n**i = 2**: `code [2]` = `suf [2 + 4 - 2] - suf [2 + 4]` = `suf [4] - suf [6]` = **12**\\n**i = 1**: `code [1]` = `suf [1 + 4 - 2] - suf [1 + 4]` = `suf [3] - suf [5]` = **9**\\n**i = 0**: `code [0]` = `suf [0 + 4 - 2] - suf [0 + 4]` = `suf [2] - suf [4]` = **5**\\n\\nReturn **code** as **`[5, 9, 12, 8]`**\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947553,
                "title": "java-o-n-using-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285276,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153936,
                "title": "simple-and-easy",
                "content": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008102,
                "title": "go-o-n-0ms-2-3mb-sliding-window-with-wrapping-indexes",
                "content": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942554,
                "title": "java-o-n-clear-explanation-beats-100",
                "content": "The idea is that for each index i, we will need to be able to query the sum of the next or prev k numbers - an easy way to achieve this is to cache the prefix sums.\\n\\nHowever, there is the added complexity of circular array so we can simply create a prefix sum array that is twice the normal length. Essentially caching the prefix sums of the array repeated.\\n\\ni.e. For something like A = [1,2,3,4], we can concatentate it with itself to create B = [1,2,3,4,1,2,3,4] so that it is easier to work with when applying circular things. \\n\\nWhen working with A, if k = 3 and i = 1, then normally we would have an add indexes 2, 3 and 4. However, index 4 would in fact be index 0 since we are working with a circular array. With our concatenated array B, we would be able to directly access index 4.\\n\\nTaking this concept 1 step further, we can then prefix sum cache this concatenated version which gives us a prefix sum cache that can find circular ranges. So if k < 0, we can find the range sum of [i-k, i-1] and if k > 0, we can find the range sum of [i+1, i+k].\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971143,
                "title": "javascript-simple",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367476,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482725,
                "title": "defuse-the-bomb",
                "content": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1903674,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384496,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152661,
                "title": "python-3-o-n-sliding-window-with-array-rotation",
                "content": "# Intuition\\nOn close inspection we find that K<0 case solution is just a rotated form of K>0 solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn 0 array for k==0 case and for other case find the next k sum array by sliding window technique and in case the k value is negative then rotate the ans list by k-1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933571,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use a sliding window to maintain sum\\n>**T/S:** O(n)/O(1), where n = size(code), (ignoring space for output)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819345,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599513,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }\\n            j--;\\n        }else{\\n            while(++k<=0){\\n                sum+=code[j--]; \\n            }\\n            j++;\\n            int temp=j;\\n            j=i;\\n            i=temp;\\n        }\\n        \\n        for(int p=0;p<code.length;p++){\\n            res[p]=sum;\\n          //  System.out.println(i+\" \"+j);\\n            j=(j+1)%code.length;\\n            sum=sum+(code[j]-code[i]);\\n            i=(i+1)%code.length;\\n        }\\n        return res;\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304860,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "**Here You Go =>**\\n\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256306,
                "title": "c-straightforward-modulo",
                "content": "![image](https://assets.leetcode.com/users/images/7d3784bc-ac6c-4d88-82be-bd82375afbbc_1657312778.1436577.png)\\n\\n**T->O(n * k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=i-1;count<abs(k);j--){\\n\\t\\t\\t\\t\\t\\tif(j==-1)j=n-1;\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179759,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1674760,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172514,
                "title": "python-beats-99-using-modulus",
                "content": "```\\n```\\nr=[]\\n        n=len(code)\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(n):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(n):\\n                e=i+k\\n                if e>0:\\n                    x=sum(code[e:i])\\n                else:\\n                    x=sum(code[:i])+sum(code[n+e:])\\n                r.append(x)\\n            return r\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010869,
                "title": "java-sum",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }\\n        }else if(k<0){\\n            k=-k;\\n            for(int i=0; i<len; i++){\\n                if(i-k>=0)\\n                    res[i] = sum[i]-sum[i-k];\\n                else\\n                    res[i] += sum[i]+sum[len]-sum[len-k+i];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 941890,
                "title": "simple-5-line-python-faster-than-100-with-comments",
                "content": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938895,
                "title": "javascript-sliding-window",
                "content": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936310,
                "title": "c-presum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935724,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935407,
                "title": "c-easy-solution-100-faster-100-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935382,
                "title": "py3-duplicate-the-array-to-simplify-things",
                "content": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "solutionTags": [],
                "code": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3912887,
                "title": "simple-list-slicing-and-loop-process-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674815,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636938,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436766,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106935,
                "title": "easy-js-solution-in-10-lines",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957477,
                "title": "runtime-55-ms-beats-100-memory-41-9-mb-beats-97-92",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/1fc69f57-672f-4bff-92c0-aa12825dcdb4_1672132892.8528547.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551093,
                "title": "java-brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }\\n           return code;\\n       }\\n        else if(k>0){\\n            \\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i+1;\\n                if(i==code.length-1){\\n                    u=0;\\n                }\\n                for(int j=u;j<code.length;j++){\\n                    \\n                    sum+=code[j];\\n                    count++;\\n                    if(j==code.length-1){\\n                        j=-1;                       \\n                    }\\n                    if(count==k){\\n                        break;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i-1;\\n                if(i==0){\\n                    u=code.length-1;\\n                }\\n                for(int j=u;j>=0;j--){\\n                    sum+=code[j];\\n                    count++;\\n                    if(count==Math.abs(k)){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        j=code.length;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2431302,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323353,
                "title": "c-solution-with-12ms-runtime",
                "content": "Stats for this solution:\\nRuntime: 12 ms, faster than 5.85% of C++ online submissions for Defuse the Bomb.\\nMemory Usage: 8.2 MB, less than 73.28% of C++ online submissions for Defuse the Bomb.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306730,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2051862,
                "title": "c-logic-two-loops-o-n2",
                "content": "Hi there , this is the simple logic that came into my mind at first, with O(n2) complexity\\nwould update a new thread if there comes another logic with better one.\\n\\nCODE- \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks for coming this far!  we can do thiss ! happy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033540,
                "title": "straight-forward-prefix-sum-solution",
                "content": "using a map to keep track of all prefix sum from 0 -> 2 * n - 1, since its a circular array.\\ntime: o(n), space: o(n)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992107,
                "title": "c-solution-t-o-nk-s-1",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985487,
                "title": "short-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967947,
                "title": "simple-javascript-solution-faster-than-70",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862972,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830648,
                "title": "python-solution-using-extra-memory",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818728,
                "title": "python-single-pass-no-reverse-no-if-s",
                "content": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1715964,
                "title": "easy-3-liner-python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640047,
                "title": "c-o-n-time-space-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623992,
                "title": "c-easy-to-understand-brute-force",
                "content": "**Brute force approach\\ntime complexity O(nxk)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603868,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514918,
                "title": "c-0ms-o-n-k-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450462,
                "title": "easy-solution",
                "content": "just go with the flow \\ntwo things \\nto travel in counter clockwise direction:  **(n+j-1)%n**\\nto travel in clockwise direction:  **(n+i)%n**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333655,
                "title": "python-solution",
                "content": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 1235556,
                "title": "python-two-lines-brute-force",
                "content": "Find the correct range based on the value of k, then sum the next/previous k values for each index using list comprehension.\\n\\n```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1218451,
                "title": "100-python-array-concatenation-prefix-sum",
                "content": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218059,
                "title": "javascript-solution",
                "content": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207790,
                "title": "python-94",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175703,
                "title": "100-efficient-solution-c",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=k;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n\\n                ans.push_back(s);\\n                k++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n        }\\n        else if(k < 0){\\n            t=abs(k);\\n            reverse(code.begin(),code.end());\\n            cout<<code.size();\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(t==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=t;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n                ans.push_back(s);\\n                t++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else if(k==0){\\n             for(int i=1;i<=code.size()/2;i++){\\n                 ans.push_back(0);\\n             }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1173463,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172511,
                "title": "using-modulus",
                "content": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114740,
                "title": "c-stupidly-concise",
                "content": "Sliding window. \\n\\n`i` is left, `j` is right, `n` is the sum of the current window. Keep moving `j` to the right, adding in whatever value we hit to our sum. \\n\\nIf the total window size hits the limit, pull up the left hand side of the window and drop the value at that index from our sum. Then set this sum into the correct index - just before the start of the window if `k` is positive, and just after the end of the window if `k` is negative.\\n```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094993,
                "title": "python-solution-array-prefix-sum",
                "content": "Array Prefix sum approach.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080903,
                "title": "c-concise-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069062,
                "title": "java-100",
                "content": "1. Calculation and its sequence are same for both directions.\\n2. If k is negative, rotate the result and return\\n```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054478,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051935,
                "title": "0ms-simple-c-solution",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036396,
                "title": "simple-c-with-circle-arr-comment-100-faster-85-better-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029160,
                "title": "simple-c-solution-100-faster",
                "content": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "solutionTags": [],
                "code": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029000,
                "title": "c-optimized-code-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }\\n        int check;\\n        if(k>0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n               int sum=0;\\n               check=k;\\n               j=i+1;\\n               while(check--)\\n               {\\n                    j=j%n;\\n                   sum+=code[j];\\n                   j++;\\n                   \\n                   \\n               }\\n                v[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                check=-k;\\n                j=i-1;\\n                if(j==-1)\\n                {\\n                    j=n-1;\\n                }\\n                while(check--)\\n                {\\n                    if(j==-1)\\n                    {\\n                        j=n-1;\\n                    }\\n                    sum+=code[j];\\n                    j--;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n       \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1003515,
                "title": "python3-easy-solution-with-list-index-manipulation",
                "content": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "codeTag": "Python3"
            },
            {
                "id": 992601,
                "title": "java-brute-force-solution-beats-47-08",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984880,
                "title": "rust-o-n",
                "content": "Working through those type conversions, a prev sol helped. :) \\n\\n\\n```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967756,
                "title": "simple-python-solution",
                "content": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "solutionTags": [],
                "code": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "codeTag": "Unknown"
            },
            {
                "id": 963902,
                "title": "go-solution-0ms-2-5mb",
                "content": "The idea is to form a temp slice that mimic the feature of circular array. It\\'ll be easy to locate the target elements, but with cost of higher memory usage.\\neg: \\nInput: code = [5,7,1,4] , k = -2\\ntemp would become  [5,7,1,4,**5,7,1,4**,5,7,1,4]\\n\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959724,
                "title": "c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950114,
                "title": "java-solution-brute-force",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943955,
                "title": "python-3-without-modulo-94-time",
                "content": "Quite a lengthy code but it does the job.\\n\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938270,
                "title": "more-understandable",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937967,
                "title": "c-o-n-time-o-1-additional-space",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936993,
                "title": "java-10-liner-o-n",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936660,
                "title": "java-0ms-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936226,
                "title": "defuse-the-bomb",
                "content": "c++  solution \\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935446,
                "title": "javascript-o-n-k-time-complexity",
                "content": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935431,
                "title": "easy-to-understand-o-nk-soln",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935393,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935391,
                "title": "java-simple-o-nk-and-sliding-window-o-n-time-solutions",
                "content": "`O(NK)` time solutions:\\nJust do what is asked in the question\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n`O(N)` time solution\\nCompute sum for the first element. Continue computing sum for others maintaining sliding window\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935388,
                "title": "java-0-ms-faster-than-100-00-39-4-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935385,
                "title": "brute-force-java",
                "content": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935371,
                "title": "kt-js-py3-cpp-one-step-at-a-time",
                "content": "**Synopsis:**\\n\\nGenerate the answer `ans` one step at a time by accumulating the total sum of the `K` values adjacent to-the-right of each `i`<sup>th</sup> element of the input array `A`.  To simplify the code when `K` is negative, simply reverse `A` and return the reversed answer using positive `K`.\\n\\n---\\n\\n**Bi-Weekly Contest 39 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/2c2f0b1a-650d-43dc-bb60-fbd2340d74c1_1605370887.2933993.png)\\n\\nhttps://www.youtube.com/watch?v=tOBm0jYytpc\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090277,
                "title": "loop-solution-time-complexity-o-n-k",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe inner loop iterates from 1 to the absolute value of k (inclusive). The purpose of this loop is to perform a certain number of shifts on the code list elements.\\n\\nInside this nested loop, there\\'s a conditional statement that checks whether k is greater than 0. If it is, it calculates the new value of newNum by adding the code element at the index (i+j)%n to newNum. If k is less than 0, it calculates newNum by adding the code element at the index (i-j)%n to newNum.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088740,
                "title": "easy-to-understand-java-solution-takes-only-1ms-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078307,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072718,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4064331,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060974,
                "title": "2ms-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055984,
                "title": "simpler-as-much-for-beginner-beatz-100",
                "content": "## Complexity\\n####  Time complexity: O(n^2) \\n#### Space complexity: O(n) \\n\\n## Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038589,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034311,
                "title": "beats-100-with-0ms-optimal-solution-with-explanation-tc-o-n-sc-o-n",
                "content": "# Intuition\\nk is basically a window of elements and we see this window moving across as we move ahead to populate our indices in the new array.\\n\\n# Approach\\nWe break down the problem into 3 parts. k==0 is straight forward. Our window slides for K>0 and K<0. the movement of the window is same, its just the starting and ending indices we have to identify for the different tow different cases of k. Once we do that we just create a for loop where we slide our window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) and I believe it can\\'t be lower than that as we are supposed to return an array and we should always create a new one rather than modifying our input unless asked to.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033458,
                "title": "one-line-solution-using-a-cyclic-iterator",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\\n> More readable\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020155,
                "title": "beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968965,
                "title": "c-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964778,
                "title": "sliding-window-reverse",
                "content": "# Intuition\\nWe can use sliding window for k > 0, for k < 0 we can reverse input and calculated outout.\\n\\n# Approach\\nFor k > 0, we can start by calculating first value with index 0, and sum from 1 to k.\\nNext we need to update n numbers, on each step we remove i + 1, element from the sum and add, k + i + 1 element to it. Use % of n to ensure data is read from ring buffer.\\nFor case when k < 0 we need to reverse input and output.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948273,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942997,
                "title": "java-straightforward-t-s-o-m-runtime-78-80-1-ms-memory-93-29-41-1-mb",
                "content": "# Intuition & Approach\\nThis `decrypt` method that takes an integer array `code` and an integer `k` as input, and it returns an integer array `decrypt` as output. The purpose of this method is to \"decrypt\" the input array `code` using the given value of `k`. \\n\\n**Let\\'s break down the code step by step:**\\n\\n```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n````\\nHere, the method starts by defining a few variables:\\n\\n- `M` represents the length of the input array `code`.\\n\\n- An integer array `decrypt` is created with the same length as `code` to store the decrypted values.\\n\\n- The `if` condition checks if `k` is equal to `0`. If `k` is indeed `0`, then the decrypt array is returned as is (in accordance with the instructions), and the method terminates.\\n\\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\\nIf `k` is not `0`, the method proceeds to this loop. This loop iterates through each index `i` of the `code` array. Here\\'s what happens in each iteration:\\n\\n- A variable `sgn` is set to either `-1` or `1` based on whether `k` is *negative* or *positive*. This is used to control the direction of decryption.\\n\\n- A variable `e` is set to the absolute value of `k`. This determines how many *steps of decryption will be performed*.\\n\\n- An integer variable `v` is initialized to `0`. This variable will accumulate the decrypted value for the current index `i`.\\n\\n- A variable `adj` is set to `M + i` if `k` is negative, or simply `i` if `k` is positive. This `adj` value is used to adjust the index when accessing elements from the `code` array.\\n\\n- An inner loop runs `e` times. In each iteration of the inner loop, it adds the value at the adjusted index `(adj + sgn * j) % M` to the variable `v`.\\n\\n- After the inner loop completes, the decrypted value for the current index `i` is stored in the `decrypt` array.\\n\\nFinally, the decrypted array `decrypt` is returned after the loop has processed all indices of the `code` array.\\n\\nIn summary, `decrypt` method decrypts the input code array by performing a series of circular shifts based on the value of `k`, and the result is stored in the `decrypt` array.\\n\\n\\n# Complexity\\n- Time complexity: $$T(M * e) = O(M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n```\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914589,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885410,
                "title": "runtime-54ms-memory-43-10-mb-easy-for-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874629,
                "title": "simple-c-solution",
                "content": "# Intuition\\nGenerate the array just the way it is described in the problem description.\\n\\n# Approach\\nCreate an array of the same size, as all operations are done simultaneously, which means we should not edit the original array.\\n\\nFor every index in the array, we sum all the values that we need. \\n\\nsteps: the amount of steps we make. We have to make a total of abs(k) steps.\\nindex: The index of the value we add to sum. We have code to wrap it around if it goes beyond the array bounds.\\nsum: Sum of the values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868122,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861654,
                "title": "by-07chorno-c-o-ms-beats-1oo-the-best-answer-click-now-to-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838391,
                "title": "1652-defuse-the-bomb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817286,
                "title": "my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814537,
                "title": "using-fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810699,
                "title": "easy-sliding-window-solution-beats-100",
                "content": "\\n# Approach\\nI think this is minor variation of fixed sliding window. \\n1. Here window is fixed however windowstart and windowEnd isn\\'t starting with 0.\\n2. Main idea is how to initialise windowStart i.e. l and windoEnd i.e r. If  k> 0 then l=1 and r=1. Else for negative k -> l,r= code.length + k i.e. if k=-2 and n=4 then l,r = 2\\n3. Like most of sliding window solutions, we will iterate for Math.abs(k) to calculate sum of window. And doing that, we will increment r. We make sure that r is reinitiaze to 0 when it reaches end of array.\\n4. Once we have the window sum, then it is easy sliding window with maintaining boundry condition for both l and r;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809538,
                "title": "defuse-the-bomb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797556,
                "title": "c-sliding-window-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto work on the circular array .We just need to think of modulo everytime we want to acess the next\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781729,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3763431,
                "title": "easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732757,
                "title": "solution-1652-defuse-the-bomb",
                "content": "# Intuition\\nThe code aims to decrypt an array of integers using a given key. It iterates through each element in the input array and calls the helperSum function to calculate the decrypted value. The helperSum function calculates the sum of elements based on the given key and the starting index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732315,
                "title": "easy-ts-solution",
                "content": "# Code\\n```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726835,
                "title": "basic-and-explained-c-solution-easy-to-understand-array-basics-beginner-friendly",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `decrypt`. This function takes a reference to a vector of integers `code` and an integer `k` as input. It aims to decrypt the given code using a specific algorithm.\\n\\n\\n# Approach\\nNow, let\\'s go through the code step by step:\\n\\n1. The code starts with an `if` condition that checks if `k` is equal to 0. If this condition is true, it means there is no encryption to decrypt, so the function creates a new vector `ans` with the same size as `code` and fills it with 0s. This is done to return a vector of zeros as the decryption result.\\n\\n2. If `k` is not equal to 0, the code proceeds to the main decryption logic. It initializes an empty vector `ans` to store the decryption results.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `code` vector. Inside this loop:\\n   - It initializes `sum` and `count` variables to 0, which will be used to calculate the sum of elements and keep track of the number of elements considered.\\n   - It checks if `k` is greater than 0. If `k` is positive, it means we need to decrypt the code in the forward direction.\\n     - If the current index `i` is the last index of `code`, a nested `for` loop is used to iterate from the first element to the `k`th element of `code`. It calculates the sum of these elements and increments the `count` variable.\\n     - If the current index `i` is not the last index, another nested `for` loop is used to iterate from the next index to `k` elements ahead, wrapping around to the beginning if necessary. Again, it calculates the sum of these elements and increments the `count` variable.\\n   - If `k` is less than or equal to 0, it means we need to decrypt the code in the backward direction. The logic is similar to the forward direction, but it iterates in reverse order and wraps around from the last index to the beginning if necessary.\\n   - Finally, the calculated `sum` is added to the `ans` vector.\\n\\n4. After the loop finishes, the function returns the `ans` vector containing the decrypted code.\\n\\n- # Complexity\\n- Time complexity : The code uses two nested loops, each iterating over the elements of the `code` vector. Therefore, the time complexity is O(n^2), where n is the size of the vector.\\n- - Space complexity : The space complexity is O(n) as it uses additional space to store the decrypted code in the `ans` vector, which has the same size as `code`.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/34d33a9f-faca-4c62-9e31-54d0b6ef0d2b_1688640507.0608313.gif)\\n\\n![upvote-raccoon.gif](https://assets.leetcode.com/users/images/e6ce0476-7e4e-47de-b6ba-05c64c207f7e_1688640515.7785654.gif)\\n\\n#Please do Upvote if you find the solution good\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701654,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692467,
                "title": "day-30",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n * abs(k)), \\n        where n is the length of the code list. This is because for\\n        each element in code, we perform a loop of length abs(k)\\n        to calculate the sum.\\n- Space complexity:\\n-       O(n) \\n        because we create a new list result of size n\\n        to store the decrypted code.\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689987,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681291,
                "title": "sliding-window-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680405,
                "title": "harshi-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673326,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665514,
                "title": "naive-method-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653280,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645630,
                "title": "go-solution-bomb-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641800,
                "title": "java-easy-beginner-friendly-solution-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629016,
                "title": "defuse-the-bomb-js-intuitive-solution",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616240,
                "title": "c-100-faster-circular-sliding-window-with-explanation",
                "content": "# Intuition\\nThe problem clearly deals with an array and sub-array with a window size of k.\\n# Approach\\n3 cases:\\n 1. k==0 return res(output array) as it is with all 0s\\n 2. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. \\nElement to be updated given by i-1\\n 3. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. Element to be updated given by (j+1)%array.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1) - excluding the output array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578348,
                "title": "100-time-beat-memory-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576292,
                "title": "lets-defuse-it-yeahhhhhhhhhhhhhh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to replace each element in the given code array with the sum of the k elements that come after it (if k > 0) or before it (if k < 0), considering the array wraps around. The intuition is to iterate through the code array and calculate the replacement value based on the specified rules.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution iterates through the code array, calling the ReplaceNum function for each element. In ReplaceNum, the replacement value is calculated by iterating k times in the specified direction (forward or backward), summing up the values encountered. The index is adjusted using the modulo operator for wrapping around the array.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3574874,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570432,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562620,
                "title": "beginner-friendly-solution-to-the-problem-2ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559879,
                "title": "python-beat-93",
                "content": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559649,
                "title": "solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556345,
                "title": "defuse-the-bomb-java-easy",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556131,
                "title": "simple-and-easy-approch",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552363,
                "title": "java-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743482,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 2043876,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1913659,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1734530,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Deletions to Make String Balanced",
        "question_content": "<p>You are given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>​​​​.</p>\n\n<p>You can delete any number of characters in <code>s</code> to make <code>s</code> <strong>balanced</strong>. <code>s</code> is <strong>balanced</strong> if there is no pair of indices <code>(i,j)</code> such that <code>i &lt; j</code> and <code>s[i] = &#39;b&#39;</code> and <code>s[j]= &#39;a&#39;</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of deletions needed to make </em><code>s</code><em> <strong>balanced</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aababbab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can either:\nDelete the characters at 0-indexed positions 2 and 6 (&quot;aa<u>b</u>abb<u>a</u>b&quot; -&gt; &quot;aaabbb&quot;), or\nDelete the characters at 0-indexed positions 3 and 6 (&quot;aab<u>a</u>bb<u>a</u>b&quot; -&gt; &quot;aabbbb&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbaaaaabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The only solution is to delete the first two characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is&nbsp;<code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>​​.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935701,
                "title": "dp-solution-beats-100-with-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997750,
                "title": "6-different-approaches-from-basic-to-the-most-optimal-c",
                "content": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935373,
                "title": "c-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936436,
                "title": "java-python-3-two-codes-1-pass-and-2-passes-w-brief-explanation-and-analysis",
                "content": "**Method 1: Use stack to cancel bad pairs**\\n\\nWhenever encounter a pair of `\"ba\"`, cancel both of them and count the number of cancellations; \\nWhy this works? \\nWhether delete `a` or `b` depending on the the character right after the last cancellation is `a` or `b`; If `a`, we have to delete `b`\\'s in all cancellations, otherwise delete either `a`\\'s or `b`\\'s. Therefore, we are sure there is no `ba` in the string.\\n\\n\\n**Q & A:**\\n\\nQ1: For this approach, it seems to be that it is more of `finding the number of deletions` rather than the `minimum` number of deletions. is there a proof that using a stack and cancelling bad pairs would lead us to the minimum deletions rather than just finding the number of deletions?\\nA1: All indices of character(s) inside stack are less than that  of those outside. Therefore, whenever we find a `\\'b\\'` inside and a `\\'a\\'` outside of the stack, we have to delete 1 (either `\\'a\\'` or `\\'b\\'`) to make the string balanced. In short, if there are total n bad pairs, then there must be n `\\'b\\'`\\'s in front of n `\\'a\\'`\\'s, and the n is the minimum deletions.\\n\\n**End of Q & A**.\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime & space: O(n), n = s.length().\\n\\n----\\n\\n**Method 2: Two passes with space O(1).**\\n\\nCount the total occurrences of `\\'a\\'` on the right and `\\'b\\'` on the left for each index, find the mininum;\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), n = s.length().\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935464,
                "title": "python-dp-o-n-short-with-explanation",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```\\nThe problem can be formulated as DP.\\n\\nAt every point when you see  \\'a\\' , you have 2 options, \\n1. remove all the b\\'s you found earlier.  --> total cost = count_of_b\\nOR\\n2. delete the current \\'a\\'. --> total cost = cur_total_cost + 1\\n\\nIf u see a \\'b\\' , then no more cost.\\n\\nThus maintain the count of \\'b\\'s you found. \\n\\nPlease Upvote!",
                "solutionTags": [],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935372,
                "title": "c-find-split-location-simple-o-n-time-o-1-mem",
                "content": "My intuition for this problem is to keep track of the extra As and Bs to the right and left of each position and find the position with the minimun extra letters. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935422,
                "title": "python-greedy-iterate-from-the-back",
                "content": "Refer to @wareag1e in the comment, the explanation is way better there.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 935399,
                "title": "c-minimalism-o-n",
                "content": "#### Approach 1: Find the split point\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Simulation\\nWe count the total number of \\'a\\' and \\'b\\'. Then, we \"eat\" all \\'a\\' from the left, and all \\'b\\' from the right.\\n\\nNow, we are at the decision point - do we remove from left of right?\\n\\nIt seems that greedy got accepted - we remove the charracter with the smaller count - but I am still thinking of the proof.\\n\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038781,
                "title": "simple-python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\\n\\nAt every point in our traversal, if we encounter an \"a\", we can either delete every \"b\" up to that point, or we can delete that one \"a\".\\n\\n```result``` keeps a running total of the number of deletions we have made so far to keep the string up until the current point balanced.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\n```result```",
                "codeTag": "Java"
            },
            {
                "id": 1020107,
                "title": "python-dp-solution-easy-to-understand",
                "content": "* O(n) for loop each character of the string s\\n* Track the minimum number of deletions to make a balanced string till current character, either ending with \\'a\\' or \\'b\\'.\\n* In the end, find the min of these two numbers\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935481,
                "title": "java-dp-17-ms-faster-than-100-00-39-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878367,
                "title": "java-simple-and-easy-to-understand-with-comments-o-n-time",
                "content": "The whole problem boils down to the positions of A and B (using A and B instead of \\'a\\' and \\'b\\' so its easier to read and understand). All is good until all the As are before the Bs. It is balanced. It becomes a problem when As appears after Bs.\\n\\nTo solve it, start going through the string, char by char, and keep a count of the Bs (increment it). Once you have your Bs, then if an A appears, then you have to cut down a A for every B (decrement it) only if the count of B is greater than 0. You also need to track the number of decrements of Bs counts (total number of removals).\\n\\nConsider this string - aabbabb\\n\\nAll is well and good until its index = 4 (\\'a\\'). Now the countB = 2, decrement it (becomes 1), and increment the removal (becomes 1).\\n\\n```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943968,
                "title": "java-dp-accepted-explanation",
                "content": "**We use Dynamic programming approach because for each substring we need to consider all cases !**\\n\\nFor the sake of explanation:\\n1. we iterate from left->right\\n2. we consider ideal case for us as \"bbbbbbbbbbbbbbb.......bbb\"\\n\\nWe move from left->right and so we consider the ideal case as all b\\'s because any number of b\\'s is valid as move from left->right(with no a\\'s in between).\\n\\nSo we consider \\'b\\' as our friendly character and \\'a\\' as our enemy .\\n\\n**So whenever we see a \\'b\\' we just increase the bCount by one and our answer for that particular substring(0..i) is dp[idx-1].**\\n\\n**But if we see an \\'a\\' then we need to take into consideration 2 cases :**\\n\\n**case 1:** keep current a. ==> prev chars must be a...a , so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n **case 2:** remove current a ==> prev chars must be a...ab...b, so need to remove current a and whatever makes substring before current i valid which is dp[idx-1]+1;\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912995,
                "title": "python-easy-to-read-and-understand-stack",
                "content": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1025601,
                "title": "c-o-n-time-complexity-and-o-1-space",
                "content": "Greedy. Use bCnt to record count for preserved b (have no way to be replaced by a) up till now, use res to record deletion count.  \\n\\nTraverse string s, for each char ch:\\n(1) If it\\'s b, we don\\'t know whether to delete it or not, only increase bCnt by 1. \\n(2) If it\\'s a, we will make deletion only when bCnt is > 0, which means there\\'re b preserved before and has no way to be replaced by traversed a. We might delete current a, or delete previous b, but we don\\'t know yet since this is decided by furture remainig chars. But no matter what we delete, the deletion cnt res will always increase by 1. Use the greedy idea, even if we delete current a, still decrease bCnt by 1 to indicate this b can be replaced by a if later we need it to be replaced\\n\\neg1. aabba\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1; \\nans: aabb\\n\\neg2. aabbaaa\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1 (aabb, or aaba)\\naabbaa -> res = 2, bCnt = 0 (aabb, or aaaa)\\naabbaaa -> res = 2, bCnt = 0 (aaaaa)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948123,
                "title": "simple-c-solution-beats-90",
                "content": "The idea is really simple; you basically count the number of \\'a\\' characters in the string, and then iterate over the string to count the number of \\'b\\' characters. The sum of these 2 values at a given index is the number of deletions you need to make in order to balance the string. \\n\\nFrom there you simply return the minimum sum (deleteCount);\\n\\n```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510493,
                "title": "c-explained-intuitive-approach",
                "content": "My approach without using DP.\\n\\nThe resultant string must have all `a\\'s` to left and all `b\\'s` to the right.\\n\\n*  Count for every index, `number of b\\'s to there left` call it as array `bvec`\\n*  Count for every index, `number of a\\'s to there right`call it as array `avec`\\n*  Now, to remove all `b` from left and all `a` from right we need one index from which it will be minimum.\\n*  Therefore, we will traverse both the array and find the minimum `bvec[i] + avec[i]` for some `i` where `0 <= i < n`\\n\\nCode : \\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935616,
                "title": "easy-to-understand-solutions-with-optimization",
                "content": "To begin with, we can think about that **if we want to obtain the min deletion, what we can do?** For each index, if we find a pair that is not banlanced, we must do 2 things to make it banlanced:\\n\\n**1. Delete all \\'b\\'s before this index**\\n\\t**2. Delete all \\'a\\'s on and after this index**\\n\\nThen we can compare those **sums of deleting times** to find the min.\\n\\nSo, we can use 2 array, *aSum* represents **how many \\'a\\'s on its right**, *bSum* represents **how many \\'b\\'s on its left**.\\n```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\\n\\nWe also notice that each element in *aSum* and *bSum* is only use once, so **we can change that 2 arrays to 2 variables**:\\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```\\n\\n**Now we can see the space complexity reduce from O(n) to O(1).**\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189982,
                "title": "top-down-dp-and-greedy-solution-c",
                "content": "### Top Down Dynamic Programming\\n\\n182 ms\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\\n\\n### Greedy Approach\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935410,
                "title": "java-get-number-of-a-from-left-and-b-from-right-o-n-time-and-o-n-space",
                "content": "Maintain number of `a` from left and number of `b` from right. Can be solved in `O(1)` space. Here is `O(N)` space solution\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819350,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848583,
                "title": "easy-c-solution-fully-explained",
                "content": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "codeTag": "C++"
            },
            {
                "id": 1674644,
                "title": "c-solution-o-n-time-complexity-beginner-friendly",
                "content": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\\n``` Just counted the pair of \"ba\" in the string. ```\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "solutionTags": [],
                "code": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\n``` Just counted the pair of \"ba\" in the string. ```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "codeTag": "Java"
            },
            {
                "id": 1643636,
                "title": "java-stack-simple-2-solutions-explained",
                "content": "The idea here is to simply push \\'b\\' onto a Stack whenever we encounter it.\\nBut what if we encounter \\'a\\', in this case we check if there is a \\'b\\' present already only then we pop \\'b\\' from the Stack (which signifies a Delete operation).\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\\nA similar solution just without Stack \\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045562,
                "title": "best-and-easiest-solution-o-n-82-faster-solution",
                "content": "same as longest increasing subsequence concept\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939185,
                "title": "python-3-one-pass",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935460,
                "title": "simplest-solution-greedy-o-n",
                "content": "* Given a desired format (`aaa....aaabbbb....bbbb`), lets call the boundary where the transition happens from `a` to `b` as pivot.\\n* To get the desired format, we want to remove all `b` to the left of the pivot. Similarly, we want to remove all `a` to the right of the pivot.\\n* Instead of actually removing, we will keep the counts of `b` to the left of current index and `a` to the right of current index.\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452670,
                "title": "python-stack-beats-95",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000518,
                "title": "java-dp",
                "content": "Store min operation to make length `i` string balanced. To make `i+1` balanced, if `i+1`th character is `b`, keep the same, otherwise either delete all `b`s or delete one more `a` which is one more extra from `i`th result.\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935403,
                "title": "python-o-n",
                "content": "`a_right_count[i]`: the number of a at the right of index i\\n`b_left_count[i]`: the number of b at the left of index i\\n`a_right_count[i] + b_left_count[i]`: the number of deleted characters at index i\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041057,
                "title": "prefix-suffix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309277,
                "title": "dp-with-o-1-space",
                "content": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2186582,
                "title": "c-prefix-suffix",
                "content": "* We want to make a sequence of characters such that all `a\\'s` are on left and all `b\\'s` are on right.\\n\\n * At each index of `s` , Keep all `a\\'s` from left till `i` and keep all `b\\'s`  from right till `i`. **Delete all remaining**. **Find minimum out of those**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075592,
                "title": "java-o-n-solution",
                "content": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1941430,
                "title": "easy-javascript-bidirectional-dp",
                "content": "This uses the same solution from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solution/\\nwhere you count the number of \\'b\\' you need to delete going from the left, and count the number of \\'a\\' you need to delete going from the right.\\nOnce you have a count, you find the min_deletion = left_dpA[i] + right_dpB[i]. Note, the bidirectional left shift and right shift is removed, by incrementing the counter after, which yields an non-inclusive character count. The character at i, can be either \\'a\\' or \\'b\\' and it wouldn\\'t effect the minimum delete because that intersection point will belong to left or right.\\n```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700646,
                "title": "java-o-1-space-o-n-complexity",
                "content": "assume we have got answer for string s, then lets suppose a new character comes and get added\\nwe then have below situations for that new character:\\n1. if it is a \\'b\\' then nothing needed, because \\'b\\' at the end will still be balanced\\n2. if it is a \\'a\\' then number of deletion have to be increased from previous no_of_deletions\\nso new no_of_deletions = no_of_deletions + 1.\\nNow we have 2 counters, no_of_b & no_of_deletions. We will take whichever is lesser of the two.\\n```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "solutionTags": [],
                "code": "```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093898,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965905,
                "title": "c-100-o-n-time-o-1-space-dp-solution-with-explanation",
                "content": "This is classic DP problem. \\n```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\\n\\nNow loop over each char of str\\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\\nNow simply return Min of nda[last], ndb[last]\\nDry Run:\\n____aababbab\\nnda 00112334\\nndb 11011122\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\\nWe can Optimise into O(1) Space since we need only 2 variables\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938408,
                "title": "a-few-solutions",
                "content": "Consider each `i`<sup>th</sup> index as a \"pivot\" position where we can balance `s` via the following 2 operations:\\n\\n1. delete all characters `\\'b\\'`  \\uD83D\\uDC48 to-the-left of `i`\\n2. delete all characters `\\'a\\'`  \\uD83D\\uDC49 to-the-right of `i`\\n\\nLet us denote the results of operation 1 and and operation 2 above as `prefix` and `suffix` correspondingly.  Then we can find the minimum amount of deletions via `prefix[i] + suffix[i] - 1`, ie. add each `i`<sup>th</sup> `prefix` + `i`<sup>th</sup> `suffix` and subtract by `1` (since we only need to delete `\\'a\\'` xor `\\'b\\'`, but *not* both, at each candidate `i`<sup>th</sup> \"pivot\" index).\\n\\n*Example 1:*\\n```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\\n\\n*Example 2:*\\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936514,
                "title": "javascript-time-o-n-space-o-1-100-both",
                "content": "I contrast to counting number of characters to delete, I count characters that I can keep in a balanced string that is subsequence of the whole string and calculate number of chars to delete by extracting it from the total string length. `lena` and `lenb` are lengths of the longest subsequences ending with `a` or `b` respectively. \\n- `a` can be appended only to subsequence ending with `a`, so the length of new subsequence ending with newly added `a` is `lena + 1`.\\n- `b` can be appended both to subsequence ending with `a` or `b` so the length of new subsequence will be `max(lena, lenb) + 1`.\\n```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935437,
                "title": "time-o-n-space-o-1-without-stack",
                "content": "We count number of \\'a\\' and \\'b\\'.\\nAnd during traversing we make a decision:\\n1. either we remove \\'b\\'.\\n2. or we remove all upcoming \\'a\\'.\\n\\n```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935387,
                "title": "python-short-and-simple-5-lines-o-n",
                "content": "If we are standing at some position, to make the string balanced by converting the left side to all *a*\\'s and the right side to all *b*\\'s, we need the number of deletions to equal the number of *b*\\'s on the left plus the number of *a*\\'s on the right.\\n\\nLet\\'s start with imaginary position right before the first (index 0) character. The number of needed deletions is the number of *a*\\'s on the right. To move to the next position in the string (between position 0 and 1, then between position 1 and 2, etc.), we need to subtract 1 from the calculated deletions if the current character is *a* (becase if moves from the right part to the left; thus, the number of needed deletions on the right decreases) and add 1 if the current character is b (becase if moves to the left part from the current position; i.e., the number of needed deletions on the left increases). \\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824481,
                "title": "c-very-easy-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267946,
                "title": "lis-dp-o-n",
                "content": "# Approach\\nThe longest nonstrictly increasing subsequence is computed and then this is subtracted from the length of the input string.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n$n$ is the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198090,
                "title": "very-easy-approach-can-be-used-for-many-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach PREFIX AND SUFFIX SUM\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971585,
                "title": "time-o-n-space-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[ Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/2912351/flip-string-to-monotone-increasing//)\\n\\nExactly Same\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918899,
                "title": "python3-solution-clean-concise-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362604,
                "title": "python3-one-pass-o-1-mem-simple-and-intuitive",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340836,
                "title": "my-java-code-o-n-time-o-1-space",
                "content": "This question is similar to->  [https://leetcode.com/problems/flip-string-to-monotone-increasing/]\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }\\n        int countflips = 0;\\n        int countb = 0;\\n        for(i=i; i < s.length(); i++){\\n            if(s.charAt(i)==\\'a\\') countflips++;\\n            \\n            else countb++;\\n            \\n            countflips = Math.min(countflips, countb);\\n        }    \\n        return countflips;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2288528,
                "title": "this-should-be-classified-as-easy-problem-simple-java-solution",
                "content": "This is a very simple question.\\n\\tThe idea is straightforward, we need to keep a count of all the `\\'b\\'` that we have encountered. If we encounter an `\\'a\\'`, we need to decrement the count of `b`, since we have found more `b`s before `a`s. And doing that, we need to increment `deleteCt` since we have more `b` and we need to remove that.\\n\\n\\n```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228525,
                "title": "faster-than-83-clean-dp-solution-with-explanation",
                "content": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1977265,
                "title": "easy-o-n-time-o-1-space",
                "content": "Basic idea is pretty simple you have to convert string to aaaaa..(n times)bbbb...(m times) so for this, you can select after what index there should be no a\\'s present in the string and before that index there should be no b\\'s. You have to find the index which will give minimum sum of count of: b\\'s from start to index and a\\'s from index to end. Your answer is the sum. \\nSteps:\\n1) Calculate the countA.\\n2) Start iterating by keeping count of a and b, and ans = min(ans,countA-a+b).\\n3) Initially your ans will be countA (no a is considered initially).\\n![image](https://assets.leetcode.com/users/images/6b49cfb3-dbb9-4d2b-83d5-f90030230b8d_1650776896.3743162.png)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775152,
                "title": "java-flip-string-to-monotone-increasing-o-n-time-o-1-space-one-pass",
                "content": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "solutionTags": [],
                "code": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1662781,
                "title": "easy-c-solution-using-stack-start-counting-from-the-end-of-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511951,
                "title": "java-find-divide-point-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406992,
                "title": "3-different-python-easy-solution",
                "content": "# Using stack\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\\n\\n        \\n\\n\\n# Using O(1) space, most optimal\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\\n        \\n        \\n        \\n        \\n        \\n\\n# Using O(n) space\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369807,
                "title": "easy-c-solution-o-n-time-with-explanation",
                "content": "Any time if we see an \\'a\\' we need to make a decision whether we: \\n- delete that \\'a\\'\\n- or delete all the previous \\'b\\'s\\n\\nwe calculate the deletion count for that \\'a\\' depending on which is least expensive - if the number of \\'b\\'s before this \\'a\\' is greater than the deletion count after deleting this \\'a\\' (i.e. +1 to the previous deletion count), then it makes sense NOT to delete all the previous \\'b\\'s because it would prove to be costlier than deleting this \\'a\\'.\\n\\nSimliarly, if the number of \\'b\\'s is lesser than the count of deletion after deleting this \\'a\\', we are better off deleting all the previous \\'b\\'s\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341776,
                "title": "c-pre-computed-arrays-basic-dp-explanation",
                "content": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1272492,
                "title": "c-simple-and-clear-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168221,
                "title": "cpp-dp-change-the-view-of-the-problem",
                "content": "You can change the view of the problem.\\nThe intent of the original problem is to find the minimum.\\nYou can find the maximum subsequence of the original string.\\nThe subsequence is like ->   a\\\\*b\\\\* , and then subtract the length of the subsequence from the original length.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163332,
                "title": "javascript-3-unique-solutions-stack-dp",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n## Solution 1: Stack\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\\n## Solution 2: DP\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\\n## Solution 3\\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133563,
                "title": "c-3-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937912,
                "title": "c-prefix-sum-with-explanation-and-example",
                "content": "A balance string is simply a lexical sorted string (all the `a` appear at left, `b` at right).\\nThe idea is to find the rightmost `a` in the longest balanced string.\\n\\ne.g. `s = \"aababbab\"`\\n\\nif choosing the `a` in index 6 as the last `a`, I will have to delete all the `b` at its left, and all the `a` at its right.\\n```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\\nHowever, if I choose the `a` in index 3, I only have to delete `b` in index 2, `a` in index 6.\\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\\nBy observation, I have to use some way to efficiently get the number of `b`s on a given `a`\\'s left, and the number of `a`s on it\\'s right.\\n\\nThe way to achieve that is to use prefix sum:\\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\\nYou can see that the minimum deletion occurs when you choose `a` at index 1 and 3, which yields the answer `2`.\\n\\nNote: for handling cases that does not contain `a`, I add a dummy `a` infront of the original string. (that does not affect the answer since it is already at it\\'s right place)\\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 935739,
                "title": "python-solution",
                "content": "Initialize `res = [0] * len(s)`, and let `res[i]` be the solution of the problem for `s[:i + 1]`, i.e., `res[i]` is the number of minimum deletions to make `s[:i+1]` balanced. It\\'s easy to see that `res[0] = 0`, because a single character is always balanced. Then we loop `i` over `range(1, len(s))`, we know that if `s[i] == \\'b\\'`, then `res[i] = res[i - 1]`, because a trailing `\\'b\\'` appending to a balanced string will always be balanced. Hence the minimum deletion that makes `s[:i]` balanced will also make `s[:i+1]` balanced; Otherwise if `s[i] == \\'a\\'`, then `res[i] = min(res[i - 1] + 1, count_b)`, where `count_b` is the number of `\\'b\\'`s in `s[:i]`, this is because to make `s[:i+1]` balanced, we have two options -- either delete the last `a`, in which case the minimum deletion to make `s[:i+1]` balanced is `res[i - 1] + 1`, or delete all the `b`s in `s[:i]`, in  which case the minimum deletion to make `s[:i+1]` balanced is `count_b`. The overall minimum is then `res[i] = min(res[i - 1] + 1, count_b)`. Finally, we return `res[-1]` to be the solution of the problem.\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\nSpace complexity can be further reduced to O(1), because we don\\'t really need the array `res`, we only need to save the minimum deletions for the previous iteration.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935455,
                "title": "java-easy-stack-solution",
                "content": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [],
                "code": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935406,
                "title": "c-dp-o-n-easy-to-understand",
                "content": "Algorithm:\\n\\t1. Use DP to record the number of a and b.\\n\\t2. Find the suitable index(How to is in Implementation).\\n\\t3. Erase all \"b\"\\'s left to the index.\\n\\t4. Erase all \"a\"\\'s right to the index.\\n\\nImplementation:\\n\\t1.dp_a records frequency of \"a\" from right to left\\n\\t2.dp_b records frequency of \"b\" from left to right\\n\\t3.sum up dp_a and dp_b and find the smallest value substracted by 1\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935377,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 4030220,
                "title": "c-without-dp-lis-prefix-suffix-o-n-tc-o-1-sc",
                "content": "# Intuition\\nAs also mentioned in Hint , we need to find for every index the number of Bs before it and the number of A\\'s after it and the minimum one will be our answer .\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877461,
                "title": "lis-binary-search-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlength of LIS using binary search.\\n`Result = size of string - lengthOfLIS`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824477,
                "title": "very-easy-stack-solution-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760035,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203527,
                "title": "python-idea-of-moving-partition-with-detailed-explanation-easy-understanding",
                "content": "# Intuition\\nWe need to find a partition such that if we remove the number of \"b\" to the left of that partition and remove the number of \"a\" on the right of that partition we get a balanced string. Details and example is shown below.\\n\\nWe would then check if the number of deletions with that particular partition and checck if this is a candidate for the minimum number of deletions. \\n\\n# Approach\\nWe can visualize the partition as following:-\\n\\nGiven s = \"aababbab\"\\n\\n`Partition at index 0: \" | aababbab \"` -> To make this balanced remove all b\\'s on left of the partition and remove all a\\'s on the right. So with this partition we would convert the string into \"bbbb\" since we would have to remove all a\\'s to the right(no b\\'s on the left of the partition)\\n\\n`Partition at index 1: \" a | ababbab \"` -> Following the above logic we try to convert it to a balanced string \"abbbb\" and check if the resultant string is a candidate for the answer by comparing to the current answer.\\n\\n`Partition at index 2: \" aa | babbab \"` -> possible balanced string is \"aabbbb\". So total 2 deletions of a\\'s on the right\\n\\n`Partition at index 3: \"aab | abbab\"` -> \"aabbb\"\\n`Partition at index 4: \" aaba | bbab \"` -> \"aaabbb\"\\n`Partition at index 5: \" aabab | bab \"` -> \"aaabb\"\\n`Partition at index 6: \" aababb | ab \"` -> \"aaab\"\\n`Partition at index 7: \" aababba | b \"` -> \"aaaab\"\\n`Partition at index 8: \" aababbab | \"` -> \"aaaa\"\\n\\n**Implementation :-**\\nMaintain variables to keep the count of a\\'s on left and right of partition and the number of b\\'s on the left and right. \\n\\nI have named them as `left_a, left_b, right_a, right_b`. Just add or subtract them as we move the partition. \\n\\nRather than explicitly moving a \"partition\" from LEFT to RIGHT, I am adding the characters into the LEFT-HALF of the partition as the implementation becomes easy that way. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086296,
                "title": "python-stack-approach",
                "content": "It is given that the string can be balanced, only if there are no pairs like -> \"ba\" in the string. \\n\\nAnd that\\'s the only thing which will make the string invalid. Hence, what we can do is, whenever we come across a situation where the previous character was a \"b\" but the current character is an \"a\", we know we have to make one deletion here. \\n\\nSo, we can simply use a stack to keep track of all the previous \"b\" and whenever we come across an \"a\", we can then check whether we have a \"b\" in the stack. If yes, it means, one deletion has to be made.\\n\\n```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2793615,
                "title": "python-98-beats-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633113,
                "title": "c-using-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568565,
                "title": "python-solution",
                "content": "use b to count current number of \"b\", use res to keep tracking current solution, res[0] is min deletions needed if keeping current \"a\", res[1] is min deletions needed if not keeping current \"a\".\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524041,
                "title": "monotonic-string-solution",
                "content": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "solutionTags": [],
                "code": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2520410,
                "title": "c-o-n-tc-space-complexity-o-1",
                "content": "* Iterate from last index to \\'0\\'.\\n* Keep the count of \\'a\\'\\n* If \\'b\\' encounters decrease count_of_a and increase your ans by 1\\n\\n\\n\\nclass Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n    }\\n    \\n    \\n    \\n   int minimumDeletions(string s) {\\n      return find_collision(s);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2405583,
                "title": "partition-at-every-index-very-simple-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2383148,
                "title": "no-dp-simple-programming-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271337,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271324,
                "title": "70-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2254688,
                "title": "c-o-n-clean-code-two-approach",
                "content": "### **Approach 1: Without Stack**\\n\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(1).**\\n\\n### **Approach 2: Using Stack**\\n\\nclass Solution {\\npublic:\\n\\n\\tint minimumDeletions(string s) {\\n    int n=s.length();\\n    stack<char> stk;\\n    int c=0;\\n    for(int i=0;i<n;i++) {\\n        if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n\\t\\t\\t\\tstk.pop(),c++;\\n\\t\\t\\telse stk.push(s[i]);\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n**Time: O(N), Space: O(N);**\\n\\nNote: Dry run for better understanding.\\nComment below for doubt or query.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2209310,
                "title": "simple-java-solution-with-o-n-time-and-o-1-space",
                "content": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2181270,
                "title": "o-n-and-o-nlogn-solutions-in-c",
                "content": "**Method 1:** O(NlogN) - Map \\'a\\' -> 0 and \\'b\\' -> 1. Find longest non-decreasing sub-sequence\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\\n\\n**Method 2:** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127919,
                "title": "simple-o-n-java-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108657,
                "title": "simplest-shortest-solution",
                "content": "a = max len string of the form aaa....aaa with possibly 0 a\\nab = max len string of the form aaa...aabb....bb with possibly 0 a and/or 0 b\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032143,
                "title": "python-simple-o-n-find-split-point",
                "content": "Basically, we want the string to end up to be \"aaaaaaaa\", or \"bbbbbbb\" or \"aaaabbbbb\". We just need to find an optimum split point in the string, whereby number of \"b\" to the left of split point + number of \"a\" to the right of split point is the minimum. \\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013333,
                "title": "python-prefix-sum",
                "content": "The question is similar to **926. Flip String to Monotone Increasing.**\\n\\nWe can apply the same logic as in the solution for question 926, create a prefix sum and find the sum of *\\'b\\'* to the left of a position in the string and *\\'a\\'* to the right of the position in the string, this sum would be the number of deletions required to make the string balanced.\\n\\nThen find the minimum of this sum by considering every possible position in the string.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011120,
                "title": "c-dp-tabulation-and-space-optimized-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006722,
                "title": "easy-to-understand-dp-solution-using-python-o-n",
                "content": "First we will create two arrays of n+1 size for storing a\\'s and b\\'s count. Now, the size of array needs to be n+1 because, we want to know that what will be the answer if we want to consider the first and last index.\\nStep1. Traverse the string and store count of a\\'s from left to right in dp_fron, including a on that position, we will start filling array from index 1 not 0\\nStep2. Repeat step1 from Right to Left for b\\'s cound and for this we will start filling from index n-1\\nStep3. We will count the a\\'s count and b\\'s count of each position and store the maximum count.\\nStep4. Subtract the max count with the length of array to get number of elements to remove.\\n```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```\\nThanks for reading it out, hope you finds this solution useful.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1965368,
                "title": "java",
                "content": "\"\"\"\\nclass Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }\\n            else\\n            {\\n                bRight -= 1;\\n                bLeft += 1;\\n            }\\n        }\\n        \\n        minDel = Math.min(minDel, bLeft + aRight);\\n        return minDel;\\n    }\\n    \\n    //Returns the count of character c in the String \\n    private int findCount(String s, char c)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                count += 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1948314,
                "title": "weeb-does-python-c-prefix-suffix-sum",
                "content": "**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}\\n\\n\\t\\t\\t\\tif (s[s.size()-i-1] == \\'b\\') sufSum[s.size()-i-1] += 1 + sufSum[s.size()-i];\\n\\n\\t\\t\\t\\telse{sufSum[s.size()-i-1] += sufSum[s.size()-i];}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxStringLen = 0;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (preSum[i] + sufSum[i] > maxStringLen) maxStringLen = preSum[i] + sufSum[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s.size() - maxStringLen;\\n\\t\\t}\\n\\t};\\n\\nTake a break, watch some anime\\nCheck out **\\u6BBA\\u3057\\u611B (Love of Kill)**\\n\\n\\n# Episodes: 12\\n# Genres: Action, Romance\\n# Themes: Adult Cast, Organized Crime\\n\\nIts a nice anime, watch it",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}",
                "codeTag": "Java"
            },
            {
                "id": 1946583,
                "title": "c-o-1-space-same-as-lc926-simple-solution-with-explanation",
                "content": "We just have two options when current character `s[i]` is `a`, and we already have best solution `res` for `0~i-1` : \\n(1) delete all `b` we have counted before\\n(2) only delete current character, sum with `res`\\nso `res = min(res+1, bcnt)`\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918029,
                "title": "elegant-c-solution",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }\\n            else if(cnt1>0)\\n            {\\n                cnt1--; \\n                cnt2++;  \\n            }\\n            i++;\\n        }\\n        return cnt2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901549,
                "title": "python-o-n-stack-with-explanation",
                "content": "Idea is to count the number of pairs of \"b\" and \"a\" such that \"a\" has appeared after a \"b\"\\n        \\n\\tuse stack\\n            see b? push to stack\\n            see a?\\n                if stack not empty: \\n                     pop from the stack and count it as a deletion \\nTime and space: O(n)\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897453,
                "title": "cpp-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }\\n        vector<int> a(n,0),b(n,0);\\n        if(s[0]==\\'b\\')\\n        {\\n            b[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                b[i]=b[i-1]+1;\\n            }\\n            else\\n            {\\n                b[i]=b[i-1];\\n            }\\n        }\\n        if(s[n-1]==\\'a\\')\\n        {\\n            a[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a[i]=a[i+1]+1;\\n            }\\n            else\\n            {\\n                a[i]=a[i+1];\\n            }\\n        }\\n        int mi=n;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            mi=min(mi,a[i+1]+b[i-1]);\\n        }\\n        if(b[n-1]==n||a[0]==n)\\n            return 0;\\n        mi=min(mi,a[0]);\\n        mi=min(mi,b[n-1]);\\n        return mi;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893179,
                "title": "java-find-the-longest-valid-sequence",
                "content": "This question translates to find the longest valid sequence and the answer would be length of string minus that. \\n\\nLet `a` be the length of a valid sequence that ends with an `a`.\\nLet `b` be the length of a valid sequence that ends with an `b`.\\n\\nCase 1 - When current char equals to a: We increment `a` by 1 as there is no way to transition from a valid sequence that ends with a `b` to `a`.\\nCase 2 - When current char equals to b: We can append this `b` to either `a` or `b` to form a valid sequence, that is, we take from `max(a, b)` and plus 1.\\n\\n\\n```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880018,
                "title": "without-stack-o-1-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873217,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }       \\n        int a=0,b=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a++;\\n                ans=max(ans,a+cntb-b);\\n            }\\n            else\\n            {\\n                b++;\\n                ans=max(ans,a+cntb-b+1);\\n            }\\n            \\n        }\\n        \\n        return n-ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1813674,
                "title": "c-prefix-sum-o-n",
                "content": "**Idea**\\nThere will exist atleast one index `i` before which we have to remove all `b` and after which will have to remove all `a`. Bulid a prefix(`left`) and suffix(`right`) array which contains no. of `b` till index `i` and no. of `a` after index `i` including `i`.\\nThen calculate min no. of operations by `min(left[i-1]+right[i])`. Take care of boundary cases.\\n**Time: O(n)**\\n**Space: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760353,
                "title": "c-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }\\n           \\n           if(count_a == 0)  return 0;\\n           int curCount_b = 0, curCount_a;\\n        \\n           int ans = INT_MAX;\\n        \\n           for(char ch : s){\\n               if(ch == \\'a\\'){\\n                   curCount_a++;\\n                   ans = min(ans, curCount_b + count_a - curCount_a);\\n               }\\n               else {\\n                      ans = min(ans, curCount_b + count_a - curCount_a); \\n                      curCount_b++;\\n               }\\n           }\\n         \\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1754652,
                "title": "javascript-iterative-dynamic-programming-explanation",
                "content": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699321,
                "title": "python3-simple-and-fast-o-n-time-o-1-space",
                "content": "We should loop through the string and keep track of the number of ***a***\\'s in the right side and the number of ***b***\\'s in the left side, the minimum sum of these two counts is the answer.\\n```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641169,
                "title": "c-o-n-time-space-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624492,
                "title": "java-easy-10-line-o-n-o-1-dp-solution",
                "content": "@a: maximum length of valid string end with a\\n@b: maximum length of valid string end with b\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591448,
                "title": "dp-c-easy-to-understand",
                "content": "You can remove only all the \\'a\\' after a certain point and the \\'b\\' before that point.\\nSo you are supposed to find the minimum among all those possible value.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583404,
                "title": "c-time-o-n-space-o-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566086,
                "title": "java-dp-two-states-switch",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }else{\\n                cur_end_a = end_a + 1;\\n                cur_end_b = Math.min(end_a, end_b);\\n            }\\n            end_a = cur_end_a;\\n            end_b = cur_end_b;\\n        }\\n        return Math.min(end_a, end_b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551143,
                "title": "o-1-space-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540821,
                "title": "simple-python-solution",
                "content": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```\\n\\n981MS, 17.8MB",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530385,
                "title": "c-o-n-time-complexity-and-o-1-space-complexity-simple-and-concise-solution",
                "content": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527058,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }\\n            else\\n            {\\n                countA++;\\n            }\\n            countA = Math.min(countA,countB);\\n        }\\n        return countA;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459817,
                "title": "simple-c-solutions-same-as-926-flip-string-to-monotone-increasing",
                "content": "This is same as **problem 926(Flip String to Monotone Increasing)** where we need to **flip** 1\\'s or 0\\'s to make string monotone increasing. Here, we need to **delete** a\\'s or b\\'s to make it increasing.\\n**Explanation**: For every index we can store number of b\\'s before that index (**bs in the code**) and keep a variable **del(required deletions)** and increment it when we see a\\'s and for every index find min of del and number of bs.\\n\\n```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```\\n\\n**Dry run:**\\nex: s= \"aababbab\"\\n(Here we need to delete a\\'s at index 3 and 6 to make s as \"aabbbb\")\\ni=0:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=1:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=2:\\nbs=1, del=0\\ndel= min(del, bs) =>del=  min(1, 0)=0\\ni=3:\\nbs=1, del=1\\ndel= min(del, bs) =>del=  min(1, 1)=1\\ni=4:\\nbs=2, del=1\\ndel= min(del, bs) =>del=  min(1, 2)=1\\ni=5:\\nbs= 3, del= 1\\ndel= min(del, bs) =>del=  min(1, 3)=1\\ni=6:\\nbs= 3, del=2\\ndel= min(del, bs) =>del=  min(2, 3)=2\\ni=7:\\nbs= 4, del=2\\ndel= min(del, bs) =>del=  min(2, 4)=2\\n\\n(Hope this is clear, pls let me know if anything\\'s not clear)\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453672,
                "title": "dp-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }\\n            else\\n            {\\n                dp[i+1]=dp[i];\\n                bcount++;\\n            }\\n        }\\n       return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402109,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395482,
                "title": "c-minimization-maximization-solution-o-n",
                "content": "**Minimization Approach:**\\n\\nThe problem is exactly similar to [926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/). Its solution is described [here](https://leetcode.com/problems/flip-string-to-monotone-increasing/discuss/1395348/C++-Solution-O(N)).\\n\\n\\n```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\\n\\nRuntime: 84 ms, faster than 90.98% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 93.87% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\\n\\n**Maximization Approach:**\\n\\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\\n\\nRuntime: 88 ms, faster than 81.27% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 75.72% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385337,
                "title": "c-simple-intuitive-solution-with-o-1-space",
                "content": "The idea here is to maintain a counter for the number of \\'b\\'.\\nTraversing the string from left to right, when the current character is \\'b\\', simply increment the counter by 1.\\nWhen the current character is \\'a\\', check if the counter is positive. If yes, simply decrement it by 1, and increase the answer by 1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345829,
                "title": "short-c-solution-o-n-time-o-1-space-w-explanation",
                "content": "The resulting string will always be some number of a\\'s then some number of b\\'s\\nSo we know that we need find a split of the string such that the number of b\\'s in the left side + the number of a\\'s on the right side is minimised\\nThis can be done in constant time by first counting how many a\\'s there are in the string then iterate through the string and count the number of a\\'s and b\\'s seen so far. We know the number of a\\'s to the right of the current position is just total number of a\\'s minus current count of a\\'s.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318797,
                "title": "very-intuitive-two-pointer-python-o-n-time-and-o-1-space-solution",
                "content": "The idea is to use two pointers i and j where i traverses from left to right and j traverses from right to left.\\nWhile traversing right, get to the first position where s[i] == \\'b\\' and similarly while traversing left, get to the first position where s[j] == \\'a\\'. We also keep on adjusting the count of \\'a\\' and \\'b\\' accordingly. Now we reach to a point where s[0:i] is all \\'a\\' and s[j+1:] is all \\'b\\'. At this point we need to decide whether we want to delete \\'a\\' or \\'b\\'. So we go greedy and delete that char whose count is less. So if count_a < count_b, we delete char \\'a\\' else we delete char \\'b\\'.\\n\\n```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```\\t\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087213,
                "title": "dp-python-simplest-constant-space-o-n-solution",
                "content": "Idea: The problem can be converted to longest aaa\\\\*bbbb\\\\* subsequence. \\n- t0 means the longest subsequence ending with a. \\n- t1 means the longest subsequence ending with b.\\nTime complexity is O(N)\\nSpace: O(1)\\n```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009031,
                "title": "java-greedy-tc-o-n-space-o-1-17ms-faster-thn-99-with-explained-easily",
                "content": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004397,
                "title": "simplest-c-o-n-without-dp-same-as-monotone-increasing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000047,
                "title": "java-very-easy-to-understand-solution",
                "content": "Question says that there shouldn\\'t be any **b** between **a\\'s sequences** and there shouldn\\'t be any **a** in **b\\'s sequences** and **b\\'s sequences** should be after **a\\'s sequences**.To make the string balance we can try to balance every substring and atlast our string will be balanced.\\n\\n*Intution*\\n1. Loop over the character of s\\n2. If the character is \\'b\\' then we don\\'t need to delete anything.\\n3. Otherwise we have two option.We can delete that character and our delete count increases by 1 or we want to delete every b to get this substring valid.\\n4. Our answer is the minimum of this value.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975389,
                "title": "java-solution-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965912,
                "title": "100-javascript-dp-o-1-space",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955662,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941114,
                "title": "6-line-c-dp-o-n-time-o-1-space-change-the-problem-definition-makes-it-easier",
                "content": "Explain in comments.\\n```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939879,
                "title": "java-solution-easy-to-understand-concise-o-3n",
                "content": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939861,
                "title": "o-n-very-simple-idea",
                "content": "Say the final answer begins at position p in the original string. To make position p a valid position, you have to delete all b\\'s before that position and all a\\'s after that position. Now we just iterate over the string and consider each possible position and try to find a p where number of deletions is minimum :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939204,
                "title": "runtime-beats-98-93-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936487,
                "title": "min-deletions-of-left-b-and-right-a",
                "content": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936468,
                "title": "swift-clean-code-o-n-time-o-1-space",
                "content": "result = length(s) - length of the valid longest subsequence\\n```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936240,
                "title": "minimum-deletions-to-make-string-balanced",
                "content": "Minimum Deletions to Make String Balanced\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935797,
                "title": "java-count-the-number-of-a-s-and-b-s-left-and-right",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935691,
                "title": "java-simple-o-n-dp-solution-beats-100-time-and-space",
                "content": "dp[i] == Number of deletions to balance `str[0, i]`. Also `dp[0] == 0` since it\\'s balanced.\\nNow if we see an `a` then we have two choices\\n\\t- Delete the `a` in which case total steps will be `dp[i-1]+1`\\n\\t- Keep the `a` and delete all preceding `b`, in which case dp[i] = `total b count so far`\\n\\t- We pick the min of the above two\\nIf we see a `b` then nothing needs to be done as `b` at end is legit. We just update counter for number of seen `b`.\\nWe can make it work with no additional space by just tracking the total deletions so far.\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935555,
                "title": "easy-c-100-better-in-time-and-100-better-in-space",
                "content": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935488,
                "title": "simple-python3-time-o-n-space-o-n",
                "content": "1. Counting all \"b\" from left to right, storing in array A.\\n2. Counting all \"a\" from right to left, storing is not needed\\n3. stored value in array A plus actual value of \"b\\' is number of deletions, if the point of \"...ab...\" is here\\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 935418,
                "title": "easy-dp-c-explained-o-n-t-c",
                "content": "***Note : Random people downvote without even reading, do read and if helps dont atleast downvote, Thank You.***\\n***Note: Always welcome for optimisations, changes and advices.***\\n\\n***Intiution***\\n 1) Keep counting the number of encountered \\'b\\', uptill current index.\\n 2) If the current element is \\'b\\' , increse the count, and solution uptill current index will be same as of previous.\\n 3) If the element is an \\'a\\'. two case arise either previous encountered number of \\'b\\' is zero then solution upto current index is same as upto previous, else it will be the minimum of previous solution + 1 and deleting the previously encountered \\'b\\' uptill now.\\n \\n\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935416,
                "title": "python-variant-of-the-longest-increasing-subsequence",
                "content": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935411,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083281,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039498,
                "title": "most-easiest-solution-using-stack-must-see-too-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005377,
                "title": "c-simple-solution-tc-o-n-sc-o-1-explanation",
                "content": "# EXPLANATION \\nAt first we count the number of **\\'a\\'** present in string and store in **a**.\\nThen again traverse in string **s**.\\nIf that char is \\'a\\' then we decrease count of **a** and do **ans=min(ans,a+b)**.\\nElse, then we do **ans=min(ans,a+b)** and increase the count of \\'b\\' in **b**.\\nOur idea is that if current is \\'a\\' then we count the number of \\'b\\' in left of it and the number of \\'a\\' on right of it.\\nElse if that current is \\'b\\' then we count the number of \\'a\\' on right and \\'b\\' on left.\\nFinally return the minimum of it and return as **ans**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002666,
                "title": "without-using-any-extra-space-and-without-using-dp-and-stack-here-is-my-o-n-time-and-o-1-space",
                "content": "# Intuition\\n  **Have a look at the below image :** \\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/18eea307-3a95-4dde-b808-9fded7848a88_1693852109.88309.jpeg)\\n\\nJust a simple approach man as we know that we don\\'t want that our string consist of \\'a\\' character after the \\'b\\' character and we can keep track of this thing from the back of the string because in the beginning we don\\'t know after \\'b\\' how many \\'a\\' were there and before \\'a\\' how many \\'b\\' were there and we don\\'t know whether we will get the minimum deletions at the left end or right hand but at the same time we can keep track of \"ba\" from the end in an easy manner.\\n\\nJust we need to keep the count of \\'a\\' character and as soon as we got the \\'b\\' character then simply we will check if the count of \\'a\\' is greater than 0 and if it that means we need to delete either \\'a\\' or \\'b\\' which will take 1 deletion operation only so in such cases we will increment our answer by 1 and will decrement the count of \\'a\\' by 1 because we have already deleted it.\\n\\nAt the end we will simply return our answer variable which will contains the required answer.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **If you find this helpful then please upvote me :)**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998778,
                "title": "o-n-o-1-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981945,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971463,
                "title": "minimum-deletions-to-make-string-valid-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958486,
                "title": "simple-python3-solution-92-47-simple-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to count the occurrences of \\'a\\' and \\'b\\' characters and use these counts to determine the minimum number of deletions needed to balance the string. We can match \\'a\\' characters with \\'b\\' characters to create pairs and eliminate the need for deletions. The goal is to minimize the total number of deletions required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables a_count and b_count to keep track of the counts of \\'a\\' and \\'b\\' characters encountered in the string, and another variable total_deletions to track the total number of deletions needed.\\n\\n2. Iterate through each character c in the input string s:\\n\\n- If c is \\'a\\':\\n\\n    - If there are \\'b\\' characters encountered before (b_count > 0), it means we can form a balanced pair by matching this \\'a\\' with a \\'b\\', so decrement b_count and increment total_deletions by 1.\\n    - Otherwise, increment a_count by 1, indicating that we\\'ve encountered an \\'a\\' character.\\n\\n- If c is \\'b\\':\\n\\n    - Increment b_count by 1, indicating that we\\'ve encountered a \\'b\\' character.\\n\\n3. After processing all characters, the total_deletions will represent the minimum number of deletions needed to make the string balanced\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 85.96%of users with Python3\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nBeats 92.47%of users with Python3\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958325,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895764,
                "content": [
                    {
                        "username": "Aayush65",
                        "content": "Can anybody tell me why is this giving TLE, when that same (61st test case) is running in 300ms when run in the console.\\nCode:\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \\n        memo = {}\\n        def dp(l: int, r: int) -> int:\\n            if (l, r) in memo:\\n                return memo[(l, r)]\\n            key = (l, r)\\n            while l < r and s[l] == \\'a\\':\\n                l += 1\\n            while r > l and s[r] == \\'b\\':\\n                r -= 1\\n            if l == r:\\n                return 0\\n            res = 1 + min(dp(l + 1, r), dp(l, r - 1))\\n            memo[key] = res\\n            return res\\n            \\n        return dp(0, len(s) - 1)\\n```"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "what is the (61st test case) ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Jumps to Reach Home",
        "question_content": "<p>A certain bug&#39;s home is on the x-axis at position <code>x</code>. Help them get there from position <code>0</code>.</p>\n\n<p>The bug jumps according to the following rules:</p>\n\n<ul>\n\t<li>It can jump exactly <code>a</code> positions <strong>forward</strong> (to the right).</li>\n\t<li>It can jump exactly <code>b</code> positions <strong>backward</strong> (to the left).</li>\n\t<li>It cannot jump backward twice in a row.</li>\n\t<li>It cannot jump to any <code>forbidden</code> positions.</li>\n</ul>\n\n<p>The bug may jump forward <strong>beyond</strong> its home, but it <strong>cannot jump</strong> to positions numbered with <strong>negative</strong> integers.</p>\n\n<p>Given an array of integers <code>forbidden</code>, where <code>forbidden[i]</code> means that the bug cannot jump to the position <code>forbidden[i]</code>, and integers <code>a</code>, <code>b</code>, and <code>x</code>, return <em>the minimum number of jumps needed for the bug to reach its home</em>. If there is no possible sequence of jumps that lands the bug on position <code>x</code>, return <code>-1.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One jump forward (0 -&gt; 16) then one jump backward (16 -&gt; 7) will get the bug home.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forbidden.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code></li>\n\t<li><code>0 &lt;= x &lt;= 2000</code></li>\n\t<li>All the elements in <code>forbidden</code> are distinct.</li>\n\t<li>Position <code>x</code> is not forbidden.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 978357,
                "title": "c-bidirectional-bfs-solution-with-proof-for-search-upper-bound",
                "content": "The main difficulty with this problem is figuring out at what `x` should the search be terminated, since otherwise in the BFS one can keep adding `a` to infinity. Just for this part I think the problem should be labeled \"hard\"`. This problem is also unsolvabe without knowing Bezout\\'s Identity. \\n\\n**Proof that maximum search is capped at `stop = a+b+max(x, max(forbidden))`**:\\n\\nFirst thing to note is that all reachable positions must be a factor of `gcd(a,b)`. This is the result Bezout\\'s Identity (https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity). **Bezout\\'s Identity just states that for some integers `x`, `y`, `z`,`a`, `b`, `x*a+y*b = z*gcd(a,b)`.** \\n\\nWhat this means in the context of this problem, is that by applying `a` size steps forward `x` times and `b` size steps backward `y` times, we must reach some position that is a multiple of `gcd(a,b)`. This part is required to find an upper bound to the BFS search without guessing.\\n\\nFor this proof, there are two cases: `a  >= b` and `a < b`.\\n\\nThe first case is trivial. If `a  = b`, then there is no point going backwards. You will end up at the position you just came from. So if you cannot reach `x` before going beyond `x`, you cannot ever reach `x`. For `a > b`, if you go beyond `x` you can never go back to `x`. So the maximum search boundary for `a >= b` is at `x`, which is less than `stop`. \\n\\nSecond case is the real problem. If `a < b` then technically we can continuously add `a`, and still find some way  to retrace back, since we can keep adding `a` then minus `b` to go back `b-a` steps. However, this is only guaranteed if the path(s) back are not blocked by forbidden positions. Thus to verify if a path is possible, we must at least search past `max(x, max(forbidden))`. \\n\\nPast `max(x, max(forbidden)`, at some point you will start hitting repeat positions. For example, you can reach some position `pos` by going forward once, or by going a few steps forward and some back to reach the same position (this is guaranteed by Bezout\\'s Identity). But the latter should not be considered since you can already reach `pos` in 1 step. This is where the repeats come in. There are an infinitely number of ways to reach `pos`, but only the shortest needs to be considered. \\n\\nSo at what point does the paths start repeating? First we need to find the starting point. Assume `max_ = max(x, max(forbidden))`. The first reachable position is the first pos `p0 = n*gcd(a,b)` such that `p > max_`. Using this definition we can say that all positions `p = p0 + m*gcd(a,b), m >= 0` are reachable. \\n\\nThe next step is to figure when do we stop (for what `m` do we not continue). The intuition is that regardless of how far you  venture out, eventually you need to come back. Otherwise you won\\'t reach `x`. Initially, you must start before `max_`. Since you can only go forward `a`, you will end up at some position `(max_, max_+a]`. Since `gcd(a,b)` is a multiple of `a`, we can say that the positions we can first reach are `[p0, p0+gcd(a,b), p0+2*gcd(a,b), ... p0+a-gcd(a,b)]`. For these positions, we can reach them from \"beyond\" by going back `b`. Thus the positions we can come back from are `gcd(a,b)` multiples in range `[p0+b, p0+a-gcd(a,b)+b]`. This also means that `p0+a-gcd(a,b)+b` is the bound we should stop searching at. This is because of the repeats. We can reach `[p0, p0+a-gcd(a,b)]` from `[p0+b, p0+a-gcd(a,b)+b]` by going back one step. Anything beyond `p0+a-gcd(a,b)+b` will take **at least** 4 or more steps. First you have to go forward `a` to go beyond `p0+a-gcd(a,b)+b`, so you at least end up at `p0+a-gcd(a,b)+b+gcd(a,b) = p0+a+b`, then you go back `b`, and end up at `p0+a > p0+a-gcd(a,b)`. So now you have to at least do another cycle (go forward `a`, go back `b`) to arrive at `p0+a-b`, and in the best scenario `b > gcd(a,b)` you end up in `[p0, p0+a-gcd(a,b)]`. This shows that venturing beyond `p0+a-gcd(a,b)+b` will always lead to higher step count, and thus this is the stopping bound. \\n\\nSo now we know that the maximum boundary is `p0+a-gcd(a,b)+b`. Using description of `p0`, we can say `p0 = max_ + delta = c*gcd(a,b)`, where `delta <= gcd(a,b)`. Thus, we can create an upperbound for `p0` using `p0 = max_ + delta = max_ + gcd(a,b)`. This leads to the upper bound `p0+a-gcd(a,b)+b = max_+gcd(a,b)+a-gcd(a,b)+b = max_+a+b = a+b+max(x, max(forbidden)`. \\n\\n\\nRun-time is `O(max(x,max(forbidden))+a+b)+len(forbiddend)`, space is `O(max(x,max(forbidden))+a+b+len(forbidden))`. \\n\\n```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935384,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false});\\n\\t\\t\\tvisited[0][0] = 1;\\n\\t\\t\\tvisited[1][0] = 1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(!qu.empty()) {\\n\\t\\t\\t\\tint len = qu.size();\\n\\t\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\t\\tif(forward < 5000 && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 936440,
                "title": "java-python-3-bfs-clean-codes-w-brief-explanation-and-analysis",
                "content": "**The key observation of the problem is that the variable to track the bug is a `vector`: direction and position.**\\n1. Use `0/True` and `1/False` to indicate forward and backward directions, respectively;\\n2. The bug at most need to reach `furthest = max(x, forbideen) + a + b` in order to arrive at `x`, hence the range of the position of the bug is `[0, furthest]`;\\n3. Use a Queue to maintain the vectors of the bug, use a Set to avoid forbidden positions and duplicates;\\n```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```\\n\\n**Analysis:**\\n\\nTime & space: O(max(x, max(forbidden)) + a + b).",
                "solutionTags": [],
                "code": "```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935419,
                "title": "python-deque-bfs-o-max-x-max-forbidden-a-b",
                "content": "The problem is actually quite straightforward. \\n\\nWe keep a deque *queue* of the positions to explore, and have an array *jumps* that records the number of jumps needed to reach the position. Forbidden positions in *jumps* are marked with -1.\\n\\nAt every step, we extract a position from *queue*. If we can make a jump forward - we update *jumps*, and add the new position to  *queue*.\\n\\nIf we can make the jump backward - we update *jumps*. As we cannot make two jumps backward, the *queue* is not updated. Instead, we check if we can make next jump forward (after the backward); if yes - we update *jumps* once again, and add the new position to  *queue*.\\n\\nFor performance, I use FIFO to extract positions from *queue*, because their required number of *jumps* is lower.\\n\\n**The role of *max_val***\\n\\nThis variable identifies the max. place for us to explore for solving the problem. It gives enough space after the last forbidden place or after *x* for the frog to try possible places. The basis for the formula is simple: the frog can freely jump backward from the last *a* spaces and not hit the forbidden, and if can jump forward from any of the b places after the last forbidden place.\\n\\nAssume that a=4, b=5. Let max. forbidden = 10. If we put the frog at any of the places in interval [11,19], it can jump to any of the places in the interval: e.g., 11->15->19->14->18->13->17->12->16->11.\\n\\nWe do need this feature, because if say forbidden = [1,2,3,5,6,7,10] and x=11, then the frog can jump to 11 only from 16, with the best path 0->4->8->12->16->11; thus, it needs that extra space beyond x and max(forbidden) to jump around.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159317,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }\\n      \\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0 ; i<forbidden.size();i++)\\n            m[forbidden[i]] = 1;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,0,a,b,x);\\n        if(ans > 1e9)return -1;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 935504,
                "title": "java-bfs-and-dfs-solution",
                "content": "Trick:\\n1.Need monitor both index and direction\\n2.Can\\'t go back twice, so max is Math.max(max value in forbidden, 2000) + 2 * b;\\n\\nDFS\\n```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\\nBFS\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950952,
                "title": "fast-python-and-c-solution-with-explanation-bfs",
                "content": "The objective is to find the minimum number of hops. BFS is the ideal candidate for this question since it will provide the shortest path.\\n**Solution:**\\n1. We start exploring from `0` position. \\n2. At each position, we can either go forward by `a` and go backward by `b`. Thing to note here is we cannot go backward twice in a row so we will maintain a flag `isForward` to signal if the previous jump was a `forward` jump.\\n3. If the previous jump was `isForward` then we have 2 positions we can go to from current position `pos` -> `pos+a` and `pos-b`\\n4. If the previous jump was not `isForward` then we  can go to 1 position only from current position `pos` -> `pos+a`\\n5. To avoid going to the same `pos` multiple times we will maintain a `visited` data-structure which will keep track of already visited positions. We will also add forbidden positions to this data structure.\\n6. The tricky bit is to figure out when the forward limit. Since the question mentions that the max x is 2000. The absolute limit is `2000 + a + b`. As anything beyond this limit will always be greater than x because there is only one backward move allowed. So any position above this limit will not be added to the search queue.\\n7. Keep exploring the positions in the `queue` until you reach destination `x` in which case `return hops` or until the `queue` is empty in which case `return -1`\\n\\nPython\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int limit = 2000 + a + b;\\n        std::queue<std::pair<int, int>> cur;\\n        cur.push({0, 1});\\n        std::unordered_set<int> visited;\\n        for (auto& x : forbidden){\\n            visited.insert(x);\\n        }\\n        \\n        int hops = 0;\\n        while(!cur.empty()){\\n            int size = cur.size();\\n            while(size--){\\n                auto it = cur.front(); cur.pop();\\n                int num = it.first;\\n                int forward = it.second;\\n                if (num == x) return hops;\\n                if (visited.count(num) != 0)\\n                    continue;\\n                visited.insert(num);\\n                if (forward){\\n                    int nxt = num - b;\\n                    if (nxt >= 0){\\n                        cur.push({nxt, 0});\\n                    }\\n                }\\n                int nxt = num + a;\\n                if (nxt <= limit){\\n                    cur.push({nxt, 1});\\n                }\\n            }\\n            ++hops;\\n        }\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935401,
                "title": "python-dfs-issue-with-121-test-case-solved",
                "content": "**UPD:**\\n\\nI believe I have found the issue: I should be able to go back more if my back step is larger than my forward step. Thanks to @ShidaLei\\n for pointing it out.\\n\\n----------------------------------------------------------------------------------------------------------------\\nUpdated, working DFS solution, still not 100% about the \"toofar\" condition, one possibly could come up with test cases where this still breaks:\\n```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\\n\\nTest case, for which I used to end up with  `-1` instead of `121`:\\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1137466,
                "title": "c-recursive-dp-40ms",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375366,
                "title": "c-simple-c-code-2-approach",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357034,
                "title": "c-bfs",
                "content": "simple bfs with only constraint to check previous step. 1 and 0 indicate backward and forward .\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966234,
                "title": "c-easy-to-understand-recursive-memoized-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935424,
                "title": "java-bfs-there-should-be-2-states-for-the-bfs-expansion",
                "content": "Mose people failing some test case is beacuse they use one state. \\nThere should be two state for the expansion :[currentPos,direction]\\n\\n`Additional Question` : why we can beak the position if we pass certain limit?\\nWe must considerate **Two Case**: a>b and  b>a\\n\\n1. if a>b, since we can go backward only 1 time,if x pass certain limit, after we do pos-b, the next step is always pos+a, which will increase the position further, the pos will only keep increasing and we can never go back\\n2. if b>a, in this case, since the backward is larger, we can go back by  at most  (b-a).  Let\\'s say out current pos is Y(Y>x,if not, just go forward).We want to reach x and (Y-x)%(b-a)=0.We may do (Y-x)/(b-a) steps. Y=(b-a)*x. We can see at some point, we can bound the Y \\n\\n\\n\\n```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943895,
                "title": "c-bfs-solution",
                "content": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935517,
                "title": "simple-concise-cpp-bfs",
                "content": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144639,
                "title": "java-bfs-with-details-explanation",
                "content": "Basically, this is a BFS issue, but the details make me crazy.\\n\\nBasically, the idea here is that :\\n- Start from index : 0 with direction forward ( you can set to backward too, if you want)\\n- Go to the next idx  with step `a` and `b`,  but we need to make sure \\n\\t- index  > 0\\n\\t-  if we move backward,  should no backward in a row\\n\\n\\nWith below thought in mind, you will be easily come with below solution:\\n## BFS initial version\\n\\n```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\\n\\n#### issues \\n- you will get timeout for most of the case\\n\\n\\n##### solution\\n- we missed quit conditions in the for loop, so put `value <= 6000` , explantion can be found in the below part.\\n- the change can fixed some failed case, but the funny things is \\n\\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\\n\\nAfter adding logs in the code, there is one impartant thing for the `visitedIdx` is that : \\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\\n\\n## Final Version\\n\\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935575,
                "title": "python-bfs-with-detailed-explanation",
                "content": "The basic setup is to do a BFS starting from position 0, and according to the rules, try to move forward or backward till we reach x. However, there are a few catches:\\n1. We cannot move backward twice in a row. To handle this, we store the state in the queue as `(0,1)` where the first element is the position and the second element is the direction of the last move. If the previous move was in the forward direction, then we can try the backwards direction.\\n2. We may land on the same position (`z`) either by moving forward (`p1 + a = z`) or backward (`p2 - b = z`). To handle this, we will iterate through the queue twice, and process all forward jumps first, then the backward jumps. The reason is because the forward jumps have no restrictions and we land on the same position, so we lose nothing by keeping only the forward jumps.\\n3. We need to bound the positions we search, otherwise the code will run forever. For the lower bound, it is given by the question that we cannot visit negative integers. For the upper bound, it is given by `max(x, max(forbidden)) + a + b`. This value is the largest position that we should explore such that it may be possible to backtrack to the bug\\'s home. For example, `a = 2, b = 3, forbidden = [7], x = 9`. We will take the path: `2 -> 4 -> 6 -> 8 -> 10 -> 12 -> 9`. Thus, at the very end we may need to go past our destination and then backtrack. We need to take into account both `x` and `max(forbidden)` because `max(forbidden)` can be insignificant or e.g. the following input: `forbidden = [10], a = 20, b = 19, x = 101`.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748557,
                "title": "c-bfs-clear-and-concise-solution-with-comments-65-time-78-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885961,
                "title": "c-bfs-easy-to-understand-solution",
                "content": "## **APPROACH**\\n* So consider this vector as graph and for any index i you have two options either to go right for exactly a steps  or left for exactly b steps  but you need to take care that no consectuve back steps(left) are taken.\\n* So to handle this we can keep track of last move in queue itself where before taking left step , we first check whether last move taken was in right or left.\\n* If lastMove was left , then only consider right step right now , but if lastMove was right , consider both left and right move.\\n* But now comes one more problem.\\n* Do we need to mark indexes as visited for both the steps?\\n* Actually not...\\n* See if you reach to some location **Q** through a backward step , now you cannot take one more backward , but it is possible that one backward is the place to reach **X** i.e the final destination.\\n* And also it is possible to reach **Q** from front taking a step and then one backward will reach to **X**.\\n* So to tackle this ,make sure to mark a point as visited only when you visit that from front direction and not from back direction.\\n\\n\\n## **CODE**\\u2714\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\n### **TIME-COMPLEXITY :**\\nO(n) , n=6000\\nFor upper limit in right direction , took 6000 which is 3 times of maximum jump in right , not sure for this , how it works!!\\n### **SPACE-COMPLEXITY:**\\nO(n)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850544,
                "title": "c-solution-bfs-simple-commented",
                "content": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**Please upvote: )**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935774,
                "title": "python3-simple-bfs-100-faster-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935515,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605355,
                "title": "java-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPlease upvote if find helful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978766,
                "title": "python3-bfs-easy-understanding",
                "content": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1540090,
                "title": "simple-bfs-clean-concise-well-coded",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1010334,
                "title": "bfs-javascript",
                "content": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911334,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087392,
                "title": "bfs",
                "content": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1689407,
                "title": "c-easy-bfs-solution-visited-track-dp-exploring-2-possibilities",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182751,
                "title": "python-3-memoization",
                "content": "The tricky part is to figure out the upper bound to stop the DFS. In the worst case, you could jump beyond home to avoid a forbidden point.\\n\\n```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935812,
                "title": "python-faster-than-100-of-python-submissions",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935436,
                "title": "java-bfs-with-simple-comments",
                "content": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935381,
                "title": "c-simulate-steps-using-dfs",
                "content": "> why you dont mark visit move2?\\n\\tans: If we move back we still want to allow forward jump from that index. If we mark them visited then we are blocking forward jump from that index.. which is not correct.\\n\\t\\n> why 4000\\nLooking at the constraint.. we can find that we can do back jump of maximum of 2000. If we have some answer (not -1) we must terminate our forward jump before `4000`. In all other cases it answer will be -1\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241529,
                "title": "python3-bfs-beats-100-with-explanation",
                "content": "# Intuition\\r\\n- We use BFS to find the minimum number of jumps required to reach the target position from the starting position.\\r\\n\\r\\n- We consider two types of moves: a forward jump of size \\'a\\', and a backward jump of size \\'b\\'.\\r\\n\\r\\n- We avoid forbidden positions, jumping backwards twice in a row and jumping into negative positions. \\r\\n\\r\\n- We keep track of positions that we have already visited to avoid revisiting them. Those can be added into set of forbidden positions.\\r\\n\\r\\n- If we cannot reach the target position from the starting position, we return -1.\\r\\n\\r\\n# Approach\\r\\n- We use BFS to explore all possible positions that we can reach from the starting position within a maximum of two forward jumps.\\r\\n- We start by setting upper and lower limits for the search, based on the target position and the highest forbidden position, and the minimum allowed position (0).\\r\\n- We create a queue to keep track of the positions to explore, their corresponding number of steps, and a boolean flag to indicate if we can or cannot make a backward jump from the current position.\\r\\n- For each position in the queue, we explore all possible forward jumps and backward jumps, as long as they are within the upper and lower limits and not forbidden, and we also use the boolean flag to prevent going backwards twice in a row.\\r\\n- If we reach the target position, we return the corresponding number of steps.\\r\\n- If we exhaust all possible positions to explore without reaching the target position, we return -1 to indicate that the target is unreachable\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(U)**\\r\\n- Where U is the upper limit of the search space. In worse case scenario, the algorithm will have to explore all positions between in range(0, U)\\r\\n\\r\\n- Space complexity: **O(U)**\\r\\n- We need to keep track of all positions between 0 and U, and each position can be added to the queue at most once.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085343,
                "title": "java-solution-6-ms-beats-99",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788411,
                "title": "c-2-approaches-dynamic-programming-recursive-memoization-simple-bfs",
                "content": "# Code\\n**IF YOU LIKE PLEASE UPVOTE, HAPPY CODING :)**\\n\\nDP Approach-------\\n\\n```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\\nUsing Simple BFS\\n\\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668948,
                "title": "c-clean-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263310,
                "title": "java-easy-bfs",
                "content": "Wonder why visited has FORWARD, BACKWARD presence?\\nto reach a num, say 10, we do not know if we reach 10 by adding a or subtracting b.\\n```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\\n\\n**If you like the solution, please upvote! Happy Learning!**\\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250752,
                "title": "c-bfs",
                "content": "**Note:**\\nvis[x][0] denotes that we have visited the position x following forward direction (some other point--->x)\\nvis[x][1] denotes that we have visited the position x following backward direction (X<--some other point)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\nplz upvote if u like it",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980115,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920366,
                "title": "java-bfs-faster-than-99-85",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868193,
                "title": "javascript-clean-bfs-99",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605214,
                "title": "c-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525906,
                "title": "java-easy-to-understand-dfs-code-with-explanation-15-ms-faster-than-94-04",
                "content": "**Key points to understand the solution.**\\n1. I have taken all variables which will be commonly used by all recursion calls commonly.\\n2. I have thought of two exit calls that are possible.\\n    a. First is when my currentNode is equal to my valueToReach value;\\n\\tb. If my currNode reaches >6000 ( max of a + max of b + max of c, got the each value from constraint as 2000),         I will simply return.\\n3. Now for understanding that when to mark a node as visited, consider the following diagram.\\n![image](https://assets.leetcode.com/users/images/056e01e4-b28b-4254-91d5-150509aff64c_1634463686.869404.jpeg)\\n4. There are two possibilities to reach from currNode - a ->currNode OR currNode + b -> currNode.\\n5. If we consider reaching to currNode from possibility 1, then there are two children possible currNode + a and currNode -b.\\n6. If we consider reaching to currNode from possibility 2, then there is one child possible i.e currNode -b.\\n7. If we mark currNode as visited because of possibility 2, then we will miss the one child of which will be currNode + a.\\n8. So we will always mark currNode as visited if we are taking a forward step from currNode - a or when previousSetp.equals(\"forward\").\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450316,
                "title": "can-t-understand-how-changing-places-of-the-conditions-work",
                "content": "So I have this code for the problem\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\nThis code is giving me wrong answer for some test cases. But after moving the FORWARD CONDITION below the other if condition, the code seems to work.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code is working fine and I don\\'t undestand why. Can someone help?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027325,
                "title": "c-memoization",
                "content": "\\n```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935583,
                "title": "java-min-jumps-bug-100-fast",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456541,
                "title": "simple-bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788811,
                "title": "python-concise-bfs-easy-understanding",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694374,
                "title": "dfs-works-too",
                "content": "##### Java\\n```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n\\n##### C++\\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522402,
                "title": "python3-bfs-and-my-interpretation-of-how-to-find-the-upper-bound",
                "content": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517465,
                "title": "c-bfs-easy-code-with-comments",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436117,
                "title": "dp-memo-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364299,
                "title": "very-easy-bfs-stepwise-explanation",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```\\ncredits: @77jj",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101575,
                "title": "c-bfs-no-dp",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please Upvote if You like the code and Explanation..!! :):)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092842,
                "title": "javascript-bfs",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053201,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029519,
                "title": "java-bfs-beats-100",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919466,
                "title": "c-bfs-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        int jumps=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto cur=q.front();\\n                q.pop();\\n                if(cur.first==x)\\n                    return jumps;\\n                if(mp[cur.first]==true)\\n                    continue;\\n                mp[cur.first]=true;\\n                if(cur.first-b>=0 && cur.second==0)\\n                    q.push({cur.first-b,1});\\n                if(cur.first<=2000+b)\\n                    q.push({cur.first+a,0});\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1870865,
                "title": "dp-clean-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839974,
                "title": "simple-solution-in-java-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316296,
                "title": "easy-bfs-solution-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248387,
                "title": "bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242963,
                "title": "simple-bfs-solution-cpp",
                "content": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1145505,
                "title": "python-bfs-solution-using-deque",
                "content": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1098702,
                "title": "easiest-bfs-java-solution",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093297,
                "title": "python-java-solution-bfs-faster-than-100-solutions",
                "content": "**Java Solution (15ms)**\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Python Solution (76ms)**\\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083263,
                "title": "c-bfs-with-brief-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052778,
                "title": "python-easy-understanding-bfs-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```\\nA traditional BFS solution by using queue. Each **element** in the queue contains:\\n* `pos`: The current position of the bug;\\n* `step`: The total step;\\n* `back`: Check if the previous step is jumping backward.\\n\\nThe **terminal conditions** is declared in the question:\\n1. `pos < 0`: The bug cannot jump to the negative position;\\n2. `pos in forbidden`: The bug cannot jump to the forbidden position;\\n3. `(pos, back) in visited`: To prevent the bug repeatly jumps between the previous and current position, it is noticeable that jump forward or backward to the position is totally different;\\n4. `pos > limit`: As `0 <= x <= 2000`, the maximum index of position will not beyond `limit`, which `limit = max(x, max(forbidden)) + a + b`.\\n\\nThe **recurrence**:\\n1. Jump forward: `queue.append((pos+a, step+1, False))`;\\n2. Jump backward: `queue.append((pos-b, step+1, True))` if the previoius step jumped forward (`if not back`).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972220,
                "title": "python-recursive-approach-with-comments",
                "content": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967434,
                "title": "the-simplest-bfs-ever-don-t-mark-backward-nodes-as-visited",
                "content": "Only important point is to not mark nodes where we have jumped backward as visited! Because then we could not go from that point backward once more. And we maybe could come to that point from forward direction and then go back. \\n```\\nclass Position {\\n\\tint x;\\n\\tint step;\\n\\tboolean backward;\\n\\t\\n\\tpublic Position(int x, int step, boolean backward) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.step = step;\\n\\t\\tthis.backward = backward;\\n\\t}\\n}\\n\\npublic class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> forbiddenSet = new HashSet<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < forbidden.length; i++) {\\n\\t\\t\\tforbiddenSet.add(forbidden[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t\\n\\t\\tvisited.add(0);\\n\\t\\t\\n\\t\\tQueue<Position> q = new LinkedList<>();\\n\\t\\t\\n\\t\\tif (!forbiddenSet.contains(a)) {\\n\\t\\t\\tq.add(new Position(a, 1, false));\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\n\\t\\t\\tPosition position = q.remove();\\n\\t\\t\\t\\n\\t\\t\\tif (position.x == x) {\\n\\t\\t\\t\\treturn position.step;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x + a <= 6000 && !forbiddenSet.contains(position.x + a)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x + a)) {\\n\\t\\t\\t\\tq.add(new Position(position.x + a, position.step + 1, false));\\n\\t\\t\\t\\tvisited.add(position.x + a);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x - b > 0 && !position.backward && !forbiddenSet.contains(position.x - b)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x - b)) {\\n\\t\\t\\t\\tq.add(new Position(position.x - b, position.step + 1, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 940613,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936219,
                "title": "c-keeping-both-current-and-isback-in-state",
                "content": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935605,
                "title": "python-bfs-faster-than-100",
                "content": "In the first I had the same issue with many people: can\\'t past the test case:\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n\\nThen I updated the code, key is about the visited set, if a position is in visited, we can\\'t ban it, because maybe we can still visit it in another direction. What we need to do is to make sure that we do not visit it in the same way as last time (forward or backward)\\n```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935461,
                "title": "c-dp-solution",
                "content": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```\\n***feel free to ask if having any doubt***",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824089,
                "title": "recursive-solution-memoisation-7-lines-of-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548500,
                "title": "simplest-c-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3037209,
                "title": "recursive-solution-memoization-beats-97-69-runtime-97-85-memory",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Here to solve this problem using Recursive \\n  First we start Recurisve function with start = 0\\n  We have to two moves :\\n    1. go from start to start + forwardJumb\\n    2. go from start to start - backwardJumb\\n But here we make boolean called isBack to make sure we do not \\n Make the second move twice , and check the current state not less than zero or greater than greatest move = 7000 and this \\nstate not forbidden\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*3)\\n- Space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N*3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829346,
                "title": "java-bfs-solution-with-line-by-line-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819352,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760953,
                "title": "java-bfs-easy-to-read-code",
                "content": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575572,
                "title": "c-simple-bfs",
                "content": "* vis[0][i] = 1= i is visited from left side\\n * vis[1][i] = 1= i is visited from the right side\\n * queue = {curr index, bool check}\\n * the bool variable tells us whether we can have a backward jump at this stage or not\\n * store the forbidden coordinates in a set\\n * push 0 into the queue\\n * start traversing, every time we have two options either move forward or backward\\n * check if that is possible or not\\n * if it is then add that one into the queue\\n * if at anytime we arrive at x then return the ans\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550370,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482322,
                "title": "c-clean-bidirectional-bfs-code-with-comments",
                "content": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382606,
                "title": "simple-bfs-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304017,
                "title": "ruby-t-o-n-s-o-n-100-100-bfs",
                "content": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2285421,
                "title": "bfs-c-solution-97-25-faster",
                "content": "```\\nclass Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1});\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n               pair<int,int> cur_vx = q.front();\\n               q.pop();\\n               int par = cur_vx.first;\\n               int dir = cur_vx.second;\\n               if(par==x) return ans;\\n               if(vis[par]==1) continue;\\n               vis[par]=1;\\n                \\n               int l = par - b;\\n               int r = par + a;\\n               if(l>=0 && dir==1) q.push({l,0});\\n               if(par <= 2000 + b ) q.push({r,1});  \\n            } \\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2280533,
                "title": "golang-bfs",
                "content": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n`````",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271420,
                "title": "bfs-c-detailed-solution",
                "content": "```\\n//vis[x][0] --> visited the position x following forward direction \\n//vis[x][1] --> visited the position x following backward direction \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir} [0->forward,1->backward]\\n         q.push({0,0}); // adding starting postion with direction as forward (0)\\n         int end=10000; // constraint(can\\'t go further than this)\\n         vector<vector<int>>vis(end+1,vector<int>(2,0));\\n        \\n        // visit the all forbidden zone\\n        for(auto zone:forbidden){\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        \\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        \\n        //starting point is both forward and backward visited(if we reach starting point in    \\n        //backward direction then we can\\'t go any further because forward of starting was already marked\\n        //in the begenning) and hence it will be a trap state\\n        vis[0][0]=true,vis[0][1]=true;\\n        \\n        \\n        int jumps=0;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                pair<int,int>p=q.front();\\n                q.pop();\\n                \\n                int pos=p.first;\\n                int dir=p.second;\\n                \\n                if(pos==x)return jumps;//destination reached\\n                \\n                 // if this position is travelled with forward direction then we can move forward as   \\n                 // well as backward direction.\\n                if(dir==0){ \\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }\\n                // if this position is travelled with backward direction then we can move only in \\n                //forward direction\\n                else{ \\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir}",
                "codeTag": "Java"
            },
            {
                "id": 2191670,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        for(int i=0;i<n;i++){\\n            mp[fb[i]]=1;\\n        }\\n        vis[{0,0}]=1;\\n        int step=1,fur=6000;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto curr=q.front();\\n                q.pop();\\n                int next_a=curr.first+a;\\n                if(next_a==x) return step;\\n                if(next_a>=0 && next_a<=fur && !vis.count({next_a,1}) && !mp.count(next_a)){\\n                    q.push({next_a,1});\\n                    vis[{next_a,1}]=1;\\n                }\\n                int next_b=curr.first-b;\\n                if(curr.second==1){\\n                    if(next_b==x) return step;\\n                    if(next_b>=0 && next_b<=fur && !vis.count({next_b,0}) && !mp.count(next_b)){\\n                        q.push({next_b,0});\\n                        vis[{next_b,0}]=1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2190113,
                "title": "rust-bfs",
                "content": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165190,
                "title": "c-dp-memoization-fast-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }\\n        return dp[pos][left];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(auto i: forbidden)fob.insert(i);\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solver(0, x, a, b, false);\\n        return (ans >= 1e9)? -1: ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2164391,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143843,
                "title": "c-bfs-easy-to-understand",
                "content": "Simple Level Order Traversal.\\n\\nHow to identify If it\\'s a bfs based problem?\\n\\nThe thumb rule  is that if it asks to find the smallest or shortest type of problem in graph then there are 95% chances  that the problem will be solved with level order traversal using BFS technique. You can solve it recurssively but I think it is better to use BFS as in DFS it can go way deeper and we will get to the ans much later as compared to BFS.\\n\\nYou can optimize the Soln of DFS based approach using Memoization. Check out other threads as well for such soln.\\n\\n6000 was just an assumption of a safe long distance space. You can choice any number greater than 6000, it will work as well.\\n\\nPlease comment down all your doubts if there are any!\\n```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137388,
                "title": "c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130948,
                "title": "python-bfs-solution-beats-93-98",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086839,
                "title": "what-s-wrong-in-this-bfs-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043357,
                "title": "python-solution-problem-is-missing-some-test-cases-or-am-i-wrong",
                "content": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1937436,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928962,
                "title": "java-bfs-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922705,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902702,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893180,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878140,
                "title": "c-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846380,
                "title": "java-intuitive-solution-bfs-easy-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836781,
                "title": "bfs-using-set-with-detail-explanation-with-edge-case",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828097,
                "title": "java-bfs",
                "content": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809146,
                "title": "easy-to-understand-standard-bfs",
                "content": "Don\\'t get confused by all the confusing top answers. Just apply standard bfs with some modifications\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807511,
                "title": "c-bfs-graph-easy-to-understand",
                "content": "\\n\\tclass Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0});\\n        int steps = 0;\\n\\t\\t\\n        while(!q.empty()){\\n            int Size = q.size();\\n            for(int i = 0;i< Size;i++){\\n                auto [pos,times] = q.front();\\n                q.pop();\\n                if(pos < 0 || Map.count(pos) || pos > 10000 || vis.count({pos,times})) continue;\\n                if(pos == x || pos == x) return steps;\\n                vis.insert({pos, times});\\n                q.push({pos + a,0});\\n                if(times == 0) q.push({pos - b,1});\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1484679,
                "title": "java-bfs-solution",
                "content": "\\tclass Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }\\n        \\n        @Override\\n        public String toString()\\n        {\\n            return this.val + \" \" + this.dir;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) \\n    {\\n        if(x == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int steps = 0, furthest = 5000 + 2*b;\\n        Set<Integer> set =  new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        for(int i = 0; i < forbidden.length; i++) \\n        {\\n            set.add(forbidden[i]);\\n            furthest = Math.max(furthest, forbidden[i] + 2*b);\\n        }\\n            \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(0,0));\\n        visited.add(0+\"-\"+0);\\n        steps++;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();   \\n            while(size-- > 0)\\n            {\\n                Node node = queue.poll();\\n                int nexta = node.val+a;\\n                \\n                if(nexta == x)\\n                {\\n                    return steps;\\n                }\\n                \\n                if(nexta >= 0 && nexta <= furthest && !set.contains(nexta) && \\n                   visited.add(nexta+\"-\"+1))\\n                {\\n                    queue.add(new Node(nexta, 1));\\n                }\\n                \\n                if(node.dir == 1)\\n                {\\n                    int nextb = node.val-b;\\n                    if(nextb == x)\\n                    {\\n                        return steps;\\n                    }\\n                    \\n                    if(nextb >= 0 && nextb <= furthest && !set.contains(nextb) && \\n                       visited.add(nextb+\"-\"+0))\\n                    {\\n                        queue.add(new Node(nextb, 0));    \\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1476948,
                "title": "c-dp-recursion",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }\\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //save the forbidden cordinates to fetch in O(1) operation;\\n        for(auto &x :forbidden) mp[x]++; \\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        // here second argument is false beccause at first we can go backward;\\n        int ans=solve(0,false,a,b,x);\\n\\n        if(ans>=1e9) return -1; //\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1416279,
                "title": "c-bfs-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314618,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163359,
                "title": "faster-than-90-and-less-memory-than-92-c",
                "content": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146906,
                "title": "c-bfs-beats-95",
                "content": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112959,
                "title": "help-me-figure-out-what-s-wrong-with-this-bfs",
                "content": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1103362,
                "title": "python3-bfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101895,
                "title": "why-does-it-not-work-if-i-push-next-in-the-queue-first-and-back-after-that",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086369,
                "title": "c-top-down-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065457,
                "title": "both-dfs-memoization-and-bfs-solutions-python",
                "content": "DFS + Memoization\\n\\n```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\\n\\n\\n=============\\n\\nBFS Solution\\n\\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055681,
                "title": "javascript-bfs-solution-with-exmplanation",
                "content": "What I learned from this problem:\\n- reason why the limit is `2000+b`. the limit should be larger than the `(x+b)` or `forbidden_MAX+b`, due to the constraints, both `x` & `forbidden[i]` have a max value of 2000.\\n- use `datastructure/Queue`  or just Array, here just use Array is enough, because no sorting.\\n- destructure from array in ES6( [docs](https://googlechrome.github.io/samples/destructuring-es6/) )\\n\\n\\n```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006979,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003679,
                "title": "wrong-example-in-example-2-why-is-it-1-when-there-exists-a-solution",
                "content": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```\\nWhy is this solution wrong?",
                "solutionTags": [],
                "code": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002763,
                "title": "bfs-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1});\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint num=q.front().first;\\n\\t\\t\\t\\tbool ch=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(num==x)return v[num][ch];\\n\\t\\t\\t\\tif(num+a<n&&v[num+a][0]==-1)\\n\\t\\t\\t\\t\\tq.push({num+a,0}),v[num+a][0]=v[num][ch]+1;\\n\\n\\t\\t\\t\\tif(!ch&&num-b>0&&v[num-b][1]==-1)\\n\\t\\t\\t\\t\\tq.push({num-b,1}),v[num-b][1]=v[num][ch]+1;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 958328,
                "title": "bfs-c",
                "content": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }\\n                if(p.second==0 && p.first-b>0 && m.find(backward)==m.end() && !visited[1][backward])\\n                {\\n                    q.push(make_pair(backward, 1));\\n                    visited[1][backward]=true;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 953184,
                "title": "easy-c-bfs-solution",
                "content": "visited matrix to be marked as done when we can visit forward as well as backward from that particular index.\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951091,
                "title": "easiest-approach-c-explaining-1998-1999-2000-2000-test-case-bfs",
                "content": "**I have applied restriction by 5998 because a=1999,b=2000,x=2000\\nAt max we can make a forward jump of max(a,b)+x\\nWhy?Because we can only make a single backward jump at once and if the region of finding x is in [2000,4000] and we go move any further beyond this range for example 4005 then we wont be able to reach our target x=2000 as 4005(a)-2000(b)=2005 which is inside our range but now we cant move further back because at max only 1 backward jump is allowed . So for the test case beyond the range i have rejected it.\\n**\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false});\\n        vis[0][0]=1;\\n        vis[1][0]=1;\\n        int ans=0;\\n        while(q.size()!=0){\\n            int n=q.size();\\n            while(n-->0){\\n                int cur=q.front().first;\\n                bool flag=q.front().second;\\n                if(cur==x){\\n                    return ans;\\n                }\\n                q.pop();\\n                int forw=cur+a;\\n                int back=cur-b;\\n                if(forw<5998 && vis[0][forw]==0 && !map.count(forw)){\\n                    q.push({forw,false});\\n                    vis[0][forw]=1;\\n                }\\n                if(back>=0 && vis[1][back]==0 && !map.count(back) && !flag){\\n                    q.push({back,true});\\n                    vis[1][back]=1;\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 938985,
                "title": "working-code-passing-all-testcases",
                "content": "Most codes are failing the testcase where the value could go above 4000 , Value can go above 4000 and then come back down ...\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 937899,
                "title": "python-bfs-with-double-queue-80ms",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```\\n* *queueA* is created after forward steps\\n* *queueB* is created after backward steps\\n* if *a >= b* then maximum position is not depending on *b* or *forbidden*\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936339,
                "title": "bfs",
                "content": "Neighbours is formed by the current state of the node.\\nIf current state has moved forward, then we can go either back or forward.\\nIf current state has moved backward, then we can only go forward.\\n\\n\\n```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```\\n\\nSource: https://bit.ly/36AlnAl",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935851,
                "title": "java-very-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935810,
                "title": "java-bfs-set-pair-avoid-fixed-size-visited-array",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935524,
                "title": "java-with-no-need-to-track-state-beats-100",
                "content": "For the life of me I cannot understand why people insist on tacking state (do we go backwards or forwards) in a solution like mine.\\n\\nOnly put positions into the queue that you reached on going back.\\nAnd only go forward from those positions that are in the queue.\\n\\n```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935443,
                "title": "go-bfs",
                "content": "I used BFS to solve this problem.  The basic idea is that you can move backwards only once so used a flag to keep track of that and you can move forwards each time.  I could not get this work without using the visited array.  Also I used 5000 because a,b <=2000 and x<=2000 so I suppose if you travel to 5000 which is about 3000 away from x and b cannot be greater than 2000,  You are not going to have chance to arrive at x, even if it is 2000.  \\n\\n```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935440,
                "title": "dfs-with-c",
                "content": "I should be more careful next time on what states I need to put in the dp and what should not be put. \\n```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935383,
                "title": "86-87-passed-why-bfs-can-t-work-change-2000-4000-it-will-work",
                "content": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "solutionTags": [],
                "code": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 4083736,
                "title": "easy-to-understand-javascript-solution-bfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(maxX*2)$$\\n\\n- Space complexity:\\n$$O(maxX*2)$$\\n\\n# Code\\n```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047716,
                "title": "recursion-memoization-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047456,
                "title": "upper-limit-to-search-with-b-greater-than-a",
                "content": "It\\'s not so difficult to find the upper limit of a breadth first search when $$b <= a$$. \\nFor the upper limit when $$b > a$$, this is a not so math-inclined approach. A movement sequence from A to Z across L like this \\n<pre>\\nM               Z    A      L    \\n|---------------|----|------|---|--|----|\\n                     |---------->      1\\n                                |==>   2\\n                <------------------|   3\\n</pre>\\ncan always be transformed into this without ever touching L\\n<pre>\\nM               Z     A     L      \\n|-|-------------|-----|-----|-----------|\\n  <-------------------|       1     \\n  |==>                        2\\n     |---------->             3\\n</pre>\\nIn the above pictures L stands for some upper limit. Both the first and third movement are single jumps, while the second might be composite of a serious of movements. Since our lovely frog is seeking her way with least jumps as possible, the second movement will never be longer than `b - a`, because if it were, she surely can go back `b - a` position(s) by two more jumps, a contradiction to the optimal assumption.\\nThe transformation can be achieved simply by switching the first the first jump and last jump. That\\'s to say, for any route that goes beyond some upper limit L, and can later go back (and might as well reach x finally),there is a corresponding route that \\n1. reaches the very same destination \\n2. does not goes beyond the limit L\\n3. does not goes back too far away to touch some lower limit which might be dangerous.\\n\\nRemaining task is to decide the accurate position of L which can be quite obvious from the above pictures.  \\n# Code\\n```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034756,
                "title": "easy-solution",
                "content": "# Code\\n```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004958,
                "title": "java-simple-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000642,
                "title": "c-implementation-using-dynamic-programing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3983359,
                "title": "python-boundary-intuition-not-formal-explained",
                "content": "# Intuition\\nIdea is that at each position we have two choices to make: move back or move forward. It is intuitive that to get the fewest number of jumps we can use a BFS exploration.\\n\\nThe more difficult part is how to bound the states: it is possible we might come up with way too many states that have no purpose.\\n\\nThe idea behind the boundary is this: we make an alternative formulation where we want to find a **pos** where there exists a path from **pos** to 0 and **pos** to x (and **pos** is not 0 or x). What is the range of values this starting **pos** can have?\\n\\nx is within 0-2000. Since b is also 0-2000, in order to land on x, we must necessarily pass through some set of nodes between 0-4000 (since we can leap back only 2000 at a time, we can not skip from 4001 to 2000 for example). \\n\\nThis implies that once we have checked states 0-4000, we can determine whether it is possible to reach x and 0 (because if we can\\'t within 0-4000, we can\\'t starting from 4001-infinity either). To check all 4000 states, we again use similar logic: to reach 0-4000, we must have **pos** be within 0-6000. If we can\\'t get to a desired state in 0-4000 from within 0-6000, then we definitely can\\'t do it starting from 6001-infinity, since you\\'ll for sure pass through 4000-6000 with a pos starting outside of 6000. \\n\\nThis means our maximum boundary is roughly 6000 in order to check all 4000 states, which then tells us whether we succeed.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961863,
                "title": "ts-bfs-66ms",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/33300e18-54d5-49a9-b1f0-3705d91c37d2_1693037351.0296571.png)\\n\\n\\n# Code\\n```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938854,
                "title": "easy-solution-java-bfs-beats-89",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933386,
                "title": "full-detailed-commented-solution-in-easy-words-bfs-beats-98-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787228,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773845,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The first solution is confusing as it uses a set to mark the visited sequence. The pair class have methods to help the set to remove the duplicates from it.\\n-  The second solution is quiet efficient as it only uses a boolean array to mark the visited combinations as a idx can be visited from backward and forward directions which is not unique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755172,
                "title": "java-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753701,
                "title": "my-solution",
                "content": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            }
        ]
    },
    {
        "title": "Distribute Repeating Integers",
        "question_content": "<p>You are given an array of <code>n</code> integers, <code>nums</code>, where there are at most <code>50</code> unique values in the array. You are also given an array of <code>m</code> customer order quantities, <code>quantity</code>, where <code>quantity[i]</code> is the amount of integers the <code>i<sup>th</sup></code> customer ordered. Determine if it is possible to distribute <code>nums</code> such that:</p>\n\n<ul>\n\t<li>The <code>i<sup>th</sup></code> customer gets <strong>exactly</strong> <code>quantity[i]</code> integers,</li>\n\t<li>The integers the <code>i<sup>th</sup></code> customer gets are <strong>all equal</strong>, and</li>\n\t<li>Every customer is satisfied.</li>\n</ul>\n\n<p>Return <code>true</code><em> if it is possible to distribute </em><code>nums</code><em> according to the above conditions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], quantity = [2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The 0<sup>th</sup> customer cannot be given two different integers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3], quantity = [2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [3,3]. The integers [1,2] are not used.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2,2], quantity = [2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [1,1], and the 1st customer is given [2,2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>m == quantity.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10</code></li>\n\t<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>There are at most <code>50</code> unique values in <code>nums</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935522,
                "title": "step-by-step-optimization-more-than-10-methods",
                "content": "> This is a very long post.\\n> I\\'ve been thinking about this problem for many days, trying to optimize it.\\n> This post shows step by step how I managed to reach the optimised methods.\\n> But I feel this is not yet the end. If one day I find a better solution, I will come back and update this post.\\n> Hope it helps. :)\\n\\n# Transformation\\n\\nFirst of all, the problem description is kind of... weird. Distributing n repeating numbers to m customers? That is a bit difficult to imagine and understand (at least for me).\\n\\nHowever, let\\'s do a simple \"transformation\", it will immediately become much clearer:\\n- In any case, the first thing we have to do, is ***counting the frequency of each number*** in `nums`. We don\\'t care about what the numbers are, but only the quantity.\\n- For any number, if the quantity of it is >= a customer\\'s order, we can distribute the number to that customer. And of course if the rest quantity of this number can satisfy any other customer\\'s order, we can continue distributing it.\\n\\t- For example, if we have *10* of number `a`, and we have customer orders *5*, *3*, and *1*, we can satisfy all 3 customers by number `a`.\\n- We want to figure out if we can satisfy all customers.\\n\\nNow the problem can be transformed to:\\n\\n> **We have N _containers/boxes/slots_, and we want to fit M _items/objects/sticks_ into them. Or, we want to allocate M chunks of _memory blocks/file spaces_ from fragmented _memory/hard drive_, which have N _continuous free spaces_.**\\n\\nMuch easier to imagine now, isn\\'t it? Code for the transformation would like:\\n\\n```cpp\\nbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\tunordered_map<int, int> fm;\\n\\tfor (int n : nums) ++fm[n];\\n\\tvector<int> counts;\\n\\tfor (auto [ignore, f] : fm) counts.push_back(f);\\n\\treturn CanAllFit(counts, quantity);\\n}\\n\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n    // ...\\n}\\n```\\n\\nFrom now on, I will be only talk about **fitting _ITEMS_ into _CONTAINERS_**, and show how to implement the `CanAllFit(contSize, itemSize)` function.\\n\\n----\\n\\n# Solutions\\n\\nTo solve this problem, there are basically two directions:\\n1. For each _item_, try to put it into any _container_ that has enough space.\\n2. For each _container_, try any _combination of item(s)_ that total size is <= the container size.\\n\\nNote: \\n\\n- There exist other methods, but I will mainly focus on **Backtracking**.\\n- The times in the brackets are only based on current testcases. It is totally possible that in the future more testcases are added and the numbers become inaccurate. Some methods may even become TLE, even if they are AC now.\\n\\n## For each item, try the containers\\n\\n#### Ver 1 - Straightforward backtracking (TLE)\\n\\nBasically try all possible combinations\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.1 - Sort items by size in descending order (700+ms)\\n\\nVer 1 would go TLE for testcases like: \\n- container sizes: [2,2,2,...,2] (50 containers with all size of 2)\\n- item sizes: [2,2,2,...,2,3] (9 of size 2 and 1 of size 3)\\n\\nReason: it\\'s actually trying every single way to fit the first 9 2s into the 50 containers - for example, it tries to put item1 in container1, then container2, then container3... Even if that makes absolutely no difference. In the worst case, it would try 50<sup>10</sup> times before it can return false.\\n\\nOn the other side, we can notice that: if we start with the biggest item, **once we find a bigger item that cannot fit into any of the rest containers, it fails. We don\\'t need to care about any of the smaller ones**.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>()); // sort in descending order\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\nNow some one may ask: what if we can fit all the bigger ones but only not the smallest one? Would it be in the same situation?\\nNo, it\\'s not the same. In the worst case, say, we can fit first 9 (bigger) items but only not the last one, we\\'ll have **at most** 9 bigger containers for these items, (if we have one more container that can fit any of the bigger item, it will definitely fit the smaller one) so we try at most 9<sup>9</sup> times. This is definitely not good enough (and we\\'ll continue optimise it later) but much better than Ver 1.\\n\\nNote:\\n> If a testcase results a `true`, the calculation is usually very fast (we find any solution and we are done). It\\'s those testcases require you to _try all the possibilities and eventually fail_ time consuming.\\n\\n#### Ver 1.2 - Data Preprocess (Pruning) (236ms)\\n\\nIn addition to sorting the item by size, we can do more preprocesses to make the calculation faster:\\n- Sort the items by size, as well as the containers\\n- If any container is smaller than the smallest item, it\\'s useless. Get rid of them.\\n- If a container can just fit the smallest item (same size), we should put the item in that container, and forget about them. Prove:\\n\\t- If we don\\'t put the smallest item in the container with same size, and there exists a solution, the container must be empty (since it cannot fit any bigger item), and we can always move the smallest item into that container and all other items still fit.\\n\\t- If we put the smallest into the container with same size and cannot fit all other items, put it in another container (leave the one with same size empty, since it can\\'t fit any bigger item) will only make less room. We still cannot fit all other items.\\n- If the smallest container left (bigger than the smallest item) can only fit one item (smaller than the sum of the two smallest items left), we find _the biggest item that fits it_ and put the item in it. Prove:\\n\\t- Say, the biggest item that smaller or the same to the smallest container `C` is `X`. If we don\\'t put X in C, and there exists a solution, then C is either empty or has _ONE_ smaller (than X) item in it, and X is in a bigger container. We can always move X into C (if empty) or swap X with the smaller item and still have a solution (return true).\\n\\t- Similar to above, if there\\'s no solution when putting X in C, moving/swapping X out of C will not make more room, and there\\'s still no solution.\\n- After the preprocess, if there\\'s no item left, we successfully fitted all items, return true.\\n- Otherwise if there\\'s no container left, no way to fit rest of the items, return false.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.3 - Grouping the container sizes (216ms)\\n\\nFrom Ver 1.1 we realised that we are doing a lot of duplicated calculations.\\nWe may be able to use dynamic programming (DP) to remember calculated subresults. However, there is a problem: if we put one item into a container, it\\'s still possible to fit other item(s) into that container. This makes applying DP trickier.\\n\\nBut don\\'t worry. There is a simpler method: (Inspired by the problem [[subsets II](https://leetcode.com/problems/subsets-ii/)])\\n- Group the containers by size\\n- We try to put an item in one container, if we failed to find a solution, then we don\\'t bother putting that item in other containers with same size - just try a container with different size.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\tmap<int, int, greater<int>> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.4 - Combine Ver 1.2 and 1.3 (200ms)\\n\\nNote: even though methods used in ver 1.2 and 1.3 are completely different, they are both trying to reduce the cases that we need to calculate. So the improvement is rather less significant by combining both.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tmap<int, int> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n----\\n\\n## For each container, try the all combinations of items that fit it\\n\\nNow let\\'s look at the other way around.\\n\\nIn this method, we use a **bit mask** to represent the combination of items.\\nFor each container, we try ALL combinations of items (mask from 0 to all 1s)\\n\\nNote: \\n- `(1 << N) - 1` => a mask with N trailing 1s\\n- `if ((mask & avail) != mask)` => check if exists any 1 in `mask` is 0 at the same bit in `avail` => check if any item chosen for the combination is not available\\n- `avail ^ mask` => remove all 1 bits in `mask` from `avail` (mask is a subset of avail)\\n\\n#### Ver 2 - Try All Combinations (TLE)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = 0; mask < (1 << itemSize.size()); ++mask) {\\n\\t\\t\\tif ((mask & avail) != mask) continue;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.0.1 - Try All Submasks (TLE)\\n\\nWe can improve Ver2 slightly by calculating **next subset mask** directly instead of iterating through 0 to all 1s:\\n- `mask = (mask - 1) & avail`\\n\\nFor more details, read [this](https://cp-algorithms.com/algebra/all-submasks.html)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.1 Dynamic Programming (700+ms)\\n\\nVer 2.0.1 still runs TLE. This is because we were repeatedly calculating the _same subproblem_.\\nFor example:\\n1. Suppose we put item A and B in container 1, and put C in container 2, then try to fit all the rest items into the rest containers and failed to find a solution. `[A, B][C]......`\\n2. We then move item B from container 1 to container 2, then we do the exactly same calculation for the rest. `[A][B, C]......`\\n\\nThis is the perfect situation to apply ***dynamic programming***.\\n\\nFor container _i_ and available item subset, we mark it `true` if we have checked it (and failed to find a solution), so we don\\'t need to check it again.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.2 DP with Remembered Subset Sums (448ms)\\n\\nIn Ver 2.1, we calculate the sum of a subset (total size of chosen items) every time.\\nWe can take one step further from by **remembering those sums**.\\n(I saw some other solutions that _precalculate_ all the sums, that also works. However, apparently we don\\'t need _all_ of them. So this method would be faster)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.3 DP with Preprocess (544ms)\\n\\nOther than DP, we can also apply the pruning explained in Ver 1.2 to this method.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.4 Combine Ver 2.2 & 2.3 (388ms)\\n\\nThen combine DP and preprocessing together:\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```cpp\\nbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\tunordered_map<int, int> fm;\\n\\tfor (int n : nums) ++fm[n];\\n\\tvector<int> counts;\\n\\tfor (auto [ignore, f] : fm) counts.push_back(f);\\n\\treturn CanAllFit(counts, quantity);\\n}\\n\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n    // ...\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>()); // sort in descending order\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\tmap<int, int, greater<int>> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tmap<int, int> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = 0; mask < (1 << itemSize.size()); ++mask) {\\n\\t\\t\\tif ((mask & avail) != mask) continue;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935476,
                "title": "c-dp-bitmask",
                "content": "1. First calculate the count of each type of value in nums and store in `vector a`\\n2. Now idea is to iterate over `a`  and try out each possible scenario of assigning this to different quantity orders i.e `b`. In particular the possibilities are to either use current element from `a` or skip it.\\n3. When considering the first option, we need to find a subset of `b`  over which we can distribute the current element from `a` . Using bitmask we can find all such subsets.\\n4. Since `m <= 10` (i.e size of `b`), there can be only 1024 subsets, we iterate over all of them. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    vector<int> a;\\n    vector<int> b;\\n    vector<vector<int> > dp;\\n    vector<int> cache;\\n    \\n    bool solve(int idx, int mask) {\\n        if(mask == (1 << m) - 1)\\n            return 1;\\n        \\n        if(idx == n)\\n            return 0;\\n        \\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        \\n        for(int i = mask + 1; i < (1 << m); ++i) {\\n            if(mask != (mask & (i))) continue;\\n            \\n            if(a[idx] >= cache[i] - cache[mask] && solve(idx + 1, i)) {\\n                return dp[idx][mask] = true;\\n            }\\n        }\\n        \\n        return dp[idx][mask] = solve(idx + 1, mask);\\n    }\\n    \\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& b) {\\n        \\n        unordered_map<int, int> mp;\\n        for(int x: nums) {\\n            mp[x] += 1;\\n        }\\n        for(auto p: mp)\\n            a.push_back(p.second);\\n        \\n        this->b = b;\\n        this->m = b.size();\\n        this->n = a.size();\\n        \\n        dp.clear(); dp.resize(n, vector<int> ((1<<m), -1));\\n        cache.clear(); cache.resize(1024, 0);\\n        \\n        for(int mask = 0; mask < (1 << m); ++mask) {\\n            for(int i = 0; i < m; ++i) {\\n                if(mask & (1 << i)) {\\n                    cache[mask] += b[i];\\n                }\\n            }\\n        }\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    vector<int> a;\\n    vector<int> b;\\n    vector<vector<int> > dp;\\n    vector<int> cache;\\n    \\n    bool solve(int idx, int mask) {\\n        if(mask == (1 << m) - 1)\\n            return 1;\\n        \\n        if(idx == n)\\n            return 0;\\n        \\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        \\n        for(int i = mask + 1; i < (1 << m); ++i) {\\n            if(mask != (mask & (i))) continue;\\n            \\n            if(a[idx] >= cache[i] - cache[mask] && solve(idx + 1, i)) {\\n                return dp[idx][mask] = true;\\n            }\\n        }\\n        \\n        return dp[idx][mask] = solve(idx + 1, mask);\\n    }\\n    \\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& b) {\\n        \\n        unordered_map<int, int> mp;\\n        for(int x: nums) {\\n            mp[x] += 1;\\n        }\\n        for(auto p: mp)\\n            a.push_back(p.second);\\n        \\n        this->b = b;\\n        this->m = b.size();\\n        this->n = a.size();\\n        \\n        dp.clear(); dp.resize(n, vector<int> ((1<<m), -1));\\n        cache.clear(); cache.resize(1024, 0);\\n        \\n        for(int mask = 0; mask < (1 << m); ++mask) {\\n            for(int i = 0; i < m; ++i) {\\n                if(mask & (1 << i)) {\\n                    cache[mask] += b[i];\\n                }\\n            }\\n        }\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935474,
                "title": "c-dfs-backtrack-solution",
                "content": "Given there are at most 50 unqiue values, and at most 10 customers.\\nIt\\'s a sign that we could do a backtrack.\\n\\nThe idea is to\\n1. count the occurance of each number\\n2. sort the customers\\' order quantities `DESC`\\n3. do a backtrack with DFS on the nubmers that are enough to be distributed to customers\\n\\n```\\nclass Solution {\\npublic:\\n    bool res = false;\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> conter;\\n        for (auto n : nums) {\\n            conter[n] += 1;\\n        }\\n\\t\\t\\n        vector<int> counts;\\n        for (auto& e : conter) counts.push_back(e.second);\\n\\t\\t\\n        sort(quantity.rbegin(), quantity.rend());\\n\\t\\t\\n        dfs(quantity, counts, 0);\\n\\t\\t\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& quantity, vector<int>& counts, int i) {\\n        if (i == quantity.size() || res) {\\n            res = true;\\n            return;\\n        }\\n\\t\\t\\n        for (int j = 0; j < counts.size(); j++) {\\n            int n = counts[j];\\n\\t\\t\\t\\n            if (n >= quantity[i]) {\\n                counts[j] -= quantity[i];\\n                dfs(quantity, counts, i + 1);\\n                counts[j] += quantity[i];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool res = false;\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> conter;\\n        for (auto n : nums) {\\n            conter[n] += 1;\\n        }\\n\\t\\t\\n        vector<int> counts;\\n        for (auto& e : conter) counts.push_back(e.second);\\n\\t\\t\\n        sort(quantity.rbegin(), quantity.rend());\\n\\t\\t\\n        dfs(quantity, counts, 0);\\n\\t\\t\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& quantity, vector<int>& counts, int i) {\\n        if (i == quantity.size() || res) {\\n            res = true;\\n            return;\\n        }\\n\\t\\t\\n        for (int j = 0; j < counts.size(); j++) {\\n            int n = counts[j];\\n\\t\\t\\t\\n            if (n >= quantity[i]) {\\n                counts[j] -= quantity[i];\\n                dfs(quantity, counts, i + 1);\\n                counts[j] += quantity[i];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935824,
                "title": "c-state-compression-dp-o-50-3-m",
                "content": "It is a State Compression DP problem. Number of quantities is less, so we need to make integers choose quantities.\\n\\n`alg[i][j]` stores whether it is possible to distribute integers for `nums[i:]`, given that chosen quantities in the previous  integers is represented as a bitset `j`. For the `ith` integer, we can choose any subset of quantities that are not already chosen and distribute the `ith` integer into them, as long as there are enough integers for the subset.\\n\\nFor example, `i=1`, `j=10101`, which means the `0th` integer is already distributed into `0th, 2nd, 4th` quantities. For the `1th` integer, we have the following choices,\\n\\n1. `00000`, we don\\'t use the `1th` integer at all;\\n2. `01000`, the `1th` integer is distributed into the `1st` quantity;\\n3. `00010`, the `1th` integer is distributed into the `3rd` quantity;\\n4. `01010`, the `1th` integer is distributed into the `1rd` and `3rd` quantity;\\n\\nWe go with the choice with minimum step. \\n\\nThus, in general, for `alg[i][j]`, we have the following choices\\n\\n```python\\n# Choice1, choose a subset of available quantities,\\nfor subset in bitwise_not(j):\\n  if enough_number(i, subset):\\n\\talg[i][j] = min(alg[i][j], alg[i+1][j | subset])\\n\\n# Choice2, bypass this integer\\nalg[i + 1][j]\\n```\\n\\nThere is an efficient technique to traverse all subsets of a set, see [this post](https://cp-algorithms.com/algebra/all-submasks.html).\\n\\n```c++\\n// Use static 2d arrays to get it faster\\n\\nbool alg[52][1 << 10];\\n// ok[i][j]: if there are enough integers for the ith integer to be distributed into a quantity subset j\\nbool ok[52][1 << 10];\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        memset(alg, 0, sizeof(alg));\\n        memset(ok, 0, sizeof(ok));\\n        \\n        unordered_map<int, int> num_to_cnt;\\n        for (auto const &num : nums) {\\n            num_to_cnt[num]++;\\n        }\\n        vector<int> cnts;\\n        for (auto const &[_, cnt] : num_to_cnt) {\\n            cnts.push_back(cnt);\\n        }\\n        \\n        int m = cnts.size();\\n        int n = quantity.size();\\n        alg[m][(1 << n) - 1] = true;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < (1 << n); ++j) {\\n                int sum = 0;\\n                for (int k = 0; k < n; ++k) {\\n                    if ((j >> k) & 1) {\\n                        sum += quantity[k];\\n                    }\\n                }\\n                if (sum <= cnts[i]) {\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = m - 1; i >= 0; --i) {\\n            for (unsigned int j = 0; j < (1 << n); ++j) {\\n                alg[i][j] = alg[i + 1][j];\\n                unsigned int whole_set = (~j) & ((1 << n) - 1);\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (int subset = whole_set; subset > 0; subset = (subset - 1) & whole_set) {\\n                    if (ok[i][subset]) {\\n                        alg[i][j] = alg[i][j] || alg[i + 1][j | subset];\\n                    }\\n                }\\n            }\\n        }\\n        return alg[0][0];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```python\\n# Choice1, choose a subset of available quantities,\\nfor subset in bitwise_not(j):\\n  if enough_number(i, subset):\\n\\talg[i][j] = min(alg[i][j], alg[i+1][j | subset])\\n\\n# Choice2, bypass this integer\\nalg[i + 1][j]\\n```\n```c++\\n// Use static 2d arrays to get it faster\\n\\nbool alg[52][1 << 10];\\n// ok[i][j]: if there are enough integers for the ith integer to be distributed into a quantity subset j\\nbool ok[52][1 << 10];\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        memset(alg, 0, sizeof(alg));\\n        memset(ok, 0, sizeof(ok));\\n        \\n        unordered_map<int, int> num_to_cnt;\\n        for (auto const &num : nums) {\\n            num_to_cnt[num]++;\\n        }\\n        vector<int> cnts;\\n        for (auto const &[_, cnt] : num_to_cnt) {\\n            cnts.push_back(cnt);\\n        }\\n        \\n        int m = cnts.size();\\n        int n = quantity.size();\\n        alg[m][(1 << n) - 1] = true;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < (1 << n); ++j) {\\n                int sum = 0;\\n                for (int k = 0; k < n; ++k) {\\n                    if ((j >> k) & 1) {\\n                        sum += quantity[k];\\n                    }\\n                }\\n                if (sum <= cnts[i]) {\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = m - 1; i >= 0; --i) {\\n            for (unsigned int j = 0; j < (1 << n); ++j) {\\n                alg[i][j] = alg[i + 1][j];\\n                unsigned int whole_set = (~j) & ((1 << n) - 1);\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (int subset = whole_set; subset > 0; subset = (subset - 1) & whole_set) {\\n                    if (ok[i][subset]) {\\n                        alg[i][j] = alg[i][j] || alg[i + 1][j | subset];\\n                    }\\n                }\\n            }\\n        }\\n        return alg[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935428,
                "title": "java-backtrack-solution-got-accepted-with-88-ms",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int num : nums) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int idx = 0;\\n        int[] arrCounts = new int[counts.size()];\\n        for (var key : counts.keySet()) {\\n            arrCounts[idx++] = counts.get(key);\\n        }\\n        return solve(arrCounts, quantity);\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity) {\\n        Arrays.sort(counts);\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        return solve(counts, quantity, 0);\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i + i < arr.length; i++) {\\n            int tmp = arr[i];\\n            arr[i] = arr[arr.length - i - 1];\\n            arr[arr.length - i - 1] = tmp;\\n        }\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity, int idx) {\\n        if (idx >= quantity.length) {\\n            return true;\\n        }\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (counts[i] >= quantity[idx]) {\\n                counts[i] -= quantity[idx];\\n                if (solve(counts, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                counts[i] += quantity[idx];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int num : nums) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int idx = 0;\\n        int[] arrCounts = new int[counts.size()];\\n        for (var key : counts.keySet()) {\\n            arrCounts[idx++] = counts.get(key);\\n        }\\n        return solve(arrCounts, quantity);\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity) {\\n        Arrays.sort(counts);\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        return solve(counts, quantity, 0);\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i + i < arr.length; i++) {\\n            int tmp = arr[i];\\n            arr[i] = arr[arr.length - i - 1];\\n            arr[arr.length - i - 1] = tmp;\\n        }\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity, int idx) {\\n        if (idx >= quantity.length) {\\n            return true;\\n        }\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (counts[i] >= quantity[idx]) {\\n                counts[i] -= quantity[idx];\\n                if (solve(counts, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                counts[i] += quantity[idx];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935554,
                "title": "python-3-o-50-3-m-bitmask-dp",
                "content": "based on @LarryNY solution\\n\\nremove an O(m) factor by precalculating subset sums\\n\\niterating through all submasks of all masks is O(3^m)\\nhttps://cp-algorithms.com/algebra/all-submasks.html\\n```\\nclass Solution:\\n    def canDistribute(self, a: List[int], customers: List[int]) -> bool:\\n        \\n        c = Counter(a)\\n        a = sorted(c.values())\\n        \\n        n = len(a)\\n        m = len(customers)\\n        \\n        ALL = (1 << m) - 1\\n        \\n        \\n        mask_sum = defaultdict(int)\\n        \\n        for mask in range(1 << m):\\n            for i in range(m):\\n                if (1 << i) & mask:\\n                    mask_sum[mask] += customers[i]\\n                    \\n        \\n        @lru_cache(None)\\n        def recurse(i, mask):\\n            \\n            if mask == 0:\\n                return True\\n            \\n            if i == n:\\n                return False\\n            \\n            submask = mask\\n            \\n            while submask:\\n                \\n                if mask_sum[submask] <= a[i] and recurse(i+1, mask ^ submask):\\n                    return True\\n                \\n                submask = (submask-1) & mask\\n            \\n            return recurse(i+1, mask)\\n                \\n        return recurse(0, ALL)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, a: List[int], customers: List[int]) -> bool:\\n        \\n        c = Counter(a)\\n        a = sorted(c.values())\\n        \\n        n = len(a)\\n        m = len(customers)\\n        \\n        ALL = (1 << m) - 1\\n        \\n        \\n        mask_sum = defaultdict(int)\\n        \\n        for mask in range(1 << m):\\n            for i in range(m):\\n                if (1 << i) & mask:\\n                    mask_sum[mask] += customers[i]\\n                    \\n        \\n        @lru_cache(None)\\n        def recurse(i, mask):\\n            \\n            if mask == 0:\\n                return True\\n            \\n            if i == n:\\n                return False\\n            \\n            submask = mask\\n            \\n            while submask:\\n                \\n                if mask_sum[submask] <= a[i] and recurse(i+1, mask ^ submask):\\n                    return True\\n                \\n                submask = (submask-1) & mask\\n            \\n            return recurse(i+1, mask)\\n                \\n        return recurse(0, ALL)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935414,
                "title": "python-backtracking",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n\\t\\t# we only need at most m different numbers, so we choose the ones which are most abundant\\n        left = sorted(c.values())[-m:]\\n        \\n\\t\\t# If the customer with most quantity required can\\'t be fulfilled, we don\\'t need to go further and answer will be false\\n        quantity.sort(reverse=True)\\n        \\n        def func(left, quantity, customer):\\n            if customer == len(quantity):\\n                return True\\n            \\n            for i in range(len(left)):\\n                if left[i] >= quantity[customer]:\\n                    left[i] -= quantity[customer]\\n                    if func(left, quantity, customer+1):\\n                        return True\\n                    left[i] += quantity[customer]\\n            return False\\n        \\n        return func(left, quantity, 0)",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n\\t\\t# we only need at most m different numbers, so we choose the ones which are most abundant\\n        left = sorted(c.values())[-m:]\\n        \\n\\t\\t# If the customer with most quantity required can\\'t be fulfilled, we don\\'t need to go further and answer will be false\\n        quantity.sort(reverse=True)\\n        \\n        def func(left, quantity, customer):\\n            if customer == len(quantity):\\n                return True\\n            \\n            for i in range(len(left)):\\n                if left[i] >= quantity[customer]:\\n                    left[i] -= quantity[customer]\\n                    if func(left, quantity, customer+1):\\n                        return True\\n                    left[i] += quantity[customer]\\n            return False\\n        \\n        return func(left, quantity, 0)",
                "codeTag": "Java"
            },
            {
                "id": 938428,
                "title": "java-backtrack-25-ms",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        \\n        // Use a map to count the numbers, ex: nums:[5,7,4,7,4,7] -> {5:1, 7:3, 4:2}\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums)\\n            freq.put(num, freq.getOrDefault(num, 0)+1);\\n        \\n        // Turn values of the map into array, ex: {5:1, 7:3, 4:2} -> [1, 3, 2]\\n        int[] dist = new int[freq.size()];\\n        int idx = 0;\\n        for (int f : freq.values())\\n            dist[idx++] = f;\\n        \\n\\t\\t// Fullfill the quantities from the biggest quantity to the smallest.\\n        // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return rec(dist, quantity, quantity.length-1);\\n    }\\n    \\n    // try to fullfill the j-th order quantity\\n    private boolean rec(int[] dist, int[] quantity, int j) {\\n        \\n        // stop condition. We\\'ve fulfilled all the order quantities.\\n        if (j == -1)\\n            return true;\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = 0 ; i < dist.length ; ++i) {\\n\\t\\t\\n\\t\\t\\t// Use a set to make sure that \\n\\t\\t\\t//   we don\\'t distribute from the same amount to this j-th order for more than once.\\n            // With this check, the program reduces from 97ms to 25 ms.\\n            if (dist[i] >= quantity[j] && used.add(dist[i])) {\\n                dist[i] -= quantity[j];\\n                if (rec(dist, quantity, j-1))\\n                    return true;\\n                dist[i] += quantity[j];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        \\n        // Use a map to count the numbers, ex: nums:[5,7,4,7,4,7] -> {5:1, 7:3, 4:2}\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums)\\n            freq.put(num, freq.getOrDefault(num, 0)+1);\\n        \\n        // Turn values of the map into array, ex: {5:1, 7:3, 4:2} -> [1, 3, 2]\\n        int[] dist = new int[freq.size()];\\n        int idx = 0;\\n        for (int f : freq.values())\\n            dist[idx++] = f;\\n        \\n\\t\\t// Fullfill the quantities from the biggest quantity to the smallest.\\n        // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return rec(dist, quantity, quantity.length-1);\\n    }\\n    \\n    // try to fullfill the j-th order quantity\\n    private boolean rec(int[] dist, int[] quantity, int j) {\\n        \\n        // stop condition. We\\'ve fulfilled all the order quantities.\\n        if (j == -1)\\n            return true;\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = 0 ; i < dist.length ; ++i) {\\n\\t\\t\\n\\t\\t\\t// Use a set to make sure that \\n\\t\\t\\t//   we don\\'t distribute from the same amount to this j-th order for more than once.\\n            // With this check, the program reduces from 97ms to 25 ms.\\n            if (dist[i] >= quantity[j] && used.add(dist[i])) {\\n                dist[i] -= quantity[j];\\n                if (rec(dist, quantity, j-1))\\n                    return true;\\n                dist[i] += quantity[j];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938440,
                "title": "c-well-commented-dp-50-3-m",
                "content": "First we calculate need, where need[i] =  min frq a number needs to have to satisfy the set i, i < 1024 = 2^10\\n\\nThen we introduce the frqs one by one (at most 50 of these). For each, we iterate over all sets i and all submasks of that set i. If frq <= need[s], that means the integer corresponding to frq can satisfy the set s, which means if i-s (arithmetic minus and set minus) can be satisfied, then so can i.\\n```\\nclass Solution {\\npublic:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    unordered_map<int,int>frq;\\n    for(int num:nums)frq[num]++;\\n    int F=frq.size(),  m=quantity.size(); // #unique integers\\n    vector<int> need(1<<m);\\n    vector<bool> res(1<<m); \\n    res[0]=true;\\n    for(int i=0;i!=1<<m; ++i){\\n      int curr=0;\\n      for(int j=0;j!=m;++j){  // is j in the i\\'th set?\\n        if((1<<j)&i)curr+=quantity[j];\\n      }\\n      need[i]=curr;\\n    }\\n    for(auto p:frq){\\n      int have=p.second;\\n      auto temp=res;  // before we had \\'have\\'\\n      for(int i=(1<<m)-1;i; --i){\\n        for (int s=i; s; s=(s-1)&i){  // submask of i\\n          if(need[s] <= have){\\n            res[i] = res[i] || temp[i-s];\\n          }\\n        }\\n      }\\n    }\\n\\treturn res.back();    // (1<<m) - 1 = the complete set\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    unordered_map<int,int>frq;\\n    for(int num:nums)frq[num]++;\\n    int F=frq.size(),  m=quantity.size(); // #unique integers\\n    vector<int> need(1<<m);\\n    vector<bool> res(1<<m); \\n    res[0]=true;\\n    for(int i=0;i!=1<<m; ++i){\\n      int curr=0;\\n      for(int j=0;j!=m;++j){  // is j in the i\\'th set?\\n        if((1<<j)&i)curr+=quantity[j];\\n      }\\n      need[i]=curr;\\n    }\\n    for(auto p:frq){\\n      int have=p.second;\\n      auto temp=res;  // before we had \\'have\\'\\n      for(int i=(1<<m)-1;i; --i){\\n        for (int s=i; s; s=(s-1)&i){  // submask of i\\n          if(need[s] <= have){\\n            res[i] = res[i] || temp[i-s];\\n          }\\n        }\\n      }\\n    }\\n\\treturn res.back();    // (1<<m) - 1 = the complete set\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340762,
                "title": "python3-dead-simple-backtracking-faster-than-98",
                "content": "1. Sort the `quantity` array in reverse order, since allocating larger quantities first will more quickly reduce the search space.\\n2. Get the frequency of each number in `nums`, ignoring the actual numbers.\\n3. Then further get the count of each frequency, storing this in `freqCounts`. We do this so that in our backtracking step, we don\\'t try allocating a quantity to two different but equal frequencies, as they would have an equivalent result.\\n4. In the backtracking, we try allocating each quantity to each unique frequency, simply decrementing and incrementing the frequency counts in each step.\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937984,
                "title": "bit-mask-backtrack-with-explanation-proof-of-time-complexity-o-m-n-but-not-o-3-m",
                "content": "# **1. Bitmask -- from numbers to customers**\\nThe core of the problem is that, given a specific integer `x` (means that there is a number occuring `x` times in the input), how can we know which subset of customers it should be distributed to. Say, `x` = 10, and `quantity=[6,4,5, 9]`, then we can assign 10 to `6,4`, `4,5`, or just any single `4`, `5`, `6`,  `9` . So we use a bit-mask to iterate all possible combinations for each integer, and see if we can satisfy all customers. \\n\\nThe basic algorithm is that\\n* we will iterate through all bitmasks for the first integer\\n* and for each mask, iterate through all of its submasks for the second integer\\n* and for each mask, iterate through all of its submasks for the third integer\\n* ...\\n* If there is submasks that satisfies all customers (all bits being set, etc), then it\\'s true.\\n\\n\\n\\n**Iterate a subset of a bit mask is like**\\n```\\nfor (int m=0; m<(1<<n); ++m)\\n    for (int s=m; s; s=(s-1)&m)\\n ... s and m ...\\n ```\\n\\nBut what\\'s the complexity? Let\\'s first consider a simple situation that there is only 2 integers -- 2 levels of submask, which is shown in the above code.\\n\\n---\\n\\nLet\\'s prove that the inner loop will execute a total of O(3^n) iterations.\\n\\nProof:\\n* Consider the i-th bit. There are exactly three options for it:\\n\\t1. it is not included in the mask m (and therefore not included in submask s),\\n\\t2. it is included in m, but not included in s, or\\n\\t3. it is included in both m and s.\\n\\n\\nAs there are a total of n bits, there will be 3^n different combinations.\\n\\n---\\nIt is similar to see that when there is m levels, then for each bit, there will be (m+1) status (either picked by any level or not picked at all).\\n\\nSo the complexity would be (m+1)^n.\\n\\n---\\n\\nFor the specific problem, we can have an optimization that, we only need at most the first n largest integers (if n < m). SO the complexity is (min(m,n)+1)^n\\n\\n\\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        cnt = collections.Counter(nums)\\n        avai = sorted([*cnt.values()])[-len(Q):]\\n        Q.sort(reverse=True)\\n        n = len(Q)\\n        @lru_cache(None)\\n        def is_ok(i, ns):\\n            needed = 0\\n            for j in range(n):\\n                if (1<<j) & ns:\\n                    needed += Q[j]\\n            return needed <= avai[i]\\n        # 1 is waiting, 0 is satisfied\\n        @lru_cache(None)\\n        def dfs(i, status):\\n            if i == len(avai) or status == 0:\\n                return status == 0\\n            if dfs(i+1, status):\\n                return True\\n            ns = status # need customer to be feeded as 1 bit\\n            while ns:\\n                if is_ok(i, ns) and dfs(i+1, ns^status):\\n                    return True\\n                ns = (ns - 1) & status\\n            return False\\n        return dfs(0, (1<<n)-1)\\n```\\n\\t\\t\\n\\n\\n\\n# 2. **Backtracking -- from customers to numbers**\\n\\nInstead of thinking how a kind of number can be distributed to different combination of customers, we can think about which number will a customer pick.\\n\\nTo do this, for each customer, we simply iterate over all possible numbers that can satisfy this customer and continue to the next customer.\\nIn worst case, for each customer (n totally), we have m choice, so the time complexity is O(m^n).\\nBut since the amount of data is small, that we can sort the numbers and use memorization to optimize it.\\nA sample python code:\\n\\n```python\\ndef canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n    cnt = collections.Counter(nums)\\n    avai = sorted([*cnt.values()])[-len(Q):]\\n    Q.sort(reverse=True)\\n    n = len(Q)\\n    @lru_cache(None)\\n    def dfs(cid, avai):\\n        \"\"\"\\n        cid: customer_id\\n        \"\"\"\\n        if cid == len(Q):\\n            return True\\n        for i in range(len(avai)):\\n            if avai[i] >= Q[cid]:\\n                new_avai = avai[:i]+avai[i+1:]\\n                if avai[i] > Q[cid]:\\n                    new_avai += (avai[i] - Q[cid]),\\n                if dfs(cid+1, tuple(sorted(new_avai, reverse=True))):\\n                    return True\\n        return False\\n    return dfs(0, tuple(avai[::-1]))\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int m=0; m<(1<<n); ++m)\\n    for (int s=m; s; s=(s-1)&m)\\n ... s and m ...\\n ```\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        cnt = collections.Counter(nums)\\n        avai = sorted([*cnt.values()])[-len(Q):]\\n        Q.sort(reverse=True)\\n        n = len(Q)\\n        @lru_cache(None)\\n        def is_ok(i, ns):\\n            needed = 0\\n            for j in range(n):\\n                if (1<<j) & ns:\\n                    needed += Q[j]\\n            return needed <= avai[i]\\n        # 1 is waiting, 0 is satisfied\\n        @lru_cache(None)\\n        def dfs(i, status):\\n            if i == len(avai) or status == 0:\\n                return status == 0\\n            if dfs(i+1, status):\\n                return True\\n            ns = status # need customer to be feeded as 1 bit\\n            while ns:\\n                if is_ok(i, ns) and dfs(i+1, ns^status):\\n                    return True\\n                ns = (ns - 1) & status\\n            return False\\n        return dfs(0, (1<<n)-1)\\n```\n```python\\ndef canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n    cnt = collections.Counter(nums)\\n    avai = sorted([*cnt.values()])[-len(Q):]\\n    Q.sort(reverse=True)\\n    n = len(Q)\\n    @lru_cache(None)\\n    def dfs(cid, avai):\\n        \"\"\"\\n        cid: customer_id\\n        \"\"\"\\n        if cid == len(Q):\\n            return True\\n        for i in range(len(avai)):\\n            if avai[i] >= Q[cid]:\\n                new_avai = avai[:i]+avai[i+1:]\\n                if avai[i] > Q[cid]:\\n                    new_avai += (avai[i] - Q[cid]),\\n                if dfs(cid+1, tuple(sorted(new_avai, reverse=True))):\\n                    return True\\n        return False\\n    return dfs(0, tuple(avai[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935599,
                "title": "c-backtracking",
                "content": "```\\npublic class Solution {\\n    public bool CanDistribute(int[] nums, int[] quantity) {\\n        var cnt = nums.GroupBy(x => x).Select(x => x.Count()).ToList();\\n        Array.Sort(quantity, (a,b) => b.CompareTo(a));\\n        return DFS(cnt, quantity, 0);\\n    }\\n    \\n    public bool DFS(List<int> cnt, int[] quantity, int idx)\\n    {\\n        if(idx == quantity.Length) return true;\\n        for(int i = 0; i < cnt.Count; i++)\\n        {\\n            if(cnt[i] >= quantity[idx])\\n            {\\n                cnt[i] -= quantity[idx];\\n                if(DFS(cnt, quantity, idx+1))\\n                    return true;\\n                cnt[i] += quantity[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanDistribute(int[] nums, int[] quantity) {\\n        var cnt = nums.GroupBy(x => x).Select(x => x.Count()).ToList();\\n        Array.Sort(quantity, (a,b) => b.CompareTo(a));\\n        return DFS(cnt, quantity, 0);\\n    }\\n    \\n    public bool DFS(List<int> cnt, int[] quantity, int idx)\\n    {\\n        if(idx == quantity.Length) return true;\\n        for(int i = 0; i < cnt.Count; i++)\\n        {\\n            if(cnt[i] >= quantity[idx])\\n            {\\n                cnt[i] -= quantity[idx];\\n                if(DFS(cnt, quantity, idx+1))\\n                    return true;\\n                cnt[i] += quantity[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388884,
                "title": "c-backtracking",
                "content": "```\\n\\n```public:\\n    map<int,int>mp;\\n    bool solve(vector<int>&q,int idx)\\n    {\\n        if(idx==q.size())\\n        {\\n            return true;\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second>=q[idx])\\n            {\\n                mp[i.first]-=q[idx];\\n                if(solve(q,idx+1))\\n                {\\n                    return true;\\n                }\\n                mp[i.first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        sort(q.begin(),q.end(),greater<int>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        return solve(q,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958560,
                "title": "dp-bitmask-faster-than-93-90-space-less-than-96-53",
                "content": "rather than going to all possiblilty and filtering out,  just moving to all the masks will reduce time from 4^n -> 3 ^n\\n```\\nclass Solution {\\npublic:\\n    int temp[1001];\\n    bool dp[51][1025];\\n    int cache[1025];\\n    int n;\\n    vector<int>a;\\n    bool solve(int ind, int mask){\\n        if(mask == 0)return true;\\n        if(ind == n)return false;\\n        if(!dp[ind][mask])return dp[ind][mask];\\n        for(int i = mask; i > 0; i = mask & (i - 1)){\\n            if(cache[i] <= a[ind] && solve(ind + 1, mask ^ i))return dp[ind][mask] = true;\\n        }\\n         return dp[ind][mask] = solve(ind + 1, mask);\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)temp[i]++;\\n        \\n        for(int i = 0; i < 1001; ++i){\\n            if(temp[i])a.push_back(temp[i]);\\n        }\\n        n = a.size();\\n        int m = quantity.size();\\n        for(int i = 0; i < 51; ++i)for(int j = 0; j < 1025; ++j)dp[i][j] = true;\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int b = 0; b < m; ++b){\\n                if((i >> b) & 1)cache[i] += quantity[b];\\n            }\\n        }\\n        return solve(0, (1 << m) - 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int temp[1001];\\n    bool dp[51][1025];\\n    int cache[1025];\\n    int n;\\n    vector<int>a;\\n    bool solve(int ind, int mask){\\n        if(mask == 0)return true;\\n        if(ind == n)return false;\\n        if(!dp[ind][mask])return dp[ind][mask];\\n        for(int i = mask; i > 0; i = mask & (i - 1)){\\n            if(cache[i] <= a[ind] && solve(ind + 1, mask ^ i))return dp[ind][mask] = true;\\n        }\\n         return dp[ind][mask] = solve(ind + 1, mask);\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)temp[i]++;\\n        \\n        for(int i = 0; i < 1001; ++i){\\n            if(temp[i])a.push_back(temp[i]);\\n        }\\n        n = a.size();\\n        int m = quantity.size();\\n        for(int i = 0; i < 51; ++i)for(int j = 0; j < 1025; ++j)dp[i][j] = true;\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int b = 0; b < m; ++b){\\n                if((i >> b) & 1)cache[i] += quantity[b];\\n            }\\n        }\\n        return solve(0, (1 << m) - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940645,
                "title": "python-slow-but-straightforward",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        X = list(Counter(nums).values())\\n        Q.sort(reverse = True)\\n        def help(X, j):\\n            if j == len(Q): return True\\n            for i, y in enumerate(X):\\n                if y >= Q[j] and help(X[:i] + [y - Q[j]] + X[i + 1:], j + 1): return True\\n            return False\\n        return help(X, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        X = list(Counter(nums).values())\\n        Q.sort(reverse = True)\\n        def help(X, j):\\n            if j == len(Q): return True\\n            for i, y in enumerate(X):\\n                if y >= Q[j] and help(X[:i] + [y - Q[j]] + X[i + 1:], j + 1): return True\\n            return False\\n        return help(X, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935426,
                "title": "java-dp-bitmasking-faster-than-100-o-n-3-40ms-well-commented",
                "content": "```\\n//Complexity should be O (   m(10) * numPiles(50) * Max(num(i))(1000)   ) \\n\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n  HashMap<String, Boolean> dp;\\n  int target;\\n\\n  public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n    dp = new HashMap<>();\\n    HashMap<Integer, Integer> hm = new HashMap<>();\\n    for (int n : nums) {\\n      hm.put(n, hm.getOrDefault(n, 0) + 1);\\n    }\\n\\n\\n    //Make a target bitmask when every customer is satisfied!\\n    target = 0;\\n    for (int i = 0; i < quantity.length; i++) {\\n      target |= (1 << i);\\n    }\\n\\n\\n    //Make an array that represent piles of the same integer\\n    int[] remaining = new int[hm.size()];\\n    ArrayList<Integer> ls = new ArrayList<>(hm.values());\\n    for (int i = 0; i < remaining.length; i++)\\n      remaining[i] = ls.get(i);\\n\\n\\n    return magic(0, 0, remaining[0], remaining, quantity);\\n  }\\n\\n\\n  boolean magic(int taken, int pos, int remain, int[] remaining, int[] quantity) {\\n\\n\\n    //Have satisfied all customers\\n    if (taken == target)\\n      return true;\\n\\n    //Exhausted all piles\\n    if (pos == remaining.length)\\n      return false;\\n\\n\\n    //Search if we have already computed.\\n    String key = pos + \" \" + taken + \" \" + remain;\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n\\n    boolean ans = false;\\n    boolean found = false;\\n\\n\\n    //Brute force check if this pile can satisfy any customer, if yes then  reduce pile.\\n    for (int i = 0; i < quantity.length; i++) {\\n      if ((taken & (1 << i)) == 0 && quantity[i] <= remain) {\\n        found = true;\\n        //dont change pile and iterate for remaining, after satisfying this customer.\\n        ans |= magic(taken | (1 << i), pos, remain - quantity[i], remaining, quantity);\\n\\n        if (ans)\\n          break;\\n      }\\n    }\\n\\n    //change pile if this pile cannot satisfy anyone anymore and we haven\\'t reached the end!\\n    if (!found && pos + 1 < remaining.length) {\\n      ans |= magic(taken, pos + 1, remaining[pos + 1], remaining, quantity);\\n    }\\n    dp.put(key, ans);\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Complexity should be O (   m(10) * numPiles(50) * Max(num(i))(1000)   ) \\n\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n  HashMap<String, Boolean> dp;\\n  int target;\\n\\n  public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n    dp = new HashMap<>();\\n    HashMap<Integer, Integer> hm = new HashMap<>();\\n    for (int n : nums) {\\n      hm.put(n, hm.getOrDefault(n, 0) + 1);\\n    }\\n\\n\\n    //Make a target bitmask when every customer is satisfied!\\n    target = 0;\\n    for (int i = 0; i < quantity.length; i++) {\\n      target |= (1 << i);\\n    }\\n\\n\\n    //Make an array that represent piles of the same integer\\n    int[] remaining = new int[hm.size()];\\n    ArrayList<Integer> ls = new ArrayList<>(hm.values());\\n    for (int i = 0; i < remaining.length; i++)\\n      remaining[i] = ls.get(i);\\n\\n\\n    return magic(0, 0, remaining[0], remaining, quantity);\\n  }\\n\\n\\n  boolean magic(int taken, int pos, int remain, int[] remaining, int[] quantity) {\\n\\n\\n    //Have satisfied all customers\\n    if (taken == target)\\n      return true;\\n\\n    //Exhausted all piles\\n    if (pos == remaining.length)\\n      return false;\\n\\n\\n    //Search if we have already computed.\\n    String key = pos + \" \" + taken + \" \" + remain;\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n\\n    boolean ans = false;\\n    boolean found = false;\\n\\n\\n    //Brute force check if this pile can satisfy any customer, if yes then  reduce pile.\\n    for (int i = 0; i < quantity.length; i++) {\\n      if ((taken & (1 << i)) == 0 && quantity[i] <= remain) {\\n        found = true;\\n        //dont change pile and iterate for remaining, after satisfying this customer.\\n        ans |= magic(taken | (1 << i), pos, remain - quantity[i], remaining, quantity);\\n\\n        if (ans)\\n          break;\\n      }\\n    }\\n\\n    //change pile if this pile cannot satisfy anyone anymore and we haven\\'t reached the end!\\n    if (!found && pos + 1 < remaining.length) {\\n      ans |= magic(taken, pos + 1, remaining[pos + 1], remaining, quantity);\\n    }\\n    dp.put(key, ans);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704738,
                "title": "c-simple-recursion-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>& cnt, int index ) {\\n        //base case\\n        if(index >= quantity.size()) {\\n            return true;\\n        }\\n        \\n        for(auto it = cnt.begin(); it != cnt.end(); it++) {\\n            if(it->second >= quantity[index]) {\\n                \\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaSol = solve(quantity, cnt, index+1);\\n                if(aageKaSol == true)\\n                    return true;\\n                //BT\\n                cnt[it->first] = cnt[it->first] + quantity[index];\\n            }\\n        }   \\n      return false;  \\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        //step1: create freq array\\n        for(int i=0; i<nums.size(); i++) {\\n            cnt[nums[i]]++;\\n        }\\n        //step2: sort quantity desc\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        \\n        bool ans = solve(quantity, cnt, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>& cnt, int index ) {\\n        //base case\\n        if(index >= quantity.size()) {\\n            return true;\\n        }\\n        \\n        for(auto it = cnt.begin(); it != cnt.end(); it++) {\\n            if(it->second >= quantity[index]) {\\n                \\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaSol = solve(quantity, cnt, index+1);\\n                if(aageKaSol == true)\\n                    return true;\\n                //BT\\n                cnt[it->first] = cnt[it->first] + quantity[index];\\n            }\\n        }   \\n      return false;  \\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        //step1: create freq array\\n        for(int i=0; i<nums.size(); i++) {\\n            cnt[nums[i]]++;\\n        }\\n        //step2: sort quantity desc\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        \\n        bool ans = solve(quantity, cnt, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240816,
                "title": "90-faster-java-backtrack-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    boolean find(int index,int arr[],int quantity[]){\\n        if(index<0)return true;\\n        boolean t=false;\\n        // Use a set to make sure that we don\\'t distribute from the same amount to this index-th order for more than once.\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<quantity[index]||set.contains(arr[i]))continue;\\n            set.add(arr[i]);\\n            arr[i]-=quantity[index];\\n            t=t||find(index-1,arr,quantity);\\n            if(t)return true;\\n            arr[i]+=quantity[index];\\n        }\\n        return t;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer,Integer>freq=new HashMap<>();\\n        for(int num : nums) freq.put(num,freq.getOrDefault(num,0)+1);\\n        int arr[]=new int[freq.size()];\\n        int i=0;\\n        for(int val : freq.values())\\n            arr[i++]=val;\\n         // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return find(quantity.length-1,arr,quantity);\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean find(int index,int arr[],int quantity[]){\\n        if(index<0)return true;\\n        boolean t=false;\\n        // Use a set to make sure that we don\\'t distribute from the same amount to this index-th order for more than once.\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<quantity[index]||set.contains(arr[i]))continue;\\n            set.add(arr[i]);\\n            arr[i]-=quantity[index];\\n            t=t||find(index-1,arr,quantity);\\n            if(t)return true;\\n            arr[i]+=quantity[index];\\n        }\\n        return t;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer,Integer>freq=new HashMap<>();\\n        for(int num : nums) freq.put(num,freq.getOrDefault(num,0)+1);\\n        int arr[]=new int[freq.size()];\\n        int i=0;\\n        for(int val : freq.values())\\n            arr[i++]=val;\\n         // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return find(quantity.length-1,arr,quantity);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103429,
                "title": "python3-backtracking",
                "content": "**Algo**\\nThis a very typical backtracking application with two pruning techniques: \\n1) dealing with large values first\\n2) skipping repetative numbers. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        freq = {}\\n        for x in nums: freq[x] = 1 + freq.get(x, 0)\\n        \\n        vals = sorted(freq.values(), reverse=True)\\n        quantity.sort(reverse=True) # pruning - large values first  \\n        \\n        def fn(i): \\n            \"\"\"Return True if possible to distribute quantity[i:] to remaining.\"\"\"\\n            if i == len(quantity): return True \\n            seen = set()\\n            for k in range(len(vals)): \\n                if vals[k] >= quantity[i] and vals[k] not in seen: \\n                    seen.add(vals[k]) # pruning - unqiue values \\n                    vals[k] -= quantity[i]\\n                    if fn(i+1): return True \\n                    vals[k] += quantity[i] # backtracking\\n                    \\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        freq = {}\\n        for x in nums: freq[x] = 1 + freq.get(x, 0)\\n        \\n        vals = sorted(freq.values(), reverse=True)\\n        quantity.sort(reverse=True) # pruning - large values first  \\n        \\n        def fn(i): \\n            \"\"\"Return True if possible to distribute quantity[i:] to remaining.\"\"\"\\n            if i == len(quantity): return True \\n            seen = set()\\n            for k in range(len(vals)): \\n                if vals[k] >= quantity[i] and vals[k] not in seen: \\n                    seen.add(vals[k]) # pruning - unqiue values \\n                    vals[k] -= quantity[i]\\n                    if fn(i+1): return True \\n                    vals[k] += quantity[i] # backtracking\\n                    \\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938666,
                "title": "java-bitmask-dp-enumerating-all-subsets",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.merge(x, 1, Integer::sum);\\n        }\\n        int n = cnt.size();\\n        int m = quantity.length;\\n        int[] freq = new int[n];\\n        int j = 0;\\n        for (int val : cnt.values()) {\\n            freq[j] = val;\\n            j++;\\n        }\\n        boolean[][] dp = new boolean[n + 1][1 << m];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 1; state < 1 << m; state++) {\\n                if (dp[i - 1][state]) {\\n                    dp[i][state] = true;\\n                    continue;\\n                }\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    if (!dp[i - 1][state - subset]) {\\n                        continue;\\n                    }\\n                    if (satisfy(freq[i - 1], quantity, subset)) {\\n                        dp[i][state] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (dp[i][(1 << m) - 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean satisfy(int cnt, int[] quantity, int bitmask) {\\n        for (int i = 0; i < quantity.length; i++) {\\n            if (((bitmask >> i) & 1) == 1) {\\n                cnt -= quantity[i];\\n                if (cnt < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.merge(x, 1, Integer::sum);\\n        }\\n        int n = cnt.size();\\n        int m = quantity.length;\\n        int[] freq = new int[n];\\n        int j = 0;\\n        for (int val : cnt.values()) {\\n            freq[j] = val;\\n            j++;\\n        }\\n        boolean[][] dp = new boolean[n + 1][1 << m];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 1; state < 1 << m; state++) {\\n                if (dp[i - 1][state]) {\\n                    dp[i][state] = true;\\n                    continue;\\n                }\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    if (!dp[i - 1][state - subset]) {\\n                        continue;\\n                    }\\n                    if (satisfy(freq[i - 1], quantity, subset)) {\\n                        dp[i][state] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (dp[i][(1 << m) - 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean satisfy(int cnt, int[] quantity, int bitmask) {\\n        for (int i = 0; i < quantity.length; i++) {\\n            if (((bitmask >> i) & 1) == 1) {\\n                cnt -= quantity[i];\\n                if (cnt < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936472,
                "title": "elegant-clean-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m ;\\n    bool ans = false ;\\n    vector<int> occurrences ;\\n    \\n    void f(vector<int>& qt,int i=0,int j=0){\\n        if (i==qt.size())  ans = true  ;\\n        if (ans) return  ;\\n        for (int k=j;k<occurrences.size();k++){\\n            if (qt[i]<=occurrences[k]){\\n                occurrences[k] = occurrences[k] - qt[i] ;\\n                f(qt,i+1,j) ;\\n                occurrences[k] = occurrences[k] + qt[i] ;\\n            }\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qt) {\\n        for (int i:nums) m[i]++ ;\\n        for (auto y = m.begin();y!=m.end();y++) occurrences.push_back(y->second) ;\\n        sort(occurrences.begin(),occurrences.end()) ;\\n        sort(qt.begin(),qt.end()) ;\\n        reverse(qt.begin(),qt.end()) ;\\n        f(qt) ;\\n        return ans ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m ;\\n    bool ans = false ;\\n    vector<int> occurrences ;\\n    \\n    void f(vector<int>& qt,int i=0,int j=0){\\n        if (i==qt.size())  ans = true  ;\\n        if (ans) return  ;\\n        for (int k=j;k<occurrences.size();k++){\\n            if (qt[i]<=occurrences[k]){\\n                occurrences[k] = occurrences[k] - qt[i] ;\\n                f(qt,i+1,j) ;\\n                occurrences[k] = occurrences[k] + qt[i] ;\\n            }\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qt) {\\n        for (int i:nums) m[i]++ ;\\n        for (auto y = m.begin();y!=m.end();y++) occurrences.push_back(y->second) ;\\n        sort(occurrences.begin(),occurrences.end()) ;\\n        sort(qt.begin(),qt.end()) ;\\n        reverse(qt.begin(),qt.end()) ;\\n        f(qt) ;\\n        return ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204208,
                "title": "backtracking-decreasing-sorting-c-easy-solution",
                "content": "# Intuition\\nSimple Backtracking problem where we check if we can take that number of tasks to the n person or not !!\\n# Approach\\nBacktracking + Sorting \\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn+n)\\n\\n- Space complexity:\\n0(n) where n is number of unique elements in the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool solve(vector<int>&q,map<int,int>&cnt,int index){\\nif(index==q.size()){\\nreturn true;\\n}\\nfor(auto it=cnt.begin();it!=cnt.end();it++){\\nif(it->second>=q[index]){\\ncnt[it->first]=cnt[it->first]-q[index];\\nbool agee_kasol=solve(q,cnt,index+1);\\nif(agee_kasol==true)\\nreturn true;\\ncnt[it->first]=cnt[it->first]+q[index];\\n}\\n}\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {   \\nmap<int,int>cnt;\\nfor(int i=0;i<nums.size();i++)\\ncnt[nums[i]]++;\\n\\nsort(quantity.begin(),quantity.end(),greater<int>());\\n\\nbool ans=solve(quantity,cnt,0);\\nreturn ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool solve(vector<int>&q,map<int,int>&cnt,int index){\\nif(index==q.size()){\\nreturn true;\\n}\\nfor(auto it=cnt.begin();it!=cnt.end();it++){\\nif(it->second>=q[index]){\\ncnt[it->first]=cnt[it->first]-q[index];\\nbool agee_kasol=solve(q,cnt,index+1);\\nif(agee_kasol==true)\\nreturn true;\\ncnt[it->first]=cnt[it->first]+q[index];\\n}\\n}\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {   \\nmap<int,int>cnt;\\nfor(int i=0;i<nums.size();i++)\\ncnt[nums[i]]++;\\n\\nsort(quantity.begin(),quantity.end(),greater<int>());\\n\\nbool ans=solve(quantity,cnt,0);\\nreturn ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967275,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quant,   map<int,int>&cnt,int i)\\n    {\\n        if(i==quant.size())\\n        {\\n            return true;\\n        }\\n        for (auto it=cnt.begin(); it!=cnt.end(); it++)\\n        {\\n            if(it->second>=quant[i])\\n            {\\n               cnt[it->first] = cnt[it->first] - quant[i];\\n                bool aage= solve(quant,cnt,i+1);\\n                if(aage)\\n                {\\n                    return true;\\n                }else{\\n                      cnt[it->first] = cnt[it->first] +quant[i];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quant) {\\n        // Step1:\\n        map<int,int>cnt;\\n       for(auto x:nums)\\n        {\\n            cnt[x]++;\\n        }\\n        \\n      // Step2 :\\n        sort(quant.begin(),quant.end(),greater<int>());\\n        \\n      bool ans =solve(quant,cnt,0);  \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quant,   map<int,int>&cnt,int i)\\n    {\\n        if(i==quant.size())\\n        {\\n            return true;\\n        }\\n        for (auto it=cnt.begin(); it!=cnt.end(); it++)\\n        {\\n            if(it->second>=quant[i])\\n            {\\n               cnt[it->first] = cnt[it->first] - quant[i];\\n                bool aage= solve(quant,cnt,i+1);\\n                if(aage)\\n                {\\n                    return true;\\n                }else{\\n                      cnt[it->first] = cnt[it->first] +quant[i];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quant) {\\n        // Step1:\\n        map<int,int>cnt;\\n       for(auto x:nums)\\n        {\\n            cnt[x]++;\\n        }\\n        \\n      // Step2 :\\n        sort(quant.begin(),quant.end(),greater<int>());\\n        \\n      bool ans =solve(quant,cnt,0);  \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283414,
                "title": "why-is-this-solution-giving-tle-as-verdict",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(int idx,vector<int>&mp,vector<int>& quantity, map<pair<int,vector<int>>,bool>&dp){\\n        int cnt = 0;\\n        if(idx==quantity.size()){\\n            return true;\\n        }\\n        \\n        if(dp.find({idx,mp})!=dp.end()){\\n            return dp[{idx,mp}];\\n        }\\n        int f = 0;\\n        int res = false;\\n        for(int i = 0;i<mp.size();i++){\\n            if(i>0 && mp[i]==mp[i-1]){\\n                continue;\\n            }\\n            else if(mp[i]>=quantity[idx]){\\n                f=1;\\n                mp[i]-=quantity[idx];\\n                if(func(idx+1, mp, quantity,dp)){\\n                    return dp[{idx,mp}] = true;\\n                }\\n                mp[i]+=quantity[idx];\\n            }\\n        }\\n        if(!f){\\n            return dp[{idx,mp}] = false;\\n        }\\n        else{\\n            return dp[{idx,mp}] = res;\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>mp2;\\n        for(auto x:nums){\\n            mp2[x]++;\\n        }\\n        vector<int>mp;\\n        for(auto x:mp2){\\n            mp.push_back(x.second);\\n        }\\n        map<pair<int,vector<int>>,bool>dp;\\n        return func(0,mp,quantity,dp);\\n    }\\n};\\n```\\nPlease lmk. Thanks in advance!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(int idx,vector<int>&mp,vector<int>& quantity, map<pair<int,vector<int>>,bool>&dp){\\n        int cnt = 0;\\n        if(idx==quantity.size()){\\n            return true;\\n        }\\n        \\n        if(dp.find({idx,mp})!=dp.end()){\\n            return dp[{idx,mp}];\\n        }\\n        int f = 0;\\n        int res = false;\\n        for(int i = 0;i<mp.size();i++){\\n            if(i>0 && mp[i]==mp[i-1]){\\n                continue;\\n            }\\n            else if(mp[i]>=quantity[idx]){\\n                f=1;\\n                mp[i]-=quantity[idx];\\n                if(func(idx+1, mp, quantity,dp)){\\n                    return dp[{idx,mp}] = true;\\n                }\\n                mp[i]+=quantity[idx];\\n            }\\n        }\\n        if(!f){\\n            return dp[{idx,mp}] = false;\\n        }\\n        else{\\n            return dp[{idx,mp}] = res;\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>mp2;\\n        for(auto x:nums){\\n            mp2[x]++;\\n        }\\n        vector<int>mp;\\n        for(auto x:mp2){\\n            mp.push_back(x.second);\\n        }\\n        map<pair<int,vector<int>>,bool>dp;\\n        return func(0,mp,quantity,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781767,
                "title": "java-simple-clean-code-99-fast-backtrack",
                "content": "In this solution, quantity is sorted and duplicate operations are avoided. Another takeway is the \"copyOfRange\" method in Arrays.\\n\\n```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n    int[] counter = count(nums);\\n    Arrays.sort(quantity);\\n\\t\\n    return dfs(counter, quantity, quantity.length - 1);\\n  }\\n\\n  private boolean dfs(int[] counter, int[] quantity, int quantityId) {\\n    if(quantityId < 0) return true;\\n\\n    for(int i = 0; i < counter.length; i++){\\n      if(i > 0 && counter[i] == counter[i-1]) continue;\\n\\n      if(counter[i] >= quantity[quantityId]){\\n        counter[i] -= quantity[quantityId];\\n        if(dfs(counter, quantity, quantityId - 1))\\n          return true;\\n        counter[i] += quantity[quantityId];\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  private int[] count(int[] nums){\\n    int[] counter = new int[1001];\\n    for(int n : nums){\\n      counter[n]++;\\n    }\\n\\n    Arrays.sort(counter);\\n    return Arrays.copyOfRange(counter, counter.length - 50, counter.length);\\n  }\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "In this solution, quantity is sorted and duplicate operations are avoided. Another takeway is the \"copyOfRange\" method in Arrays.\\n\\n```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n    int[] counter = count(nums);\\n    Arrays.sort(quantity);\\n\\t\\n    return dfs(counter, quantity, quantity.length - 1);\\n  }\\n\\n  private boolean dfs(int[] counter, int[] quantity, int quantityId) {\\n    if(quantityId < 0) return true;\\n\\n    for(int i = 0; i < counter.length; i++){\\n      if(i > 0 && counter[i] == counter[i-1]) continue;\\n\\n      if(counter[i] >= quantity[quantityId]){\\n        counter[i] -= quantity[quantityId];\\n        if(dfs(counter, quantity, quantityId - 1))\\n          return true;\\n        counter[i] += quantity[quantityId];\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  private int[] count(int[] nums){\\n    int[] counter = new int[1001];\\n    for(int n : nums){\\n      counter[n]++;\\n    }\\n\\n    Arrays.sort(counter);\\n    return Arrays.copyOfRange(counter, counter.length - 50, counter.length);\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1710389,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    map<int,int> mp;\\n    bool fun(vector<int> &quantity, vector<int> &arr, int idx)\\n    {\\n        if(idx==quantity.size())\\n        {\\n            return true;\\n        }\\n        for(int i=0; i<arr.size();i++)\\n        {\\n            if(i>0 && arr[i]==arr[i-1]) //skip the elements on which we have already made a function call\\n                continue;\\n            if(arr[i]>=quantity[idx]) \\n            {\\n                arr[i]-=quantity[idx]; //either we pick nums[i]\\n                if(fun(quantity,arr,idx+1))\\n                    return true;\\n                arr[i]+=quantity[idx]; //or not\\n            }\\n        }\\n        return false;\\n       }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mp[nums[i]]++;\\n        }\\n        vector<int> arr;  \\n        for(auto x:mp)\\n            arr.push_back(x.second);\\n        return fun(quantity,arr,0);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    map<int,int> mp;\\n    bool fun(vector<int> &quantity, vector<int> &arr, int idx)\\n    {\\n        if(idx==quantity.size())\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1710275,
                "title": "best-java-solution-100",
                "content": "class Solution\\n{\\n  public boolean canDistribute (int[]nums, int[]quantity)\\n  {\\n    int n = quantity.length;\\n      Arrays.sort (quantity);\\n    for (int i = 0; i < n / 2; i++)\\n      {\\n\\tint temp = quantity[i];\\n\\t  quantity[i] = quantity[n - i - 1];\\n\\n\\t  quantity[n - i - 1] = temp;\\n      }\\n    // In upper section sort and reverse quantity    \\n    int r[] = new int[1001];\\n    Arrays.fill (r, 0);\\n    int count = 1;\\n    for (int i = 0; i < nums.length; i++)\\n      {\\n\\tr[nums[i]]++;\\n      }\\n\\n    for (int i = 0; i < quantity.length; i++)\\n      {\\n\\tint j = 0, k = 0, l = 0;\\n\\n\\tfor (j = 1; j < r.length; j++)  //case 1 loop\\n\\t  {\\n\\n\\t    if (quantity[i] == r[j])\\n\\t      {\\n\\t\\tr[j] = 0;\\n\\n\\t\\tbreak;\\n\\t      }\\n\\t  }\\n\\tif (j == r.length)\\n\\t  {\\n\\t    for (k = 1; k < r.length; k++)     //case 2 loop\\n\\t      {\\n\\t\\tif (quantity[i] < r[k])\\n\\t\\t  {\\n\\t\\t    if (r[k] != 0 && (r[k] % quantity[i]) == 0)\\n\\t\\t      {\\n\\n\\t\\t\\tr[k] = (r[k] - quantity[i]);\\n\\n\\t\\t\\tbreak;\\n\\t\\t      }\\n\\t\\t  }\\n\\t      }\\n\\t  }\\n\\tif (k == r.length)\\n\\t  {\\n\\t    for (l = 1; l < r.length; l++)    //case 3 loop\\n\\t      {\\n\\t\\tif (quantity[i] < r[l])\\n\\t\\t  {\\n\\t\\t    r[l] -= quantity[i];\\n\\n\\t\\t    break;\\n\\t\\t  }\\n\\t      }\\n\\t  }\\n\\tif (j == r.length && k == r.length && l == r.length)\\n\\t  {\\n\\t    return false;\\n\\t  }\\n      }\\n    return true;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n  public boolean canDistribute (int[]nums, int[]quantity)\\n  {\\n    int n = quantity.length;\\n      Arrays.sort (quantity);\\n    for (int i = 0; i < n / 2; i++)\\n      {\\n\\tint temp = quantity[i];\\n\\t  quantity[i] = quantity[n - i - 1];\\n\\n\\t  quantity[n - i - 1] = temp;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1560161,
                "title": "java-9-ms-26-lines-dfs-beat-95",
                "content": "```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n\\tint[] count = new int[1001];\\n\\tfor (int num : nums)\\n\\t\\t++count[num];\\n\\tArrays.sort(quantity);\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int num : count)\\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\treturn dfs(quantity, map, quantity.length - 1);\\n}\\n\\nprivate boolean dfs(int[] quantity, Map<Integer, Integer> map, int curr) {\\n\\tif (curr == -1)\\n\\t\\treturn true;\\n\\tfor (int key : new HashSet<>(map.keySet()))\\n\\t\\tif (key >= quantity[curr]) {\\n\\t\\t\\tmap.put(key, map.get(key) - 1);\\n\\t\\t\\tmap.remove(key, 0);\\n\\t\\t\\tmap.put(key - quantity[curr], map.getOrDefault(key - quantity[curr], 0) + 1);\\n\\t\\t\\tif (dfs(quantity, map, curr - 1))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tmap.put(key - quantity[curr], map.get(key - quantity[curr]) - 1);\\n\\t\\t\\tmap.remove(key - quantity[curr], 0);\\n\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n\\tint[] count = new int[1001];\\n\\tfor (int num : nums)\\n\\t\\t++count[num];\\n\\tArrays.sort(quantity);\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int num : count)\\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\treturn dfs(quantity, map, quantity.length - 1);\\n}\\n\\nprivate boolean dfs(int[] quantity, Map<Integer, Integer> map, int curr) {\\n\\tif (curr == -1)\\n\\t\\treturn true;\\n\\tfor (int key : new HashSet<>(map.keySet()))\\n\\t\\tif (key >= quantity[curr]) {\\n\\t\\t\\tmap.put(key, map.get(key) - 1);\\n\\t\\t\\tmap.remove(key, 0);\\n\\t\\t\\tmap.put(key - quantity[curr], map.getOrDefault(key - quantity[curr], 0) + 1);\\n\\t\\t\\tif (dfs(quantity, map, curr - 1))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tmap.put(key - quantity[curr], map.get(key - quantity[curr]) - 1);\\n\\t\\t\\tmap.remove(key - quantity[curr], 0);\\n\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489459,
                "title": "simple-dfs-with-bitmasking",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        arr=[0]*(1001)\\n        for i in nums:\\n            arr[i]+=1\\n            \\n        arr.sort(reverse=True)\\n        #print(arr)\\n        arr=arr[:10]\\n        dict={}\\n        def dfs(ind,arr):\\n            if ind==m:\\n                return True\\n            if (ind,tuple(arr)) in dict:\\n                return dict[(ind,tuple(arr))]\\n            \\n            for i in range(0,10):\\n                if arr[i]>=quantity[ind]:\\n                    arr[i]-=quantity[ind]\\n                    a=dfs(ind+1,arr)\\n                    arr[i]+=quantity[ind]\\n                    if a:\\n                        dict[(ind,tuple(arr))]=True\\n                        \\n                        return True\\n                    \\n            dict[(ind,tuple(arr))]=False\\n            return False\\n        m=len(quantity)\\n        return dfs(0,arr)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        arr=[0]*(1001)\\n        for i in nums:\\n            arr[i]+=1\\n            \\n        arr.sort(reverse=True)\\n        #print(arr)\\n        arr=arr[:10]\\n        dict={}",
                "codeTag": "Java"
            },
            {
                "id": 1293102,
                "title": "python-bfs-bitmask",
                "content": "```\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        # BFS bismask\\n        # Time: O(3^m) \\n\\t\\t# ref : https://cp-algorithms.com/algebra/all-submasks.html\\n        \\n        counts = sorted(\\n            Counter(nums).values(),\\n            reverse = True\\n        )[:len(quantity)]\\n        N, M = len(counts), len(quantity)\\n        \\n        subsums = [0] * (1 << M)\\n        for mask in range(1 << M):\\n            for i in range(M):\\n                if mask & (1 << i):\\n                    subsums[mask] += quantity[i]\\n        \\n        # q is reachable masks (of satisfied customers) in level i (counts[:i] have been exhausted)\\n        q = {0}\\n        for i in range(N):\\n            q_next = set()\\n            for mask in q:\\n                not_mask = ((1 << M) - 1) ^ mask\\n                submask = not_mask\\n                while submask:\\n                    if subsums[submask] <= counts[i]:\\n                        next_mask = mask | submask\\n                        if next_mask == (1 << M) - 1:\\n                            return True\\n                        q_next.add(next_mask)\\n                    submask = (submask - 1) & not_mask\\n            q = q_next\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        # BFS bismask\\n        # Time: O(3^m) \\n\\t\\t# ref : https://cp-algorithms.com/algebra/all-submasks.html\\n        \\n        counts = sorted(\\n            Counter(nums).values(),\\n            reverse = True\\n        )[:len(quantity)]\\n        N, M = len(counts), len(quantity)\\n        \\n        subsums = [0] * (1 << M)\\n        for mask in range(1 << M):\\n            for i in range(M):\\n                if mask & (1 << i):\\n                    subsums[mask] += quantity[i]\\n        \\n        # q is reachable masks (of satisfied customers) in level i (counts[:i] have been exhausted)\\n        q = {0}\\n        for i in range(N):\\n            q_next = set()\\n            for mask in q:\\n                not_mask = ((1 << M) - 1) ^ mask\\n                submask = not_mask\\n                while submask:\\n                    if subsums[submask] <= counts[i]:\\n                        next_mask = mask | submask\\n                        if next_mask == (1 << M) - 1:\\n                            return True\\n                        q_next.add(next_mask)\\n                    submask = (submask - 1) & not_mask\\n            q = q_next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1110578,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&q, map<int,int>&count, int idx){\\n        if(idx==q.size()){\\n            return true;\\n        }\\n        for(auto it=count.begin();it!=count.end();it++){\\n            if(it->second>=q[idx]){\\n                count[it->first]-=q[idx];\\n                if(solve(q,count,idx+1))\\n                    return true;\\n                count[it->first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(quantity,count,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&q, map<int,int>&count, int idx){\\n        if(idx==q.size()){\\n            return true;\\n        }\\n        for(auto it=count.begin();it!=count.end();it++){\\n            if(it->second>=q[idx]){\\n                count[it->first]-=q[idx];\\n                if(solve(q,count,idx+1))\\n                    return true;\\n                count[it->first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(quantity,count,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084121,
                "title": "c-dfs",
                "content": "sort quantity in descending order.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(auto a: nums) mp[a]++;\\n        \\n        \\n        vector<int> cnt;\\n        for(auto& [k, v] : mp) cnt.push_back(v);\\n        \\n        \\n        priority_queue<int> pq;\\n        for(auto a : cnt) {\\n            if(a > 0) pq.push(a);\\n        }\\n        sort(quantity.begin(), quantity.end(), [](int& a, int&b) { return a > b;});\\n\\n        return helper(cnt, quantity, 0);\\n    }\\n    \\n    bool helper(vector<int>& cnt, vector<int>& quantity, int pos) {\\n        if(pos == quantity.size()) return true;\\n        \\n        for(int i=0; i<cnt.size(); ++i) {\\n            int cur = cnt[i];\\n            if(cur >= quantity[pos]) {\\n                cnt[i] = cur - quantity[pos];\\n                if(helper(cnt, quantity, pos+1)) return true;\\n                cnt[i] = cur;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(auto a: nums) mp[a]++;\\n        \\n        \\n        vector<int> cnt;\\n        for(auto& [k, v] : mp) cnt.push_back(v);\\n        \\n        \\n        priority_queue<int> pq;\\n        for(auto a : cnt) {\\n            if(a > 0) pq.push(a);\\n        }\\n        sort(quantity.begin(), quantity.end(), [](int& a, int&b) { return a > b;});\\n\\n        return helper(cnt, quantity, 0);\\n    }\\n    \\n    bool helper(vector<int>& cnt, vector<int>& quantity, int pos) {\\n        if(pos == quantity.size()) return true;\\n        \\n        for(int i=0; i<cnt.size(); ++i) {\\n            int cur = cnt[i];\\n            if(cur >= quantity[pos]) {\\n                cnt[i] = cur - quantity[pos];\\n                if(helper(cnt, quantity, pos+1)) return true;\\n                cnt[i] = cur;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962695,
                "title": "dfs-solution",
                "content": "First of all, we create a map mapping the repeat time to the number of integers repeated that time in the array. For example, for array [1,1,2,3], the map is {2:1, 1: 2}. Then, for each customer order, we need to choose the integer, from the integers repeating more than the order quantity, to satisfy his order. As long as each customer\\'s order is satisfied, we are able to distribute the array. One way to determine is by considering all possible distributions. As long as one of distribution satisfy the conditions, it is ok. This is backtracing. \\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def dfs(idx):\\n            if idx >= len(quantity):\\n                return True\\n            repeat_array = list(repeat_map.keys())\\n            for r in repeat_array:\\n                # we can use certain integer, repeated r times, \\n                # satisfy the order\\n                if r >= quantity[idx]:\\n                    # update the map after the order is satisfied\\n                    repeat_map[r] -= 1\\n                    if repeat_map[r] == 0:\\n                        del repeat_map[r]\\n                    repeat_map[r-quantity[idx]] = repeat_map.get(r-quantity[idx],0)+1\\n                    if dfs(idx+1):\\n                        return True\\n                    # recover to the original state\\n                    repeat_map[r-quantity[idx]] -= 1\\n                    if repeat_map[r-quantity[idx]] == 0:\\n                        del repeat_map[r-quantity[idx]]\\n                    repeat_map[r] = repeat_map.get(r, 0)+1\\n            return False\\n        \\n        \\n        num_map = [0]*1001\\n        for n in nums:\\n            num_map[n] += 1\\n        # map repeat time to the number of integers repeated exactly that time. \\n        repeat_map = {}\\n        for n in num_map:\\n            repeat_map[n] = repeat_map.get(n, 0)+1\\n        if dfs(0):\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def dfs(idx):\\n            if idx >= len(quantity):\\n                return True\\n            repeat_array = list(repeat_map.keys())\\n            for r in repeat_array:\\n                # we can use certain integer, repeated r times, \\n                # satisfy the order\\n                if r >= quantity[idx]:\\n                    # update the map after the order is satisfied\\n                    repeat_map[r] -= 1\\n                    if repeat_map[r] == 0:\\n                        del repeat_map[r]\\n                    repeat_map[r-quantity[idx]] = repeat_map.get(r-quantity[idx],0)+1\\n                    if dfs(idx+1):\\n                        return True\\n                    # recover to the original state\\n                    repeat_map[r-quantity[idx]] -= 1\\n                    if repeat_map[r-quantity[idx]] == 0:\\n                        del repeat_map[r-quantity[idx]]\\n                    repeat_map[r] = repeat_map.get(r, 0)+1\\n            return False\\n        \\n        \\n        num_map = [0]*1001\\n        for n in nums:\\n            num_map[n] += 1\\n        # map repeat time to the number of integers repeated exactly that time. \\n        repeat_map = {}\\n        for n in num_map:\\n            repeat_map[n] = repeat_map.get(n, 0)+1\\n        if dfs(0):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942307,
                "title": "c-backtracking-greedy-with-some-optimizations-beat-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& freq, vector<int>& q, int index) {\\n        if (index >= q.size()) return true;\\n        \\n        int j = 0;\\n        for (int i = 0; i < freq.size(); i = j) {\\n            // Optimization 2: reduce double count.\\n            for (j = i; j < freq.size() && freq[j] == freq[i]; j++);\\n            \\n            if (q[index] > freq[i]) continue;\\n            freq[i] -= q[index];\\n            if (dfs(freq, q, index + 1)) {\\n                return true;\\n            }\\n            freq[i] += q[index];\\n        } \\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int total = 0;\\n        for (auto q: quantity) total += q;\\n        if (total > nums.size()) return false;\\n        \\n        unordered_map<int, int> m1;\\n        for (auto n: nums) m1[n]++;\\n        vector<int> freq;\\n        for (auto it: m1) freq.push_back(it.second);\\n        \\n        // Optimization 1: Greedy, start from the large integer.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        return dfs(freq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& freq, vector<int>& q, int index) {\\n        if (index >= q.size()) return true;\\n        \\n        int j = 0;\\n        for (int i = 0; i < freq.size(); i = j) {\\n            // Optimization 2: reduce double count.\\n            for (j = i; j < freq.size() && freq[j] == freq[i]; j++);\\n            \\n            if (q[index] > freq[i]) continue;\\n            freq[i] -= q[index];\\n            if (dfs(freq, q, index + 1)) {\\n                return true;\\n            }\\n            freq[i] += q[index];\\n        } \\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int total = 0;\\n        for (auto q: quantity) total += q;\\n        if (total > nums.size()) return false;\\n        \\n        unordered_map<int, int> m1;\\n        for (auto n: nums) m1[n]++;\\n        vector<int> freq;\\n        for (auto it: m1) freq.push_back(it.second);\\n        \\n        // Optimization 1: Greedy, start from the large integer.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        return dfs(freq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936501,
                "title": "java-dp-bottom-up-bitmasking-o-n-3-m-time-complexity",
                "content": "```\\n/*\\nTime Complexity = O(N * (3 ^ M)) where N = \\'unique values\\' in nums ( = 50), M = size of \\'quantity\\'\\n*/\\n\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int rows = 0, cols = quantity.length;\\n        Map<Integer, Integer> frequencyByNumber = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            frequencyByNumber.put(nums[i], 1 + frequencyByNumber.getOrDefault(nums[i], 0));\\n        }\\n        List<Integer> numbers = new ArrayList<Integer>(frequencyByNumber.keySet());\\n        rows = numbers.size();\\n        int[] requirement = new int[(1 << cols)];\\n        for(int mask = 0; mask < (1 << cols); mask++) {\\n            for(int i = 0; i < cols; i++) {\\n                if((mask & (1 << i)) != 0) {\\n                    requirement[mask] += quantity[i];\\n                }\\n            }\\n        }\\n        boolean[][] DP = new boolean[rows + 1][(1 << cols)];\\n        DP[0][0] = true;\\n        for(int i = 0; i < rows; i++) {\\n            for(int mask = ((1 << cols) - 1); mask >= 0; mask--) {\\n                DP[i + 1][mask] = DP[i + 1][mask] || DP[i][mask];\\n                for(int subMask = mask; subMask > 0; subMask = ((subMask - 1) & mask)) {\\n                    if(requirement[subMask] <= frequencyByNumber.get(numbers.get(i)) && DP[i][mask ^ subMask]) {\\n                        DP[i + 1][mask] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return DP[rows][(1 << cols) - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nTime Complexity = O(N * (3 ^ M)) where N = \\'unique values\\' in nums ( = 50), M = size of \\'quantity\\'\\n*/\\n\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int rows = 0, cols = quantity.length;\\n        Map<Integer, Integer> frequencyByNumber = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            frequencyByNumber.put(nums[i], 1 + frequencyByNumber.getOrDefault(nums[i], 0));\\n        }\\n        List<Integer> numbers = new ArrayList<Integer>(frequencyByNumber.keySet());\\n        rows = numbers.size();\\n        int[] requirement = new int[(1 << cols)];\\n        for(int mask = 0; mask < (1 << cols); mask++) {\\n            for(int i = 0; i < cols; i++) {\\n                if((mask & (1 << i)) != 0) {\\n                    requirement[mask] += quantity[i];\\n                }\\n            }\\n        }\\n        boolean[][] DP = new boolean[rows + 1][(1 << cols)];\\n        DP[0][0] = true;\\n        for(int i = 0; i < rows; i++) {\\n            for(int mask = ((1 << cols) - 1); mask >= 0; mask--) {\\n                DP[i + 1][mask] = DP[i + 1][mask] || DP[i][mask];\\n                for(int subMask = mask; subMask > 0; subMask = ((subMask - 1) & mask)) {\\n                    if(requirement[subMask] <= frequencyByNumber.get(numbers.get(i)) && DP[i][mask ^ subMask]) {\\n                        DP[i + 1][mask] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return DP[rows][(1 << cols) - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936159,
                "title": "java-intuitive-recursive-solution-trying-all-possibilities-76ms",
                "content": "It does\\'t matter which numbers we give out. It is the frequencies of numbers that tell whether we can give out that particular number or not. \\n\\nThe key for this to get accepted is processing quantity requests in decreasing order.\\n\\n```\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // frequency of numbers in nums array\\n        int[] freq = new int[1001]; // 1 <= nums[i] <= 1000\\n        int count = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            if (freq[num] == 1) count++;\\n        }\\n        \\n        // stores frequencies of unique numbers appearing in nums.\\n        int[] numFreq = new int[count];\\n        int idx = 0;\\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] == 0) continue; // i didn\\'t occur in nums array.\\n            numFreq[idx++] = freq[i];\\n        }\\n        \\n        // without this sort, we get TLE. couldn\\'t figure this during contest. damn it!\\n        // Processing large quantity requests first reduces recursion tree size.\\n        Arrays.sort(quantity);\\n        // Java doesn\\'t have sort ints in decreasing order. So, we will process from end.\\n        return distribute(numFreq, quantity, quantity.length-1);\\n    }\\n    \\n    private boolean distribute(int[] numFreq, int[] quantity, int idx) {\\n        // try all num frequencies which can satisfy quantity[idx]\\n        boolean result = false;\\n        for (int i = 0; i < numFreq.length; i++) {\\n            if (numFreq[i] >= quantity[idx]) {\\n                numFreq[i] -= quantity[idx];\\n                result = idx == 0 ? true : distribute(numFreq, quantity, idx-1);\\n                if (result) break;\\n                numFreq[i] += quantity[idx]; // backtrack. it didn\\'t work.\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // frequency of numbers in nums array\\n        int[] freq = new int[1001]; // 1 <= nums[i] <= 1000\\n        int count = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            if (freq[num] == 1) count++;\\n        }\\n        \\n        // stores frequencies of unique numbers appearing in nums.\\n        int[] numFreq = new int[count];\\n        int idx = 0;\\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] == 0) continue; // i didn\\'t occur in nums array.\\n            numFreq[idx++] = freq[i];\\n        }\\n        \\n        // without this sort, we get TLE. couldn\\'t figure this during contest. damn it!\\n        // Processing large quantity requests first reduces recursion tree size.\\n        Arrays.sort(quantity);\\n        // Java doesn\\'t have sort ints in decreasing order. So, we will process from end.\\n        return distribute(numFreq, quantity, quantity.length-1);\\n    }\\n    \\n    private boolean distribute(int[] numFreq, int[] quantity, int idx) {\\n        // try all num frequencies which can satisfy quantity[idx]\\n        boolean result = false;\\n        for (int i = 0; i < numFreq.length; i++) {\\n            if (numFreq[i] >= quantity[idx]) {\\n                numFreq[i] -= quantity[idx];\\n                result = idx == 0 ? true : distribute(numFreq, quantity, idx-1);\\n                if (result) break;\\n                numFreq[i] += quantity[idx]; // backtrack. it didn\\'t work.\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935541,
                "title": "java-backtracking-324-ms-faster-than-80-00-54-3-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = nums.length;\\n        int n = quantity.length;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        for (int num : nums) {\\n            cnts.put(num, cnts.getOrDefault(num, 0) + 1);\\n        }\\n        Arrays.sort(quantity);\\n        return dfs(new ArrayList<>(cnts.values()), quantity.length - 1, quantity);\\n    }\\n\\n    private boolean dfs(List<Integer> cnts, int pos, int[] quantity) {\\n        if (pos < 0) {\\n            return true;\\n        }\\n        for (int i = 0; i < cnts.size(); ++i) {\\n            if (cnts.get(i) >= quantity[pos]) {\\n                cnts.set(i, cnts.get(i) - quantity[pos]);\\n                if (dfs(cnts, pos - 1, quantity)) {\\n                    return true;\\n                }\\n                cnts.set(i, cnts.get(i) + quantity[pos]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = nums.length;\\n        int n = quantity.length;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        for (int num : nums) {\\n            cnts.put(num, cnts.getOrDefault(num, 0) + 1);\\n        }\\n        Arrays.sort(quantity);\\n        return dfs(new ArrayList<>(cnts.values()), quantity.length - 1, quantity);\\n    }\\n\\n    private boolean dfs(List<Integer> cnts, int pos, int[] quantity) {\\n        if (pos < 0) {\\n            return true;\\n        }\\n        for (int i = 0; i < cnts.size(); ++i) {\\n            if (cnts.get(i) >= quantity[pos]) {\\n                cnts.set(i, cnts.get(i) - quantity[pos]);\\n                if (dfs(cnts, pos - 1, quantity)) {\\n                    return true;\\n                }\\n                cnts.set(i, cnts.get(i) + quantity[pos]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935492,
                "title": "c-backtrack-backtrack-with-explanation",
                "content": "The algorithm consists of:\\n1) Counting the occurance of each number in input array;\\n2) Leave only ```quantity.size()``` amount of the most frequently met numbers;\\n3) Sort quantity in descending order for better performance;\\n4) Run backtrack;\\n5) Return true, if backtrack found at least 1 solution, otherwise return false.\\n```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int> &n, const vector<int> &q, int k) {\\n        if (k == q.size())\\n            return true;  // All customers are satisfied\\n        for (int i = 0; i < n.size(); ++i) {\\n            if (n[i] >= q[k]) {\\n                n[i] -= q[k];  \\n                if (backtrack(n, q, k + 1)) {  // Trying to satisfy next customer\\n                    return true;\\n                }\\n                n[i] += q[k];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& n, vector<int>& q) {\\n        if (q.size() == 0) {\\n            return true;\\n        }\\n\\t\\t// Calculate repeated nums\\n\\t\\tvector<int> count(1001, 0);\\n        for (int i = 0; i < n.size(); ++i) {\\n            ++count[n[i]];\\n        }\\n        \\n\\t\\t// Sort in reversed order\\n        sort(count.begin(), count.end(), greater<int>());\\n        sort(q.begin(), q.end(), greater<int>());\\n\\t\\t\\n        // Max number of unique numbers we can use to satisfy each customer\\n        count.resize(q.size());\\n        \\n        return backtrack(count, q, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```quantity.size()```\n```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int> &n, const vector<int> &q, int k) {\\n        if (k == q.size())\\n            return true;  // All customers are satisfied\\n        for (int i = 0; i < n.size(); ++i) {\\n            if (n[i] >= q[k]) {\\n                n[i] -= q[k];  \\n                if (backtrack(n, q, k + 1)) {  // Trying to satisfy next customer\\n                    return true;\\n                }\\n                n[i] += q[k];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& n, vector<int>& q) {\\n        if (q.size() == 0) {\\n            return true;\\n        }\\n\\t\\t// Calculate repeated nums\\n\\t\\tvector<int> count(1001, 0);\\n        for (int i = 0; i < n.size(); ++i) {\\n            ++count[n[i]];\\n        }\\n        \\n\\t\\t// Sort in reversed order\\n        sort(count.begin(), count.end(), greater<int>());\\n        sort(q.begin(), q.end(), greater<int>());\\n\\t\\t\\n        // Max number of unique numbers we can use to satisfy each customer\\n        count.resize(q.size());\\n        \\n        return backtrack(count, q, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935392,
                "title": "python3-sort-backtracking",
                "content": "```\\nfrom collections import Counter\\nimport bisect\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        nums = list(Counter(nums).values())\\n        nums.sort()\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def solve(qi):\\n            if qi == len(quantity):\\n                return True\\n            elif len(nums)==0:\\n                return False\\n            else:\\n                cs = bisect.bisect_left(nums, quantity[qi])\\n                if cs < len(nums) and nums[cs]>=quantity[qi]:\\n                    for x in range(cs,len(nums)):\\n                        r = nums.pop(x)\\n                        rem = r -  quantity[qi]\\n                        idx = bisect.bisect_right(nums, rem)\\n                        bisect.insort(nums, rem)\\n                        if solve(qi+1):\\n                            return True\\n                        del nums[idx]\\n                        nums.insert(idx, r)\\n                \\n                return False\\n        \\n        return solve(0)\\n```   \\nPrune search by fulfilling largest orders first. Use insort to maintain remaining orders as the list is small.\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nimport bisect\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        nums = list(Counter(nums).values())\\n        nums.sort()\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def solve(qi):\\n            if qi == len(quantity):\\n                return True\\n            elif len(nums)==0:\\n                return False\\n            else:\\n                cs = bisect.bisect_left(nums, quantity[qi])\\n                if cs < len(nums) and nums[cs]>=quantity[qi]:\\n                    for x in range(cs,len(nums)):\\n                        r = nums.pop(x)\\n                        rem = r -  quantity[qi]\\n                        idx = bisect.bisect_right(nums, rem)\\n                        bisect.insort(nums, rem)\\n                        if solve(qi+1):\\n                            return True\\n                        del nums[idx]\\n                        nums.insert(idx, r)\\n                \\n                return False\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974700,
                "title": "1655-distribute-repeating-integers",
                "content": "```\\nclass Solution {\\n public:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    // validDistribution[i][j] := true if it\\'s possible to distribute i-th freq\\n    // into a subset of quantity represented by the mask j\\n    const vector<int> freqs = getFreqs(nums);\\n    const vector<vector<bool>> validDistribution =\\n        getValidDistribuition(freqs, quantity);\\n    const int n = freqs.size();\\n    const int m = quantity.size();\\n    const int maxMask = 1 << m;\\n    // dp[i][j] := true if it\\'s possible to distribute freqs[i:] with selected\\n    // quantity represented by the mask j\\n    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));\\n    dp[n][maxMask - 1] = true;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int mask = 0; mask < maxMask; ++mask) {\\n        dp[i][mask] = dp[i + 1][mask];\\n        const int availableMask = ~mask & (maxMask - 1);\\n        for (int submask = availableMask; submask > 0;\\n             submask = (submask - 1) & availableMask)\\n          if (validDistribution[i][submask])\\n            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];\\n      }\\n\\n    return dp[0][0];\\n  }\\n\\n private:\\n  vector<int> getFreqs(const vector<int>& nums) {\\n    vector<int> freqs;\\n    unordered_map<int, int> count;\\n    for (const int num : nums)\\n      ++count[num];\\n    for (const auto& [_, freq] : count)\\n      freqs.push_back(freq);\\n    return freqs;\\n  }\\n\\n  vector<vector<bool>> getValidDistribuition(const vector<int>& freqs,\\n                                             const vector<int>& quantity) {\\n    const int maxMask = 1 << quantity.size();\\n    vector<vector<bool>> validDistribution(freqs.size(), vector<bool>(maxMask));\\n    for (int i = 0; i < freqs.size(); ++i)\\n      for (int mask = 0; mask < maxMask; ++mask)\\n        if (freqs[i] >= getQuantitySum(quantity, mask))\\n          validDistribution[i][mask] = true;\\n    return validDistribution;\\n  }\\n\\n  // Returns the sum of the selected quantity represented by the `mask`.\\n  int getQuantitySum(const vector<int>& quantity, int mask) {\\n    int sum = 0;\\n    for (int i = 0; i < quantity.size(); ++i)\\n      if (mask >> i & 1)\\n        sum += quantity[i];\\n    return sum;\\n  }\\n};\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "class Solution {\\n public:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    // validDistribution[i][j] := true if it\\'s possible to distribute i-th freq\\n    // into a subset of quantity represented by the mask j\\n    const vector<int> freqs = getFreqs(nums);\\n    const vector<vector<bool>> validDistribution =\\n        getValidDistribuition(freqs, quantity);\\n    const int n = freqs.size();\\n    const int m = quantity.size();\\n    const int maxMask = 1 << m;\\n    // dp[i][j] := true if it\\'s possible to distribute freqs[i:] with selected\\n    // quantity represented by the mask j\\n    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));\\n    dp[n][maxMask - 1] = true;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int mask = 0; mask < maxMask; ++mask) {\\n        dp[i][mask] = dp[i + 1][mask];\\n        const int availableMask = ~mask & (maxMask - 1);\\n        for (int submask = availableMask; submask > 0;\\n             submask = (submask - 1) & availableMask)\\n          if (validDistribution[i][submask])\\n            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3907242,
                "title": "c-backtracking-easy",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<int> &frq, vector<int> &quantity, int idx){\\n        // Base condition\\n        if(idx >= quantity.size()) return true;\\n\\n        for(auto &f : frq){\\n            if(f >= quantity[idx]){\\n                f -= quantity[idx];\\n                if(helper(frq, quantity, idx + 1)) return true;\\n                // Back tracking\\n                f += quantity[idx];\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // Intution\\n        // The idea in here is really very simple. First we will count the frequencies of characters present in the nums vector and then we will store them inside a map\\n        unordered_map<int, int> mp;\\n        for(auto & num : nums){\\n            mp[num] += 1;\\n        }\\n        vector<int> frq;\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            frq.push_back(itr->second);\\n        }\\n        // Reverse sorting the frq and the quantity array so that the frequencies can be correctly related\\n        sort(frq.rbegin(), frq.rend());\\n        sort(quantity.rbegin(), quantity.rend());\\n        return helper(frq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool helper(vector<int> &frq, vector<int> &quantity, int idx){\\n        // Base condition\\n        if(idx >= quantity.size()) return true;\\n\\n        for(auto &f : frq){\\n            if(f >= quantity[idx]){\\n                f -= quantity[idx];\\n                if(helper(frq, quantity, idx + 1)) return true;\\n                // Back tracking\\n                f += quantity[idx];\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // Intution\\n        // The idea in here is really very simple. First we will count the frequencies of characters present in the nums vector and then we will store them inside a map\\n        unordered_map<int, int> mp;\\n        for(auto & num : nums){\\n            mp[num] += 1;\\n        }\\n        vector<int> frq;\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            frq.push_back(itr->second);\\n        }\\n        // Reverse sorting the frq and the quantity array so that the frequencies can be correctly related\\n        sort(frq.rbegin(), frq.rend());\\n        sort(quantity.rbegin(), quantity.rend());\\n        return helper(frq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880824,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_distinct_nums * (3 ^ n_quantity))\\n * Space Complexity: O(n_distinct_nums + (2 ^ n_quantity))\\n * where `n_distinct_nums` is the number of distinct elements of the vector `nums`\\n *       `n_quantity` is the length of the vector `quantity`\\n */\\nclass Solution {\\n public:\\n  bool canDistribute(const vector<int> &nums, const vector<int> &quantity) {\\n    constexpr int range = 2;\\n    unordered_map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n\\n    vector<int> counts;\\n    for (const auto [_, count] : num_to_count) {\\n      counts.emplace_back(count);\\n    }\\n\\n    const int n_quantity = static_cast<int>(quantity.size());\\n    const int layouts = 1 << n_quantity;\\n    int layout_to_count[layouts];\\n    memset(layout_to_count, 0, sizeof(layout_to_count));\\n    for (int i = 0; i < n_quantity; ++i) {\\n      for (int sub_layout = 0; sub_layout < (1 << i); ++sub_layout) {\\n        layout_to_count[(1 << i) | sub_layout] = quantity[i] + layout_to_count[sub_layout];\\n      }\\n    }\\n\\n    bool dp[range][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = true;\\n    const int n_distinct_nums = static_cast<int>(counts.size());\\n    for (int i = 0; i < n_distinct_nums && !dp[previous][layouts - 1]; ++i) {\\n      const int count = counts[i];\\n      dp[current][0] = true;\\n      for (int current_layout = 1; current_layout < layouts; ++current_layout) {\\n        dp[current][current_layout] = dp[previous][current_layout];\\n        for (int sub_layout = current_layout; sub_layout > 0; sub_layout = (sub_layout - 1) & current_layout) {\\n          if (layout_to_count[sub_layout] <= count && dp[previous][current_layout ^ sub_layout]) {\\n            dp[current][current_layout] = true;\\n          }\\n        }\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][layouts - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_distinct_nums * (3 ^ n_quantity))\\n * Space Complexity: O(n_distinct_nums + (2 ^ n_quantity))\\n * where `n_distinct_nums` is the number of distinct elements of the vector `nums`\\n *       `n_quantity` is the length of the vector `quantity`\\n */\\nclass Solution {\\n public:\\n  bool canDistribute(const vector<int> &nums, const vector<int> &quantity) {\\n    constexpr int range = 2;\\n    unordered_map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n\\n    vector<int> counts;\\n    for (const auto [_, count] : num_to_count) {\\n      counts.emplace_back(count);\\n    }\\n\\n    const int n_quantity = static_cast<int>(quantity.size());\\n    const int layouts = 1 << n_quantity;\\n    int layout_to_count[layouts];\\n    memset(layout_to_count, 0, sizeof(layout_to_count));\\n    for (int i = 0; i < n_quantity; ++i) {\\n      for (int sub_layout = 0; sub_layout < (1 << i); ++sub_layout) {\\n        layout_to_count[(1 << i) | sub_layout] = quantity[i] + layout_to_count[sub_layout];\\n      }\\n    }\\n\\n    bool dp[range][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = true;\\n    const int n_distinct_nums = static_cast<int>(counts.size());\\n    for (int i = 0; i < n_distinct_nums && !dp[previous][layouts - 1]; ++i) {\\n      const int count = counts[i];\\n      dp[current][0] = true;\\n      for (int current_layout = 1; current_layout < layouts; ++current_layout) {\\n        dp[current][current_layout] = dp[previous][current_layout];\\n        for (int sub_layout = current_layout; sub_layout > 0; sub_layout = (sub_layout - 1) & current_layout) {\\n          if (layout_to_count[sub_layout] <= count && dp[previous][current_layout ^ sub_layout]) {\\n            dp[current][current_layout] = true;\\n          }\\n        }\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][layouts - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828403,
                "title": "using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    bool canDistributeHelper(vector<int>& counts, vector<int>& quantity, int ithCustomer)\\n    {\\n        // Base case\\n        if(ithCustomer == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0; i<counts.size(); i++)\\n        {\\n            if(counts[i] >= quantity[ithCustomer])\\n            {\\n                counts[i] -= quantity[ithCustomer];\\n\\n                if(canDistributeHelper(counts, quantity, ithCustomer + 1))\\n                {\\n                    return true;\\n                }\\n                counts[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num:nums)\\n        {\\n            countMap[num]++;\\n        }\\n        vector<int> counts;\\n        for(auto it: countMap)\\n        {\\n            counts.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend()); // sort DESC\\n        return canDistributeHelper(counts, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool canDistributeHelper(vector<int>& counts, vector<int>& quantity, int ithCustomer)\\n    {\\n        // Base case\\n        if(ithCustomer == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0; i<counts.size(); i++)\\n        {\\n            if(counts[i] >= quantity[ithCustomer])\\n            {\\n                counts[i] -= quantity[ithCustomer];\\n\\n                if(canDistributeHelper(counts, quantity, ithCustomer + 1))\\n                {\\n                    return true;\\n                }\\n                counts[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num:nums)\\n        {\\n            countMap[num]++;\\n        }\\n        vector<int> counts;\\n        for(auto it: countMap)\\n        {\\n            counts.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend()); // sort DESC\\n        return canDistributeHelper(counts, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797874,
                "title": "easy-c-map-solution",
                "content": "**Intuition:**\\n\\nThe problem requires checking if it is possible to distribute the integers in `nums` among the customers such that each customer receives exactly `quantity[i]` integers, all integers the customer receives are equal, and all customers are satisfied. To achieve this, we need to try all possible combinations of the integers in `nums` and check if they can satisfy the given quantities for each customer.\\n\\n**Approach:**\\n\\n1. Create a frequency map (`freqMap`) to store the count of each unique integer in `nums`.\\n2. Extract the unique integers from `freqMap` and store them in the `uniqueNums` array.\\n3. Use backtracking to try all possible combinations of `uniqueNums` and check if they can satisfy the orders for each customer. Start with the first customer (`idx = 0`) and recursively explore all possibilities.\\n4. During backtracking, for each unique integer, check if it has enough frequency to satisfy the current customer\\'s order. If yes, reduce its frequency and continue with the next customer. If no, backtrack and try other possibilities.\\n5. If we can satisfy all customers\\' orders, return `true`; otherwise, return `false`.\\n\\n**Complexity Analysis:**\\n\\nLet N be the length of `nums` (number of integers) and M be the number of customers.\\n\\n- Time Complexity: The time complexity of this approach is O(2^M * N). For each customer, we have two choices for each unique integer in `nums`: either include it in the current customer\\'s order or exclude it. This results in 2^M possible combinations to check.\\n- Space Complexity: The space complexity is O(N + M) to store the frequency map (`freqMap`) and the recursion stack.\\n\\n# Code\\n```\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freqMap;\\n        for (int num : nums) {\\n            freqMap[num]++;\\n        }\\n        sort(quantity.rbegin(), quantity.rend());\\n        vector<int> uniqueNums;\\n        for (auto& entry : freqMap) {\\n            uniqueNums.push_back(entry.first);\\n        }\\n        \\n        return backtrack(uniqueNums, freqMap, quantity, 0);\\n    }\\n    \\n    bool backtrack(vector<int>& uniqueNums, unordered_map<int, int>& freqMap, vector<int>& quantity, int idx) {\\n        if (idx == quantity.size()) {\\n            return true; // All customers are satisfied\\n        }\\n        \\n        for (int i = 0; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums[i];\\n            if (freqMap[num] >= quantity[idx]) {\\n                freqMap[num] -= quantity[idx]; // Decrease the frequency of current number\\n                if (backtrack(uniqueNums, freqMap, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                freqMap[num] += quantity[idx]; // Backtrack by increasing the frequency\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freqMap;\\n        for (int num : nums) {\\n            freqMap[num]++;\\n        }\\n        sort(quantity.rbegin(), quantity.rend());\\n        vector<int> uniqueNums;\\n        for (auto& entry : freqMap) {\\n            uniqueNums.push_back(entry.first);\\n        }\\n        \\n        return backtrack(uniqueNums, freqMap, quantity, 0);\\n    }\\n    \\n    bool backtrack(vector<int>& uniqueNums, unordered_map<int, int>& freqMap, vector<int>& quantity, int idx) {\\n        if (idx == quantity.size()) {\\n            return true; // All customers are satisfied\\n        }\\n        \\n        for (int i = 0; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums[i];\\n            if (freqMap[num] >= quantity[idx]) {\\n                freqMap[num] -= quantity[idx]; // Decrease the frequency of current number\\n                if (backtrack(uniqueNums, freqMap, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                freqMap[num] += quantity[idx]; // Backtrack by increasing the frequency\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3768146,
                "title": "distribute-repeating-integers-recursive-backtracking",
                "content": "# Intuition\\nUpon analyzing the problem, my initial thoughts on how to solve it are as follows:\\n\\n1. To satisfy the given conditions, each customer must receive a specific quantity of integers, and all the integers for each customer must be equal.\\n2. We need to determine if it is possible to distribute the given `nums` array in a way that satisfies all the customers\\' orders.\\n3. We can start by counting the frequency of each unique value in the `nums` array. This will give us an idea of the available quantities we have to distribute.\\n4. We can then sort the customers\\' order quantities in descending order to prioritize larger orders.\\n5. Next, we can try to distribute the integers from the `nums` array to satisfy each customer\\'s order quantity.\\n6. We can use recursion with backtracking to explore different possible distributions. We start with the largest order quantity and iterate over the available quantities. For each available quantity, we try to satisfy the current customer\\'s order by reducing the quantity from the available pool.\\n7. If we successfully distribute the integers for the current customer, we move on to the next customer and repeat the process recursively.\\n8. If at any point we are unable to satisfy a customer\\'s order, we backtrack by restoring the quantity for the previous customer and try different options.\\n9. If we are able to distribute all the integers and satisfy all the customers\\' orders, we return `true`. Otherwise, we return `false`.\\n\\nThis initial approach of using recursion with backtracking should help us explore different distribution possibilities and determine if it is possible to satisfy all the customers\\' orders according to the given conditions.\\n\\n# Approach\\nTo solve the problem, we can use a recursive approach with backtracking. Here\\'s the step-by-step approach:\\n\\n1. Create a frequency map to count the occurrences of each unique number in the `nums` array.\\n2. Convert the frequency map into a list of frequencies.\\n3. Sort the `quantity` array in descending order to prioritize larger orders.\\n4. Implement a recursive function, `distribute`, that takes the following parameters:\\n   - `frequencies`: A list of frequencies.\\n   - `quantity`: The `quantity` array.\\n   - `index`: The index of the current customer we are trying to satisfy.\\n5. Check the base case: If `index` is equal to the length of the `quantity` array, return `true` (all customers are satisfied).\\n6. Iterate over the frequencies list:\\n   - Get the current frequency.\\n   - If the frequency is greater than or equal to the current customer\\'s order quantity (`quantity[index]`):\\n     - Subtract the order quantity from the current frequency.\\n     - Recursively call the `distribute` function for the next customer (`index + 1`).\\n     - If the recursive call returns `true`, return `true`.\\n     - Otherwise, backtrack by restoring the frequency back to its original value.\\n7. If no distribution is possible for any frequency, return `false`.\\n8. Finally, call the `distribute` function with the initial parameters (`frequencies`, `quantity`, and `0`) and return the result.\\n\\nThe recursive `distribute` function tries to distribute the available frequencies to satisfy each customer\\'s order. It explores different possibilities by iterating over the frequencies and recursively calling itself for the next customer. If a distribution is successful for all customers, it returns `true`. If not, it backtracks and tries different options.\\n\\nBy following this approach, we can determine if it is possible to distribute the integers from the `nums` array to satisfy all the customers\\' orders according to the given conditions.\\n\\n# Complexity\\n- Time complexity:\\nO(2^m * n)\\n\\n- Space complexity:\\nO(n + m)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n   // Count the frequency of each unique number in nums\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Convert the frequency map to a list of frequencies\\n        List<Integer> frequencies = new ArrayList<>(frequencyMap.values());\\n        \\n        // Sort the quantities in descending order to prioritize larger orders\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        \\n        return distribute(frequencies, quantity, 0);\\n    }\\n    \\n    private boolean distribute(List<Integer> frequencies, int[] quantity, int index) {\\n        // Base case: All customers are satisfied\\n        if (index == quantity.length) {\\n            return true;\\n        }\\n        \\n        // Try to satisfy the current customer\\'s order quantity\\n        int orderQuantity = quantity[index];\\n        for (int i = 0; i < frequencies.size(); i++) {\\n            int frequency = frequencies.get(i);\\n            if (frequency >= orderQuantity) {\\n                // Use the current frequency to satisfy the order quantity\\n                frequencies.set(i, frequency - orderQuantity);\\n                \\n                // Recursively distribute the remaining quantities\\n                if (distribute(frequencies, quantity, index + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack: restore the frequency to its original value\\n                frequencies.set(i, frequency);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void reverse(int[] array) {\\n        int left = 0, right = array.length - 1;\\n        while (left < right) {\\n            int temp = array[left];\\n            array[left] = array[right];\\n            array[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n   // Count the frequency of each unique number in nums\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Convert the frequency map to a list of frequencies\\n        List<Integer> frequencies = new ArrayList<>(frequencyMap.values());\\n        \\n        // Sort the quantities in descending order to prioritize larger orders\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        \\n        return distribute(frequencies, quantity, 0);\\n    }\\n    \\n    private boolean distribute(List<Integer> frequencies, int[] quantity, int index) {\\n        // Base case: All customers are satisfied\\n        if (index == quantity.length) {\\n            return true;\\n        }\\n        \\n        // Try to satisfy the current customer\\'s order quantity\\n        int orderQuantity = quantity[index];\\n        for (int i = 0; i < frequencies.size(); i++) {\\n            int frequency = frequencies.get(i);\\n            if (frequency >= orderQuantity) {\\n                // Use the current frequency to satisfy the order quantity\\n                frequencies.set(i, frequency - orderQuantity);\\n                \\n                // Recursively distribute the remaining quantities\\n                if (distribute(frequencies, quantity, index + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack: restore the frequency to its original value\\n                frequencies.set(i, frequency);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void reverse(int[] array) {\\n        int left = 0, right = array.length - 1;\\n        while (left < right) {\\n            int temp = array[left];\\n            array[left] = array[right];\\n            array[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752005,
                "title": "backtracking-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& counts, vector<int>& qnty, int cus_indx)\\n    {\\n        //base case\\n        if(cus_indx >= qnty.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0;i<counts.size();i++)\\n        {\\n            if(counts[i] >= qnty[cus_indx])\\n            {\\n                counts[i] -= qnty[cus_indx];\\n                if(helper(counts, qnty, cus_indx + 1) == true){\\n                    return true;\\n                }\\n                counts[i] += qnty[cus_indx];//backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(int num : nums)\\n        {\\n            mp[num] += 1;\\n        }\\n\\n        vector<int> counts;\\n        for(auto it : mp)\\n        {\\n            counts.push_back(it.second);\\n        }\\n//agar mai sabse max quantity ko satisfy nahi kar paunga toh jaldi false condition dhoond loonga toh depth of recursion kam ho jayega aur back jaunga TLE se\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        int start_cus_indx = 0;\\n        return helper(counts, quantity, start_cus_indx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& counts, vector<int>& qnty, int cus_indx)\\n    {\\n        //base case\\n        if(cus_indx >= qnty.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0;i<counts.size();i++)\\n        {\\n            if(counts[i] >= qnty[cus_indx])\\n            {\\n                counts[i] -= qnty[cus_indx];\\n                if(helper(counts, qnty, cus_indx + 1) == true){\\n                    return true;\\n                }\\n                counts[i] += qnty[cus_indx];//backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(int num : nums)\\n        {\\n            mp[num] += 1;\\n        }\\n\\n        vector<int> counts;\\n        for(auto it : mp)\\n        {\\n            counts.push_back(it.second);\\n        }\\n//agar mai sabse max quantity ko satisfy nahi kar paunga toh jaldi false condition dhoond loonga toh depth of recursion kam ho jayega aur back jaunga TLE se\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        int start_cus_indx = 0;\\n        return helper(counts, quantity, start_cus_indx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708434,
                "title": "easy-simple-and-fastest-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\n    bool helper(vector<int>& arr, vector<int>& q, int idx) {\\n\\n        if(idx >= q.size()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] >= q[idx]) { \\n                arr[i] -= q[idx];\\n                if(helper(arr, q, idx+1))\\n                    return true;\\n                arr[i] += q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    void print(multiset<int>& arr) {\\n        for(int a : arr) cout<<a<<\" \";\\n            cout<<endl;\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        int len = nums.size();\\n\\n        for(int i=0; i<len; i++)  {\\n            mp[nums[i]]++;\\n        }\\n\\n        vector<int> arr;\\n        for(auto m : mp) {\\n            arr.push_back(m.second);\\n        }\\n\\n        // to optimize the algo arrange quantity arr in decending order.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        return helper(arr, quantity, 0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool helper(vector<int>& arr, vector<int>& q, int idx) {\\n\\n        if(idx >= q.size()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] >= q[idx]) { \\n                arr[i] -= q[idx];\\n                if(helper(arr, q, idx+1))\\n                    return true;\\n                arr[i] += q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    void print(multiset<int>& arr) {\\n        for(int a : arr) cout<<a<<\" \";\\n            cout<<endl;\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        int len = nums.size();\\n\\n        for(int i=0; i<len; i++)  {\\n            mp[nums[i]]++;\\n        }\\n\\n        vector<int> arr;\\n        for(auto m : mp) {\\n            arr.push_back(m.second);\\n        }\\n\\n        // to optimize the algo arrange quantity arr in decending order.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        return helper(arr, quantity, 0);\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3683549,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& qt, int i){\\n        if(i == qt.size())\\n        return true;\\n\\n        for(auto it:mp){\\n            if(it.second >= qt[i]){\\n                mp[it.first] = mp[it.first] - qt[i];\\n                \\n                bool ans = solve(mp, qt, i+1);\\n\\n                if(ans == true)\\n                return true;\\n                else\\n                mp[it.first] = mp[it.first] + qt[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> mp;\\n\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        return solve(mp, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& qt, int i){\\n        if(i == qt.size())\\n        return true;\\n\\n        for(auto it:mp){\\n            if(it.second >= qt[i]){\\n                mp[it.first] = mp[it.first] - qt[i];\\n                \\n                bool ans = solve(mp, qt, i+1);\\n\\n                if(ans == true)\\n                return true;\\n                else\\n                mp[it.first] = mp[it.first] + qt[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> mp;\\n\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        return solve(mp, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608628,
                "title": "c-solution-easy-to-understand-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool solve(vector<int>& quantity,vector<int>& counts,int ithcustomer)\\n{\\n    //base case\\n    if(ithcustomer == quantity.size())\\n    {\\n        return true;\\n    }\\n\\n    for(int i=0;i<counts.size();i++)\\n    {\\n        if(counts[i]>=quantity[ithcustomer]) // that means we can allocate to the customer \\n        {\\n          counts[i]-=quantity[ithcustomer];\\n          //recursive call\\n          if(solve(quantity,counts,ithcustomer+1))\\n          {\\n           return true;   \\n          }\\n          //backtrack\\n          counts[i]+=quantity[ithcustomer];\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n     //first i need to create a mapping for getting the frequency\\n     unordered_map<int,int>freq;\\n     for(auto num:nums)\\n     {\\n         freq[num]++;\\n     }\\n     vector<int>counts;\\n     for(auto it:freq)\\n     {\\n         counts.push_back(it.second); // so in counts we will be having only frequencies corresponding to integers\\n     }\\n     //************now sorting the quantity in decreasing order in order to get the false case faster******************\\n     sort(quantity.rbegin(),quantity.rend());\\n     return solve(quantity,counts,0); // this 0 refers to the ith customer\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool solve(vector<int>& quantity,vector<int>& counts,int ithcustomer)\\n{\\n    //base case\\n    if(ithcustomer == quantity.size())\\n    {\\n        return true;\\n    }\\n\\n    for(int i=0;i<counts.size();i++)\\n    {\\n        if(counts[i]>=quantity[ithcustomer]) // that means we can allocate to the customer \\n        {\\n          counts[i]-=quantity[ithcustomer];\\n          //recursive call\\n          if(solve(quantity,counts,ithcustomer+1))\\n          {\\n           return true;   \\n          }\\n          //backtrack\\n          counts[i]+=quantity[ithcustomer];\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n     //first i need to create a mapping for getting the frequency\\n     unordered_map<int,int>freq;\\n     for(auto num:nums)\\n     {\\n         freq[num]++;\\n     }\\n     vector<int>counts;\\n     for(auto it:freq)\\n     {\\n         counts.push_back(it.second); // so in counts we will be having only frequencies corresponding to integers\\n     }\\n     //************now sorting the quantity in decreasing order in order to get the false case faster******************\\n     sort(quantity.rbegin(),quantity.rend());\\n     return solve(quantity,counts,0); // this 0 refers to the ith customer\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593131,
                "title": "distribute-repeating-integers-c-solution-backtrack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute_helper(vector<int>& count, vector<int>& quantity, int ithCustomer){\\n        // base case\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n\\n        for(int i=0; i < count.size(); i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistribute_helper(count, quantity, ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       unordered_map<int, int>countNum;\\n       for(auto num: nums){\\n           countNum[num]++;\\n       } \\n       vector<int>count;\\n       for(auto i: countNum){\\n           count.push_back(i.second); // to access the count from map\\n       }\\n       sort(quantity.rbegin(), quantity.rend()); // Decreasing sort to reduce time complexity to find elements\\n       return canDistribute_helper(count, quantity, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute_helper(vector<int>& count, vector<int>& quantity, int ithCustomer){\\n        // base case\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n\\n        for(int i=0; i < count.size(); i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistribute_helper(count, quantity, ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       unordered_map<int, int>countNum;\\n       for(auto num: nums){\\n           countNum[num]++;\\n       } \\n       vector<int>count;\\n       for(auto i: countNum){\\n           count.push_back(i.second); // to access the count from map\\n       }\\n       sort(quantity.rbegin(), quantity.rend()); // Decreasing sort to reduce time complexity to find elements\\n       return canDistribute_helper(count, quantity, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579113,
                "title": "easy-and-beginner-friendly-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool canDistribute_helper( vector<int>&  count,vector<int>& quantity,int i){\\n    if(i>=quantity.size()){\\n        return true;\\n    }\\n\\n\\n    for(int j=0; j<count.size(); j++){\\n        if(count[j]>=quantity[i]){\\n            count[j]-=quantity[i];\\n           if(canDistribute_helper(count,quantity,i+1)){\\n               return true;\\n           }\\n            count[j]+=quantity[i];\\n        }\\n    }\\n    return false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(),nums.end());\\n        sort(quantity.rbegin(),quantity.rend());\\n        unordered_map<int,int>counts;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            counts[nums[i]]++;\\n        }\\n        vector<int>count;\\n        for(auto i:counts){\\n            count.push_back(i.second);\\n        }\\n        return canDistribute_helper(count,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool canDistribute_helper( vector<int>&  count,vector<int>& quantity,int i){\\n    if(i>=quantity.size()){\\n        return true;\\n    }\\n\\n\\n    for(int j=0; j<count.size(); j++){\\n        if(count[j]>=quantity[i]){\\n            count[j]-=quantity[i];\\n           if(canDistribute_helper(count,quantity,i+1)){\\n               return true;\\n           }\\n            count[j]+=quantity[i];\\n        }\\n    }\\n    return false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(),nums.end());\\n        sort(quantity.rbegin(),quantity.rend());\\n        unordered_map<int,int>counts;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            counts[nums[i]]++;\\n        }\\n        vector<int>count;\\n        for(auto i:counts){\\n            count.push_back(i.second);\\n        }\\n        return canDistribute_helper(count,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573933,
                "title": "easiest-small-solution-c-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool sol(map<int,int> &mp,vector<int> &q,int ind){\\n        if(ind >= q.size()) return true;\\n        for(auto &i:mp){\\n            if(i.second >= q[ind]){\\n                i.second -= q[ind];\\n                bool ans = sol(mp,q,ind+1);\\n                if(ans) return true;\\n                i.second += q[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        sort(q.rbegin(),q.rend());\\n        return sol(mp,q,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool sol(map<int,int> &mp,vector<int> &q,int ind){\\n        if(ind >= q.size()) return true;\\n        for(auto &i:mp){\\n            if(i.second >= q[ind]){\\n                i.second -= q[ind];\\n                bool ans = sol(mp,q,ind+1);\\n                if(ans) return true;\\n                i.second += q[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        sort(q.rbegin(),q.rend());\\n        return sol(mp,q,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571885,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: `O(nlogN)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // void printf(vector<int>&a){\\n    //     for(auto it:a)cout<<it<<\" \";\\n    //     cout<<endl;\\n    // }\\n    // bool check(vector<int>&a, int quan){\\n    //     int maxi = *max_element(a.begin(),a.end());\\n    //     //cout<<maxi;\\n    //     int n = a.size();\\n    //     if(maxi<quan) return false;\\n\\n    //     else{\\n    //         for(int i = n-1; i>=0; i--){\\n    //             if(a[i]>quan){\\n    //                 a[i] = a[i] - quan;\\n    //                 break;\\n    //             }\\n    //         }\\n    //         sort(a.begin(),a.end());\\n    //     }\\n    //     return true;\\n    // }\\n\\n    bool helper(vector<int>&freq, vector<int>&quan, int q = 0){\\n        if(q>=quan.size()) return true;\\n\\n        bool ans;\\n        for(int i = 0; i<freq.size(); i++){\\n            if(freq[i]>=quan[q]){\\n                freq[i] = freq[i] - quan[q];\\n                ans = helper(freq,quan,q+1);\\n                if(ans)return true;\\n                freq[i]=freq[i] + quan[q];\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        \\n        unordered_map<int,int>mp;\\n\\n        for(auto it:nums)mp[it]++;\\n        vector<int>freq;\\n        for(auto it:mp)freq.push_back(it.second);\\n        sort(quantity.rbegin(),quantity.rend());\\n        return helper(freq,quantity);\\n        \\n        \\n        \\n        // map<int,int>mp;\\n        // for(auto it:nums)mp[it]++;\\n        // //sort(quantity.begin(),quantity.end(),greater<int>());\\n        // //unordered_set<int>freq;\\n        // //set<int>freq;\\n\\n        // vector<int>freq;\\n        // //int freq[mp.size()];\\n        // for(auto it:mp)freq.push_back(it.second);\\n        // //for(int i = 0; i<mp.size(); i++)freq[i] = mp.second;\\n        // // int max_ele = *max_element(quantity.begin(),quantity.end());\\n        // // return ((accumulate(freq.begin(),freq.end(),0)>=accumulate(quantity.begin(),quantity.end(),0)) && (find(freq.begin(),freq.end(),max_ele)!=freq.end()))? true : false;\\n        // sort(freq.begin(),freq.end());\\n        // //printf(freq);\\n        // bool flag = true;\\n        // //unordered_set<int>:: iterator itr;\\n        // //set<int>:: iterator itr;\\n        // vector<int>:: iterator itr;\\n        // //vector<int>:: iterator result;\\n        \\n        \\n        // for(auto it:quantity){\\n        //     //int *itr = find(freq, freq+mp.size(), it);\\n        //     //printf(freq);\\n        //     itr = find(freq.begin(),freq.end(),it);\\n        //     if(itr!=freq.end()){\\n        //         *itr = 0;\\n        //     }\\n        //     //result = max_element(freq.begin(),freq.end());\\n        //     // int *result = maxi(freq);\\n        //     // cout<<*result;\\n        //     //else if((result!=freq.end()) && (*result>it)){\\n        //     // else if(result!=freq.end()){\\n        //     //     *result = *result-it;\\n        //     // }\\n        //     //cout<<*(freq.end()-1);\\n        //     //cout<<*result;\\n        //     // else if(*result>it){\\n        //     //     *\\n        //     // }\\n\\n        //     else if(check(freq,it)) continue;\\n        //     else{\\n        //         flag = !flag;\\n        //         break;\\n        //     }\\n        // }\\n        // return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // void printf(vector<int>&a){\\n    //     for(auto it:a)cout<<it<<\" \";\\n    //     cout<<endl;\\n    // }\\n    // bool check(vector<int>&a, int quan){\\n    //     int maxi = *max_element(a.begin(),a.end());\\n    //     //cout<<maxi;\\n    //     int n = a.size();\\n    //     if(maxi<quan) return false;\\n\\n    //     else{\\n    //         for(int i = n-1; i>=0; i--){\\n    //             if(a[i]>quan){\\n    //                 a[i] = a[i] - quan;\\n    //                 break;\\n    //             }\\n    //         }\\n    //         sort(a.begin(),a.end());\\n    //     }\\n    //     return true;\\n    // }\\n\\n    bool helper(vector<int>&freq, vector<int>&quan, int q = 0){\\n        if(q>=quan.size()) return true;\\n\\n        bool ans;\\n        for(int i = 0; i<freq.size(); i++){\\n            if(freq[i]>=quan[q]){\\n                freq[i] = freq[i] - quan[q];\\n                ans = helper(freq,quan,q+1);\\n                if(ans)return true;\\n                freq[i]=freq[i] + quan[q];\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        \\n        unordered_map<int,int>mp;\\n\\n        for(auto it:nums)mp[it]++;\\n        vector<int>freq;\\n        for(auto it:mp)freq.push_back(it.second);\\n        sort(quantity.rbegin(),quantity.rend());\\n        return helper(freq,quantity);\\n        \\n        \\n        \\n        // map<int,int>mp;\\n        // for(auto it:nums)mp[it]++;\\n        // //sort(quantity.begin(),quantity.end(),greater<int>());\\n        // //unordered_set<int>freq;\\n        // //set<int>freq;\\n\\n        // vector<int>freq;\\n        // //int freq[mp.size()];\\n        // for(auto it:mp)freq.push_back(it.second);\\n        // //for(int i = 0; i<mp.size(); i++)freq[i] = mp.second;\\n        // // int max_ele = *max_element(quantity.begin(),quantity.end());\\n        // // return ((accumulate(freq.begin(),freq.end(),0)>=accumulate(quantity.begin(),quantity.end(),0)) && (find(freq.begin(),freq.end(),max_ele)!=freq.end()))? true : false;\\n        // sort(freq.begin(),freq.end());\\n        // //printf(freq);\\n        // bool flag = true;\\n        // //unordered_set<int>:: iterator itr;\\n        // //set<int>:: iterator itr;\\n        // vector<int>:: iterator itr;\\n        // //vector<int>:: iterator result;\\n        \\n        \\n        // for(auto it:quantity){\\n        //     //int *itr = find(freq, freq+mp.size(), it);\\n        //     //printf(freq);\\n        //     itr = find(freq.begin(),freq.end(),it);\\n        //     if(itr!=freq.end()){\\n        //         *itr = 0;\\n        //     }\\n        //     //result = max_element(freq.begin(),freq.end());\\n        //     // int *result = maxi(freq);\\n        //     // cout<<*result;\\n        //     //else if((result!=freq.end()) && (*result>it)){\\n        //     // else if(result!=freq.end()){\\n        //     //     *result = *result-it;\\n        //     // }\\n        //     //cout<<*(freq.end()-1);\\n        //     //cout<<*result;\\n        //     // else if(*result>it){\\n        //     //     *\\n        //     // }\\n\\n        //     else if(check(freq,it)) continue;\\n        //     else{\\n        //         flag = !flag;\\n        //         break;\\n        //     }\\n        // }\\n        // return flag;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558640,
                "title": "best-optimised-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& counts, vector<int>& quantity,int ithCustomer){\\n        //base\\n        if(ithCustomer == quantity.size()){\\n            return true;//completed all the conditions\\n        }\\n        \\n        for(int i=0;i<counts.size();i++){\\n            if(counts[i] >= quantity[ithCustomer]){\\n                counts[i] -= quantity[ithCustomer];\\n                if(solve(counts,quantity,ithCustomer+1)){\\n                    return true;//completed all the conditions\\n                }\\n                counts[i] += quantity[ithCustomer];//backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>count;\\n        for(auto num:nums){\\n            count[num]++;\\n        }\\n\\n        vector<int>counts;\\n        for(auto it:count){\\n            counts.push_back(it.second);//pushing values into vector\\n        }\\n\\n        sort(quantity.rbegin(),quantity.rend());//sort decreasing order\\n        return solve(counts,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& counts, vector<int>& quantity,int ithCustomer){\\n        //base\\n        if(ithCustomer == quantity.size()){\\n            return true;//completed all the conditions\\n        }\\n        \\n        for(int i=0;i<counts.size();i++){\\n            if(counts[i] >= quantity[ithCustomer]){\\n                counts[i] -= quantity[ithCustomer];\\n                if(solve(counts,quantity,ithCustomer+1)){\\n                    return true;//completed all the conditions\\n                }\\n                counts[i] += quantity[ithCustomer];//backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>count;\\n        for(auto num:nums){\\n            count[num]++;\\n        }\\n\\n        vector<int>counts;\\n        for(auto it:count){\\n            counts.push_back(it.second);//pushing values into vector\\n        }\\n\\n        sort(quantity.rbegin(),quantity.rend());//sort decreasing order\\n        return solve(counts,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546331,
                "title": "backtracking-with-memoization-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know we only have 10 customers at worst. We also know we have at most 50 unique items in our set up. We can backtrack on the customers and on the items, and can limit ourselves to only as many items as we have customers if we go in greatest reversed order of items present. This lets us limit ourselves appropriately to a space at worst of 10^10. We can allow ourselves to stop early by utilizing a backtracking string to target the current items and current customers as a key, thus letting us memoize results and reduce computational time altogether. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind your number of items, your number of customers, and then check to make sure you at least have enough items to match customers before any combinations. \\n\\nThen, get the frequency of your items. \\nTurn nums into the sorted form of the frequencies (not the items, the frequencies) in reverse order for as many as you have customers. This lets you focus on a subset of size 10^10 at worst. \\n\\nSort your quantities in reverse. \\n\\nIf your sum of item frequencies is less than the sum of your quantity, you can also return False already. \\n\\nOtherwise, set up a memo \\n\\nDuring the backtracking phase, pass in the current items, customer index, and current customer statuses \\n- Build a backtrack key using the items sorted | customer status sorted as a string \\n- If your customer index is past the total number number of customers, set memo at backtrack key to true and return true \\n- If you have the backtrack key in the memo, return what you found already and skip the preprocess. This is the reason for the sorting as it combines similar set ups with different location strings. \\n- otherwise, get the current amount as quantity at customer index \\n- set your current item index to 0 \\n- while your current item index is in range of your current items length \\n    - if the item here is not big enough -> move forward by 1 until it is \\n    - otherwise \\n        - if the current item index is greater than 0 and we have matching items here \\n            - go until the last version of these if you can \\n            - if you end up out of range, break \\n            - otherwise if you end up at a bad spot, move forward one and continue \\n        - otherwise try to use the current item to satisfy the current customer, updating in both lists appropriately \\n        - make a temp key of doing so \\n        - if you have seen this temp key and it doesn\\'t work \\n            - unset what you did and move forward one and continue \\n        - if you saw it and it did work \\n            - set memo for the backtrack key and return True \\n        - otherwise, go check it out\\n            - then update the memo\\n            - if it was true, update memo for backtrack key and return \\n            - otherwise, undo the look, move forward and continue \\n- if you never got a success in the loop, update the memo here and return False \\n\\nTo solve, kick off backtrack with nums, 0, quantity           \\n\\n# Complexity\\n- Time complexity : O (Sum m! / (i!(m-i)!) for i in range 1, m-1, where m is number of customers)\\n    - O(10^10) at worst since we do 10^10 considerations in our backtracking is the naive amount \\n    - However, we can limit down since our sort for the backtrack keys worked (never caused an error) to O(3629822) operations, since we now know that we are dealing with combinatory states where no repeats are allowed and order doesn\\'t matter (otherwise, the backtrack keys would have caused a problem). Due to this, we get the time complexity of combinations with no repeats instead of permutations with repeats for the backtrack process.   \\n    - This puts our overall time complexity in the form of O(Sum m!/(i!(m-i)!) for i in range 1, m-1), where m is the number of customers according to the problem statement. For comparison sakes, this is about 2750 times faster than O(10^10)\\n\\n- Space complexity : Due to backtracking nature, we match our space complexity unfortunately, but due handidly beat the space in the other case due to our size reduction. If someone is interested, this can potentially be done in bottom up form and save us the massive amounts of space with the time savings. \\n\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool :\\n        \\'\\'\\'\\n            at most 50 unique values in the array \\n            customer quantities -> no more than 10 customers -> m \\n                                -> each customer can order between 1 and 10^5, the number of items range as well \\n            nums -> amount of items \\n            want to distribute nums so that \\n                each customer gets exactly customer_i items (so if there are not exactly i items not gonna work)\\n                the integers that compose the ith customer order are all equal and sum to customer i items \\n                every customer can be satisfied \\n        \\n        \\'\\'\\'\\n        # get number of items and number of customers \\n        number_of_items = len(nums)\\n        number_of_customers = len(quantity) \\n        # before doing frequency work, if you do not have enough items, you\\'ll never satisfy everyone \\n        if number_of_items < number_of_customers : \\n            return False \\n        # find out your frequency of your items \\n        frequency_of_items = collections.Counter(nums)\\n        # and limit yourself to the best for your customers \\n        nums = sorted(frequency_of_items.values(), reverse=True)[:number_of_customers]\\n        quantity.sort(reverse = True)\\n        # if you still can\\'t satisfy everyone, don\\'t try and return False \\n        if sum(nums) < sum(quantity) : \\n            return False \\n        # set up a memo to track your progress \\n        self.memo = dict() \\n\\n        def backtrack(current_items, customer_index, current_customers) :\\n            # set up a backtrack key where you use the sorted form of each to capture as many possible alternate substates as you can \\n            backtrack_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)]) \\n            # if you reached the end, mark it and return True. Otherwise, if you\\'ve seen this, return what you already found! \\n            if customer_index == number_of_customers : \\n                self.memo[backtrack_key] = True\\n                return True \\n            elif backtrack_key in self.memo : \\n                return self.memo[backtrack_key]\\n\\n            # figure out how much you have \\n            current_amount = quantity[customer_index]\\n\\n            # consider all your items \\n            c_i = 0 \\n            while c_i < len(current_items) :\\n                # if we have an item that is gte here  \\n                if current_items[c_i] >= current_amount :\\n                    # if we are past 0 and have a matching situation  \\n                    if c_i > 0 and current_items[c_i] == current_items[c_i - 1] :\\n                        # go until you run out of room, or until you run out of matches, or until you run into a problem  \\n                        while c_i < len(current_items) and current_items[c_i] == current_items[c_i - 1] and current_items[c_i] >= current_amount : \\n                            c_i += 1 \\n                        # if you ran out of room, nothing to do here, break \\n                        if c_i >= len(current_items) : \\n                            break \\n                        elif current_items[c_i] < current_amount :\\n                            # otherwise, if you ran out items, skip on to the next  \\n                            c_i += 1 \\n                            continue  \\n                    # otherwise, if you have not run out room, and you do have an item worth looking at \\n                    # look at it \\n                    current_items[c_i] -= current_amount\\n                    current_customers[customer_index] = 0 \\n                    # get the key \\n                    temp_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)])\\n                    # check if you have it and it doesn\\'t work \\n                    if temp_key in self.memo and self.memo[temp_key] == False :\\n                        # if it doesn\\'t, unset the looking and then move forward one  \\n                        current_items[c_i] += current_amount\\n                        current_customers[customer_index] = current_amount\\n                        c_i += 1 \\n                        continue \\n                    elif temp_key in self.memo and self.memo[temp_key] == True : \\n                        # if you have the key and it worked already, skip out of there after resetting your backtrack key as well \\n                        self.memo[backtrack_key] = True\\n                        return True \\n                    elif temp_key not in self.memo : \\n                        # otherwise if we have not seen this thing, set up a temp result and lock it in \\n                        temp_result = backtrack(current_items, customer_index + 1, current_customers) \\n                        self.memo[temp_key] = temp_result \\n                        if temp_result == True : \\n                            # on success, update and return \\n                            self.memo[backtrack_key] = True \\n                            return True \\n                        else : \\n                            # on failure, unset and continue \\n                            current_items[c_i] += current_amount \\n                            current_customers[customer_index] = current_amount\\n                            c_i += 1 \\n                            continue \\n                else : \\n                    c_i += 1 \\n                    continue \\n\\n            # if you ran out of room or weren\\'t able to make it work -> set False and return it \\n            self.memo[backtrack_key] = False\\n            return False \\n        \\n        # kick it off with our altered nums and quantities \\n        return backtrack(nums, 0, quantity)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool :\\n        \\'\\'\\'\\n            at most 50 unique values in the array \\n            customer quantities -> no more than 10 customers -> m \\n                                -> each customer can order between 1 and 10^5, the number of items range as well \\n            nums -> amount of items \\n            want to distribute nums so that \\n                each customer gets exactly customer_i items (so if there are not exactly i items not gonna work)\\n                the integers that compose the ith customer order are all equal and sum to customer i items \\n                every customer can be satisfied \\n        \\n        \\'\\'\\'\\n        # get number of items and number of customers \\n        number_of_items = len(nums)\\n        number_of_customers = len(quantity) \\n        # before doing frequency work, if you do not have enough items, you\\'ll never satisfy everyone \\n        if number_of_items < number_of_customers : \\n            return False \\n        # find out your frequency of your items \\n        frequency_of_items = collections.Counter(nums)\\n        # and limit yourself to the best for your customers \\n        nums = sorted(frequency_of_items.values(), reverse=True)[:number_of_customers]\\n        quantity.sort(reverse = True)\\n        # if you still can\\'t satisfy everyone, don\\'t try and return False \\n        if sum(nums) < sum(quantity) : \\n            return False \\n        # set up a memo to track your progress \\n        self.memo = dict() \\n\\n        def backtrack(current_items, customer_index, current_customers) :\\n            # set up a backtrack key where you use the sorted form of each to capture as many possible alternate substates as you can \\n            backtrack_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)]) \\n            # if you reached the end, mark it and return True. Otherwise, if you\\'ve seen this, return what you already found! \\n            if customer_index == number_of_customers : \\n                self.memo[backtrack_key] = True\\n                return True \\n            elif backtrack_key in self.memo : \\n                return self.memo[backtrack_key]\\n\\n            # figure out how much you have \\n            current_amount = quantity[customer_index]\\n\\n            # consider all your items \\n            c_i = 0 \\n            while c_i < len(current_items) :\\n                # if we have an item that is gte here  \\n                if current_items[c_i] >= current_amount :\\n                    # if we are past 0 and have a matching situation  \\n                    if c_i > 0 and current_items[c_i] == current_items[c_i - 1] :\\n                        # go until you run out of room, or until you run out of matches, or until you run into a problem  \\n                        while c_i < len(current_items) and current_items[c_i] == current_items[c_i - 1] and current_items[c_i] >= current_amount : \\n                            c_i += 1 \\n                        # if you ran out of room, nothing to do here, break \\n                        if c_i >= len(current_items) : \\n                            break \\n                        elif current_items[c_i] < current_amount :\\n                            # otherwise, if you ran out items, skip on to the next  \\n                            c_i += 1 \\n                            continue  \\n                    # otherwise, if you have not run out room, and you do have an item worth looking at \\n                    # look at it \\n                    current_items[c_i] -= current_amount\\n                    current_customers[customer_index] = 0 \\n                    # get the key \\n                    temp_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)])\\n                    # check if you have it and it doesn\\'t work \\n                    if temp_key in self.memo and self.memo[temp_key] == False :\\n                        # if it doesn\\'t, unset the looking and then move forward one  \\n                        current_items[c_i] += current_amount\\n                        current_customers[customer_index] = current_amount\\n                        c_i += 1 \\n                        continue \\n                    elif temp_key in self.memo and self.memo[temp_key] == True : \\n                        # if you have the key and it worked already, skip out of there after resetting your backtrack key as well \\n                        self.memo[backtrack_key] = True\\n                        return True \\n                    elif temp_key not in self.memo : \\n                        # otherwise if we have not seen this thing, set up a temp result and lock it in \\n                        temp_result = backtrack(current_items, customer_index + 1, current_customers) \\n                        self.memo[temp_key] = temp_result \\n                        if temp_result == True : \\n                            # on success, update and return \\n                            self.memo[backtrack_key] = True \\n                            return True \\n                        else : \\n                            # on failure, unset and continue \\n                            current_items[c_i] += current_amount \\n                            current_customers[customer_index] = current_amount\\n                            c_i += 1 \\n                            continue \\n                else : \\n                    c_i += 1 \\n                    continue \\n\\n            # if you ran out of room or weren\\'t able to make it work -> set False and return it \\n            self.memo[backtrack_key] = False\\n            return False \\n        \\n        # kick it off with our altered nums and quantities \\n        return backtrack(nums, 0, quantity)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540265,
                "title": "javascript-dfs-dp-backtracking-discretization-518ms",
                "content": "use discretization to minimize the values to improve running speed (solve TLE)\\nexample: discretize([535,535,547,413,547])  // [ 1, 1, 2, 0, 2 ] (413->0 535->1, 547->2)\\n```\\nlet b, f;\\nconst canDistribute = (a, B) => {\\n    B.sort((x, y) => y - x);\\n    let [d, ct] = discretize(a);\\n    b = B, f = Array(ct + 1).fill(0);\\n    d.map(x => f[x]++);\\n    f.sort((x, y) => x - y);\\n    f = f.filter((x, i) => i >= f.length - Math.min(f.length, b.length))\\n    return dfs(0);\\n};\\n\\nconst dfs = (idx) => {\\n    if (idx >= b.length) return true;\\n    for (let i = 0; i < f.length; i++) {\\n        if (f[i] >= b[idx]) {\\n            f[i] -= b[idx];\\n            if (dfs(idx + 1)) return true;\\n            f[i] += b[idx];\\n        }\\n    }\\n    return false;\\n};\\n\\nconst discretize = (a) => {\\n    let n = a.length, d = a.map((x, i) => [i, x]).sort((x, y) => x[1] - y[1] || x[0] - y[0]), cur = 0, res = Array(n).fill(0);\\n    d.map((e, i) => {\\n        if (i - 1 >= 0 && e[1] != d[i - 1][1]) cur++;\\n        res[e[0]] = cur;\\n    })\\n    return [res, cur];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet b, f;\\nconst canDistribute = (a, B) => {\\n    B.sort((x, y) => y - x);\\n    let [d, ct] = discretize(a);\\n    b = B, f = Array(ct + 1).fill(0);\\n    d.map(x => f[x]++);\\n    f.sort((x, y) => x - y);\\n    f = f.filter((x, i) => i >= f.length - Math.min(f.length, b.length))\\n    return dfs(0);\\n};\\n\\nconst dfs = (idx) => {\\n    if (idx >= b.length) return true;\\n    for (let i = 0; i < f.length; i++) {\\n        if (f[i] >= b[idx]) {\\n            f[i] -= b[idx];\\n            if (dfs(idx + 1)) return true;\\n            f[i] += b[idx];\\n        }\\n    }\\n    return false;\\n};\\n\\nconst discretize = (a) => {\\n    let n = a.length, d = a.map((x, i) => [i, x]).sort((x, y) => x[1] - y[1] || x[0] - y[0]), cur = 0, res = Array(n).fill(0);\\n    d.map((e, i) => {\\n        if (i - 1 >= 0 && e[1] != d[i - 1][1]) cur++;\\n        res[e[0]] = cur;\\n    })\\n    return [res, cur];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418226,
                "title": "easy-methode-simple-approach-simple-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity,int ithCustomer){\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistributeHelper(count,quantity,ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num : nums){\\n            countMap[num]++;\\n\\n        }\\n        vector<int>count;\\n        for(auto it:countMap){\\n            count.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend());\\n        return canDistributeHelper(count,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity,int ithCustomer){\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistributeHelper(count,quantity,ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num : nums){\\n            countMap[num]++;\\n\\n        }\\n        vector<int>count;\\n        for(auto it:countMap){\\n            count.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend());\\n        return canDistributeHelper(count,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354901,
                "title": "easy-peasy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& quantity,map<int,int> &count,int index){\\n//base case\\nif(index == quantity.size()){\\n  return true;\\n}\\n\\n//rec\\n\\nfor(auto it=count.begin();it!=count.end();it++)\\n{ //for example:(2,2) check if 2 >= quantity[index]\\n  if(it->second >= quantity[index]){\\n    count[it->first]=count[it->first]-quantity[index];\\n    bool solver=solve(quantity,count,index+1);\\n    if(solver == true){\\n      return true;\\n    }\\n    //backtracking(if the current state is false,backtrack to pevious state)\\n    count[it->first]=count[it->first]+quantity[index];\\n  }\\n}\\n\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        for(int i=0;i<nums.size();i++){\\n          count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\nbool ans=solve(quantity,count,0);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& quantity,map<int,int> &count,int index){\\n//base case\\nif(index == quantity.size()){\\n  return true;\\n}\\n\\n//rec\\n\\nfor(auto it=count.begin();it!=count.end();it++)\\n{ //for example:(2,2) check if 2 >= quantity[index]\\n  if(it->second >= quantity[index]){\\n    count[it->first]=count[it->first]-quantity[index];\\n    bool solver=solve(quantity,count,index+1);\\n    if(solver == true){\\n      return true;\\n    }\\n    //backtracking(if the current state is false,backtrack to pevious state)\\n    count[it->first]=count[it->first]+quantity[index];\\n  }\\n}\\n\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        for(int i=0;i<nums.size();i++){\\n          count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\nbool ans=solve(quantity,count,0);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333895,
                "title": "importance-of-failing-fast-on-backtrack",
                "content": "# Intuition\\n\\nDisclaimer: I originally came with a very similar solution, but was at the threshold of failure due to TLE until I checked the fastest solutions. Unfortunately I dont have the handle of the person to give the credit.\\n\\nThe difference between my code and the faster version is that on the original code I processed the quantity values in the order that they were provided, or even worst some versions were processing the quantity values from smallest to biggest! To achieve the best performance we must process from biggest to smallest.\\n\\nThe reason for this is simple, the bigger quantities have less matching scenarios, causing the backtrack tree to have smaller initial situations, therefore we avoid testing a lot of levels just to fail at the end (i.e we fail faster in this scenario)\\n\\n# Approach\\n- Backtrack\\n\\n# Complexity\\n- Time complexity:\\n$$O(nums.length^{quantity.length})$$\\n\\n- Space complexity:\\n$$O(quantity.length)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/0b958d5e-05d7-4649-a082-82974456d189_1679610091.3029313.png)\\n\\n```java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // Counting the frequency of each item\\n        int[] tmp=new int[1001];\\n        for(int n: nums) tmp[n]++;\\n        // removing items with frequency 0 to enhance performance\\n        int nonZeroCount=0;\\n        for(int f: tmp) if(f!=0) nonZeroCount++;\\n        int[] fa=new int[nonZeroCount];\\n        for(int f: tmp) if(f!=0) fa[--nonZeroCount]=f;\\n\\n        // This was not originally in my code and makes all\\n        // the difference in the world\\n        Arrays.sort(quantity);\\n        // It is important to decrease the index so we process\\n        // bigger items first\\n        return helper(quantity.length-1,fa,quantity);\\n    }\\n    boolean helper(int in, int[] fa, int[] quantity) {\\n        if(in==-1) return true;\\n        int need=quantity[in];\\n        for(int i=fa.length-1;i>-1;i--) {\\n            if(fa[i]<need||i>0&&fa[i]==fa[i-1]) continue;\\n            fa[i]-=need;\\n            // Notice that we decrease the index so to process\\n            // bigger values first\\n            if(helper(in-1,fa,quantity)) return true;\\n            fa[i]+=need;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // Counting the frequency of each item\\n        int[] tmp=new int[1001];\\n        for(int n: nums) tmp[n]++;\\n        // removing items with frequency 0 to enhance performance\\n        int nonZeroCount=0;\\n        for(int f: tmp) if(f!=0) nonZeroCount++;\\n        int[] fa=new int[nonZeroCount];\\n        for(int f: tmp) if(f!=0) fa[--nonZeroCount]=f;\\n\\n        // This was not originally in my code and makes all\\n        // the difference in the world\\n        Arrays.sort(quantity);\\n        // It is important to decrease the index so we process\\n        // bigger items first\\n        return helper(quantity.length-1,fa,quantity);\\n    }\\n    boolean helper(int in, int[] fa, int[] quantity) {\\n        if(in==-1) return true;\\n        int need=quantity[in];\\n        for(int i=fa.length-1;i>-1;i--) {\\n            if(fa[i]<need||i>0&&fa[i]==fa[i-1]) continue;\\n            fa[i]-=need;\\n            // Notice that we decrease the index so to process\\n            // bigger values first\\n            if(helper(in-1,fa,quantity)) return true;\\n            fa[i]+=need;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280041,
                "title": "c-easy-solution-backtraking-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int>& nums,vector<int>& q,map<int,int>& mp,int n,int m){\\n        if(i==m){\\n            return true;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=q[i]){\\n                mp[it.first]-=q[i];\\n                int temp=find(i+1,nums,q,mp,n,m);\\n                if(temp){\\n                    return true;\\n                }         \\n                mp[it.first]+=q[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n=nums.size(),m=quantity.size();\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n       map<int,int> mp;\\n       for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n       }\\n       return find(0,nums,quantity,mp,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int>& nums,vector<int>& q,map<int,int>& mp,int n,int m){\\n        if(i==m){\\n            return true;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=q[i]){\\n                mp[it.first]-=q[i];\\n                int temp=find(i+1,nums,q,mp,n,m);\\n                if(temp){\\n                    return true;\\n                }         \\n                mp[it.first]+=q[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n=nums.size(),m=quantity.size();\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n       map<int,int> mp;\\n       for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n       }\\n       return find(0,nums,quantity,mp,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251846,
                "title": "simple-explaination-c-backtracking",
                "content": "# Approach:\\n\\nThe problem requires us to distribute elements from a given array into groups based on a given quantity distribution.\\nWe can use a recursive approach to check if it\\'s possible to distribute the elements to satisfy the given quantity distribution.\\n# Algorithm:\\n\\n1. First, count the occurrences of each element in the given array using an unordered map.\\n2. Sort the quantity distribution in non-increasing order.\\n3. Call a recursive function with arguments quantity, cnt (unordered map), and index.\\n4. The recursive function checks if we have satisfied all the quantities in the quantity vector. If we have, it returns true.\\n5. If not, it loops through each element in the cnt unordered map and checks if we can use it to satisfy the current quantity at index index in the quantity vector.\\n6. If we can, we subtract the count of that element from cnt, call the solve function recursively with the next index, and check if the recursive call returns true.\\n7. If it does, we return true. If not, we add the count of that element back to cnt and continue with the next element in the map.\\n8. If we\\'ve checked all elements in the map and none of them can be used to satisfy the current quantity, we return false.\\n# Space Complexity:\\n\\n- The space complexity of the algorithm is O(N+M) where N is the size of the nums array and M is the number of unique elements in nums.\\n- This is because we\\'re using an unordered map to count the occurrences of each element in nums, which has space complexity O(M).\\n- The recursion stack space used by the recursive function is also O(M) since the function will recurse M times at most.\\n# Time Complexity:\\n\\n- The time complexity of the algorithm is O(N * 2^M) where N is the size of the nums array and M is the number of unique elements in nums.\\n- This is because for each element in nums, we check if we can use it to satisfy each quantity in the quantity vector. There are M unique elements, so we need to make M choices for each element in nums.\\n- Since we use backtracking to explore all possible choices, the time complexity of the algorithm is O(N * 2^M).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity, unordered_map<int,int>&cnt, int index)\\n    {\\n        if(index == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(auto it = cnt.begin(); it != cnt.end(); it++)\\n        {\\n            if(it -> second >= quantity[index])\\n            {\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaAns = solve(quantity, cnt , index + 1);\\n\\n                if( aageKaAns == true )\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    cnt[it->first] = cnt[it->first] + quantity[index];\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n       unordered_map<int,int>cnt;\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        for(auto& it : nums)\\n        {\\n            cnt[it]++;\\n        }\\n\\n        return solve(quantity, cnt , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity, unordered_map<int,int>&cnt, int index)\\n    {\\n        if(index == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(auto it = cnt.begin(); it != cnt.end(); it++)\\n        {\\n            if(it -> second >= quantity[index])\\n            {\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaAns = solve(quantity, cnt , index + 1);\\n\\n                if( aageKaAns == true )\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    cnt[it->first] = cnt[it->first] + quantity[index];\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n       unordered_map<int,int>cnt;\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        for(auto& it : nums)\\n        {\\n            cnt[it]++;\\n        }\\n\\n        return solve(quantity, cnt , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248942,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        n, m = len(nums), len(quantity)\\n\\n        dict1 = collections.Counter(nums)\\n\\n        quantity.sort(reverse = True)\\n\\n        def dfs(i):\\n            if i == m:\\n                return True \\n\\n            for key,val in dict1.items():\\n                if val >= quantity[i]:\\n                    dict1[key] -= quantity[i]\\n\\n                    if dfs(i+1):\\n                        return True\\n\\n                    dict1[key] += quantity[i]\\n\\n            return False \\n\\n        return dfs(0)\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        n, m = len(nums), len(quantity)\\n\\n        dict1 = collections.Counter(nums)\\n\\n        quantity.sort(reverse = True)\\n\\n        def dfs(i):\\n            if i == m:\\n                return True \\n\\n            for key,val in dict1.items():\\n                if val >= quantity[i]:\\n                    dict1[key] -= quantity[i]\\n\\n                    if dfs(i+1):\\n                        return True\\n\\n                    dict1[key] += quantity[i]\\n\\n            return False \\n\\n        return dfs(0)\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242963,
                "title": "c-easiest-solution-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>&cnt,int index){\\n        // base case\\n        if(index == quantity.size()){\\n            return true;\\n        }\\n        for(auto it = cnt.begin() ;it!=cnt.end() ;it++){\\n            if(it->second >= quantity[index]){\\n                //action\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                //recursive relation\\n                bool aagesolution = solve(quantity,cnt,index+1);\\n                if(aagesolution){\\n                    return true;\\n                }\\n                else{\\n                    //backtrack \\n                    cnt[it->first]  = cnt[it->first] + quantity[index];\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        for(int i =0;i<nums.size();i++){\\n            cnt[nums[i]]++;\\n        }\\n\\n        //sort the quantity in decreasing order\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n\\n        bool ans = solve(quantity,cnt,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>&cnt,int index){\\n        // base case\\n        if(index == quantity.size()){\\n            return true;\\n        }\\n        for(auto it = cnt.begin() ;it!=cnt.end() ;it++){\\n            if(it->second >= quantity[index]){\\n                //action\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                //recursive relation\\n                bool aagesolution = solve(quantity,cnt,index+1);\\n                if(aagesolution){\\n                    return true;\\n                }\\n                else{\\n                    //backtrack \\n                    cnt[it->first]  = cnt[it->first] + quantity[index];\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        for(int i =0;i<nums.size();i++){\\n            cnt[nums[i]]++;\\n        }\\n\\n        //sort the quantity in decreasing order\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n\\n        bool ans = solve(quantity,cnt,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213418,
                "title": "using-java-backtracking-approach",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    private void reverseArray(int[] arr){\\n        int l=0,h=arr.length-1;\\n        while(l<h){\\n            int temp=arr[l];\\n            arr[l]=arr[h];\\n            arr[h]=temp;\\n            l++;\\n            h--;\\n        }\\n        return;\\n    }\\n\\n \\n    private boolean recursive_approach(int a1Idx,int[] arr1,int[] arr2){\\n        int n=arr1.length;\\n        if(a1Idx==n){\\n            return true;\\n        }\\n\\n        //maximum this loop runs upto 50 times as\\n        //we can have atmost 50 unique values\\n        for(int i=0;i<arr2.length;i++){\\n            \\n            if(arr2[i]>=arr1[a1Idx]){\\n                arr2[i]=arr2[i]-arr1[a1Idx];\\n                boolean flage=recursive_approach(a1Idx+1,arr1,arr2);\\n                if(flage==true) return true;\\n                arr2[i]=arr2[i]+arr1[a1Idx];\\n            }\\n            \\n            \\n        }\\n        return false;\\n    }\\n\\n   \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n        Map<Integer,Integer>mp=new HashMap<>();\\n\\n        //atmost we can have 50 unique values\\n        //tracks the count of the unique keys present\\n        for(int i:nums){\\n            mp.put(i,mp.getOrDefault(i,0)+1);\\n        }\\n\\n        int[] frequencyArr=new int[mp.size()];\\n        int idx=0;\\n        for(var e:mp.keySet()){\\n            frequencyArr[idx++]=mp.get(e);\\n        }\\n\\n        \\n        Arrays.sort(quantity);\\n        Arrays.sort(frequencyArr);\\n        reverseArray(quantity);\\n\\n\\n        //recursive_approach\\n        boolean flage=recursive_approach(0,quantity,frequencyArr);\\n        return flage;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    private void reverseArray(int[] arr){\\n        int l=0,h=arr.length-1;\\n        while(l<h){\\n            int temp=arr[l];\\n            arr[l]=arr[h];\\n            arr[h]=temp;\\n            l++;\\n            h--;\\n        }\\n        return;\\n    }\\n\\n \\n    private boolean recursive_approach(int a1Idx,int[] arr1,int[] arr2){\\n        int n=arr1.length;\\n        if(a1Idx==n){\\n            return true;\\n        }\\n\\n        //maximum this loop runs upto 50 times as\\n        //we can have atmost 50 unique values\\n        for(int i=0;i<arr2.length;i++){\\n            \\n            if(arr2[i]>=arr1[a1Idx]){\\n                arr2[i]=arr2[i]-arr1[a1Idx];\\n                boolean flage=recursive_approach(a1Idx+1,arr1,arr2);\\n                if(flage==true) return true;\\n                arr2[i]=arr2[i]+arr1[a1Idx];\\n            }\\n            \\n            \\n        }\\n        return false;\\n    }\\n\\n   \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n        Map<Integer,Integer>mp=new HashMap<>();\\n\\n        //atmost we can have 50 unique values\\n        //tracks the count of the unique keys present\\n        for(int i:nums){\\n            mp.put(i,mp.getOrDefault(i,0)+1);\\n        }\\n\\n        int[] frequencyArr=new int[mp.size()];\\n        int idx=0;\\n        for(var e:mp.keySet()){\\n            frequencyArr[idx++]=mp.get(e);\\n        }\\n\\n        \\n        Arrays.sort(quantity);\\n        Arrays.sort(frequencyArr);\\n        reverseArray(quantity);\\n\\n\\n        //recursive_approach\\n        boolean flage=recursive_approach(0,quantity,frequencyArr);\\n        return flage;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192952,
                "title": "python3-memory-efficient-and-fast-dfs-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis can be approached as a DFS problem with memoization and greedy search space reduction.\\n\\nFirst, one should observe the recursive property of the problem: A customer comes and wants a certain amount of equal integers. There might be mutliple equal integers we could give him, which the changes the equal integers we can give the next customer.\\n\\nSo we need a recursion, that has as input the current customer we are dealing with and which are left and the amount of equal integers we have left. The customers that are left can be coded as a pointer into the customer array. The amount of equal integers ist more difficult. At first, on can realize that we count the amount of equal integers per integer, but it does not really matter which customer gets which integer, it is only important how many we have of those. E.G. if we have four 4\\'s and four 3\\'s our recursive relation does not care or change if we give the customer 4s or 3s. Therefore we can code our state of integers left as a dict, that tells us we have: 3 equal integers two times for the example above.\\n\\nWe can then use these two things (count of equal integers and pointer into the customer array) to make a unique key for a state. Also that state repeats so we can add memoization to not compute problems again. I use a frozenset over the items of our counter dict as a pythonic and fast way to make a hashable tuple from the dict.\\n\\nThe second thing one needs to figure our is that we can decrease our search space much faster by dealing with difficult customers first (the ones wanting a whole lot of equal numbers), as there are only a few possibilities of those, which reduces the number of splits at the beginning of our recursion tree.\\n\\nThe problem really needs some time to figure out. Maybe try to look at my code. I myself was really surpised, I figured this out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach includes memoization, state coding and search space reduction\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI haven\\'t figured it out yet, please let me know if you have an idea.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI haven\\'t figured it out yet, please let me know if you have an idea.\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n        # count the amount of same integers\\n        cn = collections.Counter(collections.Counter(nums).values())\\n        \\n        # sort the customers to deal with the most difficult ones first\\n        quantity.sort(reverse=True)\\n\\n        # make recursive dfs with memoization\\n        cache = dict()\\n        def dfs(items, idx):\\n            if idx >= len(quantity): return True\\n            tp_it = frozenset(items.items())\\n            if (tp_it, idx) not in cache:\\n\\n                # go though all the frequent items\\n                result = False\\n                for qnti, nq in list(items.items()):\\n                    \\n                    # check whether we have similar integers\\n                    if not nq or qnti < quantity[idx]: continue\\n\\n                    # update our items\\n                    items[qnti] -= 1\\n                    items[qnti-quantity[idx]] += 1\\n\\n                    # recurse deeper\\n                    if dfs(items, idx+1):\\n                        result = True\\n                        break\\n\\n                    # undo changes to items\\n                    items[qnti] += 1\\n                    items[qnti-quantity[idx]] -= 1\\n                \\n                # set the cache\\n                cache[(tp_it, idx)] = result\\n            return cache[(tp_it, idx)]\\n        return dfs(cn, 0)\\n\\n                    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n        # count the amount of same integers\\n        cn = collections.Counter(collections.Counter(nums).values())\\n        \\n        # sort the customers to deal with the most difficult ones first\\n        quantity.sort(reverse=True)\\n\\n        # make recursive dfs with memoization\\n        cache = dict()\\n        def dfs(items, idx):\\n            if idx >= len(quantity): return True\\n            tp_it = frozenset(items.items())\\n            if (tp_it, idx) not in cache:\\n\\n                # go though all the frequent items\\n                result = False\\n                for qnti, nq in list(items.items()):\\n                    \\n                    # check whether we have similar integers\\n                    if not nq or qnti < quantity[idx]: continue\\n\\n                    # update our items\\n                    items[qnti] -= 1\\n                    items[qnti-quantity[idx]] += 1\\n\\n                    # recurse deeper\\n                    if dfs(items, idx+1):\\n                        result = True\\n                        break\\n\\n                    # undo changes to items\\n                    items[qnti] += 1\\n                    items[qnti-quantity[idx]] -= 1\\n                \\n                # set the cache\\n                cache[(tp_it, idx)] = result\\n            return cache[(tp_it, idx)]\\n        return dfs(cn, 0)\\n\\n                    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_distribute(nums: Vec<i32>, quantity: Vec<i32>) -> bool {\\n        use std::collections::HashMap;\\n\\n        fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n            if index == quantity.len() {\\n                return true;\\n            }\\n            for i in 0..counts.len() {\\n                if counts[i] >= quantity[index] {\\n                    let p = quantity[index];\\n                    counts[i] -= p;\\n                    if backtrack(counts, quantity, index + 1) {\\n                        return true;\\n                    }\\n                    counts[i] += p;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            *counts.entry(*n).or_insert(0) += 1;\\n        }\\n        let mut counts = counts.values().copied().collect::<Vec<_>>();\\n        counts.sort_by(|a, b| b.cmp(a));\\n        let mut quantity = quantity;\\n        quantity.sort_by(|a, b| b.cmp(a));\\n\\n        backtrack(&mut counts, &quantity, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_distribute(nums: Vec<i32>, quantity: Vec<i32>) -> bool {\\n        use std::collections::HashMap;\\n\\n        fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n            if index == quantity.len() {\\n                return true;\\n            }\\n            for i in 0..counts.len() {\\n                if counts[i] >= quantity[index] {\\n                    let p = quantity[index];\\n                    counts[i] -= p;\\n                    if backtrack(counts, quantity, index + 1) {\\n                        return true;\\n                    }\\n                    counts[i] += p;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            *counts.entry(*n).or_insert(0) += 1;\\n        }\\n        let mut counts = counts.values().copied().collect::<Vec<_>>();\\n        counts.sort_by(|a, b| b.cmp(a));\\n        let mut quantity = quantity;\\n        quantity.sort_by(|a, b| b.cmp(a));\\n\\n        backtrack(&mut counts, &quantity, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170542,
                "title": "c-backtrack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& A, vector<int>& Q) {\\n        int cnt[1001]{}, m = Q.size();\\n        unordered_set<int> keys;\\n        for(auto e : A) {\\n            cnt[e]++;\\n            keys.insert(e);\\n        }\\n\\n        sort(rbegin(Q), rend(Q));\\n\\n        function<bool(int)> dfs = [&](int t) {\\n            if(t >= m) return true;\\n            for(auto k : keys) {\\n                if(cnt[k] >= Q[t]) {\\n                    cnt[k] -= Q[t];\\n                    if(dfs(t+1)) return true;\\n                    cnt[k] += Q[t];\\n                }\\n            }\\n            return false;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& A, vector<int>& Q) {\\n        int cnt[1001]{}, m = Q.size();\\n        unordered_set<int> keys;\\n        for(auto e : A) {\\n            cnt[e]++;\\n            keys.insert(e);\\n        }\\n\\n        sort(rbegin(Q), rend(Q));\\n\\n        function<bool(int)> dfs = [&](int t) {\\n            if(t >= m) return true;\\n            for(auto k : keys) {\\n                if(cnt[k] >= Q[t]) {\\n                    cnt[k] -= Q[t];\\n                    if(dfs(t+1)) return true;\\n                    cnt[k] += Q[t];\\n                }\\n            }\\n            return false;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095291,
                "title": "c-easy-backtracking-method",
                "content": "# Intuition\\nWe need to try more ways in which we distrubute the repeating numbers, because we can distribute them in more ways but not all of them will satisfy all customers.\\n\\n# Approach\\nCreate a histogram(count how many times each number was seen) and we will try to satisfy all customers while going through the histogram, once we have a good match we try to solve using that number from the histogram as modified, if that doesn\\'t work, we go back, revert the change and try another permutation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Solve(vector<int>& quantity, map<int, int>& pairs, int qindex){\\n        if(qindex == quantity.size()){\\n            return true;\\n        }\\n\\n        for(auto& element : pairs){\\n            if(quantity[qindex] <= element.second){\\n                element.second -= quantity[qindex];\\n                if(Solve(quantity, pairs, qindex + 1)){\\n                    return true;\\n                }\\n                element.second += quantity[qindex];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> pairs;\\n        \\n        for(auto& n : nums){\\n            ++pairs[n];\\n        }\\n\\n        std::sort(quantity.begin(), quantity.end(), greater<>());\\n\\n        return Solve(quantity, pairs, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool Solve(vector<int>& quantity, map<int, int>& pairs, int qindex){\\n        if(qindex == quantity.size()){\\n            return true;\\n        }\\n\\n        for(auto& element : pairs){\\n            if(quantity[qindex] <= element.second){\\n                element.second -= quantity[qindex];\\n                if(Solve(quantity, pairs, qindex + 1)){\\n                    return true;\\n                }\\n                element.second += quantity[qindex];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> pairs;\\n        \\n        for(auto& n : nums){\\n            ++pairs[n];\\n        }\\n\\n        std::sort(quantity.begin(), quantity.end(), greater<>());\\n\\n        return Solve(quantity, pairs, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076334,
                "title": "python-dfs-solution-cache-in-tuple-99-faster",
                "content": "```\\ndef canDistribute(self, nums: List[int], q: List[int]) -> bool:\\n\\tnums = sorted(nlargest(len(q), Counter(nums).values()), reverse=True)\\n\\tq = sorted(q, reverse=True)\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(tup, i):\\n\\t\\tif i == len(q):\\n\\t\\t\\treturn True\\n\\t\\tfor k in range(len(tup)):\\n\\t\\t\\tif tup[k] >= q[i]:\\n\\t\\t\\t\\tnxt = list(tup[:k])+[tup[k]-q[i]]+list(tup[k+1:])\\n\\t\\t\\t\\tif dfs(tuple(sorted(nxt, reverse=True)), i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn dfs(tuple(nums), 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef canDistribute(self, nums: List[int], q: List[int]) -> bool:\\n\\tnums = sorted(nlargest(len(q), Counter(nums).values()), reverse=True)\\n\\tq = sorted(q, reverse=True)\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(tup, i):\\n\\t\\tif i == len(q):\\n\\t\\t\\treturn True\\n\\t\\tfor k in range(len(tup)):\\n\\t\\t\\tif tup[k] >= q[i]:\\n\\t\\t\\t\\tnxt = list(tup[:k])+[tup[k]-q[i]]+list(tup[k+1:])\\n\\t\\t\\t\\tif dfs(tuple(sorted(nxt, reverse=True)), i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn dfs(tuple(nums), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3060161,
                "title": "74-87-faster-c-bitmask-dp-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1<<10][51];\\n    vector<ll>pre;\\n\\n    ll solve(vector<ll>&container,vector<int>&quantity,ll mask,ll index,ll m,ll n){\\n        if(mask==(1<<m)-1){\\n            return 1;\\n        }\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[mask][index]!=-1){\\n            return dp[mask][index];\\n        }\\n        ll answer=0,current=mask^((1<<m)-1);\\n        answer=(answer+solve(container,quantity,mask,index+1,m,n));\\n        for(ll i=current;i>0;i=(i-1)&current){\\n            if(pre[i]>container[index]){\\n                continue;\\n            }\\n            answer=(answer+solve(container,quantity,mask|i,index+1,m,n));\\n        }\\n        return dp[mask][index]=answer;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        ll m=quantity.size();\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<ll,ll>mp1;\\n        for(auto &x:nums){\\n            mp1[x]++;\\n        }\\n        vector<ll>container;\\n        for(auto &x:mp1){\\n            container.push_back(x.second);\\n        }\\n        pre.resize(1<<m);\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1<<j)){\\n                    sum+=quantity[j];\\n                }\\n            }\\n            pre[i]=sum;\\n        }\\n        ll n=container.size();\\n        return solve(container,quantity,0,0,m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1<<10][51];\\n    vector<ll>pre;\\n\\n    ll solve(vector<ll>&container,vector<int>&quantity,ll mask,ll index,ll m,ll n){\\n        if(mask==(1<<m)-1){\\n            return 1;\\n        }\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[mask][index]!=-1){\\n            return dp[mask][index];\\n        }\\n        ll answer=0,current=mask^((1<<m)-1);\\n        answer=(answer+solve(container,quantity,mask,index+1,m,n));\\n        for(ll i=current;i>0;i=(i-1)&current){\\n            if(pre[i]>container[index]){\\n                continue;\\n            }\\n            answer=(answer+solve(container,quantity,mask|i,index+1,m,n));\\n        }\\n        return dp[mask][index]=answer;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        ll m=quantity.size();\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<ll,ll>mp1;\\n        for(auto &x:nums){\\n            mp1[x]++;\\n        }\\n        vector<ll>container;\\n        for(auto &x:mp1){\\n            container.push_back(x.second);\\n        }\\n        pre.resize(1<<m);\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1<<j)){\\n                    sum+=quantity[j];\\n                }\\n            }\\n            pre[i]=sum;\\n        }\\n        ll n=container.size();\\n        return solve(container,quantity,0,0,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045265,
                "title": "c-tried-to-explain-every-step-backtracking-easy-solution",
                "content": "```\\n/*\\nIntution :\\n\\n1-> Count the frequencies and make an array out of it\\n2-> Sort the quantities in descending order. We do this to get an early termination if for\\n    the max value in quantity we are not able to find a collection of integers\\n3-> Call the recursive function\\n4-> Recursive Code is explained below\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& freq, vector<int>& quantity, int idx) {\\n        \\n        // If we have fullly traversed the quantity array means that we were able to satisfy\\n        // everyone so return true\\n        if(idx == quantity.size())\\n            return true;\\n        \\n        // For every \\'quantity\\' value check if freq array has a value that can satisfy it\\n        // If yes call the recursive function for the next quantity value \\n        \\n        // As true will only be hit when we get to the end of the \\'quantity\\' array \\n        // This would lead to a chain of return true statements that would finally return\\n        // true to our calling function\\n        \\n        for(int i=0; i<freq.size(); i++) {\\n            \\n            if(freq[i] >= quantity[idx]) {\\n                freq[i] -= quantity[idx];\\n                \\n                // Calling Recursively\\n                if(solve(freq,quantity,idx+1)) {\\n                    return true;\\n                }\\n                // backtracting step\\n                // as it may be possible that we would want to assign a different collection \\n                // of integers to this particular customer\\n                else {\\n                    freq[i] += quantity[idx];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> freq;\\n        \\n        // 1)\\n        for(int i=0; i<nums.size(); i++) {\\n            if(i == nums.size()-1) {\\n                freq.push_back(1);\\n                continue;\\n            }\\n            \\n            int count = 1;\\n            int n = nums[i];\\n            if(i+1 < nums.size())\\n                i += 1;\\n            \\n            while(true and i<nums.size()) {\\n                if(nums[i] == n) {\\n                    count++;\\n                    i++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            i -= 1;\\n            freq.push_back(count);\\n        }\\n        // ---------------------------------------------------------------------------------\\n        \\n        // 2)\\n        auto compare = [](auto &a, auto &b) {\\n            return a > b;\\n        };\\n        sort(quantity.begin(), quantity.end(), compare); \\n        \\n        // ---------------------------------------------------------------------------------\\n        \\n        // 3)\\n        return solve(freq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/*\\nIntution :\\n\\n1-> Count the frequencies and make an array out of it\\n2-> Sort the quantities in descending order. We do this to get an early termination if for\\n    the max value in quantity we are not able to find a collection of integers\\n3-> Call the recursive function\\n4-> Recursive Code is explained below\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& freq, vector<int>& quantity, int idx) {\\n        \\n        // If we have fullly traversed the quantity array means that we were able to satisfy\\n        // everyone so return true\\n        if(idx == quantity.size())\\n            return true;\\n        \\n        // For every \\'quantity\\' value check if freq array has a value that can satisfy it\\n        // If yes call the recursive function for the next quantity value \\n        \\n        // As true will only be hit when we get to the end of the \\'quantity\\' array \\n        // This would lead to a chain of return true statements that would finally return\\n        // true to our calling function\\n        \\n        for(int i=0; i<freq.size(); i++) {\\n            \\n            if(freq[i] >= quantity[idx]) {\\n                freq[i] -= quantity[idx];\\n                \\n                // Calling Recursively\\n                if(solve(freq,quantity,idx+1)) {\\n                    return true;\\n                }\\n                // backtracting step\\n                // as it may be possible that we would want to assign a different collection \\n                // of integers to this particular customer\\n                else {\\n                    freq[i] += quantity[idx];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> freq;\\n        \\n        // 1)\\n        for(int i=0; i<nums.size(); i++) {\\n            if(i == nums.size()-1) {\\n                freq.push_back(1);\\n                continue;\\n            }\\n            \\n            int count = 1;\\n            int n = nums[i];\\n            if(i+1 < nums.size())\\n                i += 1;\\n            \\n            while(true and i<nums.size()) {\\n                if(nums[i] == n) {\\n                    count++;\\n                    i++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            i -= 1;\\n            freq.push_back(count);\\n        }\\n        // ---------------------------------------------------------------------------------\\n        \\n        // 2)\\n        auto compare = [](auto &a, auto &b) {\\n            return a > b;\\n        };\\n        sort(quantity.begin(), quantity.end(), compare); \\n        \\n        // ---------------------------------------------------------------------------------\\n        \\n        // 3)\\n        return solve(freq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017877,
                "title": "explanation-and-typescript-solution",
                "content": "\\nLet (dp1) represent ways to choose customers.\\ndp1[i] => sum of integers ordered by customers represented by bits of i (in binary form)\\nfor eg. if i = 5 => 101 in binary => hence dp1[i] = quantity[2] + quantity[0] where quantity[i] is the amount of integers the ith customer ordered.\\n\\nlet dp represent, whether it is possible to distribute numbers to customer satisfying the criteria (given in question).\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/76114205-34d1-4183-9592-b13732de07c0_1673159686.07661.png)\\n\\n\\n\\n\\n\\n\\n\\n```\\nfunction canDistribute(nums: number[], quantity: number[]): boolean {\\n    const mapNums = new Map<number, number>();\\n    for (let i = 0; i < nums.length; i++) {\\n      let Acount = mapNums.get(nums[i]) || 0;\\n      mapNums.set(nums[i], count + 1);\\n    }\\n    const numsFreq: number[] = [];\\n    let iterator = mapNums.values();\\n    while (true) {\\n      let value = iterator.next();\\n      if (value.done) break;\\n      numsFreq.push(value.value);\\n    }\\n    numsFreq.sort((a, b) => a - b);\\n    const len = Math.pow(2, quantity.length);\\n    const dp1 = new Array<number>(len);\\n\\n    dp1[0] = 0;\\n\\n    const m = quantity.length;\\n\\n    for (let i = 1; i < len; i++) {\\n      let res = 0;\\n      for (let j = 0; j < m; j++) {\\n        let bit = (i >> j) & 1;\\n        if (bit === 1) res += quantity[j];\\n      }\\n      dp1[i] = res;\\n    }\\n    const dp = new Array<boolean[]>(numsFreq.length);\\n    for (let i = 0; i < dp.length; i++) {\\n      dp[i] = new Array<boolean>(len);\\n      for (let j = 0; j < dp[i].length; j++) {\\n        dp[i][j] = true;\\n      }\\n    }\\n\\n    for (let i = 0; i < dp.length; i++) {\\n      for (let j = 1; j < dp[i].length; j++) {\\n        if (i === 0) dp[i][j] = dp1[j] <= numsFreq[i];\\n        else {\\n          let res = false;\\n          for (let k = 0; k <= j; k++) {\\n            let xored = k ^ j;\\n            if (xored > j) continue;\\n            if (xored === j) {\\n              if (dp1[j] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            } else {\\n              if (dp[i - 1][k] && dp1[xored] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            }\\n          }\\n          dp[i][j] = res;\\n        }\\n      }\\n      if (dp[i][dp[i].length - 1]) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction canDistribute(nums: number[], quantity: number[]): boolean {\\n    const mapNums = new Map<number, number>();\\n    for (let i = 0; i < nums.length; i++) {\\n      let Acount = mapNums.get(nums[i]) || 0;\\n      mapNums.set(nums[i], count + 1);\\n    }\\n    const numsFreq: number[] = [];\\n    let iterator = mapNums.values();\\n    while (true) {\\n      let value = iterator.next();\\n      if (value.done) break;\\n      numsFreq.push(value.value);\\n    }\\n    numsFreq.sort((a, b) => a - b);\\n    const len = Math.pow(2, quantity.length);\\n    const dp1 = new Array<number>(len);\\n\\n    dp1[0] = 0;\\n\\n    const m = quantity.length;\\n\\n    for (let i = 1; i < len; i++) {\\n      let res = 0;\\n      for (let j = 0; j < m; j++) {\\n        let bit = (i >> j) & 1;\\n        if (bit === 1) res += quantity[j];\\n      }\\n      dp1[i] = res;\\n    }\\n    const dp = new Array<boolean[]>(numsFreq.length);\\n    for (let i = 0; i < dp.length; i++) {\\n      dp[i] = new Array<boolean>(len);\\n      for (let j = 0; j < dp[i].length; j++) {\\n        dp[i][j] = true;\\n      }\\n    }\\n\\n    for (let i = 0; i < dp.length; i++) {\\n      for (let j = 1; j < dp[i].length; j++) {\\n        if (i === 0) dp[i][j] = dp1[j] <= numsFreq[i];\\n        else {\\n          let res = false;\\n          for (let k = 0; k <= j; k++) {\\n            let xored = k ^ j;\\n            if (xored > j) continue;\\n            if (xored === j) {\\n              if (dp1[j] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            } else {\\n              if (dp[i - 1][k] && dp1[xored] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            }\\n          }\\n          dp[i][j] = res;\\n        }\\n      }\\n      if (dp[i][dp[i].length - 1]) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986447,
                "title": "c-backtracking-self-explainable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    bool solve(int ind,vector<int>& quantity){\\n        if(ind==quantity.size()){\\n            return true;\\n        }\\n        for(auto& it:mpp){\\n            if(it.second>=quantity[ind]){\\n                it.second = it.second-quantity[ind];\\n                bool ans = solve(ind+1,quantity);\\n                if(ans){\\n                    return ans;\\n                }\\n                it.second = it.second+quantity[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n        }\\n        //sorting optimizes the code\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(0,quantity);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    bool solve(int ind,vector<int>& quantity){\\n        if(ind==quantity.size()){\\n            return true;\\n        }\\n        for(auto& it:mpp){\\n            if(it.second>=quantity[ind]){\\n                it.second = it.second-quantity[ind];\\n                bool ans = solve(ind+1,quantity);\\n                if(ans){\\n                    return ans;\\n                }\\n                it.second = it.second+quantity[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n        }\\n        //sorting optimizes the code\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(0,quantity);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985011,
                "title": "python-bitmask-dp",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], qy: List[int]) -> bool:\\n        fr=Counter(nums)\\n        frx=[fr[k] for k in fr]\\n        rbm=[0]\\n        for i in range(len(qy)):rbm[0]|=1<<i\\n        @cache\\n        def dp(fi,ost,bm):\\n            if bm==rbm[0]:return True\\n            if fi>=len(frx):return True if bm==rbm[0] else False\\n            if ost==0:\\n                if fi+1>=len(frx):return True if bm==rbm[0] else False\\n                return dp(fi+1,frx[fi+1],bm)\\n            for i in range(len(qy)):\\n                k=1<<i\\n                if bm&k!=0:continue\\n                if qy[i]<=ost:\\n                    if dp(fi,ost-qy[i],bm|k):return True\\n            if fi+1>=len(frx):return False  \\n            return dp(fi+1,frx[fi+1],bm)\\n        return dp(0,frx[0],0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], qy: List[int]) -> bool:\\n        fr=Counter(nums)\\n        frx=[fr[k] for k in fr]\\n        rbm=[0]\\n        for i in range(len(qy)):rbm[0]|=1<<i\\n        @cache\\n        def dp(fi,ost,bm):\\n            if bm==rbm[0]:return True\\n            if fi>=len(frx):return True if bm==rbm[0] else False\\n            if ost==0:\\n                if fi+1>=len(frx):return True if bm==rbm[0] else False\\n                return dp(fi+1,frx[fi+1],bm)\\n            for i in range(len(qy)):\\n                k=1<<i\\n                if bm&k!=0:continue\\n                if qy[i]<=ost:\\n                    if dp(fi,ost-qy[i],bm|k):return True\\n            if fi+1>=len(frx):return False  \\n            return dp(fi+1,frx[fi+1],bm)\\n        return dp(0,frx[0],0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914918,
                "title": "swift-solution-100-efficient-in-terms-of-time-and-space-complexity",
                "content": "# Approach\\n1. Count the frequencies of each number in nums, and store the frequencies in an array cnts.\\n2. Remove all the zeros from cnts, and store the remaining non-zeros in a list.\\n3. Call the recursive function f with the sorted list q of quanta, and the index of the last element in q.\\n4. If the index i is -1, return true.\\n5. Otherwise, for each element e in the list, if e is greater than or equal to q[i], subtract q[i] from e, and call f with the updated list and the index i-1.\\n6. If f returns true, return true.\\n7. Otherwise, restore the value of e to its original value, and proceed to the next element in the list.\\n8. If f fails to return true for all elements in the list, return false.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    var list = [Int]()\\n    \\n    func f(_ q: [Int], _ i: Int) -> Bool {\\n        if i<0 { return true }\\n        for j in 0..<list.count {\\n            var e = list[j]\\n            if e>=q[i] {\\n                list[j] = e-q[i]\\n                if f(q, i-1) { return true }\\n                list[j] = e\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func canDistribute(_ nums: [Int], _ q: [Int]) -> Bool {\\n        var cnts = [Int](repeating: 0, count: 1001)\\n        for n in nums { cnts[n] += 1 }\\n        for n in cnts {\\n            if n>0 { list.append(n) }\\n        }\\n        return f(q.sorted(), q.count-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var list = [Int]()\\n    \\n    func f(_ q: [Int], _ i: Int) -> Bool {\\n        if i<0 { return true }\\n        for j in 0..<list.count {\\n            var e = list[j]\\n            if e>=q[i] {\\n                list[j] = e-q[i]\\n                if f(q, i-1) { return true }\\n                list[j] = e\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func canDistribute(_ nums: [Int], _ q: [Int]) -> Bool {\\n        var cnts = [Int](repeating: 0, count: 1001)\\n        for n in nums { cnts[n] += 1 }\\n        for n in cnts {\\n            if n>0 { list.append(n) }\\n        }\\n        return f(q.sorted(), q.count-1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631467,
                "title": "simple-short-code",
                "content": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, m;\\n    vi(ll)freq, cost;\\n    vi(vi(ll))dp;\\n    void getFreq(const vi(int)&v){\\n        vi(ll)ump(100001);\\n        for(ll it:v){\\n            ++ump[it];\\n        }\\n        for(auto it:ump){\\n            if(it>0){\\n                freq.pb(it);\\n            }\\n        }\\n    }\\n    void getCost(const vi(int)&q){\\n        for(ll bm=0;bm<cost.size();++bm){\\n            for(ll i=0;i<n;++i){\\n                if((bm>>i)&1){\\n                    cost[bm]+=q[i];\\n                }\\n            }\\n        }\\n    }\\n    bool func(const vi(int)&q, ll in, ll bm){\\n        if(__builtin_popcount(bm)==n){\\n            return true;\\n        }\\n        if(in==m){\\n            return false;\\n        }\\n        ll&ans=dp[bm][in];\\n        if(ans==-1){\\n            ans=0;\\n            for(ll it=bm;it<cost.size() && !ans;++it){\\n                if(bm!=(it&bm) || freq[in]<cost[bm^it]){\\n                    continue;\\n                }\\n                freq[in]-=cost[bm^it];\\n                ans|=func(q, in+1, it);\\n                freq[in]+=cost[bm^it];\\n            }\\n        }\\n        return ans;\\n    }\\n    bool canDistribute(vector<int>&v, vector<int>&q) {\\n        getFreq(v);\\n        m=freq.size(), n=q.size();\\n        dp.assign(1<<n, vi(ll)(m, -1)), cost.assign(1<<n, 0);\\n        getCost(q);\\n        return func(q, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, m;\\n    vi(ll)freq, cost;\\n    vi(vi(ll))dp;\\n    void getFreq(const vi(int)&v){\\n        vi(ll)ump(100001);\\n        for(ll it:v){\\n            ++ump[it];\\n        }\\n        for(auto it:ump){\\n            if(it>0){\\n                freq.pb(it);\\n            }\\n        }\\n    }\\n    void getCost(const vi(int)&q){\\n        for(ll bm=0;bm<cost.size();++bm){\\n            for(ll i=0;i<n;++i){\\n                if((bm>>i)&1){\\n                    cost[bm]+=q[i];\\n                }\\n            }\\n        }\\n    }\\n    bool func(const vi(int)&q, ll in, ll bm){\\n        if(__builtin_popcount(bm)==n){\\n            return true;\\n        }\\n        if(in==m){\\n            return false;\\n        }\\n        ll&ans=dp[bm][in];\\n        if(ans==-1){\\n            ans=0;\\n            for(ll it=bm;it<cost.size() && !ans;++it){\\n                if(bm!=(it&bm) || freq[in]<cost[bm^it]){\\n                    continue;\\n                }\\n                freq[in]-=cost[bm^it];\\n                ans|=func(q, in+1, it);\\n                freq[in]+=cost[bm^it];\\n            }\\n        }\\n        return ans;\\n    }\\n    bool canDistribute(vector<int>&v, vector<int>&q) {\\n        getFreq(v);\\n        m=freq.size(), n=q.size();\\n        dp.assign(1<<n, vi(ll)(m, -1)), cost.assign(1<<n, 0);\\n        getCost(q);\\n        return func(q, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522526,
                "title": "c-backtracking-with-explanation",
                "content": "The procedure first computes frequencies and then tries to find if any straightforward solution exists. Let\\'s consider nf the number of buckets of numbers and nq the number of quantities. If a solution exists for the problem then at least one solution using the nq largest buckets of numbers exists. As the result buckers of numbers from nq + 1 to nf are ignored. A straightforward solution consists of assigning the largest bucket to the largest frequency, the second largest bucket to the second largest frequency and so on.\\n\\nAn implication of the lack of a straightforward solution is that at least one bucket of numbers doesn\\'t help, also the procedure drops the smallest remaining one (the less impactful one). Then the procedure tries to further reduce nf: if the smallest bucket is smaller than the smallest quantity there is no point to keep the bucket, and if the smallest bucket is smaller than the 2nd smallest quantity, then the only possible assignment for the bucket is the smallest quantity. In that case the procedure also drops the smallest quantity.\\n\\nThen the  procedure computes totf defined as the total sum of numbers in the buckets and checks if totf is enough compared to the total number of quantities preq[0], with preq the prefix sum of quantities in reverse order. Finally, if there is enough numbers to assign, the procedure checks if there is just 1 or less remaining buckets as in this case the problem is straightforward again.\\n\\nThe backtrack is very standard: at the kth level of the backtrack, the procedure tries to assign the 1st bucket to the kth quantity, then the 2nd bucket to the kth quantity ans so on till the last bucket. Of course, the procedure only considers buckets whith enough remaining numbers rem[i]. This was enough to make the backtrack working but I added two more things.\\n\\nInitialization of i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1 means that if the quantity k is the same than the quantity k - 1 then the procedure doesn\\'t start iterating from the first bucket as this will generate assignments that the procedure already visited. It is enough to start with the previously assigned bucket.\\n\\nKeep totf updated and check if there is enough remaining numbers to be assigned before calling the recursion. The procedure compute the remaining numbers needed preq[k + 1] - preq[nq] with a prefix sum as nq may decrease when the function bound updates totf.\\n\\nIn order to keep totf updated, the function bound first checks if the considered bucket still contains enough remaining numbers to be assigned to the smallest quantity. If no, it removes the whole remaining bucket size from totf as no further assignments can be done. Then it checks if the considered bucket still contains enough remaining numbers to be assigned to the 2nd smallest quantity. If no, the best possible use of the remaing numbers is to assign them to the smallest quantity, it removes the whole remaining bucket size from totf and it drops the smallest quantity. Finally it just remove the number assigned numbers qnt[k] from totf if it can\\'t do better.\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool canDistribute(vector<int>& nums, vector<int>& qnt) {\\n\\t\\tvector<int> frq(1001, 0);\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tfrq[n]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsort(frq.begin(), frq.end(), greater<int>());\\n\\t\\tsort(qnt.begin(), qnt.end(), greater<int>());\\n\\t\\tint nf = min(nf, (int)qnt.size());\\n\\t\\tint nq = (int)qnt.size();\\n\\n\\t\\tbool str = nf == nq;\\n\\t\\tfor (int i = 0; str && i < nf; i++) {\\n\\t\\t\\tif (qnt[i] > frq[i]) {\\n\\t\\t\\t\\tstr = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (str) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile (--nf > 0 && (frq[nf - 1] < qnt[nq - 1] || (nq > 1 && frq[nf - 1] >= qnt[nq - 1] && frq[nf - 1] < qnt[nq - 2]))) {\\n\\t\\t\\tif (frq[nf - 1] >= qnt[nq - 1]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> rem(frq.begin(), frq.begin() + nf);\\n\\t\\tvector<int> preq(11, 0);\\n\\t\\tint totf = 0;\\n\\t\\tfor (int i = nq - 1; i >= 0; preq[i--] = (i == nq - 1 ? 0 : preq[i + 1]) + qnt[i]);\\n\\t\\tfor (int i = 0; i < nf; totf += frq[i++]);\\n\\t\\tif (totf < preq[0]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (nf <= 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfunction<int(int, int, int)> bound = [&](int k, int i, int t1) {\\n\\t\\t\\tif (nq - 1 > k && rem[i] < qnt[nq - 1]) {\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nq - 2 > k && rem[i] < qnt[nq - 2]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\treturn totf - qnt[k];\\n\\t\\t};\\n\\n\\t\\tfunction<bool(int, int)> bt = [&](int k, int im1) {\\n\\t\\t\\tfor (int i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1; i < nf; i++) {\\n\\t\\t\\t\\tif (frq[i] < qnt[k]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (rem[i] >= qnt[k]) {\\n\\t\\t\\t\\t\\tif (k + 1 == nq) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint t1 = rem[i], t2 = totf, t3 = nq;\\n\\t\\t\\t\\t\\trem[i] -= qnt[k];\\n\\t\\t\\t\\t\\ttotf = bound(k, i, t1);\\n\\t\\t\\t\\t\\tif (totf >= preq[k + 1] - preq[nq]) {\\n\\t\\t\\t\\t\\t\\tif (bt(k + 1, i)) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\trem[i] = t1; totf = t2; nq = t3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn bt(0, 0);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool canDistribute(vector<int>& nums, vector<int>& qnt) {\\n\\t\\tvector<int> frq(1001, 0);\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tfrq[n]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsort(frq.begin(), frq.end(), greater<int>());\\n\\t\\tsort(qnt.begin(), qnt.end(), greater<int>());\\n\\t\\tint nf = min(nf, (int)qnt.size());\\n\\t\\tint nq = (int)qnt.size();\\n\\n\\t\\tbool str = nf == nq;\\n\\t\\tfor (int i = 0; str && i < nf; i++) {\\n\\t\\t\\tif (qnt[i] > frq[i]) {\\n\\t\\t\\t\\tstr = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (str) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile (--nf > 0 && (frq[nf - 1] < qnt[nq - 1] || (nq > 1 && frq[nf - 1] >= qnt[nq - 1] && frq[nf - 1] < qnt[nq - 2]))) {\\n\\t\\t\\tif (frq[nf - 1] >= qnt[nq - 1]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> rem(frq.begin(), frq.begin() + nf);\\n\\t\\tvector<int> preq(11, 0);\\n\\t\\tint totf = 0;\\n\\t\\tfor (int i = nq - 1; i >= 0; preq[i--] = (i == nq - 1 ? 0 : preq[i + 1]) + qnt[i]);\\n\\t\\tfor (int i = 0; i < nf; totf += frq[i++]);\\n\\t\\tif (totf < preq[0]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (nf <= 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfunction<int(int, int, int)> bound = [&](int k, int i, int t1) {\\n\\t\\t\\tif (nq - 1 > k && rem[i] < qnt[nq - 1]) {\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nq - 2 > k && rem[i] < qnt[nq - 2]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\treturn totf - qnt[k];\\n\\t\\t};\\n\\n\\t\\tfunction<bool(int, int)> bt = [&](int k, int im1) {\\n\\t\\t\\tfor (int i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1; i < nf; i++) {\\n\\t\\t\\t\\tif (frq[i] < qnt[k]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (rem[i] >= qnt[k]) {\\n\\t\\t\\t\\t\\tif (k + 1 == nq) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint t1 = rem[i], t2 = totf, t3 = nq;\\n\\t\\t\\t\\t\\trem[i] -= qnt[k];\\n\\t\\t\\t\\t\\ttotf = bound(k, i, t1);\\n\\t\\t\\t\\t\\tif (totf >= preq[k + 1] - preq[nq]) {\\n\\t\\t\\t\\t\\t\\tif (bt(k + 1, i)) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\trem[i] = t1; totf = t2; nq = t3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn bt(0, 0);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380994,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        #We only need the 10 largest frequencies.\\n        freq = sorted(collections.Counter(nums).values())[-10:]\\n        quantity.sort(reverse = True)\\n        \\n        def dfs(i):\\n            if i == len(quantity):\\n                return True\\n            \\n            for j in range(len(freq)):\\n                if freq[j] >= quantity[i]:\\n                    freq[j] += -quantity[i]\\n                    if dfs(i+1):\\n                        return True\\n                    freq[j] += quantity[i]\\n            return False\\n        \\n        return dfs(0)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        #We only need the 10 largest frequencies.\\n        freq = sorted(collections.Counter(nums).values())[-10:]\\n        quantity.sort(reverse = True)\\n        \\n        def dfs(i):\\n            if i == len(quantity):\\n                return True\\n            \\n            for j in range(len(freq)):\\n                if freq[j] >= quantity[i]:\\n                    freq[j] += -quantity[i]\\n                    if dfs(i+1):\\n                        return True\\n                    freq[j] += quantity[i]\\n            return False\\n        \\n        return dfs(0)",
                "codeTag": "Java"
            },
            {
                "id": 2296608,
                "title": "java-backtracking-10ms-99-speed-no-memo-or-dp-explained",
                "content": "#### Optimization\\nTwo optimizations (1 and 2) are needed to avoid TLE, both of them are quite crucial.\\n1. Consider a test case such as `[1,1,2,2,3,3,4,4,5,5,6,6,7,7...]` where each element appears twice. The naive way would be to count them and have `count[1]=2, count[2]=2, count[3]=2, ...` This however is very inefficient because the backtracking function will be checking a lot of layers. Think about it in another way, we should have a `FREQ` array that has `freq[2] = 7`, meaning there are 7 numbers with frequency of 2. This way, backtracking function will only check 1 spot.\\n\\n2. If the max quantity requested is more than the max frequency appears, we ought to return false right away.\\n\\n3. As a bonus, we should remove the frequency key if it reaches 0 before making the next recursive call. This way it won\\'t be checking empty keys.\\n\\n#### Some Details\\nRemoving/adding a key from hashmap will get you Concurrent Modification error. We will use bitset in replace of it.\\nBitSet operates close to `O(1)` for this problem and does not have Concurrent Modification restriction.\\n\\n#### Java\\n#### 10ms (109 / 109 test cases passed.)\\n```Java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] arr = new int[1001];\\n        int max = 0;\\n        for (int n : nums){\\n            max = Math.max(++arr[n], max);\\n        }\\n        int min = Arrays.stream(quantity).max().getAsInt();\\n        if (max < min){ // optimization 2\\n            return false;\\n        }\\n        int[] map = new int[max+1]; // freq map\\n        BitSet bit = new BitSet();\\n        for (int i = 0; i <= 1000; i++) if (arr[i] > 0){ // optimization 1\\n            map[arr[i]]++;\\n            bit.set(arr[i]);\\n        }\\n        return solve(0, map, quantity, bit);\\n    }\\n\\n    private boolean solve(int idx, int[] map, int[] q, BitSet bit){\\n        if (idx==q.length){\\n            return true;\\n        }\\n        for (int key = bit.nextSetBit(0); key >= 0; key = bit.nextSetBit(key+1)){\\n            if (q[idx]>key){\\n                continue;\\n            }\\n            if (--map[key]==0){ // optimization 3\\n                bit.clear(key);\\n            }\\n            if (key-q[idx]>0){\\n                map[key-q[idx]]++;\\n                bit.set(key-q[idx]);\\n            }\\n            if (solve(idx+1, map, q, bit)){\\n                return true;\\n            }\\n            if (key-q[idx]>0&&--map[key-q[idx]]==0){\\n                bit.clear(key-q[idx]);\\n            }\\n            if (++map[key]==1){\\n                bit.set(key);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] arr = new int[1001];\\n        int max = 0;\\n        for (int n : nums){\\n            max = Math.max(++arr[n], max);\\n        }\\n        int min = Arrays.stream(quantity).max().getAsInt();\\n        if (max < min){ // optimization 2\\n            return false;\\n        }\\n        int[] map = new int[max+1]; // freq map\\n        BitSet bit = new BitSet();\\n        for (int i = 0; i <= 1000; i++) if (arr[i] > 0){ // optimization 1\\n            map[arr[i]]++;\\n            bit.set(arr[i]);\\n        }\\n        return solve(0, map, quantity, bit);\\n    }\\n\\n    private boolean solve(int idx, int[] map, int[] q, BitSet bit){\\n        if (idx==q.length){\\n            return true;\\n        }\\n        for (int key = bit.nextSetBit(0); key >= 0; key = bit.nextSetBit(key+1)){\\n            if (q[idx]>key){\\n                continue;\\n            }\\n            if (--map[key]==0){ // optimization 3\\n                bit.clear(key);\\n            }\\n            if (key-q[idx]>0){\\n                map[key-q[idx]]++;\\n                bit.set(key-q[idx]);\\n            }\\n            if (solve(idx+1, map, q, bit)){\\n                return true;\\n            }\\n            if (key-q[idx]>0&&--map[key-q[idx]]==0){\\n                bit.clear(key-q[idx]);\\n            }\\n            if (++map[key]==1){\\n                bit.set(key);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275211,
                "title": "c-simple-logic-beats-95",
                "content": "```\\nclass Solution {\\npublic:\\n    string getKey(map<int,vector<int>> &fc, int idx) {\\n        string k = \"\";\\n        for (auto p : fc) {\\n            k += \"(\"+to_string(p.first)+\"+\"+to_string(p.second.size())+\"),\";\\n        }\\n        k += to_string(idx);\\n        return k;\\n    }\\n    \\n    bool searchFeasible(map<int,vector<int>> &fc, int idx, vector<int> &qu, unordered_set<string> &mem) {\\n        if (idx == qu.size()) return true;\\n        \\n        string k = getKey(fc, idx);\\n        if (mem.count(k)) return false;\\n        mem.insert(k);\\n        \\n        vector<int> counts;\\n        for (auto ff : fc) {\\n            counts.push_back(ff.first);\\n        }\\n        \\n        for (auto ff : counts) {\\n            if (ff >= qu[idx]) {\\n                int itemCount = ff;\\n                int itemId = fc[itemCount].back(); fc[itemCount].pop_back();\\n                if(fc[itemCount].empty()) fc.erase(itemCount);\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].push_back(itemId);\\n                \\n                if (searchFeasible(fc, idx+1, qu, mem)) return true;\\n\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].pop_back();\\n                if (fc[itemCount-qu[idx]].empty()) fc.erase(itemCount-qu[idx]);\\n                fc[itemCount].push_back(itemId);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> catalog;\\n        map<int,vector<int>> freqCount; \\n        unordered_set<string> mem;\\n        for (auto n : nums) {\\n            ++catalog[n];\\n        }\\n        \\n        for (auto c : catalog) {\\n            freqCount[c.second].push_back(c.first);\\n        }\\n        \\n        sort(quantity.begin(), quantity.end(), [] (int l, int r) {return l > r;});\\n        return searchFeasible(freqCount, 0, quantity, mem);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getKey(map<int,vector<int>> &fc, int idx) {\\n        string k = \"\";\\n        for (auto p : fc) {\\n            k += \"(\"+to_string(p.first)+\"+\"+to_string(p.second.size())+\"),\";\\n        }\\n        k += to_string(idx);\\n        return k;\\n    }\\n    \\n    bool searchFeasible(map<int,vector<int>> &fc, int idx, vector<int> &qu, unordered_set<string> &mem) {\\n        if (idx == qu.size()) return true;\\n        \\n        string k = getKey(fc, idx);\\n        if (mem.count(k)) return false;\\n        mem.insert(k);\\n        \\n        vector<int> counts;\\n        for (auto ff : fc) {\\n            counts.push_back(ff.first);\\n        }\\n        \\n        for (auto ff : counts) {\\n            if (ff >= qu[idx]) {\\n                int itemCount = ff;\\n                int itemId = fc[itemCount].back(); fc[itemCount].pop_back();\\n                if(fc[itemCount].empty()) fc.erase(itemCount);\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].push_back(itemId);\\n                \\n                if (searchFeasible(fc, idx+1, qu, mem)) return true;\\n\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].pop_back();\\n                if (fc[itemCount-qu[idx]].empty()) fc.erase(itemCount-qu[idx]);\\n                fc[itemCount].push_back(itemId);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> catalog;\\n        map<int,vector<int>> freqCount; \\n        unordered_set<string> mem;\\n        for (auto n : nums) {\\n            ++catalog[n];\\n        }\\n        \\n        for (auto c : catalog) {\\n            freqCount[c.second].push_back(c.first);\\n        }\\n        \\n        sort(quantity.begin(), quantity.end(), [] (int l, int r) {return l > r;});\\n        return searchFeasible(freqCount, 0, quantity, mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250601,
                "title": "python-easy-backtracking-solution-faster-than-90-beats-98-for-space",
                "content": "\\tclass Solution:\\n\\t\\tdef canDistribute(self, nums: List[int], quan: List[int]) -> bool:\\n\\t\\t\\th = {}\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\th[i] = 1 + h.get(i, 0)\\n\\t\\t\\tn = len(quan)\\n\\t\\t\\tquan.sort(reverse = True)\\n\\t\\t\\tdef solve(i):\\n\\t\\t\\t\\tnonlocal h\\n\\t\\t\\t\\tnonlocal n\\n\\t\\t\\t\\tif i == n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor key, val in h.items():\\n\\t\\t\\t\\t\\tif val >= quan[i]:\\n\\t\\t\\t\\t\\t\\th[key] -= quan[i]\\n\\t\\t\\t\\t\\t\\tif solve(i+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\th[key] += quan[i]\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn solve(0)",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canDistribute(self, nums: List[int], quan: List[int]) -> bool:\\n\\t\\t\\th = {}",
                "codeTag": "Java"
            },
            {
                "id": 2227779,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    bool solve(int pos, vector<int> &v, vector<int> &q){\\n        if(pos == q.size())\\n            return true;\\n        for(int i=0; i < v.size(); i++){\\n            if(i && v[i] == v[i-1])    // skip the elements which we have already checked\\n                continue;\\n            if(v[i] >= q[pos]){\\n                v[i] -= q[pos];\\n                if(solve(pos+1, v, q))\\n                    return true;\\n                v[i] += q[pos];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)\\n            mp[i]++;\\n        vector<int> v;\\n        for(auto i : mp)\\n            v.push_back(i.second);\\n        sort(quantity.rbegin(), quantity.rend());\\n        return solve(0, v, quantity);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    bool solve(int pos, vector<int> &v, vector<int> &q){\\n        if(pos == q.size())\\n            return true;\\n        for(int i=0; i < v.size(); i++){\\n            if(i && v[i] == v[i-1])    // skip the elements which we have already checked\\n                continue;\\n            if(v[i] >= q[pos]){\\n                v[i] -= q[pos];\\n                if(solve(pos+1, v, q))\\n                    return true;\\n                v[i] += q[pos];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)\\n            mp[i]++;\\n        vector<int> v;\\n        for(auto i : mp)\\n            v.push_back(i.second);\\n        sort(quantity.rbegin(), quantity.rend());\\n        return solve(0, v, quantity);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217939,
                "title": "c-solution-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //1. index->let uniqueValues be the array representing all the unique values present in nums\\n    //then index tells us which index of that array we are on\\n    //2. mask-> a bitmask which tells us which orders have been fullfilled\\n    vector<vector<int>>mem;\\n    //stores the total quantity demanded for a particular set of orders\\n    vector<int>total;\\n    //stores the count of the unique values present in nums\\n    unordered_map<int,int>cnts;\\n    int findTotalQuantity(vector<int>&quantity,int mask){\\n        int ans=0;\\n        //iterate thorugh the bitmask by setting the rightmost bit to zero, and add the \\n        //quantity of that position to the answer.\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=quantity[pos];\\n        }\\n        return ans;\\n    }\\n    //for subset of unfullfilled orders we will see if the current index has enough frequency \\n    //to cover the total quantity demanded by the subset, if yes then mark that subset in the mask\\n    //and perform a recursive call, if any of them return true, then return true, else return false.\\n    bool solve(vector<int>&uniqueValues,int index,int mask){\\n        int size=total.size();\\n        int m=log2(size);\\n        if(mask==(1<<m)-1){\\n            return true;\\n        } else if(index==uniqueValues.size()){\\n            return false;\\n        } else if(mem[index][mask]!=-1){\\n            return mem[index][mask];\\n        } else {\\n\\t\\t//ignore the current index and move on\\n            bool ans=solve(uniqueValues,index+1,mask);\\n            if(ans){\\n                return mem[index][mask]=true;\\n            } else {\\n\\t\\t\\t//try every possible subset of the orders that have not been completed\\n                int remainingOrders=((1<<m)-1)^mask;\\n                int value=uniqueValues[index];\\n                for(int submask=remainingOrders;submask>0;submask=(submask-1)&remainingOrders){\\n                    if(cnts[value]>=total[submask]){\\n                        if(solve(uniqueValues,index+1,mask|submask)){\\n                            return mem[index][mask]=true;\\n                        }\\n                    }\\n                }\\n                return mem[index][mask]=false;\\n            }\\n        }\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int m=quantity.size();\\n        for(int i=0;i<nums.size();i++){\\n            cnts[nums[i]]++;\\n        }\\n        vector<int>uniqueValues;\\n        for(unordered_map<int,int>::iterator it=cnts.begin();it!=cnts.end();it++){\\n            uniqueValues.push_back(it->first);\\n        }\\n        int n=uniqueValues.size();\\n        mem=vector<vector<int>>(n,vector<int>(1<<m,-1));\\n        total=vector<int>(1<<m,-1);\\n        for(int mask=0;mask<(1<<m);mask++){\\n            total[mask]=findTotalQuantity(quantity,mask);\\n        }\\n        return solve(uniqueValues,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //1. index->let uniqueValues be the array representing all the unique values present in nums\\n    //then index tells us which index of that array we are on\\n    //2. mask-> a bitmask which tells us which orders have been fullfilled\\n    vector<vector<int>>mem;\\n    //stores the total quantity demanded for a particular set of orders\\n    vector<int>total;\\n    //stores the count of the unique values present in nums\\n    unordered_map<int,int>cnts;\\n    int findTotalQuantity(vector<int>&quantity,int mask){\\n        int ans=0;\\n        //iterate thorugh the bitmask by setting the rightmost bit to zero, and add the \\n        //quantity of that position to the answer.\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=quantity[pos];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2189118,
                "title": "welp-python-backtracking-bruteforce-worked",
                "content": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        \"\"\"\\n            observations:\\n                at most 50 unique values in nums\\n            \\n            distribute the asked quantity of nums to query\\n            \\n            now for a queery like:\\n                [1,1,1,1,2,2,2]  q = [1, 4] , we cant take query1 \"1\" out from  list of 1, bcz if we do, 1 remains = 3 and we wont be able to fulfil 2nd query q2 = \"4\", \\n                \\n            I think we can be a lil greedy and always give away the lowest fulfilling char so we have 3 \"2\" and 4 \"1\" so we fulfil any query less than 3 using 2 \\n                    \\n        \"\"\"\\n        \\n        \"\"\"\\n        s = SortedList([(c, num) for num, c in Counter(nums).items()])\\n        s1 = s.copy()\\n        n = len(s)\\n        quantity.sort(reverse=True)\\n        \\n        \\n        \\n        for q in quantity:\\n            i = s.bisect_left((q, 0))\\n            if i >= n:\\n                return False # cant fill this query\\n            curr_c, curr_elem = s.pop(i)\\n            if curr_c < q:\\n                return False # cant fill\\n            elif curr_c == q:\\n                # exact match\\n                s.add((0, curr_elem)) # no more left\\n            else:\\n                s.add((curr_c - q, curr_elem))\\n        \\n        return True\\n        \"\"\"\\n        \"\"\"\\n        ^ code doesnt work for the case\\n        \\n        [1,1,2,2,1]\\n        [2,2,1]\\n        \\n        which was actually last test case L.. But idea being the hypothesis that give the lowest count element first doesnt stand true, we need look ahead, i.e DP\\n        \\n        bounded sequence donot matter dp ( we need tuple)\\n        \\n        dp(?)\\n        states\\n        state transition\\n        base\\n        \"\"\"\\n        quantity.sort(reverse=True)\\n        counts = Counter(nums)\\n        \\n        \\n        def dp(qi, c):\\n            \\n            \\n            if qi == len(quantity):\\n                return True\\n            \\n            needed_elems = quantity[qi]\\n            \\n            for i in c:\\n                if c[i] >= needed_elems:\\n                    \\n                    c[i] -= needed_elems\\n                    if dp(qi+1, c) == True:\\n                        return True\\n                    c[i] += needed_elems\\n            \\n            return False\\n    \\n        return dp(0, counts)\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        \"\"\"\\n            observations:\\n                at most 50 unique values in nums\\n            \\n            distribute the asked quantity of nums to query\\n            \\n            now for a queery like:\\n                [1,1,1,1,2,2,2]  q = [1, 4] , we cant take query1 \"1\" out from  list of 1, bcz if we do, 1 remains = 3 and we wont be able to fulfil 2nd query q2 = \"4\", \\n                \\n            I think we can be a lil greedy and always give away the lowest fulfilling char so we have 3 \"2\" and 4 \"1\" so we fulfil any query less than 3 using 2 \\n                    \\n        \"\"\"\\n        \\n        \"\"\"\\n        s = SortedList([(c, num) for num, c in Counter(nums).items()])\\n        s1 = s.copy()\\n        n = len(s)\\n        quantity.sort(reverse=True)\\n        \\n        \\n        \\n        for q in quantity:\\n            i = s.bisect_left((q, 0))\\n            if i >= n:\\n                return False # cant fill this query\\n            curr_c, curr_elem = s.pop(i)\\n            if curr_c < q:\\n                return False # cant fill\\n            elif curr_c == q:\\n                # exact match\\n                s.add((0, curr_elem)) # no more left\\n            else:\\n                s.add((curr_c - q, curr_elem))\\n        \\n        return True\\n        \"\"\"\\n        \"\"\"\\n        ^ code doesnt work for the case\\n        \\n        [1,1,2,2,1]\\n        [2,2,1]\\n        \\n        which was actually last test case L.. But idea being the hypothesis that give the lowest count element first doesnt stand true, we need look ahead, i.e DP\\n        \\n        bounded sequence donot matter dp ( we need tuple)\\n        \\n        dp(?)\\n        states\\n        state transition\\n        base\\n        \"\"\"\\n        quantity.sort(reverse=True)\\n        counts = Counter(nums)\\n        \\n        \\n        def dp(qi, c):\\n            \\n            \\n            if qi == len(quantity):\\n                return True\\n            \\n            needed_elems = quantity[qi]\\n            \\n            for i in c:\\n                if c[i] >= needed_elems:\\n                    \\n                    c[i] -= needed_elems\\n                    if dp(qi+1, c) == True:\\n                        return True\\n                    c[i] += needed_elems\\n            \\n            return False\\n    \\n        return dp(0, counts)\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186765,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int pos , vector<int>&freq , vector<int>&Q ){\\n        if(pos >= Q.size()) return true ;\\n        \\n        for(int i = 0 ; i < freq.size() ; ++i ){\\n            if(freq[i] < Q[pos]) continue  ;\\n            \\n            freq[i] -= Q[pos] ;\\n            if(solve(pos + 1 , freq,Q)) return true ;\\n            freq[i] += Q[pos] ;\\n        }\\n        \\n        return false ;\\n        \\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& Q) {\\n        int f[1001] = {} ;\\n        for(auto &x : nums) ++f[x] ;\\n        vector<int> freq ; \\n        for(auto &x : f) if(x) freq.push_back(x) ;\\n\\t\\t//Keep larger frequencies first\\n        sort(rbegin(Q),rend(Q)) ;\\n        return solve(0,freq,Q) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int pos , vector<int>&freq , vector<int>&Q ){\\n        if(pos >= Q.size()) return true ;\\n        \\n        for(int i = 0 ; i < freq.size() ; ++i ){\\n            if(freq[i] < Q[pos]) continue  ;\\n            \\n            freq[i] -= Q[pos] ;\\n            if(solve(pos + 1 , freq,Q)) return true ;\\n            freq[i] += Q[pos] ;\\n        }\\n        \\n        return false ;\\n        \\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& Q) {\\n        int f[1001] = {} ;\\n        for(auto &x : nums) ++f[x] ;\\n        vector<int> freq ; \\n        for(auto &x : f) if(x) freq.push_back(x) ;\\n\\t\\t//Keep larger frequencies first\\n        sort(rbegin(Q),rend(Q)) ;\\n        return solve(0,freq,Q) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104328,
                "title": "c-17-dfs-backtracking-with-optimizations",
                "content": "# [C++17] DFS/Backtracking with optimizations\\n\\n```\\n// Idea / Approach: DFS/Backtracking without memo; how to do a memo?\\n// TODO: Implement a memo for the last k-elements in the supplies of numbers\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // sort the demands descendingly\\n        sort(quantity.begin(), quantity.end(), greater<>());\\n        // do a frequency statistics over the numbers.\\n        auto freqDesc = doFrequencyStatistics(nums);\\n        // remove the useless entries from freqDesc\\n        {\\n            while (!freqDesc.empty() && freqDesc.back() < quantity.back()) {\\n                freqDesc.pop_back();\\n            }\\n            if (freqDesc.empty()) {\\n                return false;\\n            }\\n        }\\n        multiset<int> supplies(freqDesc.begin(), freqDesc.end());\\n        // greedy: find the exact matches, and remove them\\n        vector<int> demands;\\n        {\\n            demands.reserve(quantity.size());\\n            for (auto d : quantity) {\\n                if (auto iter = supplies.find(d); iter != supplies.end()) {\\n                    supplies.erase(iter);\\n                } else {\\n                    demands.emplace_back(d);\\n                }\\n            }\\n        }\\n        if (demands.empty()) {\\n            return true;\\n        }\\n        // dfs ie backtracking\\n        return dfs(supplies, demands, 0);\\n    }\\n\\n    /// dfs from i-th distinct number and c-th customer\\n    bool dfs(multiset<int>& supplies, const vector<int>& demands, int c) {\\n        int currDemand = demands[c];\\n        if (c == demands.size() - 1) { // the last customer\\n            if (!supplies.empty() && *supplies.rbegin() >= currDemand) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        auto supp2 = supplies;\\n        int prevSupply = -1;\\n        for (auto iter = supplies.rbegin(); iter != supplies.rend() && *iter >= currDemand;\\n             ++iter) {\\n            if (*iter == prevSupply) {\\n                continue; // skip duplicated counts\\n            }\\n            prevSupply = *iter;\\n\\n            supp2.erase(supp2.find(*iter));\\n            if (*iter > currDemand) {\\n                supp2.insert(*iter - currDemand);\\n            }\\n            if (dfs(supp2, demands, c + 1)) {\\n                return true;\\n            }\\n            // restore supp2\\n            supp2.insert(*iter);\\n            if (*iter > currDemand) {\\n                supp2.erase(supp2.find(*iter - currDemand));\\n            }\\n        }\\n        return false;\\n    }\\n\\n    static inline vector<int> doFrequencyStatistics(const vector<int>& nums) {\\n        unordered_map<int, int> freqMap;\\n        for (auto a : nums) {\\n            ++freqMap[a];\\n        }\\n        vector<int> freqs;\\n        for (auto [i, freq] : freqMap) {\\n            freqs.emplace_back(freq);\\n        }\\n        sort(freqs.begin(), freqs.end(), greater<>());\\n        return freqs;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea / Approach: DFS/Backtracking without memo; how to do a memo?\\n// TODO: Implement a memo for the last k-elements in the supplies of numbers\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // sort the demands descendingly\\n        sort(quantity.begin(), quantity.end(), greater<>());\\n        // do a frequency statistics over the numbers.\\n        auto freqDesc = doFrequencyStatistics(nums);\\n        // remove the useless entries from freqDesc\\n        {\\n            while (!freqDesc.empty() && freqDesc.back() < quantity.back()) {\\n                freqDesc.pop_back();\\n            }\\n            if (freqDesc.empty()) {\\n                return false;\\n            }\\n        }\\n        multiset<int> supplies(freqDesc.begin(), freqDesc.end());\\n        // greedy: find the exact matches, and remove them\\n        vector<int> demands;\\n        {\\n            demands.reserve(quantity.size());\\n            for (auto d : quantity) {\\n                if (auto iter = supplies.find(d); iter != supplies.end()) {\\n                    supplies.erase(iter);\\n                } else {\\n                    demands.emplace_back(d);\\n                }\\n            }\\n        }\\n        if (demands.empty()) {\\n            return true;\\n        }\\n        // dfs ie backtracking\\n        return dfs(supplies, demands, 0);\\n    }\\n\\n    /// dfs from i-th distinct number and c-th customer\\n    bool dfs(multiset<int>& supplies, const vector<int>& demands, int c) {\\n        int currDemand = demands[c];\\n        if (c == demands.size() - 1) { // the last customer\\n            if (!supplies.empty() && *supplies.rbegin() >= currDemand) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        auto supp2 = supplies;\\n        int prevSupply = -1;\\n        for (auto iter = supplies.rbegin(); iter != supplies.rend() && *iter >= currDemand;\\n             ++iter) {\\n            if (*iter == prevSupply) {\\n                continue; // skip duplicated counts\\n            }\\n            prevSupply = *iter;\\n\\n            supp2.erase(supp2.find(*iter));\\n            if (*iter > currDemand) {\\n                supp2.insert(*iter - currDemand);\\n            }\\n            if (dfs(supp2, demands, c + 1)) {\\n                return true;\\n            }\\n            // restore supp2\\n            supp2.insert(*iter);\\n            if (*iter > currDemand) {\\n                supp2.erase(supp2.find(*iter - currDemand));\\n            }\\n        }\\n        return false;\\n    }\\n\\n    static inline vector<int> doFrequencyStatistics(const vector<int>& nums) {\\n        unordered_map<int, int> freqMap;\\n        for (auto a : nums) {\\n            ++freqMap[a];\\n        }\\n        vector<int> freqs;\\n        for (auto [i, freq] : freqMap) {\\n            freqs.emplace_back(freq);\\n        }\\n        sort(freqs.begin(), freqs.end(), greater<>());\\n        return freqs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091316,
                "title": "python-without-bit-masking-backtracking-beats-94-73-time",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt = Counter(nums)\\n        l = []\\n        for k, v in cnt.items():\\n            l.append(v)\\n        l = sorted(l, reverse=True)\\n        n = len(quantity)\\n        \\n        @lru_cache(None)\\n        def dp(i, left):\\n            if i == n:\\n                return True\\n            left = list(left)\\n            for j, c in enumerate(left):\\n                if c >= quantity[i]:\\n                    left[j] -= quantity[i]\\n                    if dp(i+1, tuple(sorted(left))):  # Sort the tuple to avoid unnecessary repitition since it doesn\\'t matter which number is assigned to each order.\\n                        return True\\n                    left[j] += quantity[i]\\n            return False\\n        \\n        return dp(0, tuple(l))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt = Counter(nums)\\n        l = []\\n        for k, v in cnt.items():\\n            l.append(v)\\n        l = sorted(l, reverse=True)\\n        n = len(quantity)\\n        \\n        @lru_cache(None)\\n        def dp(i, left):\\n            if i == n:\\n                return True\\n            left = list(left)\\n            for j, c in enumerate(left):\\n                if c >= quantity[i]:\\n                    left[j] -= quantity[i]\\n                    if dp(i+1, tuple(sorted(left))):  # Sort the tuple to avoid unnecessary repitition since it doesn\\'t matter which number is assigned to each order.\\n                        return True\\n                    left[j] += quantity[i]\\n            return False\\n        \\n        return dp(0, tuple(l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053729,
                "title": "python-dfs-with-bitmask-o-n-3-m",
                "content": "Let\\'s analyze the time complexity.\\nIf we fix i and mask, dfs(i, mask) takes 2^j where j is the number of ones in the binary representation of mask.\\nSince there are mCj masks whose number of ones in binary representaion is j, the complexity becomes\\nsum_{j from 0 to m} mCj * 2^j = (2+1)^m = 3^m. \\nFinally, we have n possibilities for i, the total time complexity becomes O(n*3^m)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = sorted(Counter(nums).values(), reverse = True)\\n        n = len(c)\\n        m = len(quantity)\\n        mask_sum = defaultdict(int)\\n        for mask in range(1<<m):\\n            for i in range(m):\\n                if (1<<i) & mask:\\n                    mask_sum[mask] += quantity[i]\\n        @lru_cache(None)\\n        def dfs(i, mask):\\n            if mask == 0: return True\\n            if i == n: return False\\n            submask = mask\\n            while submask:\\n                if mask_sum[submask] <= c[i] and dfs(i+1, mask^submask):\\n                    return True\\n                submask = (submask-1) & mask\\n            return False\\n        return dfs(0, (1<<m)-1)\\n        \\n        \\n            \\n            \\n            \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "Let\\'s analyze the time complexity.\\nIf we fix i and mask, dfs(i, mask) takes 2^j where j is the number of ones in the binary representation of mask.\\nSince there are mCj masks whose number of ones in binary representaion is j, the complexity becomes\\nsum_{j from 0 to m} mCj * 2^j = (2+1)^m = 3^m. \\nFinally, we have n possibilities for i, the total time complexity becomes O(n*3^m)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = sorted(Counter(nums).values(), reverse = True)\\n        n = len(c)\\n        m = len(quantity)\\n        mask_sum = defaultdict(int)\\n        for mask in range(1<<m):\\n            for i in range(m):\\n                if (1<<i) & mask:\\n                    mask_sum[mask] += quantity[i]\\n        @lru_cache(None)\\n        def dfs(i, mask):\\n            if mask == 0: return True\\n            if i == n: return False\\n            submask = mask\\n            while submask:\\n                if mask_sum[submask] <= c[i] and dfs(i+1, mask^submask):\\n                    return True\\n                submask = (submask-1) & mask\\n            return False\\n        return dfs(0, (1<<m)-1)\\n        \\n        \\n            \\n            \\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1876491,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cnt;\\n    vector<unordered_map<string, int>> memo;\\n    \\n    bool dfs(vector<int> &quantity, string &mem, int index) {\\n        if (index == quantity.size())\\n            return true;\\n        \\n        bool pos = false;\\n        if (memo[index].count(mem))\\n            return memo[index][mem];\\n        \\n        for (auto &[k, v]: cnt) {\\n            if (v >= quantity[index]) {\\n                cnt[k] -= quantity[index];\\n                mem += cnt[k] + \\'0\\';\\n                pos = pos || dfs(quantity, mem, index + 1);\\n                mem.pop_back();\\n                if (pos) return true;\\n                cnt[k] += quantity[index];\\n            }\\n        }\\n        return memo[index][mem] = pos;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = quantity.size();\\n        string mem = \"\";\\n        memo = vector<unordered_map<string, int>>(n);\\n\\n        for (int i: nums)\\n            cnt[i]++;\\n\\n        return dfs(quantity, mem, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cnt;\\n    vector<unordered_map<string, int>> memo;\\n    \\n    bool dfs(vector<int> &quantity, string &mem, int index) {\\n        if (index == quantity.size())\\n            return true;\\n        \\n        bool pos = false;\\n        if (memo[index].count(mem))\\n            return memo[index][mem];\\n        \\n        for (auto &[k, v]: cnt) {\\n            if (v >= quantity[index]) {\\n                cnt[k] -= quantity[index];\\n                mem += cnt[k] + \\'0\\';\\n                pos = pos || dfs(quantity, mem, index + 1);\\n                mem.pop_back();\\n                if (pos) return true;\\n                cnt[k] += quantity[index];\\n            }\\n        }\\n        return memo[index][mem] = pos;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = quantity.size();\\n        string mem = \"\";\\n        memo = vector<unordered_map<string, int>>(n);\\n\\n        for (int i: nums)\\n            cnt[i]++;\\n\\n        return dfs(quantity, mem, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813206,
                "title": "subtraction-and-backtracking-c",
                "content": "\\t  inline  bool helper(vector<int> &buckets,vector<int> &quantity,int k)\\n\\t\\t{\\n        if(quantity.size()==k)\\n            return true;\\n        \\n        for(int i=0;i<buckets.size();i++)\\n            if(buckets[i]-quantity[k]>=0)\\n            {\\n                buckets[i]-=quantity[k];\\n                \\n                if(helper(buckets,quantity,k+1))\\n                    return true;\\n                \\n                buckets[i]+=quantity[k];\\n            }\\n                \\n        \\n        return false;\\n    }\\n    \\n    \\n\\t   inline bool canDistribute(vector<int>& nums, vector<int>& quantity) \\n\\t\\t{\\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]++;\\n        \\n        vector<int> buckets;\\n        \\n        for(auto &ell:hash)\\n             buckets.push_back(ell.second);\\n        \\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        sort(buckets.begin(),buckets.end(),greater<int>());\\n        \\n        return helper(buckets,quantity,0);\\n    }",
                "solutionTags": [],
                "code": "\\t  inline  bool helper(vector<int> &buckets,vector<int> &quantity,int k)\\n\\t\\t{\\n        if(quantity.size()==k)\\n            return true;\\n        \\n        for(int i=0;i<buckets.size();i++)\\n            if(buckets[i]-quantity[k]>=0)\\n            {\\n                buckets[i]-=quantity[k];\\n                \\n                if(helper(buckets,quantity,k+1))\\n                    return true;\\n                \\n                buckets[i]+=quantity[k];\\n            }\\n                \\n        \\n        return false;\\n    }\\n    \\n    \\n\\t   inline bool canDistribute(vector<int>& nums, vector<int>& quantity) \\n\\t\\t{\\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]++;\\n        \\n        vector<int> buckets;\\n        \\n        for(auto &ell:hash)\\n             buckets.push_back(ell.second);\\n        \\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        sort(buckets.begin(),buckets.end(),greater<int>());\\n        \\n        return helper(buckets,quantity,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1676209,
                "title": "dp-o-n-q-2-q-c-solution-with-no-comments-or-explanation",
                "content": "Time complexity of O(n.q.2^q) and space complexity of O(n.2^q), where n = length of nums array ( < 10^5), q = length of quantity array ( < 10)\\n```\\n    vector<unordered_set<int>> dp;\\n    int customerSatisfied(int customers, int customer){\\n        return customers & (1 << customer);\\n    }\\n    \\n    int newCustomer(int customers, int customer){\\n        return customers ^ (1 << customer);\\n    }\\n    \\n    int find(int i, vector<int> &nums, vector<int>& quantity, int* cond, int customers, int n, int q){\\n        if(customers == (1 << q) - 1) return true;\\n        if(i == n) return false;\\n        //cout << i << endl;\\n        if(dp[i].find(customers) != dp[i].end()) return false;\\n        \\n        bool res;\\n        for(int j = 0; j < q; j++){\\n            if(customerSatisfied(customers, j)) continue;\\n            if(cond[i] - i + 1 >= quantity[j]){\\n                res = find(i + quantity[j], nums, quantity, cond, newCustomer(customers, j), n, q);\\n                if(res) return true;\\n            }\\n        }\\n        \\n        res = find(cond[i]+1, nums, quantity, cond, customers, n, q);\\n        if(res) return true;\\n        dp[i].insert(customers);\\n        return false;\\n        \\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int *cond = new int[n];\\n        cond[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(nums[i] == nums[i+1]) cond[i] = cond[i+1];\\n            else cond[i] = i;\\n        }\\n        int q = quantity.size();\\n        dp = vector(n, unordered_set<int>());\\n        return find(0, nums, quantity, cond, 0, n, q);\\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<unordered_set<int>> dp;\\n    int customerSatisfied(int customers, int customer){\\n        return customers & (1 << customer);\\n    }\\n    \\n    int newCustomer(int customers, int customer){\\n        return customers ^ (1 << customer);\\n    }\\n    \\n    int find(int i, vector<int> &nums, vector<int>& quantity, int* cond, int customers, int n, int q){\\n        if(customers == (1 << q) - 1) return true;\\n        if(i == n) return false;\\n        //cout << i << endl;\\n        if(dp[i].find(customers) != dp[i].end()) return false;\\n        \\n        bool res;\\n        for(int j = 0; j < q; j++){\\n            if(customerSatisfied(customers, j)) continue;\\n            if(cond[i] - i + 1 >= quantity[j]){\\n                res = find(i + quantity[j], nums, quantity, cond, newCustomer(customers, j), n, q);\\n                if(res) return true;\\n            }\\n        }\\n        \\n        res = find(cond[i]+1, nums, quantity, cond, customers, n, q);\\n        if(res) return true;\\n        dp[i].insert(customers);\\n        return false;\\n        \\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int *cond = new int[n];\\n        cond[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(nums[i] == nums[i+1]) cond[i] = cond[i+1];\\n            else cond[i] = i;\\n        }\\n        int q = quantity.size();\\n        dp = vector(n, unordered_set<int>());\\n        return find(0, nums, quantity, cond, 0, n, q);\\n        \\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1514301,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        #Backtracking approach\\n        counter = {}\\n        for num in nums:\\n            counter[num] = counter.get(num, 0) + 1\\n        freq_counter = {val: sum(1 for key in counter.keys() if counter[key] == val) for val in counter.values()}\\n        res = False\\n        #Call inner function with quantity array sorted in reverse\\n        def check_distribute(freq_counter, quantity):\\n            #print(f\\'Currently: freq_counter {freq_counter} and quantity: {quantity}\\')\\n            nonlocal res\\n            if not quantity:\\n                #All customers served\\n                #print(\\'!\\')\\n                res = True\\n                return \\n            else:\\n                if not res:\\n                    quant = quantity[-1]\\n                    for key in freq_counter:\\n                        if key < quant or freq_counter[key] == 0:\\n                            continue\\n                        else:\\n                            diff = key - quant\\n                            new_count = freq_counter[key] - 1\\n                            check_distribute({**freq_counter, key: new_count, diff: freq_counter.get(diff,0) + 1},quantity[:-1])\\n        #Call inner function \\n        check_distribute(freq_counter,sorted(quantity))\\n        return res \\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        #Backtracking approach\\n        counter = {}\\n        for num in nums:\\n            counter[num] = counter.get(num, 0) + 1\\n        freq_counter = {val: sum(1 for key in counter.keys() if counter[key] == val) for val in counter.values()}\\n        res = False\\n        #Call inner function with quantity array sorted in reverse\\n        def check_distribute(freq_counter, quantity):\\n            #print(f\\'Currently: freq_counter {freq_counter} and quantity: {quantity}\\')\\n            nonlocal res\\n            if not quantity:\\n                #All customers served\\n                #print(\\'!\\')\\n                res = True\\n                return \\n            else:\\n                if not res:\\n                    quant = quantity[-1]\\n                    for key in freq_counter:\\n                        if key < quant or freq_counter[key] == 0:\\n                            continue\\n                        else:\\n                            diff = key - quant\\n                            new_count = freq_counter[key] - 1\\n                            check_distribute({**freq_counter, key: new_count, diff: freq_counter.get(diff,0) + 1},quantity[:-1])\\n        #Call inner function \\n        check_distribute(freq_counter,sorted(quantity))\\n        return res \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1504805,
                "title": "python-iterative-dp-with-explanation-and-picture",
                "content": "![image](https://assets.leetcode.com/users/images/85fd017c-b649-4e50-821f-6dd1895f8d57_1633447604.9101381.jpeg)\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        same_items = sorted(Counter(nums).values())\\n        m, n = len(Q), len(same_items)\\n        masks = [sum(Q[i] for i in range(m) if mask & 1<<i) for mask in range(1<<m)]  # I call entries of this array \"Q_sums\"\\n        valids = set()   # These are the bitmasks that correspond to possible maps same_items[idx] --> Q[i] for all i in mask\\n        winner = (1<<m) - 1\\n        for idx in range(n):\\n            new_valids = set()\\n            for mask, x in enumerate(masks):\\n                if same_items[idx] >= x:\\n                    if mask == winner: return True\\n                    new_valids.add(mask)\\n            for x in valids.copy():\\n                for y in new_valids:\\n                    if x & y == 0: \\n                        merged_mask = x | y\\n                        if merged_mask == winner: return True\\n                        valids.add(merged_mask)\\n            valids.update(new_valids)            \\n        return False\\n        # It seems like what I want to check for is if same_items has enough items to distribute across Q\\n        # So, from indices of same_items, we generate bitmasks saying which objects of Q that we are covering\\n        # Thus, a valid bitmask for same_items[idx] is one whose Q_sum <= same_items[idx].\\n        # Further, each entry of Q cannot cannot receive items from different same_items[idx]. Hence, two compatible\\n        # bitmasks x, y are s.t. x & y == 0. \\n        # Therefore, we return true iff we encounter the bitmask (1<<m) - 1 (eg 11111 if m = 5)\\n        \\n        # We propagate bitmasks by first finding all valid masks for same_items[0]. Then we find all valid masks for same_items[1].\\n        # We keep a set of valid masks encountered so far, since it\\'s possible that a valid distribution of items from same_items does \\n        # not involve all items in same_items (as the picture I drew illustrates). Then, for same_items[idx] we put valid masks\\n        # in new_valids, and then for each entry in new_valids, we loop over valids and toss in compatible masks. Continue until see winner or loop ends.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        same_items = sorted(Counter(nums).values())\\n        m, n = len(Q), len(same_items)\\n        masks = [sum(Q[i] for i in range(m) if mask & 1<<i) for mask in range(1<<m)]  # I call entries of this array \"Q_sums\"\\n        valids = set()   # These are the bitmasks that correspond to possible maps same_items[idx] --> Q[i] for all i in mask\\n        winner = (1<<m) - 1\\n        for idx in range(n):\\n            new_valids = set()\\n            for mask, x in enumerate(masks):\\n                if same_items[idx] >= x:\\n                    if mask == winner: return True\\n                    new_valids.add(mask)\\n            for x in valids.copy():\\n                for y in new_valids:\\n                    if x & y == 0: \\n                        merged_mask = x | y\\n                        if merged_mask == winner: return True\\n                        valids.add(merged_mask)\\n            valids.update(new_valids)            \\n        return False\\n        # It seems like what I want to check for is if same_items has enough items to distribute across Q\\n        # So, from indices of same_items, we generate bitmasks saying which objects of Q that we are covering\\n        # Thus, a valid bitmask for same_items[idx] is one whose Q_sum <= same_items[idx].\\n        # Further, each entry of Q cannot cannot receive items from different same_items[idx]. Hence, two compatible\\n        # bitmasks x, y are s.t. x & y == 0. \\n        # Therefore, we return true iff we encounter the bitmask (1<<m) - 1 (eg 11111 if m = 5)\\n        \\n        # We propagate bitmasks by first finding all valid masks for same_items[0]. Then we find all valid masks for same_items[1].\\n        # We keep a set of valid masks encountered so far, since it\\'s possible that a valid distribution of items from same_items does \\n        # not involve all items in same_items (as the picture I drew illustrates). Then, for same_items[idx] we put valid masks\\n        # in new_valids, and then for each entry in new_valids, we loop over valids and toss in compatible masks. Continue until see winner or loop ends.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499692,
                "title": "c-bitmask-dp-with-mask-enumeration-time-complexity-o-50-3-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getQuantityUsed(int mask, vector<int>&quantity){\\n        int sz = quantity.size();\\n        int total = 0;\\n        int i, j;\\n        for(i = 0; i < sz; i++){\\n            j = sz - 1 - i;\\n            if((1 << i) & mask){\\n                total += quantity[j];\\n            }\\n        }\\n        return total;\\n    }\\n    \\n    bool canDistribute(vector<int>&nums, vector<int>&quantity){\\n        int i, j, k, l;\\n        int sz = quantity.size();\\n        int len = nums.size();\\n        int bitmask = 1 << sz;\\n        unordered_map<int, int>hashMap;\\n        vector<int>uniqueNums; \\n        \\n        for(i = 0; i < len; i++){\\n            if(hashMap.find(nums[i]) == hashMap.end()){\\n                hashMap[nums[i]] = 1;\\n                uniqueNums.push_back(nums[i]);\\n            }\\n            else{\\n                hashMap[nums[i]]++;\\n            }\\n        }        \\n        \\n        len = uniqueNums.size();\\n        vector<vector<bool>>isValid(len, vector<bool>(bitmask));\\n        for(i = 0; i < len; i++){\\n            for(j = 0; j < bitmask; j++){\\n                if(getQuantityUsed(j, quantity) <= hashMap[uniqueNums[i]]){\\n                    isValid[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<bool>>dp(bitmask, vector<bool>(len + 1));\\n        for(i = 0; i <= len; i++){\\n            dp[0][i] = true;\\n        }\\n        for(i = 1; i < bitmask; i++){\\n            for(j = 1; j <= len; j++){\\n                dp[i][j] = dp[i][j - 1];\\n                for(k = i; k; k = (k - 1) & i){\\n                    if(isValid[j - 1][k]){\\n                        dp[i][j] = dp[i][j] || dp[i - k][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[bitmask - 1][len];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getQuantityUsed(int mask, vector<int>&quantity){\\n        int sz = quantity.size();\\n        int total = 0;\\n        int i, j;\\n        for(i = 0; i < sz; i++){\\n            j = sz - 1 - i;\\n            if((1 << i) & mask){\\n                total += quantity[j];\\n            }\\n        }\\n        return total;\\n    }\\n    \\n    bool canDistribute(vector<int>&nums, vector<int>&quantity){\\n        int i, j, k, l;\\n        int sz = quantity.size();\\n        int len = nums.size();\\n        int bitmask = 1 << sz;\\n        unordered_map<int, int>hashMap;\\n        vector<int>uniqueNums; \\n        \\n        for(i = 0; i < len; i++){\\n            if(hashMap.find(nums[i]) == hashMap.end()){\\n                hashMap[nums[i]] = 1;\\n                uniqueNums.push_back(nums[i]);\\n            }\\n            else{\\n                hashMap[nums[i]]++;\\n            }\\n        }        \\n        \\n        len = uniqueNums.size();\\n        vector<vector<bool>>isValid(len, vector<bool>(bitmask));\\n        for(i = 0; i < len; i++){\\n            for(j = 0; j < bitmask; j++){\\n                if(getQuantityUsed(j, quantity) <= hashMap[uniqueNums[i]]){\\n                    isValid[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<bool>>dp(bitmask, vector<bool>(len + 1));\\n        for(i = 0; i <= len; i++){\\n            dp[0][i] = true;\\n        }\\n        for(i = 1; i < bitmask; i++){\\n            for(j = 1; j <= len; j++){\\n                dp[i][j] = dp[i][j - 1];\\n                for(k = i; k; k = (k - 1) & i){\\n                    if(isValid[j - 1][k]){\\n                        dp[i][j] = dp[i][j] || dp[i - k][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[bitmask - 1][len];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482717,
                "title": "dp-memoized-approach",
                "content": "```\\nclass Solution {\\n    map<vector<int>,int> dp[11];\\n    int n,m;\\npublic:\\n    bool solver(int st,vector<int> q,vector<int> f){\\n        sort(f.begin(),f.end(),greater<int>());\\n        if(dp[st].find(f)!=dp[st].end())\\n            return dp[st][f];\\n        if(st==(m-1))\\n            return f[0]>=q[st];\\n        bool next=0;\\n        for(int i=0;i<n;i++){\\n            if(next)\\n                break;\\n            if(f[i]>=q[st]){\\n                f[i]-=q[st];\\n                next=solver(st+1,q,f);\\n                f[i]+=q[st];\\n            }\\n            else\\n                break;\\n        }\\n        return dp[st][f]=next;\\n    }\\n    \\n    bool canDistribute(vector<int>& a, vector<int>& q) {\\n        vector<int> f(1002,0);\\n        for(auto e:a)\\n            f[e]++;\\n        vector<int> t;\\n        for(auto e:f)\\n            if(e)\\n                t.push_back(e);\\n        n=t.size();\\n        m=q.size();\\n        return solver(0,q,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    map<vector<int>,int> dp[11];\\n    int n,m;\\npublic:\\n    bool solver(int st,vector<int> q,vector<int> f){\\n        sort(f.begin(),f.end(),greater<int>());\\n        if(dp[st].find(f)!=dp[st].end())\\n            return dp[st][f];\\n        if(st==(m-1))\\n            return f[0]>=q[st];\\n        bool next=0;\\n        for(int i=0;i<n;i++){\\n            if(next)\\n                break;\\n            if(f[i]>=q[st]){\\n                f[i]-=q[st];\\n                next=solver(st+1,q,f);\\n                f[i]+=q[st];\\n            }\\n            else\\n                break;\\n        }\\n        return dp[st][f]=next;\\n    }\\n    \\n    bool canDistribute(vector<int>& a, vector<int>& q) {\\n        vector<int> f(1002,0);\\n        for(auto e:a)\\n            f[e]++;\\n        vector<int> t;\\n        for(auto e:f)\\n            if(e)\\n                t.push_back(e);\\n        n=t.size();\\n        m=q.size();\\n        return solver(0,q,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397945,
                "title": "c-dp-fast",
                "content": "```\\n\\tbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> hm;\\n        for(int n:nums){\\n            hm[n]++;\\n        }\\n        vector<int> freq;\\n        for(auto p:hm){\\n            freq.push_back(p.second);\\n        }\\n        int n=freq.size(),m=quantity.size();\\n        vector<vector<int>> poss(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum=0;\\n                for(int k=0;k<m && sum<=freq[i];k++){\\n                    if(j&(1<<k)){\\n                        sum+=quantity[k];\\n                    }\\n                }\\n                if(sum<=freq[i]){\\n                    poss[i].push_back(j);\\n                }\\n            }\\n        }\\n        bool dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=j+1==1<<m;\\n                }else{\\n                    dp[i][j]=false;\\n                    for(int k:poss[i]){\\n                        if(dp[i][j]){\\n                            break;\\n                        }\\n                        if((k&j)==0 && dp[i+1][j|k]){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> hm;\\n        for(int n:nums){\\n            hm[n]++;\\n        }\\n        vector<int> freq;\\n        for(auto p:hm){\\n            freq.push_back(p.second);\\n        }\\n        int n=freq.size(),m=quantity.size();\\n        vector<vector<int>> poss(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum=0;\\n                for(int k=0;k<m && sum<=freq[i];k++){\\n                    if(j&(1<<k)){\\n                        sum+=quantity[k];\\n                    }\\n                }\\n                if(sum<=freq[i]){\\n                    poss[i].push_back(j);\\n                }\\n            }\\n        }\\n        bool dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=j+1==1<<m;\\n                }else{\\n                    dp[i][j]=false;\\n                    for(int k:poss[i]){\\n                        if(dp[i][j]){\\n                            break;\\n                        }\\n                        if((k&j)==0 && dp[i+1][j|k]){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220772,
                "title": "swift-dfs-backtrack-solution",
                "content": "The question is essentially asking if the quantity\\'s array can be fulfilled given the number of orders. In example 3, ***nums = [1,1,2,2], quantity = [2,2]*** the result is true because there are 2 similar orders that can be taken by the first customer, and the next customer also takes another 2 similar orders. It doesn\\'t matter what the numbers are in the nums array, rather how many repeated numbers are there in the nums array.\\n    \\n```\\nclass Solution {\\n    \\n    /*\\n    Task:\\n        1. Get the frequency count for each number using a dictionary\\n        2. Convert the values in the dictionary to an array \\n        3. Sort the quantity in descending order\\n        4. Backtrack\\n            I. If there is an order that is less than what we need in the quantity array,\\n\\t\\t\\tkeep moving forward to see if the next order can fulfill the quantity. \\n\\t\\t\\t\\n            II. Otherwise, remove the quantity from the orders array and see if the rest of the quantitys can be fulfilled.\\n    */\\n    \\n    func canDistribute(_ nums: [Int], _ quantity: [Int]) -> Bool {\\n        var map: [Int: Int] = [:]\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n\\n        var orders: [Int] = Array(map.values)\\n        \\n        // Descendiing order\\n        var sortedQuantity = quantity.sorted { $0 > $1 } \\n        \\n        return helper(sortedQuantity, &orders, 0)\\n    }\\n    \\n    func helper(_ quantity: [Int], _ orders: inout [Int], _ start: Int) -> Bool {\\n        \\n        // All customer\\'s get their orders\\n        if start == quantity.count { return true }\\n        \\n        for index in 0..<orders.count {\\n            var num = orders[index]\\n            \\n            // We need an order that is >= the quantity\\n            if num < quantity[start] { continue }\\n            \\n            // Quantity amount gets taken by customer\\n            orders[index] -= quantity[start]\\n            \\n            // Check if the next customers will also get their orders\\n            if helper(quantity, &orders, start+1) {\\n                return true\\n            }\\n            \\n            // Backtrack\\n            orders[index] += quantity[start]      \\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n    Task:\\n        1. Get the frequency count for each number using a dictionary\\n        2. Convert the values in the dictionary to an array \\n        3. Sort the quantity in descending order\\n        4. Backtrack\\n            I. If there is an order that is less than what we need in the quantity array,\\n\\t\\t\\tkeep moving forward to see if the next order can fulfill the quantity. \\n\\t\\t\\t\\n            II. Otherwise, remove the quantity from the orders array and see if the rest of the quantitys can be fulfilled.\\n    */\\n    \\n    func canDistribute(_ nums: [Int], _ quantity: [Int]) -> Bool {\\n        var map: [Int: Int] = [:]\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n\\n        var orders: [Int] = Array(map.values)\\n        \\n        // Descendiing order\\n        var sortedQuantity = quantity.sorted { $0 > $1 } \\n        \\n        return helper(sortedQuantity, &orders, 0)\\n    }\\n    \\n    func helper(_ quantity: [Int], _ orders: inout [Int], _ start: Int) -> Bool {\\n        \\n        // All customer\\'s get their orders\\n        if start == quantity.count { return true }\\n        \\n        for index in 0..<orders.count {\\n            var num = orders[index]\\n            \\n            // We need an order that is >= the quantity\\n            if num < quantity[start] { continue }\\n            \\n            // Quantity amount gets taken by customer\\n            orders[index] -= quantity[start]\\n            \\n            // Check if the next customers will also get their orders\\n            if helper(quantity, &orders, start+1) {\\n                return true\\n            }\\n            \\n            // Backtrack\\n            orders[index] += quantity[start]      \\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068287,
                "title": "python-3-knapsack-brute-force-with-memorization-732m-beat-97",
                "content": "Each specific number is a bag. # of the number is the size of the bag. Quantity[i] is an item with size quantity[i]. Then, just use brute-force with memo. \\nO(50^10)\\n\\n```\\n        if sum(quantity) > len(nums): return False\\n        c = Counter(nums)\\n        # sizes of bags\\n        bags = list(c.values())\\n        bags.sort(reverse = True)\\n        \\n        quantity.sort(reverse = True)\\n        \\n        @lru_cache(None)\\n        def tryone(idx,bags):\\n            if idx == len(quantity): return True\\n            return any( tryone(idx + 1, tuple(sorted(bags[:b] + (bags[b] - quantity[idx],) + bags[b+1:], reverse = True))  )\\n                for b in range(len(bags)) if bags[b] >= quantity[idx])\\n            \\n        return tryone(0, tuple(bags))\\n```",
                "solutionTags": [],
                "code": "```\\n        if sum(quantity) > len(nums): return False\\n        c = Counter(nums)\\n        # sizes of bags\\n        bags = list(c.values())\\n        bags.sort(reverse = True)\\n        \\n        quantity.sort(reverse = True)\\n        \\n        @lru_cache(None)\\n        def tryone(idx,bags):\\n            if idx == len(quantity): return True\\n            return any( tryone(idx + 1, tuple(sorted(bags[:b] + (bags[b] - quantity[idx],) + bags[b+1:], reverse = True))  )\\n                for b in range(len(bags)) if bags[b] >= quantity[idx])\\n            \\n        return tryone(0, tuple(bags))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1065905,
                "title": "python3-easy-to-understand-backtracking-solution",
                "content": "It doesn\\'t matter what the contents of num are. So tracking the count of each item in nums is sufficient. Going one step further, we can maintain a count of counts and  update the counter while backtracking.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def backtrack(i, cntr):\\n            if i == len(quantity):\\n                return True\\n            \\n\\t\\t\\t# cnt is the number of times some element is occuring in the array.\\n\\t\\t\\t# If we use one of those nums, decrement the count of that num count\\n\\t\\t\\t# Now the number of elems in the bucket we chose would have decreased and\\n\\t\\t\\t# this new count needs to be added to the counter\\n\\t\\t\\t# If the number of buckets of  some count becomes zero, remove it from the counter\\n\\t\\t\\t# If backtrack returns False, just reverse these operations\\n\\t\\t\\t# A temp counter is necessary for these operations because we are changing the size of the original counter\\n\\t\\t\\ttemp_counter = cntr.copy()\\n            for cnt in cntr:\\n                if cnt >= quantity[i]:\\n                    temp_counter[cnt] -= 1\\n                    if temp_counter[cnt] == 0:\\n                        temp_counter.pop(cnt)\\n                    rem = cnt - quantity[i]\\n                    temp_counter[rem] += 1\\n                    \\n                    if backtrack(i+1, temp_counter):\\n                        return True\\n                    \\n                    temp_counter[rem] -= 1\\n                    if temp_counter[rem] == 0:\\n                        temp_counter.pop(rem)\\n                    temp_counter[cnt] += 1\\n                    \\n            return False\\n        \\n        count_of_counts = Counter(Counter(nums).values())\\n        quantity.sort(reverse=True)\\n        return backtrack(0, count_of_counts)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def backtrack(i, cntr):\\n            if i == len(quantity):\\n                return True\\n            \\n\\t\\t\\t# cnt is the number of times some element is occuring in the array.\\n\\t\\t\\t# If we use one of those nums, decrement the count of that num count\\n\\t\\t\\t# Now the number of elems in the bucket we chose would have decreased and\\n\\t\\t\\t# this new count needs to be added to the counter\\n\\t\\t\\t# If the number of buckets of  some count becomes zero, remove it from the counter\\n\\t\\t\\t# If backtrack returns False, just reverse these operations\\n\\t\\t\\t# A temp counter is necessary for these operations because we are changing the size of the original counter\\n\\t\\t\\ttemp_counter = cntr.copy()\\n            for cnt in cntr:\\n                if cnt >= quantity[i]:\\n                    temp_counter[cnt] -= 1\\n                    if temp_counter[cnt] == 0:\\n                        temp_counter.pop(cnt)\\n                    rem = cnt - quantity[i]\\n                    temp_counter[rem] += 1\\n                    \\n                    if backtrack(i+1, temp_counter):\\n                        return True\\n                    \\n                    temp_counter[rem] -= 1\\n                    if temp_counter[rem] == 0:\\n                        temp_counter.pop(rem)\\n                    temp_counter[cnt] += 1\\n                    \\n            return False\\n        \\n        count_of_counts = Counter(Counter(nums).values())\\n        quantity.sort(reverse=True)\\n        return backtrack(0, count_of_counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049282,
                "title": "c-no-dp-only-recursion-passed",
                "content": "```\\n\\tbool go(vector<int> &pool, vector<int> &qty, int i) {\\n        if(i == qty.size())             return true;\\n        \\n        bool ans = false;\\n        for(int j=0; j<pool.size(); j++) {\\n            if(pool[j] >= qty[i]) {\\n                pool[j] -= qty[i];\\n                if(go(pool, qty, i+1))  return true;\\n                pool[j] += qty[i];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qty) {\\n        unordered_map<int, int> cnt;\\n        for(auto val: nums) {\\n            cnt[val]++;\\n        }\\n        \\n        vector<int> pool;   // max size = 50\\n        for(auto p: cnt) {\\n            pool.push_back(p.second);\\n        }\\n        // larger qty first \\n        sort(qty.begin(), qty.end(), greater<int>());\\n        \\n        return go(pool, qty, 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool go(vector<int> &pool, vector<int> &qty, int i) {\\n        if(i == qty.size())             return true;\\n        \\n        bool ans = false;\\n        for(int j=0; j<pool.size(); j++) {\\n            if(pool[j] >= qty[i]) {\\n                pool[j] -= qty[i];\\n                if(go(pool, qty, i+1))  return true;\\n                pool[j] += qty[i];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qty) {\\n        unordered_map<int, int> cnt;\\n        for(auto val: nums) {\\n            cnt[val]++;\\n        }\\n        \\n        vector<int> pool;   // max size = 50\\n        for(auto p: cnt) {\\n            pool.push_back(p.second);\\n        }\\n        // larger qty first \\n        sort(qty.begin(), qty.end(), greater<int>());\\n        \\n        return go(pool, qty, 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049062,
                "title": "c-kind-of-greedy",
                "content": "Sort quantity in reverse order, and put number counts in multiset.\\nIterate through quantities.  For each one quantity, find the exact count first.  If none, find the exact mutliple of count.  If still none, try the largest count.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto & d : nums)\\n            mp[d]++;\\n        \\n        multiset<int, greater<int>> ss;\\n        for (auto & it : mp)\\n            ss.emplace(it.second);\\n        \\n        sort(quantity.rbegin(), quantity.rend());\\n        \\n        for (auto & q : quantity) {\\n            if (ss.size() == 0)\\n                return false;\\n            \\n            int maxcnt = *ss.begin();\\n            if (maxcnt < q)\\n                return false;\\n            \\n            bool fFound = false;\\n            \\n            for (int i = q; i <= maxcnt; i += q) {\\n                auto it = ss.find(i);\\n                \\n                if (it != ss.end()) {\\n                    fFound = true;\\n                    ss.erase(it);\\n                    \\n                    if (i != q)\\n                        ss.emplace(i - q);\\n                    break;\\n                }\\n            }\\n            \\n            if (!fFound) {\\n                auto it = ss.begin();\\n                int x = *it;\\n                \\n                ss.erase(it);\\n                ss.emplace(x - q);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto & d : nums)\\n            mp[d]++;\\n        \\n        multiset<int, greater<int>> ss;\\n        for (auto & it : mp)\\n            ss.emplace(it.second);\\n        \\n        sort(quantity.rbegin(), quantity.rend());\\n        \\n        for (auto & q : quantity) {\\n            if (ss.size() == 0)\\n                return false;\\n            \\n            int maxcnt = *ss.begin();\\n            if (maxcnt < q)\\n                return false;\\n            \\n            bool fFound = false;\\n            \\n            for (int i = q; i <= maxcnt; i += q) {\\n                auto it = ss.find(i);\\n                \\n                if (it != ss.end()) {\\n                    fFound = true;\\n                    ss.erase(it);\\n                    \\n                    if (i != q)\\n                        ss.emplace(i - q);\\n                    break;\\n                }\\n            }\\n            \\n            if (!fFound) {\\n                auto it = ss.begin();\\n                int x = *it;\\n                \\n                ss.erase(it);\\n                ss.emplace(x - q);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048601,
                "title": "c-dfs-beat-98",
                "content": "some optimization:\\n1) preprocess, remove all the frequency less than min of quantity;\\n2) preprocess, remove the frenquecy and quantity which equal\\n3) start dfs from the largest quantity to smallest\\n4) recored visited fequency to get rid of duplicate\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        auto [vfeq, vquant] = preprocess(nums, quantity);\\n        return dfs(vfeq, vquant, 0);\\n    }\\n    \\n    bool dfs(vector<int>& vfeq, const vector<int>& vquant, int i){\\n        if(i == vquant.size()){\\n            return true;\\n        }\\n        set<int> visited;\\n        for(auto& f:vfeq){\\n            if(f < vquant[i] || visited.count(f)) continue;\\n            visited.insert(f);\\n            f-=vquant[i];\\n            if(dfs(vfeq, vquant, i+1)) return true;\\n            f+=vquant[i];\\n        }\\n        return false;\\n    }\\n    \\n    pair<vector<int>, vector<int>> preprocess(vector<int>& nums, vector<int>& quantity){\\n        unordered_map<int,int> cnt; \\n        for(auto x:nums) cnt[x]++;\\n\\n        map<int,int> feqs;\\n        for(auto [x, n]:cnt) feqs[n]++;\\n        sort(quantity.begin(), quantity.end());\\n        while(!feqs.empty() && feqs.begin()->first < quantity[0]) feqs.erase(feqs.begin());\\n        map<int,int> mQuanti;\\n        for(auto x:quantity) mQuanti[x]++;\\n        for(auto& [n, cnt] : mQuanti) {\\n            int y = feqs[n];\\n            feqs[n] -= min(y, cnt);\\n            cnt -= min(y, cnt);\\n        }\\n        \\n        vector<int> vfeq, vquant;\\n        for(auto [n, cnt] : feqs) while(cnt-- >0) vfeq.push_back(n);\\n        for(auto [n, cnt] : mQuanti) while(cnt-- >0) vquant.push_back(n);\\n        sort(vquant.begin(), vquant.end(), greater());\\n        return pair{vfeq, vquant};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        auto [vfeq, vquant] = preprocess(nums, quantity);\\n        return dfs(vfeq, vquant, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 998750,
                "title": "java-greedy-dfs-backtracing",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int sum=0;\\n        for(int q:quantity) sum+=q;\\n\\t\\t// if sum is greater than number count, not possible\\n        if(sum>nums.length) return false;\\n        Map<Integer,Integer> cnts=new HashMap<>();\\n        for(int num:nums) {\\n\\t\\t\\t// group numbers\\n            cnts.put(num,cnts.getOrDefault(num,0)+1);\\n        }\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(var cnt:cnts.values()) {\\n\\t\\t\\t// group counts\\n            map.put(cnt,map.getOrDefault(cnt,0)+1);\\n        }\\n\\t\\t// sort quantity\\n        Arrays.sort(quantity);\\n\\t\\t// let\\'s start from high to low to improve performace\\n        return dfs(map,quantity,quantity.length-1);\\n    }\\n    \\n    boolean dfs(Map<Integer,Integer> map,int[]  arr,int idx) {\\n        if (idx<0) return true;\\n        if(map.containsKey(arr[idx])) {\\n            // greedy, take exactly match\\n            var cnt=map.get(arr[idx]);\\n            if(cnt==1) {\\n                map.remove(arr[idx]);\\n            } else {\\n                map.put(arr[idx],cnt-1);\\n            }\\n            if(dfs(map,arr,idx-1)) return true;\\n            // if it doesn\\'t work, backtracking\\n            map.put(arr[idx],cnt);\\n            return false;\\n        } else {\\n            var keys=new ArrayList<>(map.keySet());\\n            for(int key:keys) {\\n                if(key<arr[idx]) continue;\\n\\t\\t\\t\\t// take away from this cnt and update map accordingly\\n                var cnt=map.get(key);\\n                if(cnt==1) {\\n                    map.remove(key);\\n                } else {\\n                    map.put(key,cnt-1);\\n                }\\n                var r=key-arr[idx];\\n                var rc=map.getOrDefault(r,0);\\n                map.put(r,rc+1);\\n                if(dfs(map,arr,idx-1)) return true;\\n                // if it doesn\\'t work, backtracking\\n                map.put(key,cnt);\\n                if(rc==0) {\\n                    map.remove(r);\\n                } else {\\n                    map.put(r,rc);\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int sum=0;\\n        for(int q:quantity) sum+=q;\\n\\t\\t// if sum is greater than number count, not possible\\n        if(sum>nums.length) return false;\\n        Map<Integer,Integer> cnts=new HashMap<>();\\n        for(int num:nums) {\\n\\t\\t\\t// group numbers\\n            cnts.put(num,cnts.getOrDefault(num,0)+1);\\n        }\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(var cnt:cnts.values()) {\\n\\t\\t\\t// group counts\\n            map.put(cnt,map.getOrDefault(cnt,0)+1);\\n        }\\n\\t\\t// sort quantity\\n        Arrays.sort(quantity);\\n\\t\\t// let\\'s start from high to low to improve performace\\n        return dfs(map,quantity,quantity.length-1);\\n    }\\n    \\n    boolean dfs(Map<Integer,Integer> map,int[]  arr,int idx) {\\n        if (idx<0) return true;\\n        if(map.containsKey(arr[idx])) {\\n            // greedy, take exactly match\\n            var cnt=map.get(arr[idx]);\\n            if(cnt==1) {\\n                map.remove(arr[idx]);\\n            } else {\\n                map.put(arr[idx],cnt-1);\\n            }\\n            if(dfs(map,arr,idx-1)) return true;\\n            // if it doesn\\'t work, backtracking\\n            map.put(arr[idx],cnt);\\n            return false;\\n        } else {\\n            var keys=new ArrayList<>(map.keySet());\\n            for(int key:keys) {\\n                if(key<arr[idx]) continue;\\n\\t\\t\\t\\t// take away from this cnt and update map accordingly\\n                var cnt=map.get(key);\\n                if(cnt==1) {\\n                    map.remove(key);\\n                } else {\\n                    map.put(key,cnt-1);\\n                }\\n                var r=key-arr[idx];\\n                var rc=map.getOrDefault(r,0);\\n                map.put(r,rc+1);\\n                if(dfs(map,arr,idx-1)) return true;\\n                // if it doesn\\'t work, backtracking\\n                map.put(key,cnt);\\n                if(rc==0) {\\n                    map.remove(r);\\n                } else {\\n                    map.put(r,rc);\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998010,
                "title": "p23-5",
                "content": "DP with bm\\nAssign each color to subse of customers",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 988773,
                "title": "java-easy-solution-by-dfs-with-pruning-22ms-beats-97-solutions",
                "content": "Not re-use the same frequency for every customer, for example:\\n[1,1,2,2,3,3,4,4,4]\\n[2,3]\\nWe know the answer is true, [1,1,4,4,4] or [2,2,4,4,4] or [3,3,4,4,4]\\n\\nThe first customer could apply two1 or two2 or two3. No matter which one picked, the result must be the same. We don\\'t have to try all of the two1 or two2 or two3 to the first cutomer.\\n\\n\\n```\\nclass Solution {\\n    boolean dfs(int idx, Set<Integer> set, int[] f, int[] quantity) {\\n        if(idx==quantity.length) return true;\\n        \\n        int pre = 0;\\n        Set<Integer> visitF = new HashSet<>();\\n        \\n        for(int num : set) { //not loop from 1-1000, because at most 50 unique numbers\\n            if(f[num]<quantity[idx]) continue;\\n            if(visitF.contains(f[num])) continue; // no necessary to re-use the same frequency\\n            visitF.add(f[num]);\\n            f[num]=f[num]-quantity[idx];\\n                if(dfs(idx+1, set, f, quantity)) {\\n                    return true;\\n                }\\n                f[num]=f[num]+quantity[idx];\\n        }\\n        \\n        return false;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] f = new int[1001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++) {\\n            set.add(nums[i]);\\n            f[nums[i]]++;\\n        }\\n        \\n        return dfs(0, set, f, quantity);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean dfs(int idx, Set<Integer> set, int[] f, int[] quantity) {\\n        if(idx==quantity.length) return true;\\n        \\n        int pre = 0;\\n        Set<Integer> visitF = new HashSet<>();\\n        \\n        for(int num : set) { //not loop from 1-1000, because at most 50 unique numbers\\n            if(f[num]<quantity[idx]) continue;\\n            if(visitF.contains(f[num])) continue; // no necessary to re-use the same frequency\\n            visitF.add(f[num]);\\n            f[num]=f[num]-quantity[idx];\\n                if(dfs(idx+1, set, f, quantity)) {\\n                    return true;\\n                }\\n                f[num]=f[num]+quantity[idx];\\n        }\\n        \\n        return false;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] f = new int[1001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++) {\\n            set.add(nums[i]);\\n            f[nums[i]]++;\\n        }\\n        \\n        return dfs(0, set, f, quantity);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959938,
                "title": "c-solution-no-bit-masking",
                "content": "//Backtracking solution\\n//Memoization on index and sorted dictionary values list\\n\\n\\npublic class Solution \\n{\\n    public bool CanDistribute(int[] nums, int[] quantity)\\n\\t{\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!count.ContainsKey(nums[i]))\\n                count.Add(nums[i], 0);\\n            count[nums[i]]++;\\n        }\\n        \\n        return CanDistribute(count, count.Keys.ToList<int>(), quantity, 0);\\n    }\\n    \\n    Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n    private bool CanDistribute(Dictionary<int, int> count, List<int> keys, int[] quantity, int start)\\n    {\\n        if(start >= quantity.Length) return true;\\n        \\n        List<int> vals = count.Values.ToList();\\n        vals.Sort();\\n        string key = start+\"#\"+string.Join(\" \", vals);\\n        \\n        if(memo.ContainsKey(key)) return memo[key];\\n        foreach(var k in keys)\\n        {\\n            if(count[k] >= quantity[start])\\n            {\\n                count[k] -= quantity[start];\\n                if(CanDistribute(count, keys, quantity, start+1))\\n                    return memo[key] = true;\\n                count[k] += quantity[start];\\n            }\\n        }\\n        \\n        return memo[key] = false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public bool CanDistribute(int[] nums, int[] quantity)\\n\\t{\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!count.ContainsKey(nums[i]))\\n                count.Add(nums[i], 0);\\n            count[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 948154,
                "title": "just-be-very-greedy-o-nlgn-solution",
                "content": "First, sort the quantity in the descending order, so we always try to serve the largest needs first, then apply as below: \\n\\n**The sequence of the principles of being greedy: **\\n\\n1. for the current largest need, if we find a repeat frequency just equal to this need, then we serve \\n2. for the current largest need, if there are any other needs with the same needed amount, then we try to find the largest combinational sum of these needs with the same amount, if there is any repeat frequency matched, then we serve \\n3. for the current largest need, find the largest repeat frequency that can satisfy this need, if there is no, then return false. if there is, subtract the need, put the rest back to the repeat frequency pool \\n\\nSo just iterate over the need values array until the end \\n\\n\\n```Scala\\n  def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {\\n    val sq = quantity.sortWith(_ >= _)\\n    import scala.collection.mutable.HashMap\\n    import java.util.TreeMap\\n    val stats = new HashMap[Int, Int]()\\n    val map = new TreeMap[Int, Int]((a: Int, b: Int) => -Integer.compare(a, b))\\n    nums.foreach(x => stats.put(x, stats.getOrElse(x, 0) + 1))\\n    stats.values.foreach(x => map.put(x, map.getOrDefault(x, 0) + 1))\\n\\n    var i = 0\\n    while (i < sq.length) {\\n      val v = sq(i)\\n      if (map.isEmpty) return false\\n      val maxKey = map.firstKey()\\n      if (maxKey < v) return false\\n\\n      var j = i\\n      while (j < sq.length && v == sq(j)) j += 1\\n      j -= 1\\n      while (j >= i) {\\n        val sum = (j - i + 1) * v\\n        if (map.containsKey(sum)) {\\n          map.put(sum, map.get(sum) - 1)\\n          if (map.get(sum) == 0) map remove sum\\n          i = j + 1\\n        } else if (i == j) {\\n          val remain = maxKey - v\\n          map.put(maxKey, map.get(maxKey) - 1)\\n          if (map.get(maxKey) == 0) map remove maxKey\\n          if (remain != 0) map.put(remain, map.getOrDefault(remain, 0) + 1)\\n          i += 1\\n        }\\n        j -= 1\\n      }\\n    }\\n    true\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {\\n    val sq = quantity.sortWith(_ >= _)\\n    import scala.collection.mutable.HashMap\\n    import java.util.TreeMap\\n    val stats = new HashMap[Int, Int]()\\n    val map = new TreeMap[Int, Int]((a: Int, b: Int) => -Integer.compare(a, b))\\n    nums.foreach(x => stats.put(x, stats.getOrElse(x, 0) + 1))\\n    stats.values.foreach(x => map.put(x, map.getOrDefault(x, 0) + 1))\\n\\n    var i = 0\\n    while (i < sq.length) {\\n      val v = sq(i)\\n      if (map.isEmpty) return false\\n      val maxKey = map.firstKey()\\n      if (maxKey < v) return false\\n\\n      var j = i\\n      while (j < sq.length && v == sq(j)) j += 1\\n      j -= 1\\n      while (j >= i) {\\n        val sum = (j - i + 1) * v\\n        if (map.containsKey(sum)) {\\n          map.put(sum, map.get(sum) - 1)\\n          if (map.get(sum) == 0) map remove sum\\n          i = j + 1\\n        } else if (i == j) {\\n          val remain = maxKey - v\\n          map.put(maxKey, map.get(maxKey) - 1)\\n          if (map.get(maxKey) == 0) map remove maxKey\\n          if (remain != 0) map.put(remain, map.getOrDefault(remain, 0) + 1)\\n          i += 1\\n        }\\n        j -= 1\\n      }\\n    }\\n    true\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 947984,
                "title": "java-4ms-state-compression-handling-duplicates",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // compress the states first\\n        int[] counts = new int[1001];\\n        int n = 0;\\n        for(int i: nums) {\\n            counts[i] ++;\\n            if (counts[i] == 1) {\\n                n++;\\n            }\\n        }\\n        \\n        nums = new int[n];\\n        int j = 0;\\n        for(int i: counts) {\\n            if (i > 0) {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        int m = quantity.length;\\n        int[] distrib = new int[m];\\n        Arrays.fill(distrib, -1);\\n        \\n        return distribute(nums, distrib, quantity, 0);\\n    }\\n    \\n    boolean distribute(int[] nums, int[] distrib, int[] quantity, int i) {\\n        int m = quantity.length;\\n        if (i == m) return true;\\n        \\n        int n = nums.length;\\n        int q = quantity[i];\\n        Set<Integer> used = new HashSet<>();\\n        for(int j = 0; j < n; j++) {\\n            int k = nums[j];\\n            if (k < q || used.contains(k)) continue;\\n            nums[j] -= q;\\n            distrib[i] = j;\\n            used.add(k); // Avoid duplicates. TLE without it.\\n            if (distribute(nums, distrib, quantity, i+1)) return true;\\n            nums[j] += q;\\n        }\\n        \\n        distrib[i] = -1;\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // compress the states first\\n        int[] counts = new int[1001];\\n        int n = 0;\\n        for(int i: nums) {\\n            counts[i] ++;\\n            if (counts[i] == 1) {\\n                n++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 947356,
                "title": "go-backtracking-without-sort",
                "content": "```\\nfunc canDistribute(nums []int, quantity []int) bool {\\n    fm := make(map[int]int)\\n    \\n    for _, n := range nums {\\n        fm[n]++\\n    }\\n    \\n    return dfs(fm, quantity)\\n}\\n\\nfunc dfs(fm map[int]int, quantity []int) bool {\\n    if len(quantity) == 0 {\\n        return true\\n    }\\n    \\n    // Visited storage\\n    visited := make(map[int]bool)\\n    \\n    for i := range fm {\\n        // Just to make sure that same frequency is not visited again\\n        if visited[fm[i]] {\\n            continue\\n        }\\n        \\n        visited[fm[i]] = true\\n        \\n        if fm[i] >= quantity[0] {\\n            fm[i]-=quantity[0]\\n            if dfs(fm, quantity[1:]) {\\n                return true\\n            }\\n            fm[i]+=quantity[0]\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nfunc canDistribute(nums []int, quantity []int) bool {\\n    fm := make(map[int]int)\\n    \\n    for _, n := range nums {\\n        fm[n]++\\n    }\\n    \\n    return dfs(fm, quantity)\\n}\\n\\nfunc dfs(fm map[int]int, quantity []int) bool {\\n    if len(quantity) == 0 {\\n        return true\\n    }\\n    \\n    // Visited storage\\n    visited := make(map[int]bool)\\n    \\n    for i := range fm {\\n        // Just to make sure that same frequency is not visited again\\n        if visited[fm[i]] {\\n            continue\\n        }\\n        \\n        visited[fm[i]] = true\\n        \\n        if fm[i] >= quantity[0] {\\n            fm[i]-=quantity[0]\\n            if dfs(fm, quantity[1:]) {\\n                return true\\n            }\\n            fm[i]+=quantity[0]\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943743,
                "title": "beginner-friendly-clean-beats-88-brute-force-backtracking",
                "content": "complexity analysis:\\n* preparing v and f would take O(N)\\n* max depth of recursion is m\\n\\t* for each resurion there is loop O(unique values)\\n\\t\\t* for each loop processing cost at max O(3*unique values)\\n*  Total number of call to recursive funtion m*(unique values)\\n\\t\\t\\n**hence time complexity will be O(N)+(3m(unique values^2))(unique values)m=O(3m^2(unique values^3))**\\n\\nIm really doubtfull at my complexity analysis will be thankful if u would help me to arrive at correct one if mine is wrong.\\n\\n\\n\\n```\\nimport bisect\\n\\nclass Solution:\\n    def toDistribute(self,values,freq,index,quantity):\\n        if index>=len(quantity):\\n            return True\\n        start=bisect.bisect_left(values,quantity[index])\\n        for i,val in enumerate(values[start:],start):\\n            if freq[i]==0:\\n                continue\\n            try:\\n                pos=values.index(val-quantity)\\n                freq[i]-=1\\n                freq[pos]+=1\\n                if self.toDistribute(values,freq,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n                freq[pos]-=1\\n                \\n            except:\\n                pos=bisect.bisect(values,val-quantity[index])\\n                freq[i]-=1\\n                temp_v=values[:pos]+[val-quantity[index]]+values[pos:]\\n                temp_f=freq[:pos]+[1]+freq[pos:]\\n                if self.toDistribute(temp_v,temp_f,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n        return False\\n    \\n\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        val=collections.Counter(nums).values()\\n        freq=collections.Counter(val)\\n        v=list(freq.keys())\\n        v.sort()\\n        f=[]\\n        for val in v:\\n            f.append(freq[val])\\n        return self.toDistribute(v,f,0,quantity)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def toDistribute(self,values,freq,index,quantity):\\n        if index>=len(quantity):\\n            return True\\n        start=bisect.bisect_left(values,quantity[index])\\n        for i,val in enumerate(values[start:],start):\\n            if freq[i]==0:\\n                continue\\n            try:\\n                pos=values.index(val-quantity)\\n                freq[i]-=1\\n                freq[pos]+=1\\n                if self.toDistribute(values,freq,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n                freq[pos]-=1\\n                \\n            except:\\n                pos=bisect.bisect(values,val-quantity[index])\\n                freq[i]-=1\\n                temp_v=values[:pos]+[val-quantity[index]]+values[pos:]\\n                temp_f=freq[:pos]+[1]+freq[pos:]\\n                if self.toDistribute(temp_v,temp_f,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n        return False\\n    \\n\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        val=collections.Counter(nums).values()\\n        freq=collections.Counter(val)\\n        v=list(freq.keys())\\n        v.sort()\\n        f=[]\\n        for val in v:\\n            f.append(freq[val])\\n        return self.toDistribute(v,f,0,quantity)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 939739,
                "title": "rust-backtracking",
                "content": "Convert counts into array of counts per unique value. Then assign each quantity using backtracking.\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n        if index == quantity.len() {\\n            return true;\\n        }\\n        for i in 0..counts.len() {\\n            if counts[i] >= quantity[index] {\\n                let p = quantity[index];\\n                counts[i] -= p;\\n                if (Self::backtrack(counts, quantity, index+1)) {\\n                    return true;\\n                }\\n                counts[i] += p;\\n            }\\n        }\\n        false\\n    }\\n    \\n    \\n    pub fn can_distribute(nums: Vec<i32>, mut quantity: Vec<i32>) -> bool {\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            let mut entry = counts.entry(*n).or_insert(0);\\n            *entry += 1;\\n        }\\n        let mut counts = counts.values().map(|x| *x).collect::<Vec<_>>();\\n        counts.sort_by(|a,b| b.cmp(a));\\n        quantity.sort_by(|a,b| b.cmp(a));\\n        \\n        Self::backtrack(&mut counts, &quantity, 0)\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n        if index == quantity.len() {\\n            return true;\\n        }\\n        for i in 0..counts.len() {\\n            if counts[i] >= quantity[index] {\\n                let p = quantity[index];\\n                counts[i] -= p;\\n                if (Self::backtrack(counts, quantity, index+1)) {\\n                    return true;\\n                }\\n                counts[i] += p;\\n            }\\n        }\\n        false\\n    }\\n    \\n    \\n    pub fn can_distribute(nums: Vec<i32>, mut quantity: Vec<i32>) -> bool {\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            let mut entry = counts.entry(*n).or_insert(0);\\n            *entry += 1;\\n        }\\n        let mut counts = counts.values().map(|x| *x).collect::<Vec<_>>();\\n        counts.sort_by(|a,b| b.cmp(a));\\n        quantity.sort_by(|a,b| b.cmp(a));\\n        \\n        Self::backtrack(&mut counts, &quantity, 0)\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939618,
                "title": "simple-python3-12-lines",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n        \\n        unique_nums = sorted(c.values())[-m:]\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def backtrack(unique_nums, cust):\\n            if cust == len(quantity): return True\\n            \\n            for i, v in enumerate(unique_nums):\\n                if v < quantity[cust]: continue\\n                    \\n                unique_nums[i] -= quantity[cust]\\n                if backtrack(unique_nums, cust+1): return True\\n                unique_nums[i] += quantity[cust]\\n        \\n        return backtrack(unique_nums, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n        \\n        unique_nums = sorted(c.values())[-m:]\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def backtrack(unique_nums, cust):\\n            if cust == len(quantity): return True\\n            \\n            for i, v in enumerate(unique_nums):\\n                if v < quantity[cust]: continue\\n                    \\n                unique_nums[i] -= quantity[cust]\\n                if backtrack(unique_nums, cust+1): return True\\n                unique_nums[i] += quantity[cust]\\n        \\n        return backtrack(unique_nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938775,
                "title": "wrong-solution",
                "content": "I think my solution is wrong, although it passes all the testcases. Can anybody provide me with a crush test?\\n```\\nclass Solution {\\n    \\n    int getSum(int[] quantity, int start, int end, int sum, int target) {\\n        int res = sum;\\n        for(int i=start; i<=end; i++) {\\n            if(sum+quantity[i]>target) break;\\n            res = Math.max(res, getSum(quantity, i+1, end, sum+quantity[i], target));\\n        }\\n        return res;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        if(nums.length<2) {\\n            if(quantity.length>1||quantity[0]>1) return false;\\n            return true;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(quantity);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> distinct = new ArrayList<>();\\n        for(int i=1; i<nums.length; i++) {\\n            int q = 1;\\n            while(i<nums.length&&nums[i]==nums[i-1]) {\\n                q++;\\n                i++;\\n            }\\n            if(map.containsKey(q)) {\\n                map.put(q, map.get(q) + 1);\\n            } else {\\n                distinct.add(q);\\n                map.put(q, 1);\\n            }\\n        }\\n        Collections.sort(distinct); \\n        int pos = distinct.size() - 1;\\n        for(int i=quantity.length-1; i>=0; i--) {\\n            if(distinct.isEmpty()) return false;\\n            if(distinct.get(distinct.size() - 1)<quantity[i]) return false;\\n            int l = 0, r = distinct.size() - 1;\\n            while(l<=r) {\\n                int mid = (l+r) / 2;\\n                if(distinct.get(mid)==quantity[i]) {\\n                    l = mid;\\n                    break;\\n                }\\n                if(distinct.get(mid)<quantity[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            pos = l;\\n            if(distinct.get(pos)!=quantity[i]) {\\n                int bestSum = 0;\\n                for(int j=pos; j<distinct.size(); j++) {\\n                    int temp = getSum(quantity, 0, i - 1, quantity[i], distinct.get(j));\\n                    if(temp>bestSum) {\\n                        bestSum = temp;\\n                        pos = j;\\n                    }\\n                }\\n            }\\n            int rem = distinct.get(pos) - quantity[i];\\n            if(map.get(distinct.get(pos))>1) {\\n                map.put(distinct.get(pos), map.get(distinct.get(pos)) - 1);\\n            } else {\\n                map.remove(distinct.get(pos));\\n                distinct.remove(pos);\\n            }\\n            if(rem>0) {\\n                if(map.containsKey(rem)) {\\n                    map.put(rem, map.get(rem) + 1);\\n                } else {\\n                    map.put(rem, 1);\\n                    l = 0;\\n                    r = pos - 1;\\n                    while(l<=r) {\\n                        int mid = (l+r) / 2;\\n                        if(distinct.get(mid)<rem) {\\n                            l = mid + 1;\\n                        } else {\\n                            r = mid - 1;\\n                        }\\n                    }\\n                    distinct.add(r + 1, rem);\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int getSum(int[] quantity, int start, int end, int sum, int target) {\\n        int res = sum;\\n        for(int i=start; i<=end; i++) {\\n            if(sum+quantity[i]>target) break;\\n            res = Math.max(res, getSum(quantity, i+1, end, sum+quantity[i], target));\\n        }\\n        return res;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        if(nums.length<2) {\\n            if(quantity.length>1||quantity[0]>1) return false;\\n            return true;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(quantity);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> distinct = new ArrayList<>();\\n        for(int i=1; i<nums.length; i++) {\\n            int q = 1;\\n            while(i<nums.length&&nums[i]==nums[i-1]) {\\n                q++;\\n                i++;\\n            }\\n            if(map.containsKey(q)) {\\n                map.put(q, map.get(q) + 1);\\n            } else {\\n                distinct.add(q);\\n                map.put(q, 1);\\n            }\\n        }\\n        Collections.sort(distinct); \\n        int pos = distinct.size() - 1;\\n        for(int i=quantity.length-1; i>=0; i--) {\\n            if(distinct.isEmpty()) return false;\\n            if(distinct.get(distinct.size() - 1)<quantity[i]) return false;\\n            int l = 0, r = distinct.size() - 1;\\n            while(l<=r) {\\n                int mid = (l+r) / 2;\\n                if(distinct.get(mid)==quantity[i]) {\\n                    l = mid;\\n                    break;\\n                }\\n                if(distinct.get(mid)<quantity[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            pos = l;\\n            if(distinct.get(pos)!=quantity[i]) {\\n                int bestSum = 0;\\n                for(int j=pos; j<distinct.size(); j++) {\\n                    int temp = getSum(quantity, 0, i - 1, quantity[i], distinct.get(j));\\n                    if(temp>bestSum) {\\n                        bestSum = temp;\\n                        pos = j;\\n                    }\\n                }\\n            }\\n            int rem = distinct.get(pos) - quantity[i];\\n            if(map.get(distinct.get(pos))>1) {\\n                map.put(distinct.get(pos), map.get(distinct.get(pos)) - 1);\\n            } else {\\n                map.remove(distinct.get(pos));\\n                distinct.remove(pos);\\n            }\\n            if(rem>0) {\\n                if(map.containsKey(rem)) {\\n                    map.put(rem, map.get(rem) + 1);\\n                } else {\\n                    map.put(rem, 1);\\n                    l = 0;\\n                    r = pos - 1;\\n                    while(l<=r) {\\n                        int mid = (l+r) / 2;\\n                        if(distinct.get(mid)<rem) {\\n                            l = mid + 1;\\n                        } else {\\n                            r = mid - 1;\\n                        }\\n                    }\\n                    distinct.add(r + 1, rem);\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938232,
                "title": "python-bfs-beats-97",
                "content": "<details>\\n\\n<summary><b>Approach: (click to show)</b></summary>\\n\\n1. Count how many times each number appears in nums. (this is the frequency of the number)\\n2. Start at the first customer i = 0 and for all frequencies grater than quantity[0] try using that number to satisfy customer i.  \\n3. When you use frequency[j] to satisfy customer i, subtract quantity[i] from frequency[j] to show quantity[i] of that number was used.\\n4. Move on to the next customer (i += 1) and repeat the process until all customers are satisfied (True) or no path is found (False).\\n\\n</details>\\n\\n<details>\\n<summary><b>Optimizations: (click to show)</b></summary>\\n\\n1. If the frequency of a number <b>exactly</b> matches a value in quantity, <b>use it</b> and remove that value from quantity.\\n\\n    i.e. nums = [4, 4, 2, 3] ; quantity = [2, 2]\\n         use [4, 4] immediately so nums = [2, 3] and quantity = [2]\\n\\n2. Sort quantity in <b>reverse</b> order (largest to smallest) so that we address the larger cusomer requests first.  <b>This helps identify False answers faster.</b>\\n\\n3. Do not try to use the same frequency twice when looking at the remaining numbers.  <b>used</b> keeps track of the frequencies tired already for quantity[i].\\n\\n4. Use a priority queue (heap) so that if a solution exists we will arrive at it sooner and can stop early.  <b>This helps identify True answers faster.</b>\\n\\n</details>\\n\\n```python\\ndef canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n\\t# 1. Find the frequency of each number\\n\\tfreq = collections.Counter(list(collections.Counter(nums).values()))\\n\\n\\t# 2. If the quantity[i] is in freq, use that number.\\n\\t#    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n\\t#         so we get quantity = [2] and nums = [2, 3]\\n\\tremoved = set()\\n\\tfor i in range(len(quantity)):\\n\\t\\tif freq[quantity[i]] > 0:\\n\\t\\t\\tfreq[quantity[i]] -= 1\\n\\t\\t\\tremoved.add(i)\\n\\tquantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n\\n\\tif not quantity: return True \\n\\tfreqs = sum(([key]*freq[key] for key in freq), [])\\n\\n\\t# 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n\\tquantity.sort(reverse = True)\\n\\n\\t# 4. Breadth First Search\\n\\tq = [(0, freqs)]\\n\\twhile q:\\n\\t\\ti, freqs = heapq.heappop(q)\\n\\t\\ti = -i\\n\\t\\tif i == len(quantity):\\n\\t\\t\\treturn True\\n\\t\\tquant = quantity[i]\\n\\t\\tused = set()                                                                        # keep track of the freqs[j] values used for quantity[i]\\n\\t\\tfor j in range(len(freqs)):\\n\\t\\t\\tif freqs[j] >= quant and freqs[j] not in used:                                  # do not use the same value more than once for quantity[i]\\n\\t\\t\\t\\tused.add(freqs[j])\\n\\t\\t\\t\\tif freqs[j] > quant:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + [freqs[j]-quant] + freqs[j+1:]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + freqs[j+1:]))                    # freqs[j] == quantity[i] we can stop checking other frequencies\\n\\t\\t\\t\\t\\tbreak\\n\\treturn False\\n```\\n\\n<details>\\n\\n<summary><b>Here is a more efficient implementation: (click to show)</b></summary>\\n\\nSo in the first solution the frequency of each number is stored in a list. i.e. nums = [1, 1, 1, 2, 4, 4, 5, 5] ; freqs = [3, 1, 2, 2]\\n\\nIt is more efficient to store freqs as a counter instead. i.e. freqs = {3: 1, 1: 1, 2: 2}\\nBecause a counter:\\n1. uses less space when there are many repeat values\\n2. can be updated in O(1) time and \\n3. we can check if quantity[i] is in freqs in O(1) time.  \\n\\n<b>However, the python heapq module does not play nice with counters</b> because Counters are not comparable.  \\ni.e. is Counter({3:1, 2:3, 1:1}) greater than Counter({2:1, 1:1, 3:3})? Python doesn\\'t know...\\n\\nTo use a counter with a heap, we a custom heap class that ignores the Counter part of an item when comparing items in the heap.  \\ni.e. item1 = ( 5, Counter({1:1, 2:2}) ) ; item2 = ( 3, Counter({7:1, 1:2}) ).  is item1 > item 2? Yes, because 5 > 3 and ignore the Counter.  \\n\\n<details>\\n\\n<summary><b>Solution: (click to show)</b></summary>\\n\\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        # 1. Find the frequency of each number\\n        freqs = collections.Counter(list(collections.Counter(nums).values()))\\n        \\n        # 2. If the quantity[i] is in freq, use that number.\\n        #    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n        #         so we get quantity = [2] and nums = [2, 3]\\n        removed = set()\\n        for i in range(len(quantity)):\\n            if freqs[quantity[i]] > 0:\\n                freqs[quantity[i]] -= 1\\n                removed.add(i)\\n        quantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n        \\n        if not quantity: return True \\n        \\n        # 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n        quantity.sort(reverse = True)\\n        \\n        # 4. Breadth First Search\\n        q = Max_Heap([(0, freqs)])\\n        while not q.is_empty():\\n            i, freqs = q.heappop()\\n            \\n            if i == len(quantity):\\n                return True\\n            quant = quantity[i]\\n            \\n            if quant in freqs and freqs[quant] > 0:\\n                new_freqs = freqs.copy()\\n                new_freqs[quant] -= 1\\n                q.heappush((i+1, new_freqs))\\n                continue\\n\\n            for f in freqs:\\n                if f > quant and freqs[f] > 0:\\n                    new_freqs = freqs.copy()\\n                    new_freqs[f] -= 1\\n                    new_freqs[f-quant] += 1\\n                    q.heappush((i+1, new_freqs))\\n            \\n        return False\\n```\\n\\n</details>\\n\\n<details>\\n\\n<summary><b>Custom Max Heap Class: (click to show)</b></summary>\\n\\n```python\\nclass Max_Heap(object):\\n    def __init__(self, arr):\\n        self.arr = arr if arr else []\\n    \\n    def heappush(self, val):\\n        self.arr.append(val)\\n        i = len(self.arr) - 1\\n        while True:\\n            i, b = self.bubble_up(i)\\n            if not b: \\n                break\\n    \\n    def heappop(self):\\n        if len(self.arr) == 1:\\n            return self.arr.pop()\\n        res = self.arr[0]\\n        self.arr[0] = self.arr.pop()\\n        i = 0\\n        while True:\\n            i, b = self.bubble_down(i)\\n            if not b:\\n                break\\n        \\n        return res\\n    \\n    def bubble_up(self, i):\\n        if not i: return (i, False)\\n        \\n        j = (i + 1) // 2\\n        if self.arr[j][0] < self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        \\n        return (i, False)\\n    \\n    def bubble_down(self, i):\\n        j = (i+1) * 2\\n        if j - 1 >= len(self.arr): \\n            return (i, False)\\n        \\n        if j == len(self.arr):\\n            # only consider left branch\\n            if self.arr[j-1][0] > self.arr[i][0]:\\n                self.arr[i], self.arr[j-1] = self.arr[j-1], self.arr[i]\\n            return (j, False)\\n        \\n        # consider left and right branch\\n        j = max((j, j-1), key = lambda x: self.arr[x][0])\\n        if self.arr[j][0] > self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        return (i, False)\\n\\n    def is_empty(self):\\n        return not bool(self.arr)\\n```\\n\\n</details>\\n\\n</details>\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n\\t# 1. Find the frequency of each number\\n\\tfreq = collections.Counter(list(collections.Counter(nums).values()))\\n\\n\\t# 2. If the quantity[i] is in freq, use that number.\\n\\t#    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n\\t#         so we get quantity = [2] and nums = [2, 3]\\n\\tremoved = set()\\n\\tfor i in range(len(quantity)):\\n\\t\\tif freq[quantity[i]] > 0:\\n\\t\\t\\tfreq[quantity[i]] -= 1\\n\\t\\t\\tremoved.add(i)\\n\\tquantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n\\n\\tif not quantity: return True \\n\\tfreqs = sum(([key]*freq[key] for key in freq), [])\\n\\n\\t# 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n\\tquantity.sort(reverse = True)\\n\\n\\t# 4. Breadth First Search\\n\\tq = [(0, freqs)]\\n\\twhile q:\\n\\t\\ti, freqs = heapq.heappop(q)\\n\\t\\ti = -i\\n\\t\\tif i == len(quantity):\\n\\t\\t\\treturn True\\n\\t\\tquant = quantity[i]\\n\\t\\tused = set()                                                                        # keep track of the freqs[j] values used for quantity[i]\\n\\t\\tfor j in range(len(freqs)):\\n\\t\\t\\tif freqs[j] >= quant and freqs[j] not in used:                                  # do not use the same value more than once for quantity[i]\\n\\t\\t\\t\\tused.add(freqs[j])\\n\\t\\t\\t\\tif freqs[j] > quant:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + [freqs[j]-quant] + freqs[j+1:]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + freqs[j+1:]))                    # freqs[j] == quantity[i] we can stop checking other frequencies\\n\\t\\t\\t\\t\\tbreak\\n\\treturn False\\n```\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        # 1. Find the frequency of each number\\n        freqs = collections.Counter(list(collections.Counter(nums).values()))\\n        \\n        # 2. If the quantity[i] is in freq, use that number.\\n        #    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n        #         so we get quantity = [2] and nums = [2, 3]\\n        removed = set()\\n        for i in range(len(quantity)):\\n            if freqs[quantity[i]] > 0:\\n                freqs[quantity[i]] -= 1\\n                removed.add(i)\\n        quantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n        \\n        if not quantity: return True \\n        \\n        # 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n        quantity.sort(reverse = True)\\n        \\n        # 4. Breadth First Search\\n        q = Max_Heap([(0, freqs)])\\n        while not q.is_empty():\\n            i, freqs = q.heappop()\\n            \\n            if i == len(quantity):\\n                return True\\n            quant = quantity[i]\\n            \\n            if quant in freqs and freqs[quant] > 0:\\n                new_freqs = freqs.copy()\\n                new_freqs[quant] -= 1\\n                q.heappush((i+1, new_freqs))\\n                continue\\n\\n            for f in freqs:\\n                if f > quant and freqs[f] > 0:\\n                    new_freqs = freqs.copy()\\n                    new_freqs[f] -= 1\\n                    new_freqs[f-quant] += 1\\n                    q.heappush((i+1, new_freqs))\\n            \\n        return False\\n```\n```python\\nclass Max_Heap(object):\\n    def __init__(self, arr):\\n        self.arr = arr if arr else []\\n    \\n    def heappush(self, val):\\n        self.arr.append(val)\\n        i = len(self.arr) - 1\\n        while True:\\n            i, b = self.bubble_up(i)\\n            if not b: \\n                break\\n    \\n    def heappop(self):\\n        if len(self.arr) == 1:\\n            return self.arr.pop()\\n        res = self.arr[0]\\n        self.arr[0] = self.arr.pop()\\n        i = 0\\n        while True:\\n            i, b = self.bubble_down(i)\\n            if not b:\\n                break\\n        \\n        return res\\n    \\n    def bubble_up(self, i):\\n        if not i: return (i, False)\\n        \\n        j = (i + 1) // 2\\n        if self.arr[j][0] < self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        \\n        return (i, False)\\n    \\n    def bubble_down(self, i):\\n        j = (i+1) * 2\\n        if j - 1 >= len(self.arr): \\n            return (i, False)\\n        \\n        if j == len(self.arr):\\n            # only consider left branch\\n            if self.arr[j-1][0] > self.arr[i][0]:\\n                self.arr[i], self.arr[j-1] = self.arr[j-1], self.arr[i]\\n            return (j, False)\\n        \\n        # consider left and right branch\\n        j = max((j, j-1), key = lambda x: self.arr[x][0])\\n        if self.arr[j][0] > self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        return (i, False)\\n\\n    def is_empty(self):\\n        return not bool(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937377,
                "title": "c-o-m-3-m",
                "content": "```\\nclass Solution {\\n    void gen(int now, int state, int sum, const vector<int> &q, vector<int> &a) {\\n        if (now >= q.size()) {\\n            a[state] = sum;\\n            return;\\n        }\\n        gen(now + 1, state, sum, q, a);\\n        gen(now + 1, state | (1 << now), sum + q[now], q, a);\\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        vector<int> v;\\n        for (const auto& p : have) {\\n            v.push_back(p.second);\\n        }\\n        sort(v.begin(), v.end());\\n        const int m = quantity.size();\\n        const int s = 1 << m;\\n        vector<int> a(s);\\n        gen(0, 0, 0, quantity, a);\\n        vector<bool> dp(s);\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int t = max(0, ((int) v.size()) - m); t < v.size(); ++t) {\\n            sum += v[t];\\n            for (int i = s - 1; i >= 0; --i) {\\n                if (a[i] > sum) continue;\\n                for (int j = i; !dp[i]; j = (j - 1) & i) {\\n                    dp[i] = dp[j] && a[i ^ j] <= v[t];\\n                    if (j == 0) break;\\n                }\\n            }\\n        }\\n        return dp[s - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void gen(int now, int state, int sum, const vector<int> &q, vector<int> &a) {\\n        if (now >= q.size()) {\\n            a[state] = sum;\\n            return;\\n        }\\n        gen(now + 1, state, sum, q, a);\\n        gen(now + 1, state | (1 << now), sum + q[now], q, a);\\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        vector<int> v;\\n        for (const auto& p : have) {\\n            v.push_back(p.second);\\n        }\\n        sort(v.begin(), v.end());\\n        const int m = quantity.size();\\n        const int s = 1 << m;\\n        vector<int> a(s);\\n        gen(0, 0, 0, quantity, a);\\n        vector<bool> dp(s);\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int t = max(0, ((int) v.size()) - m); t < v.size(); ++t) {\\n            sum += v[t];\\n            for (int i = s - 1; i >= 0; --i) {\\n                if (a[i] > sum) continue;\\n                for (int j = i; !dp[i]; j = (j - 1) & i) {\\n                    dp[i] = dp[j] && a[i ^ j] <= v[t];\\n                    if (j == 0) break;\\n                }\\n            }\\n        }\\n        return dp[s - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937346,
                "title": "python-3-dp-status-compression-solution",
                "content": "since quantity is limited so we can use bitmap to store the status.\\nwe only care fre of numbers in nums, thus we want to get a cnt first.\\nthen we want to allocate each fre to each quantity.\\nthe relation is like a typic dp problem:\\ndp(i,j)=dp(i-1,j) or dp(i-1,j-s) where i means we have  subarray cnt[0...j],j means we need to satisfy subquantity j. s means one sub-bit of j such that cnt[i] will satisfy s bit-map group=>sums_need(s)<=cnt[i]\\neg: the final j is (1<<m)-1) which is like 11111..1111 means we want to satisfy all m numbers in quantity.\\nthus we want to iterate all sub-bit of j, there is a way to do that descending:sub=(sub-1)&j, which will remove leftmost 1 bit and recover all 1 after removed 1 bit, so we will get highest bit from all remain one.\\nthen we need to compare sums of subset number and cnt[i], we can pre-calcualte it.\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt=sorted(collections.Counter(nums).values(),reverse=True)[:len(quantity)]\\n        m,n=len(quantity),len(cnt)\\n        mask_sums=[0]*(1<<m)#pre-calculate sums of need for mask x.\\n        for bit in range(1,1<<m):\\n            for i in range(m):#add sums for each bit 1.\\n                if bit &(1<<i):\\n                    mask_sums[bit]+=quantity[i]\\n        \\n        @lru_cache(None)\\n        def dp(i,j):#find if exist dp(i-1,j-s) value is True or dp(i,j-s) is True\\n            if i<0:#no element,only True when no quantity required\\n                return j==0\\n            if j==0 or dp(i-1,j):#dp(i,j) is depend on dp(i-1,j) or any(dp(i-1,j-sub) is true)\\n                return True\\n            sub=j\\n            while sub!=0:\\n                if dp(i-1,j-sub) and cnt[i]>=mask_sums[sub]:\\n                    return True\\n                sub=(sub-1)&j   \\n            return False\\n        return dp(n-1,(1<<m)-1)",
                "solutionTags": [],
                "code": "since quantity is limited so we can use bitmap to store the status.\\nwe only care fre of numbers in nums, thus we want to get a cnt first.\\nthen we want to allocate each fre to each quantity.\\nthe relation is like a typic dp problem:\\ndp(i,j)=dp(i-1,j) or dp(i-1,j-s) where i means we have  subarray cnt[0...j],j means we need to satisfy subquantity j. s means one sub-bit of j such that cnt[i] will satisfy s bit-map group=>sums_need(s)<=cnt[i]\\neg: the final j is (1<<m)-1) which is like 11111..1111 means we want to satisfy all m numbers in quantity.\\nthus we want to iterate all sub-bit of j, there is a way to do that descending:sub=(sub-1)&j, which will remove leftmost 1 bit and recover all 1 after removed 1 bit, so we will get highest bit from all remain one.\\nthen we need to compare sums of subset number and cnt[i], we can pre-calcualte it.\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt=sorted(collections.Counter(nums).values(),reverse=True)[:len(quantity)]\\n        m,n=len(quantity),len(cnt)\\n        mask_sums=[0]*(1<<m)#pre-calculate sums of need for mask x.\\n        for bit in range(1,1<<m):\\n            for i in range(m):#add sums for each bit 1.\\n                if bit &(1<<i):\\n                    mask_sums[bit]+=quantity[i]\\n        \\n        @lru_cache(None)\\n        def dp(i,j):#find if exist dp(i-1,j-s) value is True or dp(i,j-s) is True\\n            if i<0:#no element,only True when no quantity required\\n                return j==0\\n            if j==0 or dp(i-1,j):#dp(i,j) is depend on dp(i-1,j) or any(dp(i-1,j-sub) is true)\\n                return True\\n            sub=j\\n            while sub!=0:\\n                if dp(i-1,j-sub) and cnt[i]>=mask_sums[sub]:\\n                    return True\\n                sub=(sub-1)&j   \\n            return False\\n        return dp(n-1,(1<<m)-1)",
                "codeTag": "Java"
            },
            {
                "id": 936820,
                "title": "java-solution-backtracking-less-code",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> list = new ArrayList<>();\\n    \\n    boolean f(int[] q, int i){\\n        if(i<0) return true;\\n        for(int j=0; j<list.size(); j++){\\n            int e = list.get(j);\\n            if(e>=q[i]){\\n                list.set(j, e-q[i]);\\n                if(f(q, i-1)) return true;\\n                list.set(j, e);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] q) {\\n        int[] cnts = new int[1001];\\n        for(int n:nums) cnts[n]++;\\n        for(int n:cnts)\\n            if(n>0) list.add(n);\\n        Arrays.sort(q); // try the largest quatity first\\n        return f(q, q.length-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> list = new ArrayList<>();\\n    \\n    boolean f(int[] q, int i){\\n        if(i<0) return true;\\n        for(int j=0; j<list.size(); j++){\\n            int e = list.get(j);\\n            if(e>=q[i]){\\n                list.set(j, e-q[i]);\\n                if(f(q, i-1)) return true;\\n                list.set(j, e);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] q) {\\n        int[] cnts = new int[1001];\\n        for(int n:nums) cnts[n]++;\\n        for(int n:cnts)\\n            if(n>0) list.add(n);\\n        Arrays.sort(q); // try the largest quatity first\\n        return f(q, q.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936431,
                "title": "c-dp-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n, m;\\n    \\n    bool isPossible(int mask, int val, vector<int> & quantity){\\n        \\n        for(int i = 0; i < n; i++){\\n            if((mask & (1 << i))){\\n                if(val >= quantity[i])\\n                    val -= quantity[i];\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool helper(int idx, int mask, vector<int> &quantity, vector<int> &arr){\\n        if(mask == (1 << n)-1) return true;\\n        if(idx == m) return false;\\n        \\n        if(dp[idx][mask] != -1) return dp[idx][mask];\\n        \\n        int tempMask = (~mask) & ((1 << n)-1);\\n        \\n\\t\\t// to check among all the possible subsets of the elements not included currently in mask. \\n        for(int s = tempMask; ; s = (s-1) & tempMask){\\n            if(isPossible(s, arr[idx], quantity)){\\n                if(helper(idx+1, mask | s, quantity, arr)) \\n                    return dp[idx][mask] =  true;\\n            }\\n            if(s == 0) break;\\n        }\\n        \\n        return dp[idx][mask] = false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freq;\\n        \\n        for(int x : nums) freq[x]++;\\n        \\n        vector<int> arr;\\n        \\n        for(auto p : freq) arr.push_back(p.second);\\n        sort(arr.begin(), arr.end());\\n        sort(quantity.begin(), quantity.end());\\n        \\n        m = arr.size();\\n        n = quantity.size();\\n        \\n        dp.resize(m, vector<int>((1 << n), -1));\\n        \\n        return helper(0, 0, quantity, arr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n, m;\\n    \\n    bool isPossible(int mask, int val, vector<int> & quantity){\\n        \\n        for(int i = 0; i < n; i++){\\n            if((mask & (1 << i))){\\n                if(val >= quantity[i])\\n                    val -= quantity[i];\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool helper(int idx, int mask, vector<int> &quantity, vector<int> &arr){\\n        if(mask == (1 << n)-1) return true;\\n        if(idx == m) return false;\\n        \\n        if(dp[idx][mask] != -1) return dp[idx][mask];\\n        \\n        int tempMask = (~mask) & ((1 << n)-1);\\n        \\n\\t\\t// to check among all the possible subsets of the elements not included currently in mask. \\n        for(int s = tempMask; ; s = (s-1) & tempMask){\\n            if(isPossible(s, arr[idx], quantity)){\\n                if(helper(idx+1, mask | s, quantity, arr)) \\n                    return dp[idx][mask] =  true;\\n            }\\n            if(s == 0) break;\\n        }\\n        \\n        return dp[idx][mask] = false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freq;\\n        \\n        for(int x : nums) freq[x]++;\\n        \\n        vector<int> arr;\\n        \\n        for(auto p : freq) arr.push_back(p.second);\\n        sort(arr.begin(), arr.end());\\n        sort(quantity.begin(), quantity.end());\\n        \\n        m = arr.size();\\n        n = quantity.size();\\n        \\n        dp.resize(m, vector<int>((1 << n), -1));\\n        \\n        return helper(0, 0, quantity, arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936233,
                "title": "cpp14-dp-backtracking-solution",
                "content": "dp[index][state] denotes whether we can satisfy customers upto index = index , such that we have already satisfied some customers and our current state of frequency is state.  \\n\\n```\\nclass Solution {\\npublic:\\n    map<vector<int> , int>dp ;\\n    int n ;\\n    vector<int> quant;\\n    map<int,int> freq ;\\n    bool solve(int index)\\n    {\\n        if(index == n) return true ;\\n        bool does = false;\\n        vector<int> currstate ;\\n        for(auto x : freq ) currstate.push_back(x.second);\\n        sort(currstate.begin(), currstate.end()) ;\\n        currstate.push_back(1e9+index);\\n        if(dp[currstate]){\\n            if(dp[currstate] == 1) return true;\\n            return false;\\n        }\\n        for(auto x : freq){\\n             int demand = quant[index];\\n             int curr = x.first;\\n             if(freq[curr] >= demand){\\n                freq[curr]-=demand;\\n                does = does | solve(index + 1);\\n                if(does == true){\\n                    dp[currstate] = 1;\\n                    return true;\\n                }\\n                freq[curr]+=demand;\\n             }\\n        }\\n        if(does == true) dp[currstate] = 1;\\n        if(does == false) dp[currstate] = 2;\\n        return does ;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        freq.clear();\\n        dp.clear() ;\\n        quant = quantity;\\n        for(auto x : nums ) freq[x]++;\\n        n = quantity.size();\\n        return solve(0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int> , int>dp ;\\n    int n ;\\n    vector<int> quant;\\n    map<int,int> freq ;\\n    bool solve(int index)\\n    {\\n        if(index == n) return true ;\\n        bool does = false;\\n        vector<int> currstate ;\\n        for(auto x : freq ) currstate.push_back(x.second);\\n        sort(currstate.begin(), currstate.end()) ;\\n        currstate.push_back(1e9+index);\\n        if(dp[currstate]){\\n            if(dp[currstate] == 1) return true;\\n            return false;\\n        }\\n        for(auto x : freq){\\n             int demand = quant[index];\\n             int curr = x.first;\\n             if(freq[curr] >= demand){\\n                freq[curr]-=demand;\\n                does = does | solve(index + 1);\\n                if(does == true){\\n                    dp[currstate] = 1;\\n                    return true;\\n                }\\n                freq[curr]+=demand;\\n             }\\n        }\\n        if(does == true) dp[currstate] = 1;\\n        if(does == false) dp[currstate] = 2;\\n        return does ;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        freq.clear();\\n        dp.clear() ;\\n        quant = quantity;\\n        for(auto x : nums ) freq[x]++;\\n        n = quantity.size();\\n        return solve(0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935864,
                "title": "java-dp-o-50-m-2-2m",
                "content": "```\\nclass Solution {\\n    int sz = 50;\\n\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = quantity.length;\\n        boolean[][] dp = new boolean[sz][1 << m];\\n        dp[0][0] = true;\\n        int[] freqs = new int[sz];\\n        Arrays.sort(nums);\\n        int prev = -1, ptr = -1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != prev) {\\n                prev = nums[i];\\n                ptr++;\\n            }\\n            freqs[ptr]++;\\n        }\\n        for(int ind = 1; ind <= sz - 1 && freqs[ind - 1] != 0; ind++) {\\n            int freq = freqs[ind - 1];\\n            for(int pre = 0; pre < (1 << m); pre++) {\\n                if(!dp[ind - 1][pre]) continue;\\n                dp[ind][pre] = true;\\n                for(int nxt = 0; nxt < (1 << m); nxt++) {\\n                    if((nxt & pre) != 0) continue;\\n                    int acc = 0;\\n                    for(int i = 0; i < m; i++) {\\n                        if((nxt & (1 << i)) != 0) {\\n                            acc += quantity[i];\\n                        }\\n                    }\\n                    if(acc > freq) continue;\\n                    dp[ind][nxt | pre] = true;\\n                    if((nxt | pre) == (1 << m) - 1) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int sz = 50;\\n\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = quantity.length;\\n        boolean[][] dp = new boolean[sz][1 << m];\\n        dp[0][0] = true;\\n        int[] freqs = new int[sz];\\n        Arrays.sort(nums);\\n        int prev = -1, ptr = -1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != prev) {\\n                prev = nums[i];\\n                ptr++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800423,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "The explanation of the first example is wrong? Should not it be \"The 0th customer cannot be given two same integers.\"?"
                    },
                    {
                        "username": "takru",
                        "content": "num = [1,1,1,1,2,2,2,2,2,2,2,2,2] quant = [3,3,3,4], how is this true?"
                    },
                    {
                        "username": "Saketh_123",
                        "content": "2 is distributed thrice and 1 is distributed 4 times\\n"
                    },
                    {
                        "username": "sahilkece0202",
                        "content": "will give 4 ones to 3rd index , after that 3-3 two\\'s to 0th,1st ,2nd index"
                    }
                ]
            },
            {
                "id": 1837837,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "The explanation of the first example is wrong? Should not it be \"The 0th customer cannot be given two same integers.\"?"
                    },
                    {
                        "username": "takru",
                        "content": "num = [1,1,1,1,2,2,2,2,2,2,2,2,2] quant = [3,3,3,4], how is this true?"
                    },
                    {
                        "username": "Saketh_123",
                        "content": "2 is distributed thrice and 1 is distributed 4 times\\n"
                    },
                    {
                        "username": "sahilkece0202",
                        "content": "will give 4 ones to 3rd index , after that 3-3 two\\'s to 0th,1st ,2nd index"
                    }
                ]
            }
        ]
    }
]